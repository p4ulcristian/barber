["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.cjs.js"],"~:js","shadow$provide[121]=function(h,a,n,f){function e(c){return c&&\"object\"===typeof c&&\"default\"in c?c[\"default\"]:c}function t(c,a){}function q(){}function x(c,a,b){var e=a.map(function(a){var e=N({},b,{},a.options);c.addEventListener(a.eventName,a.fn,e);return function(){c.removeEventListener(a.eventName,a.fn,e)}});return function(){e.forEach(function(c){c()})}}function w(c){this.message=c}function m(c,a){if(!c){throw new w(\"Invariant failed\");throw new w(\"Invariant failed: \"+(a||\"\"));}}function E(c,\na){if(c.findIndex)return c.findIndex(a);for(var b=0;b<c.length;b++)if(a(c[b]))return b;return-1}function z(c,a){if(c.find)return c.find(a);a=E(c,a);if(-1!==a)return c[a]}function I(c){return c.at&&\"REORDER\"===c.at.type?c.at.destination:null}function F(c){return c.at&&\"COMBINE\"===c.at.type?c.at.combine:null}function D(c){var a=c.destination,b=c.displacedBy,e=c.viewport,f=c.forceShouldAnimate,h=c.last;return c.afterDragging.reduce(function(c,k){var p=aa.getRect(aa.expand(k.page.marginBox,{top:b.point.y,\nright:0,bottom:0,left:b.point.x}));var u=k.descriptor.id;c.all.push(u);if(!Fd(N({},{target:p,destination:a,viewport:e,withDroppableDisplacement:!0},{isVisibleThroughFrameFn:Wc})))return c.invisible[k.descriptor.id]=!0,c;\"boolean\"===typeof f?k=f:h?(k=h.visible,k=h.invisible[u]?!1:(k=k[u])?k.shouldAnimate:!0):k=!0;c.visible[u]={draggableId:u,shouldAnimate:k};return c},{all:[],visible:{},invisible:{}})}function v(c){var a=c.insideDestination,b=c.displacedBy,e=c.destination;c=c.inHomeList;a.length?(a=\na[a.length-1].descriptor.index,a=c?a:a+1):a=0;return{displaced:gc,displacedBy:b,at:{type:\"REORDER\",destination:{droppableId:e.descriptor.id,index:a}}}}function r(c){var a=c.draggable,b=c.insideDestination,e=c.destination,f=c.viewport,h=c.displacedBy,m=c.last,n=c.index;c=c.forceShouldAnimate;var r=Mb(a,e);if(null==n)return v({insideDestination:b,inHomeList:r,displacedBy:h,destination:e});var q=z(b,function(c){return c.descriptor.index===n});if(!q)return v({insideDestination:b,inHomeList:r,displacedBy:h,\ndestination:e});a=Yc(a,b);b=b.indexOf(q);b=a.slice(b);return{displaced:D({afterDragging:b,destination:e,displacedBy:h,last:m,viewport:f.frame,forceShouldAnimate:c}),displacedBy:h,at:{type:\"REORDER\",destination:{droppableId:e.descriptor.id,index:n}}}}function R(c,a){return c.map(function(c){return a[c]})}function G(c){return\"DRAGGING\"===c.phase||\"COLLECTING\"===c.phase}function V(c){var a=c.closest;return a?c.inHomeList?a.descriptor.index>c.draggable.descriptor.index?a.descriptor.index-1:a.descriptor.index:\na.descriptor.index:null}function K(c){var a=c.combineWithId,b=c.destinationId,e=c.userDirection;c=c.previousImpact;var f=c.at&&\"COMBINE\"===c.at.type?c.at:null;e=f?a!==f.combine.draggableId?e:f.whenEntered:e;return{displacedBy:c.displacedBy,displaced:c.displaced,at:{type:\"COMBINE\",whenEntered:e,combine:{draggableId:a,droppableId:b}}}}function P(c,a){return c.map(function(c){return a[c]})}function S(c){return c.isDragging&&\"SNAP\"===c.movementMode?N({phase:\"DRAGGING\"},c,{scrollJumpRequest:null}):c}function ba(c){return{eventName:\"scroll\",\noptions:{passive:!0,capture:!1},fn:function(a){a.target!==window&&a.target!==window.document||c()}}}function ta(c){function a(){return h!==q}var b=c.onWindowScroll,e=Hb(function(){b({x:window.pageXOffset,y:window.pageYOffset})}),f=ba(e),h=q;return{start:function(){a()?m(!1):void 0;h=x(window,[f])},stop:function(){a()?void 0:m(!1);e.cancel();h();h=q},isActive:a}}function Y(c){var a=c.registry,b=c.callbacks,e=be(),f=null,h=function(){f||(b.collectionStarting(),f=requestAnimationFrame(function(){f=null;\nvar c=e,k=c.removals,p=c.modified;c=Ya(c.additions).map(function(c){return a.draggable.getById(c).getDimension(na)}).sort(function(c,a){return c.descriptor.index-a.descriptor.index});p=Ya(p).map(function(c){var b=a.droppable.getById(c).callbacks.getScrollWhileDragging();return{droppableId:c,scroll:b}});k={additions:c,removals:Ya(k),modified:p};e=be();b.publish(k)}))};return{add:function(c){var a=c.descriptor.id;e.additions[a]=c;e.modified[c.descriptor.droppableId]=!0;e.removals[a]&&delete e.removals[a];\nh()},remove:function(c){c=c.descriptor;e.removals[c.id]=!0;e.modified[c.droppableId]=!0;e.additions[c.id]&&delete e.additions[c.id];h()},stop:function(){f&&(cancelAnimationFrame(f),f=null,e=be())}}}function ea(c,a,b){return b.descriptor.id===a.id||b.descriptor.type!==a.type?!1:\"virtual\"!==c.droppable.getById(b.descriptor.droppableId).descriptor.mode?(void 0,!1):!0}function Ga(c,a){var b=C.useMemo(function(){var a=yg(c),b={selector:a(sc.contextId),styles:{always:\"\\n          -webkit-touch-callout: none;\\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\\n          touch-action: manipulation;\\n        \",\nresting:\"\\n      cursor: -webkit-grab;\\n      cursor: grab;\\n    \",dragging:\"pointer-events: none;\",dropAnimating:\"\\n      cursor: -webkit-grab;\\n      cursor: grab;\\n    \"}};var e=\"\\n      transition: \"+Qb.outOfTheWay+\";\\n    \";e={selector:a(gd.contextId),styles:{dragging:e,dropAnimating:e,userCancel:e}};a={selector:a(wg),styles:{always:\"overflow-anchor: none;\"}};b=[e,b,a,{selector:\"body\",styles:{dragging:\"\\n        cursor: grabbing;\\n        cursor: -webkit-grabbing;\\n        user-select: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        overflow-anchor: none;\\n      \"}}];\nreturn{always:Na(b,\"always\"),resting:Na(b,\"resting\"),dragging:Na(b,\"dragging\"),dropAnimating:Na(b,\"dropAnimating\"),userCancel:Na(b,\"userCancel\")}},[c]),e=Q.useRef(null),f=Q.useRef(null),k=C.useCallback(oa(function(c){var a=f.current;a?void 0:m(!1);a.textContent=c}),[]),h=C.useCallback(function(c){var a=e.current;a?void 0:m(!1);a.textContent=c},[]);wa(function(){e.current||f.current?m(!1):void 0;var p=hd(a),u=hd(a);e.current=p;f.current=u;p.setAttribute(\"data-rbd-always\",c);u.setAttribute(\"data-rbd-dynamic\",\nc);nc().appendChild(p);nc().appendChild(u);h(b.always);k(b.resting);return function(){var c=function(c){var a=c.current;a?void 0:m(!1);nc().removeChild(a);c.current=null};c(e);c(f)}},[a,h,k,b.always,b.resting,c]);var n=C.useCallback(function(){return k(b.dragging)},[k,b.dragging]),r=C.useCallback(function(c){\"DROP\"===c?k(b.dropAnimating):k(b.userCancel)},[k,b.dropAnimating,b.userCancel]),q=C.useCallback(function(){f.current&&k(b.resting)},[k,b.resting]);return C.useMemo(function(){return{dragging:n,\ndropping:r,resting:q}},[n,r,q])}function ua(c){return c instanceof(c&&c.ownerDocument?c.ownerDocument.defaultView:window).HTMLElement}function Z(c,a){c=Array.prototype.slice.call(document.querySelectorAll(\"[\"+sc.contextId+'\\x3d\"'+c+'\"]'));if(!c.length)return void 0,null;c=z(c,function(c){return c.getAttribute(sc.draggableId)===a});return c&&ua(c)?c:(void 0,null)}function A(c){var a=Q.useRef({}),b=Q.useRef(null),e=Q.useRef(null),f=Q.useRef(!1),h=C.useCallback(function(c,b){var e={id:c,focus:b};a.current[c]=\ne;return function(){var b=a.current;b[c]!==e&&delete b[c]}},[]),m=C.useCallback(function(a){(a=Z(c,a))&&a!==document.activeElement&&a.focus()},[c]),n=C.useCallback(function(c,a){b.current===c&&(b.current=a)},[]),r=C.useCallback(function(){!e.current&&f.current&&(e.current=requestAnimationFrame(function(){e.current=null;var c=b.current;c&&m(c)}))},[m]),q=C.useCallback(function(c){b.current=null;var a=document.activeElement;a&&a.getAttribute(sc.draggableId)===c&&(b.current=c)},[]);wa(function(){f.current=\n!0;return function(){f.current=!1;var c=e.current;c&&cancelAnimationFrame(c)}},[]);return C.useMemo(function(){return{register:h,tryRecordFocus:q,tryRestoreFocusRecorded:r,tryShiftRecord:n}},[h,q,r,n])}function ha(){function c(c){f.length&&f.forEach(function(a){return a(c)})}function a(c){return e.draggables[c]||null}function b(c){return e.droppables[c]||null}var e={draggables:{},droppables:{}},f=[];return{draggable:{register:function(a){e.draggables[a.descriptor.id]=a;c({type:\"ADDITION\",value:a})},\nupdate:function(c,a){var b=e.draggables[a.descriptor.id];b&&b.uniqueId===c.uniqueId&&(delete e.draggables[a.descriptor.id],e.draggables[c.descriptor.id]=c)},unregister:function(b){var f=b.descriptor.id,k=a(f);k&&b.uniqueId===k.uniqueId&&(delete e.draggables[f],c({type:\"REMOVAL\",value:b}))},getById:function(c){(c=a(c))?void 0:m(!1);return c},findById:a,exists:function(c){return!!a(c)},getAllByType:function(c){return dc(e.draggables).filter(function(a){return a.descriptor.type===c})}},droppable:{register:function(c){e.droppables[c.descriptor.id]=\nc},unregister:function(c){var a=b(c.descriptor.id);a&&c.uniqueId===a.uniqueId&&delete e.droppables[c.descriptor.id]},getById:function(c){(c=b(c))?void 0:m(!1);return c},findById:b,exists:function(c){return!!b(c)},getAllByType:function(c){return dc(e.droppables).filter(function(a){return a.descriptor.type===c})}},subscribe:function(c){f.push(c);return function(){var a=f.indexOf(c);-1!==a&&f.splice(a,1)}},clean:function(){e.draggables={};e.droppables={};f.length=0}}}function ma(){var c=C.useMemo(ha,\n[]);Q.useEffect(function(){return function(){requestAnimationFrame(c.clean)}},[c]);return c}function Qa(c){var a=C.useMemo(function(){return\"rbd-announcement-\"+c},[c]),b=Q.useRef(null);Q.useEffect(function(){b.current?m(!1):void 0;var c=document.createElement(\"div\");b.current=c;c.id=a;c.setAttribute(\"aria-live\",\"assertive\");c.setAttribute(\"role\",\"log\");c.setAttribute(\"aria-atomic\",\"true\");Ib(c.style,jf);Ba().appendChild(c);return function(){setTimeout(function(){var c=b.current;c?void 0:m(!1);Ba().removeChild(c);\nb.current=null})}},[a]);return C.useCallback(function(c){var a=b.current;a?a.textContent=c:void 0},[])}function ka(c,a){var b=C.useMemo(function(){return\"rbd-lift-instruction-\"+c},[c]);Q.useEffect(function(){var c=document.createElement(\"div\");c.id=b;c.textContent=a;Ib(c.style,jf);Ba().appendChild(c);return function(){Ba().removeChild(c)}},[b,a]);return b}function ca(c){var a=Q.useRef(c);Q.useEffect(function(){a.current=c});return a}function sa(){function c(){a?void 0:m(!1);a=null}var a=null;return{isClaimed:function(){return!!a},\nisActive:function(c){return c===a},claim:function(c){a?m(!1):void 0;return a=c={abandon:c}},release:c,tryAbandon:function(){a&&(a.abandon(),c())}}}function Ka(c){var a=c.cancel,b=c.completed,e=c.getPhase,f=c.setPhase;return[{eventName:\"mousemove\",fn:function(c){if(0===c.button){var a={x:c.clientX,y:c.clientY},b=e();if(\"DRAGGING\"===b.type)c.preventDefault(),b.actions.move(a);else{\"PENDING\"!==b.type?m(!1):void 0;var k=b.point;if(5<=Math.abs(a.x-k.x)||5<=Math.abs(a.y-k.y))c.preventDefault(),c=b.actions.fluidLift(a),\nf({type:\"DRAGGING\",actions:c})}}}},{eventName:\"mouseup\",fn:function(c){var f=e();\"DRAGGING\"!==f.type?a():(c.preventDefault(),f.actions.drop({shouldBlockNextClick:!0}),b())}},{eventName:\"mousedown\",fn:function(c){\"DRAGGING\"===e().type&&c.preventDefault();a()}},{eventName:\"keydown\",fn:function(c){\"PENDING\"===e().type?a():27===c.keyCode?(c.preventDefault(),a()):kf[c.keyCode]&&c.preventDefault()}},{eventName:\"resize\",fn:a},{eventName:\"scroll\",options:{passive:!0,capture:!1},fn:function(){\"PENDING\"===\ne().type&&a()}},{eventName:\"webkitmouseforcedown\",fn:function(c){var b=e();\"IDLE\"===b.type?m(!1):void 0;b.actions.shouldRespectForcePress()?a():c.preventDefault()}},{eventName:je,fn:a}]}function Ra(){}function $b(c,a){function b(){a();c.cancel()}return[{eventName:\"keydown\",fn:function(e){27===e.keyCode?(e.preventDefault(),b()):32===e.keyCode?(e.preventDefault(),a(),c.drop()):40===e.keyCode?(e.preventDefault(),c.moveDown()):38===e.keyCode?(e.preventDefault(),c.moveUp()):39===e.keyCode?(e.preventDefault(),\nc.moveRight()):37===e.keyCode?(e.preventDefault(),c.moveLeft()):Jg[e.keyCode]?e.preventDefault():kf[e.keyCode]&&e.preventDefault()}},{eventName:\"mousedown\",fn:b},{eventName:\"mouseup\",fn:b},{eventName:\"click\",fn:b},{eventName:\"touchstart\",fn:b},{eventName:\"resize\",fn:b},{eventName:\"wheel\",fn:b,options:{passive:!0}},{eventName:je,fn:b}]}function vc(c){var a=c.cancel,b=c.getPhase;return[{eventName:\"orientationchange\",fn:a},{eventName:\"resize\",fn:a},{eventName:\"contextmenu\",fn:function(c){c.preventDefault()}},\n{eventName:\"keydown\",fn:function(c){\"DRAGGING\"===b().type&&27===c.keyCode&&c.preventDefault();a()}},{eventName:je,fn:a}]}function da(c){var a=c.cancel,b=c.completed,e=c.getPhase;return[{eventName:\"touchmove\",options:{capture:!1},fn:function(c){var b=e();if(\"DRAGGING\"!==b.type)a();else{b.hasMoved=!0;var f=c.touches[0];f={x:f.clientX,y:f.clientY};c.preventDefault();b.actions.move(f)}}},{eventName:\"touchend\",fn:function(c){var f=e();\"DRAGGING\"!==f.type?a():(c.preventDefault(),f.actions.drop({shouldBlockNextClick:!0}),\nb())}},{eventName:\"touchcancel\",fn:function(c){\"DRAGGING\"===e().type&&c.preventDefault();a()}},{eventName:\"touchforcechange\",fn:function(c){var b=e();\"IDLE\"===b.type?m(!1):void 0;var f=c.touches[0];f&&.15<=f.force&&(f=b.actions.shouldRespectForcePress(),\"PENDING\"===b.type?f&&a():f?b.hasMoved?c.preventDefault():a():c.preventDefault())}},{eventName:je,fn:a}]}function eb(c,a){if(null==a)return!1;if(Cg[a.tagName.toLowerCase()])return!0;var b=a.getAttribute(\"contenteditable\");return\"true\"===b||\"\"===b?\n!0:a===c?!1:eb(c,a.parentElement)}function Xb(c,a){a=a.target;return ua(a)?eb(c,a):!1}function md(c,a){return null==c?null:c[Bg](a)?c:md(c.parentElement,a)}function yb(c,a){a=a.target;if(!(a instanceof(a&&a.ownerDocument?a.ownerDocument.defaultView:window).Element))return void 0,null;c=\"[\"+sc.contextId+'\\x3d\"'+c+'\"]';c=a.closest?a.closest(c):md(a,c);return c?ua(c)?c:(void 0,null):null}function zb(c,a){c=Array.prototype.slice.call(document.querySelectorAll(\"[\"+gd.contextId+'\\x3d\"'+c+'\"]'));c=z(c,function(c){return c.getAttribute(gd.id)===\na});return c?ua(c)?c:(void 0,null):null}function Yb(c){c.preventDefault()}function nb(c){var a=c.expected,b=c.phase,e=c.isLockActive;c=c.shouldWarn;return e()&&a===b?!0:(c&&void 0,!1)}function Zb(c){var a=c.store,b=c.registry,e=c.draggableId;if(c.lockAPI.isClaimed())return!1;c=b.draggable.findById(e);return c?c.options.isEnabled&&Ze(a.getState(),e)?!0:!1:(void 0,!1)}function ac(c){function a(){return Tc.options.shouldRespectForcePress}function b(){return f.isActive(kd)}function e(c){function e(a,\nb){void 0===b&&(b={shouldBlockNextClick:!1});c.cleanup();b.shouldBlockNextClick&&(b=x(window,[{eventName:\"click\",fn:Yb,options:{once:!0,passive:!1,capture:!0}}]),setTimeout(b));f.release();C=\"COMPLETED\";n.dispatch({type:\"DROP\",payload:{reason:a}})}\"PRE_DRAG\"!==C&&(f.release(),C=\"COMPLETED\",\"PRE_DRAG\"!==C?m(!1):void 0);n.dispatch({type:\"LIFT\",payload:c.liftActionArgs});C=\"DRAGGING\";return N({isActive:function(){return nb({expected:\"DRAGGING\",phase:C,isLockActive:b,shouldWarn:!1})},shouldRespectForcePress:a,\ndrop:function(c){return e(\"DROP\",c)},cancel:function(c){return e(\"CANCEL\",c)}},c.actions)}var f=c.lockAPI,h=c.contextId,n=c.store,r=c.registry,t=c.draggableId,v=c.forceSensorStop;c=c.sourceEvent;if(!Zb({lockAPI:f,store:n,registry:r,draggableId:t}))return null;var Tc=r.draggable.getById(t),w=zb(h,Tc.descriptor.id);if(!w)return void 0,null;if(c&&!Tc.options.canDragInteractiveElements&&Xb(w,c))return null;var kd=f.claim(v||q),C=\"PRE_DRAG\",A=function(c,a){nb({expected:c,phase:C,isLockActive:b,shouldWarn:!0})&&\nn.dispatch(a())}.bind(this,\"DRAGGING\");return{isActive:function(){return nb({expected:\"PRE_DRAG\",phase:C,isLockActive:b,shouldWarn:!1})},shouldRespectForcePress:a,fluidLift:function(c){var a=Hb(function(c){A(function(){return Ge({client:c})})});c=e({liftActionArgs:{id:t,clientSelection:c,movementMode:\"FLUID\"},cleanup:function(){return a.cancel()},actions:{move:a}});return N({},c,{move:a})},snapLift:function(){return e({liftActionArgs:{id:t,clientSelection:aa.getRect(w.getBoundingClientRect()).center,\nmovementMode:\"SNAP\"},cleanup:q,actions:{moveUp:function(){return A(Xf)},moveRight:function(){return A(ad)},moveDown:function(){return A(Yf)},moveLeft:function(){return A($f)}}})},abort:function(){nb({expected:\"PRE_DRAG\",phase:C,isLockActive:b,shouldWarn:!0})&&f.release()}}}function Ab(c){var a=c.contextId,b=c.store,e=c.registry;c=[].concat(c.enableDefaultSensors?Zf:[],c.customSensors||[]);var f=Q.useState(function(){return sa()})[0],h=C.useCallback(function(c,a){c.isDragging&&!a.isDragging&&f.tryAbandon()},\n[f]);wa(function(){var c=b.getState();return b.subscribe(function(){var a=b.getState();h(c,a);c=a})},[f,b,h]);wa(function(){return f.tryAbandon},[f.tryAbandon]);for(var m=C.useCallback(function(c){return Zb({lockAPI:f,registry:e,store:b,draggableId:c})},[f,e,b]),n=C.useCallback(function(c,k,p){return ac({lockAPI:f,registry:e,contextId:a,store:b,draggableId:c,forceSensorStop:k,sourceEvent:p&&p.sourceEvent?p.sourceEvent:null})},[a,f,e,b]),r=C.useCallback(function(c){c=(c=yb(a,c))?c.getAttribute(sc.draggableId):\nnull;return c},[a]),q=C.useCallback(function(c){return(c=e.draggable.findById(c))?c.options:null},[e.draggable]),t=C.useCallback(f.tryAbandon,[f]),v=C.useCallback(f.isClaimed,[f]),w=C.useMemo(function(){return{canGetLock:m,tryGetLock:n,findClosestDraggableId:r,findOptionsForDraggable:q,tryReleaseLock:t,isLockClaimed:v}},[m,n,r,q,t,v]),x=0;x<c.length;x++)c[x](w)}function ob(c){c.current?void 0:m(!1);return c.current}function fb(c){var a=c.contextId,b=c.setCallbacks,e=c.sensors,f=c.nonce,h=c.liftInstruction,\nm=Q.useRef(null),n=ca(c),r=C.useCallback(function(){var c=n.current;return{onBeforeDragStart:c.onBeforeDragStart,onDragStart:c.onDragStart,onDragEnd:c.onDragEnd,onDragUpdate:c.onDragUpdate}},[n]),q=Qa(a),t=ka(a,h),v=Ga(a,f),w=C.useCallback(function(c){ob(m).dispatch(c)},[]),x=C.useMemo(function(){return Fb.bindActionCreators({publishWhileDragging:Td,updateDroppableScroll:Ob,updateDroppableIsEnabled:Ud,updateDroppableIsCombineEnabled:Pb,collectionStarting:Fe},w)},[w]),z=ma(),D=C.useMemo(function(){return og(z,\nx)},[z,x]),E=C.useMemo(function(){return vg(N({scrollWindow:pg,scrollDroppable:D.scrollDroppable},Fb.bindActionCreators({move:Ge},w)))},[D.scrollDroppable,w]),F=A(a);f=C.useMemo(function(){return Fb.createStore(ib,ng(Fb.applyMiddleware(bg(v),Te(D),ag(D),Kc,kg,Se,mg,lg(E),fg,Ue(F),jg(r,q))))},[q,E,D,F,r,v]);m.current=f;var H=C.useCallback(function(){var c=ob(m);\"IDLE\"!==c.getState().phase&&c.dispatch({type:\"FLUSH\",payload:null})},[]),I=C.useCallback(function(){var c=ob(m).getState();return c.isDragging||\n\"DROP_ANIMATING\"===c.phase},[]);h=C.useMemo(function(){return{isDragging:I,tryAbort:H}},[I,H]);b(h);var K=C.useCallback(function(c){return Ze(ob(m).getState(),c)},[]),M=C.useCallback(function(){return G(ob(m).getState())},[]);b=C.useMemo(function(){return{marshal:D,focus:F,contextId:a,canLift:K,isMovementAllowed:M,liftInstructionId:t,registry:z}},[a,D,F,K,M,t,z]);Ab({contextId:a,store:f,registry:z,customSensors:e,enableDefaultSensors:!1!==c.enableDefaultSensors});Q.useEffect(function(){return H},\n[H]);return ia.createElement(Oc.Provider,{value:b},ia.createElement(Gb.Provider,{context:Pc,store:f},c.children))}function za(c){(c=Q.useContext(c))?void 0:m(!1);return c}function Xa(c){var a=Q.useRef(qc++);return c+\"::\"+a.current}function td(c){var a=Q.useRef(null),b=za(Oc),e=Xa(\"droppable\"),f=b.registry,h=b.marshal,n=ca(c),r=C.useMemo(function(){return{id:c.droppableId,type:c.type,mode:c.mode}},[c.droppableId,c.mode,c.type]),q=Q.useRef(r),t=C.useMemo(function(){return oa(function(c,b){a.current?\nvoid 0:m(!1);h.updateDroppableScroll(r.id,{x:c,y:b})})},[r.id,h]),v=C.useCallback(function(){var c=a.current;return c&&c.env.closestScrollable?pf(c.env.closestScrollable):na},[]),w=C.useCallback(function(){var c=v();t(c.x,c.y)},[v,t]),x=C.useMemo(function(){return Hb(w)},[w]),A=C.useCallback(function(){var c=a.current,b=c&&c.env.closestScrollable||null;c&&b?void 0:m(!1);c.scrollOptions.shouldPublishImmediately?w():x()},[x,w]),z=C.useCallback(function(c,e){a.current?m(!1):void 0;var f=n.current,k=\nf.getDroppableRef();k?void 0:m(!1);var p=Hh(k);var u=Qc(k);p={closestScrollable:p,isFixedOnPage:u};e={ref:k,descriptor:r,env:p,scrollOptions:e};a.current=e;var h=f.direction,y=f.isDropDisabled;u=f.isCombineEnabled;f=!f.ignoreContainerClipping;var B=p.closestScrollable;var q=aa.getBox(k);if(B&&k===B){k=q.paddingBox.top-B.scrollTop;var t=q.paddingBox.left-B.scrollLeft;k=aa.expand({top:k,right:t+B.scrollWidth,bottom:k+B.scrollHeight,left:t},q.border);q=aa.createBox({borderBox:k,margin:q.margin,border:q.border,\npadding:q.padding})}k=aa.withScroll(q,c);if(B){t=aa.getBox(B);var X={scrollHeight:B.scrollHeight,scrollWidth:B.scrollWidth};B={client:t,page:aa.withScroll(t,c),scroll:pf(B),scrollSize:X,shouldClipSubject:f}}else B=null;c=!y;y=p.isFixedOnPage;f=q;B?(q=B.scrollSize,t=B.client,X=We({scrollHeight:q.scrollHeight,scrollWidth:q.scrollWidth,height:t.paddingBox.height,width:t.paddingBox.width}),B={pageMarginBox:B.page.marginBox,frameClient:t,scrollSize:q,shouldClipSubject:B.shouldClipSubject,scroll:{initial:B.scroll,\ncurrent:B.scroll,max:X,diff:{value:na,displacement:na}}}):B=null;h=\"vertical\"===h?gb:Ed;q=fc({page:k,withPlaceholder:null,axis:h,frame:B});u={descriptor:r,isCombineEnabled:u,isFixedOnPage:y,axis:h,isEnabled:c,client:f,page:k,frame:B,subject:q};if(p=p.closestScrollable)p.setAttribute(gf.contextId,b.contextId),p.addEventListener(\"scroll\",A,e.scrollOptions.shouldPublishImmediately?Og:rf);return u},[b.contextId,r,A,n]),D=C.useCallback(function(){var c=a.current,b=c&&c.env.closestScrollable||null;c&&b?\nvoid 0:m(!1);return pf(b)},[]),E=C.useCallback(function(){var c=a.current;c?void 0:m(!1);var b=c&&c.env.closestScrollable||null;a.current=null;b&&(x.cancel(),b.removeAttribute(gf.contextId),b.removeEventListener(\"scroll\",A,c.scrollOptions.shouldPublishImmediately?Og:rf))},[A,x]),F=C.useCallback(function(c){var b=a.current;b?void 0:m(!1);(b=b&&b.env.closestScrollable||null)?void 0:m(!1);b.scrollTop+=c.y;b.scrollLeft+=c.x},[]),H=C.useMemo(function(){return{getDimensionAndWatchScroll:z,getScrollWhileDragging:D,\ndragStopped:E,scroll:F}},[E,z,D,F]),G=C.useMemo(function(){return{uniqueId:e,descriptor:r,callbacks:H}},[H,r,e]);wa(function(){q.current=G.descriptor;f.droppable.register(G);return function(){a.current&&(void 0,E());f.droppable.unregister(G)}},[H,r,E,G,h,f.droppable]);wa(function(){a.current&&h.updateDroppableIsEnabled(q.current.id,!c.isDropDisabled)},[c.isDropDisabled,h]);wa(function(){a.current&&h.updateDroppableIsCombineEnabled(q.current.id,c.isCombineEnabled)},[c.isCombineEnabled,h])}function bc(){}\nfunction vd(c){var a=Xa(\"draggable\"),b=c.descriptor,e=c.registry,f=c.getDraggableRef,h=c.canDragInteractiveElements,n=c.shouldRespectForcePress,q=c.isEnabled,r=C.useMemo(function(){return{canDragInteractiveElements:h,shouldRespectForcePress:n,isEnabled:q}},[h,q,n]),t=C.useCallback(function(c){var a=f();a?void 0:m(!1);var e=c;void 0===e&&(e=na);c=window.getComputedStyle(a);var k=a.getBoundingClientRect();k=aa.calculateBox(k,c);e=aa.withScroll(k,e);a={client:k,tagName:a.tagName.toLowerCase(),display:c.display};\nreturn{descriptor:b,placeholder:a,displaceBy:{x:k.marginBox.width,y:k.marginBox.height},client:k,page:e}},[b,f]),v=C.useMemo(function(){return{uniqueId:a,descriptor:b,options:r,getDimension:t}},[b,t,r,a]),w=Q.useRef(v),x=Q.useRef(!0);wa(function(){e.draggable.register(w.current);return function(){return e.draggable.unregister(w.current)}},[e.draggable]);wa(function(){if(x.current)x.current=!1;else{var c=w.current;w.current=v;e.draggable.update(v,c)}},[v,e.draggable])}function Bb(c){c.preventDefault()}\nfunction wd(){var c=oa(function(c,a){return{x:c,y:a}}),a=oa(function(c,a,b,e,f){return{isDragging:!0,isClone:a,isDropAnimating:!!f,dropAnimation:f,mode:c,draggingOver:b,combineWith:e,combineTargetFor:null}}),b=oa(function(c,b,e,f,k,p,h){return{mapped:{type:\"DRAGGING\",dropping:null,draggingOver:k,combineWith:p,mode:b,offset:c,dimension:e,forceShouldAnimate:h,snapshot:a(b,f,k,p,null)}}});return function(e,f){if(e.isDragging){if(e.critical.draggable.id!==f.draggableId)return null;var k=e.current.client.offset,\np=e.dimensions.draggables[f.draggableId],u=ja(e.impact);var h=e.impact;h=h.at&&\"COMBINE\"===h.at.type?h.at.combine.draggableId:null;var m=e.forceShouldAnimate;return b(c(k.x,k.y),e.movementMode,p,f.isClone,u,h,m)}if(\"DROP_ANIMATING\"===e.phase){p=e.completed;if(p.result.draggableId!==f.draggableId)return null;k=f.isClone;f=e.dimensions.draggables[f.draggableId];h=p.result;p=h.mode;u=Pg(h);h=h.combine?h.combine.draggableId:null;m={duration:e.dropDuration,curve:Wd.drop,moveTo:e.newHomeClientOffset,opacity:h?\nkc.opacity.drop:null,scale:h?kc.scale.drop:null};return{mapped:{type:\"DRAGGING\",offset:e.newHomeClientOffset,dimension:f,dropping:m,draggingOver:u,combineWith:h,mode:p,forceShouldAnimate:null,snapshot:a(p,k,u,h,m)}}}return null}}function qb(c){return{isDragging:!1,isDropAnimating:!1,isClone:!1,dropAnimation:null,mode:null,draggingOver:null,combineTargetFor:c,combineWith:null}}function Cb(){var c=oa(function(c,a){return{x:c,y:a}}),a=oa(qb),b=oa(function(c,b,e){void 0===b&&(b=null);return{mapped:{type:\"SECONDARY\",\noffset:c,combineTargetFor:b,shouldAnimateDisplacement:e,snapshot:a(b)}}}),e=function(a,e,f,k){var p=f.displaced.visible[a],u=!(!k.inVirtualList||!k.effected[a]),h=F(f);e=h&&h.draggableId===a?e:null;if(!p){if(!u)return e?b(na,e,!0):null;if(f.displaced.invisible[a])return null;p=$a(k.displacedBy.point);p=c(p.x,p.y);return b(p,e,!0)}if(u)return e?b(na,e,!0):null;a=f.displacedBy.point;a=c(a.x,a.y);return b(a,e,p.shouldAnimate)};return function(c,a){return c.isDragging?c.critical.draggable.id===a.draggableId?\nnull:e(a.draggableId,c.critical.draggable.id,c.impact,c.afterCritical):\"DROP_ANIMATING\"===c.phase?(c=c.completed,c.result.draggableId===a.draggableId?null:e(a.draggableId,c.result.draggableId,c.impact,c.afterCritical)):null}}function Db(c){return za(sf).isUsingCloneFor!==c.draggableId||c.isClone?ia.createElement(Xd,c):null}Object.defineProperty(f,\"__esModule\",{value:!0});var Q=a(5),ia=e(Q),C=a(24),Uc=e(a(62)),N=e(a(70)),Fb=a(73),Gb=a(101),aa=a(103),oa=e(a(104)),dc=e(a(108)),Ya=e(a(112)),Hb=e(a(113)),\nZa=e(a(116)),Ib=e(a(69)),ec=e(a(14));e(a(120));t.bind(null,\"warn\");t.bind(null,\"error\");w.prototype.toString=function(){return this.message};var Da=function(c){function a(){for(var a,b=arguments.length,e=Array(b),f=0;f<b;f++)e[f]=arguments[f];a=c.call.apply(c,[this].concat(e))||this;a.callbacks=null;a.unbind=q;a.onWindowError=function(c){var b=a.getCallbacks();b.isDragging()&&(b.tryAbort(),void 0);c.error instanceof w&&c.preventDefault()};a.getCallbacks=function(){if(!a.callbacks)throw Error(\"Unable to find AppCallbacks in \\x3cErrorBoundary/\\x3e\");\nreturn a.callbacks};a.setCallbacks=function(c){a.callbacks=c};return a}Uc(a,c);var b=a.prototype;b.componentDidMount=function(){this.unbind=x(window,[{eventName:\"error\",fn:this.onWindowError}])};b.componentWillUnmount=function(){this.unbind()};b.componentDidCatch=function(c){if(c instanceof w)this.setState({});else throw c;};b.render=function(){return this.props.children(this.setCallbacks)};return a}(ia.Component),xd=function(c,a){var b=c.index+1,e=a.index+1;return c.droppableId===a.droppableId?\"\\n      You have moved the item from position \"+\nb+\"\\n      to position \"+e+\"\\n    \":\"\\n    You have moved the item from position \"+b+\"\\n    in list \"+c.droppableId+\"\\n    to list \"+a.droppableId+\"\\n    in position \"+e+\"\\n  \"},yd=function(c,a,b){return a.droppableId===b.droppableId?\"\\n      The item \"+c+\"\\n      has been combined with \"+b.draggableId:\"\\n      The item \"+c+\"\\n      in list \"+a.droppableId+\"\\n      has been combined with \"+b.draggableId+\"\\n      in list \"+b.droppableId+\"\\n    \"},fa=function(c){return\"\\n  The item has returned to its starting position\\n  of \"+\n(c.index+1)+\"\\n\"},Jb=function(c){return\"\\n  You have lifted an item in position \"+(c.source.index+1)+\".\\n  Use the arrow keys to move, space bar to drop, and escape to cancel.\\n\"},Vc=function(c){var a=c.destination;return a?xd(c.source,a):(a=c.combine)?yd(c.draggableId,c.source,a):\"You are over an area that cannot be dropped on\"},Kb=function(c){if(\"CANCEL\"===c.reason)return\"\\n      Movement cancelled.\\n      \"+fa(c.source)+\"\\n    \";var a=c.destination,b=c.combine;return a?\"\\n      You have dropped the item.\\n      \"+\nxd(c.source,a)+\"\\n    \":b?\"\\n      You have dropped the item.\\n      \"+yd(c.draggableId,c.source,b)+\"\\n    \":\"\\n    The item has been dropped while not over a drop area.\\n    \"+fa(c.source)+\"\\n  \"},na={x:0,y:0},M=function(c,a){return{x:c.x+a.x,y:c.y+a.y}},pa=function(c,a){return{x:c.x-a.x,y:c.y-a.y}},b=function(c,a){return c.x===a.x&&c.y===a.y},$a=function(c){return{x:0!==c.x?-c.x:0,y:0!==c.y?-c.y:0}},H=function(c,a,b){var e;void 0===b&&(b=0);return e={},e[c]=a,e[\"x\"===c?\"y\":\"x\"]=b,e},va=function(c,\na){return Math.sqrt(Math.pow(a.x-c.x,2)+Math.pow(a.y-c.y,2))},cc=function(a,b){return Math.min.apply(Math,b.map(function(c){return va(a,c)}))},zd=function(a){return function(c){return{x:a(c.x),y:a(c.y)}}},pb=function(a,b){return{top:a.top+b.y,left:a.left+b.x,bottom:a.bottom+b.y,right:a.right+b.x}},ud=function(a){return[{x:a.left,y:a.top},{x:a.right,y:a.top},{x:a.left,y:a.bottom},{x:a.right,y:a.bottom}]},fc=function(a){var c=a.page,b=a.withPlaceholder,e=a.axis;a=a.frame;var f=c.marginBox;f=a?pb(f,\na.scroll.diff.displacement):f;if(b&&b.increasedBy){var h;e=N({},f,(h={},h[e.end]=f[e.end]+b.increasedBy[e.line],h))}else e=f;h=e;a&&a.shouldClipSubject?(a=a.pageMarginBox,a=aa.getRect({top:Math.max(h.top,a.top),right:Math.min(h.right,a.right),bottom:Math.min(h.bottom,a.bottom),left:Math.max(h.left,a.left)}),a=0>=a.width||0>=a.height?null:a):a=aa.getRect(h);return{page:c,withPlaceholder:b,active:a}},Ad=function(a,b){a.frame?void 0:m(!1);var c=a.frame,e=pa(b,c.scroll.initial),f=$a(e);b=N({},c,{scroll:{initial:c.scroll.initial,\ncurrent:b,diff:{value:e,displacement:f},max:c.scroll.max}});c=fc({page:a.subject.page,withPlaceholder:a.subject.withPlaceholder,axis:a.axis,frame:b});return N({},a,{frame:b,subject:c})},Bd=oa(function(a){return a.reduce(function(a,c){a[c.descriptor.id]=c;return a},{})}),Cd=oa(function(a){return a.reduce(function(a,c){a[c.descriptor.id]=c;return a},{})}),Ta=oa(function(a){return dc(a)}),Dd=oa(function(a){return dc(a)}),Lb=oa(function(a,b){return Dd(b).filter(function(c){return a===c.descriptor.droppableId}).sort(function(a,\nc){return a.descriptor.index-c.descriptor.index})}),re={vertical:\"down\",horizontal:\"right\"},Hf={vertical:\"up\",horizontal:\"left\"},Yc=oa(function(a,b){return b.filter(function(c){return c.descriptor.id!==a.descriptor.id})}),If=function(a){function c(a){return N({},n,{at:{type:\"COMBINE\",whenEntered:b?re:Hf,combine:{draggableId:a,droppableId:f.descriptor.id}}})}var b=a.isMovingForward,e=a.draggable,f=a.destination,h=a.insideDestination,n=a.previousImpact;if(!f.isCombineEnabled||!I(n))return null;a=n.displaced.all;\nvar q=a.length?a[0]:null;if(b)return q?c(q):null;e=Yc(e,h);if(!q)return e.length?c(e[e.length-1].descriptor.id):null;h=E(e,function(a){return a.descriptor.id===q});-1===h?m(!1):void 0;--h;return 0>h?null:c(e[h].descriptor.id)},Mb=function(a,b){return a.descriptor.droppableId===b.descriptor.id},se={point:na,value:0},gc={invisible:{},visible:{},all:[]},Cc={displaced:gc,displacedBy:se,at:null},Ha=function(a,b){return function(c){return a<=c&&c<=b}},Wc=function(a){var c=Ha(a.top,a.bottom),b=Ha(a.left,\na.right);return function(e){if(c(e.top)&&c(e.bottom)&&b(e.left)&&b(e.right))return!0;var f=c(e.top)||c(e.bottom),k=b(e.left)||b(e.right);if(f&&k)return!0;var p=e.top<a.top&&e.bottom>a.bottom;e=e.left<a.left&&e.right>a.right;return p&&e?!0:p&&k||e&&f}},Jf=function(a){var c=Ha(a.top,a.bottom),b=Ha(a.left,a.right);return function(a){return c(a.top)&&c(a.bottom)&&b(a.left)&&b(a.right)}},gb={direction:\"vertical\",line:\"y\",crossAxisLine:\"x\",start:\"top\",end:\"bottom\",size:\"height\",crossAxisStart:\"left\",crossAxisEnd:\"right\",\ncrossAxisSize:\"width\"},Ed={direction:\"horizontal\",line:\"x\",crossAxisLine:\"y\",start:\"left\",end:\"right\",size:\"width\",crossAxisStart:\"top\",crossAxisEnd:\"bottom\",crossAxisSize:\"height\"},Lf=function(a){return function(c){var b=Ha(c.top,c.bottom),e=Ha(c.left,c.right);return function(c){return a===gb?b(c.top)&&b(c.bottom):e(c.left)&&e(c.right)}}},Fd=function(a){var c=a.target,b=a.destination,e=a.viewport,f=a.isVisibleThroughFrameFn;a=a.withDroppableDisplacement?pb(c,b.frame?b.frame.scroll.diff.displacement:\nna):c;b=b.subject.active?f(b.subject.active)(a):!1;b&&(b=f(e)(a));return b},te=function(a){return Fd(N({},a,{isVisibleThroughFrameFn:Jf}))},Nf=function(a){var c=a.displaced,b=a.combineWith,e=a.displacedBy;c=!(!c.visible[b]&&!c.invisible[b]);return a.afterCritical.effected[b]?c?na:$a(e.point):c?e.point:na},ue=function(a,b,e){return b[a.crossAxisStart]+e.margin[a.crossAxisStart]+e.borderBox[a.crossAxisSize]/2},ve=function(a){var c=a.axis,b=a.moveRelativeTo;a=a.isMoving;return H(c.line,b.marginBox[c.end]+\n(a.margin[c.start]+a.borderBox[c.size]/2),ue(c,b.marginBox,a))},we=function(a){var c=a.axis,b=a.moveRelativeTo;a=a.isMoving;return H(c.line,b.marginBox[c.start]-(a.margin[c.end]+a.borderBox[c.size]/2),ue(c,b.marginBox,a))},lh=function(a){var c=a.impact,b=a.draggable,e=a.draggables,f=a.droppable,h=a.afterCritical,m=Lb(f.descriptor.id,e);a=b.page;var n=f.axis;if(!m.length)return b=f.page,H(n.line,b.contentBox[n.start]+(a.margin[n.start]+a.borderBox[n.size]/2),ue(n,b.contentBox,a));f=c.displacedBy;if(c=\nc.displaced.all[0]){b=e[c];if(h.effected[c])return we({axis:n,moveRelativeTo:b.page,isMoving:a});b=aa.offset(b.page,f.point);return we({axis:n,moveRelativeTo:b,isMoving:a})}e=m[m.length-1];return e.descriptor.id===b.descriptor.id?a.borderBox.center:h.effected[e.descriptor.id]?(b=aa.offset(e.page,$a(h.displacedBy.point)),ve({axis:n,moveRelativeTo:b,isMoving:a})):ve({axis:n,moveRelativeTo:e.page,isMoving:a})},Fc=function(a,b){return(a=a.frame)?M(b,a.scroll.diff.displacement):b},Hd=function(a){var c=\na.impact;var b=a.draggable,e=a.droppable,f=a.draggables,h=a.afterCritical,n=b.page.borderBox.center,q=c.at;e&&q?\"REORDER\"===q.type?c=lh({impact:c,draggable:b,draggables:f,droppable:e,afterCritical:h}):((b=F(c))?void 0:m(!1),b=b.draggableId,f=f[b].page.borderBox.center,c=Nf({displaced:c.displaced,afterCritical:h,combineWith:b,displacedBy:c.displacedBy}),c=M(f,c)):c=n;return(a=a.droppable)?Fc(a,c):c},xe=function(a,b){var c=pa(b,a.scroll.initial),e=$a(c);return{frame:aa.getRect({top:b.y,bottom:b.y+a.frame.height,\nleft:b.x,right:b.x+a.frame.width}),scroll:{initial:a.scroll.initial,max:a.scroll.max,current:b,diff:{value:c,displacement:e}}}},Of=function(a){var c=a.impact,b=a.viewport,e=a.destination,f=a.draggables;a=a.maxScrollChange;var h=xe(b,M(b.scroll.current,a)),m=e.frame?Ad(e,M(e.frame.scroll.current,a)):e;a=c.displaced;e=D({afterDragging:R(a.all,f),destination:e,displacedBy:c.displacedBy,viewport:h.frame,last:a,forceShouldAnimate:!1});b=D({afterDragging:R(a.all,f),destination:m,displacedBy:c.displacedBy,\nviewport:b.frame,last:a,forceShouldAnimate:!1});var n={},q={},r=[a,e,b];a.all.forEach(function(a){var c;a:{for(c=0;c<r.length;c++){var b=r[c].visible[a];if(b){c=b;break a}}c=null}c?q[a]=c:n[a]=!0});return N({},c,{displaced:{all:a.all,invisible:n,visible:q}})},Ae=function(a){var c=a.draggable;a=M(a.viewport.scroll.diff.displacement,a.pageBorderBoxCenter);a=pa(a,c.page.borderBox.center);return M(c.client.borderBox.center,a)},Pf=function(a){var c=a.draggable,b=a.destination,e=a.viewport,f=a.withDroppableDisplacement,\nh=a.onlyOnMainAxis;h=void 0===h?!1:h;a=pa(a.newPageBorderBoxCenter,c.page.borderBox.center);c={target:pb(c.page.borderBox,a),destination:b,withDroppableDisplacement:f,viewport:e};return h?Fd(N({},c,{isVisibleThroughFrameFn:Lf(c.destination.axis)})):te(c)},mh=function(a){var c=a.isMovingForward,b=a.draggable,e=a.destination,f=a.draggables,h=a.previousImpact,n=a.viewport,q=a.previousPageBorderBoxCenter,t=a.previousClientSelection;a=a.afterCritical;if(!e.isEnabled)return null;var v=Lb(e.descriptor.id,\nf),w=Mb(b,e),x;(x=If({isMovingForward:c,draggable:b,destination:e,insideDestination:v,previousImpact:h}))||((x=h.at)?void 0:m(!1),\"REORDER\"===x.type?(x=x.destination,v.length?(x=x.index,c=c?x+1:x-1,x=v[v.length-1].descriptor.index,c=c<v[0].descriptor.index||c>(w?x:x+1)?null:c):c=null,x=null==c?null:r({draggable:b,insideDestination:v,destination:e,viewport:n,last:h.displaced,displacedBy:h.displacedBy,index:c})):(w=x.combine,e.isCombineEnabled?(w=w.draggableId,x=f[w].descriptor.index,c=a.effected[w]?\nc?x:x-1:c?x+1:x):c=null,x=null==c?null:r({draggable:b,insideDestination:v,destination:e,viewport:n,last:h.displaced,displacedBy:h.displacedBy,index:c})));h=x;if(!h)return null;a=Hd({impact:h,draggable:b,droppable:e,draggables:f,afterCritical:a});if(Pf({draggable:b,destination:e,newPageBorderBoxCenter:a,viewport:n.frame,withDroppableDisplacement:!1,onlyOnMainAxis:!0}))return{clientSelection:Ae({pageBorderBoxCenter:a,draggable:b,viewport:n}),impact:h,scrollJumpRequest:null};b=pa(a,q);e=Of({impact:h,\nviewport:n,destination:e,draggables:f,maxScrollChange:b});return{clientSelection:t,impact:e,scrollJumpRequest:b}},Fa=function(a){(a=a.subject.active)?void 0:m(!1);return a},nh=function(a){var c=a.isMovingForward,b=a.pageBorderBoxCenter,e=a.source,f=a.droppables,h=a.viewport,m=e.subject.active;if(!m)return null;var n=e.axis,q=Ha(m[n.start],m[n.end]);a=Ta(f).filter(function(a){return a!==e}).filter(function(a){return a.isEnabled}).filter(function(a){return!!a.subject.active}).filter(function(a){return Wc(h.frame)(Fa(a))}).filter(function(a){a=\nFa(a);return c?m[n.crossAxisEnd]<a[n.crossAxisEnd]:a[n.crossAxisStart]<m[n.crossAxisStart]}).filter(function(a){a=Fa(a);var c=Ha(a[n.start],a[n.end]);return q(a[n.start])||q(a[n.end])||c(m[n.start])||c(m[n.end])}).sort(function(a,b){a=Fa(a)[n.crossAxisStart];b=Fa(b)[n.crossAxisStart];return c?a-b:b-a}).filter(function(a,c,b){return Fa(a)[n.crossAxisStart]===Fa(b[0])[n.crossAxisStart]});if(!a.length)return null;if(1===a.length)return a[0];f=a.filter(function(a){return Ha(Fa(a)[n.start],Fa(a)[n.end])(b[n.line])});\nreturn 1===f.length?f[0]:1<f.length?f.sort(function(a,c){return Fa(a)[n.start]-Fa(c)[n.start]})[0]:a.sort(function(a,c){var e=cc(b,ud(Fa(a))),f=cc(b,ud(Fa(c)));return e!==f?e-f:Fa(a)[n.start]-Fa(c)[n.start]})[0]},Gc=function(a,b){var c=a.page.borderBox.center;return b.effected[a.descriptor.id]?pa(c,b.displacedBy.point):c},Qf=function(a){var c=a.pageBorderBoxCenter,b=a.viewport,e=a.destination,f=a.afterCritical;return a.insideDestination.filter(function(a){var c=a.page.borderBox;a=f.effected[a.descriptor.id]?\npb(c,$a(f.displacedBy.point)):c;return te({target:a,destination:e,viewport:b.frame,withDroppableDisplacement:!0})}).sort(function(a,b){var k=va(c,Fc(e,Gc(a,f))),p=va(c,Fc(e,Gc(b,f)));return k<p?-1:p<k?1:a.descriptor.index-b.descriptor.index})[0]||null},la=oa(function(a,b){b=b[a.line];return{value:b,point:H(a.line,b)}}),qa=function(a,b,e){var c=a.axis;if(\"virtual\"===a.descriptor.mode)return H(c.line,b[c.line]);var f=a.subject.page.contentBox[c.size];a=Lb(a.descriptor.id,e).reduce(function(a,b){return a+\nb.client.marginBox[c.size]},0)+b[c.line]-f;return 0>=a?null:H(c.line,a)},hc=function(a,b,e){var c=a.frame;Mb(b,a)?m(!1):void 0;a.subject.withPlaceholder?m(!1):void 0;b=la(a.axis,b.displaceBy).point;var f=qa(a,b,e);e={placeholderSize:b,increasedBy:f,oldFrameMaxScroll:a.frame?a.frame.scroll.max:null};if(!c)return c=fc({page:a.subject.page,withPlaceholder:e,axis:a.axis,frame:a.frame}),N({},a,{subject:c});b=f?M(c.scroll.max,f):c.scroll.max;c=N({},c,{scroll:N({},c.scroll,{max:b})});e=fc({page:a.subject.page,\nwithPlaceholder:e,axis:a.axis,frame:c});return N({},a,{subject:e,frame:c})},ja=function(a){return(a=a.at)?\"REORDER\"===a.type?a.destination.droppableId:a.combine.droppableId:null},Kd=function(a){var c=a.state;a=a.type;var b=c.dimensions.droppables;var e=ja(c.impact);b=e?b[e]:null;e=c.dimensions.droppables[c.critical.droppable.id];var f=b||e;e=f.axis.direction;if((e=\"vertical\"===e&&(\"MOVE_UP\"===a||\"MOVE_DOWN\"===a)||\"horizontal\"===e&&(\"MOVE_LEFT\"===a||\"MOVE_RIGHT\"===a))&&!b)return null;var h=\"MOVE_DOWN\"===\na||\"MOVE_RIGHT\"===a;a=c.dimensions.draggables[c.critical.draggable.id];var m=c.current.page.borderBoxCenter,n=c.dimensions;b=n.draggables;n=n.droppables;if(e)a=mh({isMovingForward:h,previousPageBorderBoxCenter:m,draggable:a,destination:f,draggables:b,viewport:c.viewport,previousClientSelection:c.current.client.selection,previousImpact:c.impact,afterCritical:c.afterCritical});else if(e=c.viewport,c=c.afterCritical,f=nh({isMovingForward:h,pageBorderBoxCenter:m,source:f,droppables:n,viewport:e})){h=\nLb(f.descriptor.id,b);if(n=Qf({pageBorderBoxCenter:m,viewport:e,destination:f,insideDestination:h,afterCritical:c})){m=m[f.axis.line]<=n.page.borderBox.center[f.axis.line];var q=n.descriptor.index;m=n.descriptor.id===a.descriptor.id||m?q:q+1;n=la(f.axis,a.displaceBy);m=r({draggable:a,insideDestination:h,destination:f,viewport:e,displacedBy:n,last:gc,index:m})}else h.length?m=null:(m={displaced:gc,displacedBy:se,at:{type:\"REORDER\",destination:{droppableId:f.descriptor.id,index:0}}},h=Hd({impact:m,\ndraggable:a,droppable:f,draggables:b,afterCritical:c}),n=Mb(a,f)?f:hc(f,a,b),m=Pf({draggable:a,destination:n,newPageBorderBoxCenter:h,viewport:e.frame,withDroppableDisplacement:!1,onlyOnMainAxis:!0})?m:null);m?(b=Hd({impact:m,draggable:a,droppable:f,draggables:b,afterCritical:c}),a={clientSelection:Ae({pageBorderBoxCenter:b,draggable:a,viewport:e}),impact:m,scrollJumpRequest:null}):a=null}else a=null;return a},Ld=function(a){var c=Ha(a.top,a.bottom),b=Ha(a.left,a.right);return function(a){return c(a.y)&&\nc(a.y)&&b(a.x)&&b(a.x)}},Rf=function(a){var c=a.target;return(a=z(Ta(a.droppables),function(a){return a.isEnabled?(a=a.subject.active)?Ld(a)(c):!1:!1}))?a.descriptor.id:null},Ce=function(a,b){return a===gb?\"down\"===b.vertical:\"right\"===b.horizontal},Md=function(a){var c=a.pageBorderBoxCenterWithDroppableScrollChange,b=a.draggable,e=a.destination,f=a.insideDestination,h=a.last,m=a.viewport,n=a.afterCritical,q=e.axis,t=Ce(e.axis,a.userDirection);a=la(e.axis,b.displaceBy);var v=c[q.line],w=a.value;c=\nYc(b,f);c=z(c,function(a){var c=a.page.borderBox,b=c[q.start];c=c[q.end];a=!!n.effected[a.descriptor.id];return t?a?v<b:v<b+w:a?v<=c-w:v<=c});c=V({draggable:b,closest:c,inHomeList:Mb(b,e)});return r({draggable:b,insideDestination:f,destination:e,viewport:m,last:h,displacedBy:a,index:c})},Sf=function(a){var c=a.draggable,b=a.pageBorderBoxCenterWithDroppableScrollChange,e=a.previousImpact,f=a.destination,h=a.insideDestination,m=a.userDirection,n=a.afterCritical;if(!f.isCombineEnabled)return null;var q=\nf.axis,r=e.displaced,t=la(f.axis,c.displaceBy);var v=e.at&&\"COMBINE\"===e.at.type?e.at:null;return(a=z(Yc(c,h),function(a){var c=a.descriptor.id,e=Nf({displaced:r,afterCritical:n,combineWith:c,displacedBy:t});var f=a.page.borderBox;a=f[q.start]+e[q.line];e=f[q.end]+e[q.line];f=.666*f[q.size];c=Ce(q,v&&c===v.combine.draggableId?v.whenEntered:m);var k=b[q.line];a=c?Ha(a,a+f)(k):Ha(e-f,e)(k);return a}))?K({combineWithId:a.descriptor.id,destinationId:f.descriptor.id,previousImpact:e,userDirection:m}):\nnull},Nd=function(a){var c=a.pageBorderBoxCenter,b=a.draggable,e=a.draggables,f=a.droppables,h=a.previousImpact,m=a.viewport,n=a.userDirection;a=a.afterCritical;var q=Rf({target:c,droppables:f});if(!q)return Cc;f=f[q];e=Lb(f.descriptor.id,e);c=(q=f.frame)?M(c,q.scroll.diff.value):c;return Sf({pageBorderBoxCenterWithDroppableScrollChange:c,draggable:b,previousImpact:h,destination:f,insideDestination:e,userDirection:n,afterCritical:a})||Md({pageBorderBoxCenterWithDroppableScrollChange:c,draggable:b,\ndestination:f,insideDestination:e,last:h.displaced,viewport:m,userDirection:n,afterCritical:a})},Od=function(a,b){var c;return N({},a,(c={},c[b.descriptor.id]=b,c))},ab=function(a){var c=a.state,b=a.impact,e=a.scrollJumpRequest,f=a.viewport||c.viewport,h=f.scroll.current,n=a.dimensions||c.dimensions;a=a.clientSelection||c.current.client.selection;var q=pa(a,c.initial.client.selection);a={offset:q,selection:a,borderBoxCenter:M(c.initial.client.borderBoxCenter,q)};var r={selection:M(a.selection,h),\nborderBoxCenter:M(a.borderBoxCenter,h)};h={client:a,page:r};a=c.userDirection;var t=pa(h.page.borderBoxCenter,c.current.page.borderBoxCenter);q=t.x;t=t.y;a={horizontal:0===q?a.horizontal:0<q?\"right\":\"left\",vertical:0===t?a.vertical:0<t?\"down\":\"up\"};if(\"COLLECTING\"===c.phase)return N({phase:\"COLLECTING\"},c,{dimensions:n,viewport:f,current:h,userDirection:a});q=n.draggables[c.critical.draggable.id];b=b||Nd({pageBorderBoxCenter:r.borderBoxCenter,draggable:q,draggables:n.draggables,droppables:n.droppables,\npreviousImpact:c.impact,viewport:f,userDirection:a,afterCritical:c.afterCritical});r=n.draggables;t=n.droppables;var v=ja(c.impact);var w=ja(b);if(v&&v!==w)if(v=t[v],v.subject.withPlaceholder){var x=v.subject.withPlaceholder;x?void 0:m(!1);(w=v.frame)?((x=x.oldFrameMaxScroll)?void 0:m(!1),w=N({},w,{scroll:N({},w.scroll,{max:x})}),x=fc({page:v.subject.page,axis:v.axis,frame:w,withPlaceholder:null}),v=N({},v,{subject:x,frame:w})):(w=fc({page:v.subject.page,axis:v.axis,frame:null,withPlaceholder:null}),\nv=N({},v,{subject:w}));v=Od(t,v)}else v=t;else v=t;(w=ja(b))?(t=t[w],Mb(q,t)||t.subject.withPlaceholder?q=v:(q=hc(t,q,r),q=Od(v,q))):q=v;return N({},c,{current:h,userDirection:a,dimensions:{draggables:n.draggables,droppables:q},impact:b,viewport:f,scrollJumpRequest:e||null,forceShouldAnimate:e?!1:null})},Pd=function(a){var c=a.impact,b=a.viewport,e=a.destination,f=a.forceShouldAnimate,h=c.displaced;a=P(h.all,a.draggables);b=D({afterDragging:a,destination:e,displacedBy:c.displacedBy,viewport:b.frame,\nforceShouldAnimate:f,last:h});return N({},c,{displaced:b})},De=function(a){var c=a.draggable,b=a.viewport;a=Hd({impact:a.impact,draggable:c,draggables:a.draggables,droppable:a.droppable,afterCritical:a.afterCritical});return Ae({pageBorderBoxCenter:a,draggable:c,viewport:b})},Ma=function(a){var c=a.state,b=a.dimensions;a=a.viewport;\"SNAP\"!==c.movementMode?m(!1):void 0;var e=c.impact;a=a||c.viewport;b=b||c.dimensions;var f=b.draggables,h=b.droppables,n=f[c.critical.draggable.id],q=ja(e);q?void 0:m(!1);\nh=h[q];e=Pd({impact:e,viewport:a,destination:h,draggables:f});f=De({impact:e,draggable:n,droppable:h,draggables:f,viewport:a,afterCritical:c.afterCritical});return ab({impact:e,clientSelection:f,state:c,dimensions:b,viewport:a})},Vf=function(a){return{index:a.index,droppableId:a.droppableId}},Va=function(a){var c=a.draggable,b=a.home,e=a.draggables;a=a.viewport;var f=la(b.axis,c.displaceBy);e=Lb(b.descriptor.id,e);var h=e.indexOf(c);-1===h?m(!1):void 0;e=e.slice(h+1);h=e.reduce(function(a,c){a[c.descriptor.id]=\n!0;return a},{});h={inVirtualList:\"virtual\"===b.descriptor.mode,displacedBy:f,effected:h};return{impact:{displaced:D({afterDragging:e,destination:b,displacedBy:f,last:null,viewport:a.frame,forceShouldAnimate:!1}),displacedBy:f,at:{type:\"REORDER\",destination:Vf(c.descriptor)}},afterCritical:h}},Wf=function(a){var c=a.updatedDroppables,b=a.viewport,e=b.scroll.diff.value;return a.additions.map(function(a){var f=c[a.descriptor.droppableId].frame;f?void 0:m(!1);var k=M(e,f.scroll.diff.value);f=b.scroll.initial;\nk=aa.offset(a.client,k);f=aa.withScroll(k,f);return N({},a,{placeholder:N({},a.placeholder,{client:k}),client:k,page:f})})},Ee=function(a){var c,b,e=a.state;a=a.published;var f=a.modified.map(function(a){return Ad(e.dimensions.droppables[a.droppableId],a.scroll)});f=N({},e.dimensions.droppables,{},Bd(f));var h=Cd(Wf({additions:a.additions,updatedDroppables:f,viewport:e.viewport})),m=N({},e.dimensions.draggables,{},h);a.removals.forEach(function(a){delete m[a]});a={droppables:f,draggables:m};h=(f=\nja(e.impact))?a.droppables[f]:null;var n=Va({draggable:a.draggables[e.critical.draggable.id],home:a.droppables[e.critical.droppable.id],draggables:m,viewport:e.viewport});f=n.impact;n=n.afterCritical;h=Nd({pageBorderBoxCenter:e.current.page.borderBoxCenter,draggable:a.draggables[e.critical.draggable.id],draggables:a.draggables,droppables:a.droppables,previousImpact:h&&h.isCombineEnabled?e.impact:f,viewport:e.viewport,userDirection:e.userDirection,afterCritical:n});a=N({phase:\"DRAGGING\"},e,(c={},c.phase=\n\"DRAGGING\",c.impact=h,c.onLiftImpact=f,c.dimensions=a,c.afterCritical=n,c.forceShouldAnimate=!1,c));return\"COLLECTING\"===e.phase?a:N({phase:\"DROP_PENDING\"},a,(b={},b.phase=\"DROP_PENDING\",b.reason=e.reason,b.isWaiting=!1,b))},Qd=function(a,b,e){var c=a.dimensions;b={draggables:c.draggables,droppables:Od(c.droppables,b)};return\"SNAP\"!==a.movementMode||e?ab({state:a,dimensions:b}):Ma({state:a,dimensions:b})},jc={phase:\"IDLE\",completed:null,shouldFlush:!1},ib=function(a,e){void 0===a&&(a=jc);if(\"FLUSH\"===\ne.type)return N({},jc,{shouldFlush:!0});if(\"INITIAL_PUBLISH\"===e.type){\"IDLE\"!==a.phase?m(!1):void 0;var c=e.payload;a=c.critical;var f=c.viewport;e=c.dimensions;var k=c.movementMode,h=e.draggables[a.draggable.id],n=e.droppables[a.droppable.id];c={selection:c.clientSelection,borderBoxCenter:h.client.borderBox.center,offset:na};c={client:c,page:{selection:M(c.selection,f.scroll.initial),borderBoxCenter:M(c.selection,f.scroll.initial)}};var q=Ta(e.droppables).every(function(a){return!a.isFixedOnPage});\nh=Va({draggable:h,home:n,draggables:e.draggables,viewport:f});n=h.impact;return{phase:\"DRAGGING\",isDragging:!0,critical:a,movementMode:k,dimensions:e,initial:c,current:c,isWindowScrollAllowed:q,impact:n,afterCritical:h.afterCritical,onLiftImpact:n,viewport:f,userDirection:re,scrollJumpRequest:null,forceShouldAnimate:null}}if(\"COLLECTION_STARTING\"===e.type){if(\"COLLECTING\"===a.phase||\"DROP_PENDING\"===a.phase)return a;\"DRAGGING\"!==a.phase?m(!1):void 0;return N({phase:\"COLLECTING\"},a,(k={},k.phase=\"COLLECTING\",\nk))}if(\"PUBLISH_WHILE_DRAGGING\"===e.type)return\"COLLECTING\"!==a.phase&&\"DROP_PENDING\"!==a.phase?m(!1):void 0,Ee({state:a,published:e.payload});if(\"MOVE\"===e.type){if(\"DROP_PENDING\"===a.phase)return a;G(a)?void 0:m(!1);f=e.payload.client;return b(f,a.current.client.selection)?a:ab({state:a,clientSelection:f,impact:\"SNAP\"===a.movementMode?a.impact:null})}if(\"UPDATE_DROPPABLE_SCROLL\"===e.type){if(\"DROP_PENDING\"===a.phase||\"COLLECTING\"===a.phase)return S(a);G(a)?void 0:m(!1);f=e.payload;e=a.dimensions.droppables[f.id];\nif(!e)return a;f=Ad(e,f.newScroll);return Qd(a,f,!1)}if(\"UPDATE_DROPPABLE_IS_ENABLED\"===e.type){if(\"DROP_PENDING\"===a.phase)return a;G(a)?void 0:m(!1);e=e.payload;f=e.isEnabled;(e=a.dimensions.droppables[e.id])?void 0:m(!1);e.isEnabled===f?m(!1):void 0;f=N({},e,{isEnabled:f});return Qd(a,f,!0)}if(\"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\"===e.type){if(\"DROP_PENDING\"===a.phase)return a;G(a)?void 0:m(!1);e=e.payload;f=e.isCombineEnabled;(e=a.dimensions.droppables[e.id])?void 0:m(!1);e.isCombineEnabled===\nf?m(!1):void 0;f=N({},e,{isCombineEnabled:f});return Qd(a,f,!0)}if(\"MOVE_BY_WINDOW_SCROLL\"===e.type){if(\"DROP_PENDING\"===a.phase||\"DROP_ANIMATING\"===a.phase)return a;G(a)?void 0:m(!1);a.isWindowScrollAllowed?void 0:m(!1);f=e.payload.newScroll;if(b(a.viewport.scroll.current,f))return S(a);f=xe(a.viewport,f);return\"SNAP\"===a.movementMode?Ma({state:a,viewport:f}):ab({state:a,viewport:f})}if(\"UPDATE_VIEWPORT_MAX_SCROLL\"===e.type){if(!G(a))return a;f=e.payload.maxScroll;if(b(f,a.viewport.scroll.max))return a;\nf=N({},a.viewport,{scroll:N({},a.viewport.scroll,{max:f})});return N({phase:\"DRAGGING\"},a,{viewport:f})}if(\"MOVE_UP\"===e.type||\"MOVE_DOWN\"===e.type||\"MOVE_LEFT\"===e.type||\"MOVE_RIGHT\"===e.type){if(\"COLLECTING\"===a.phase||\"DROP_PENDING\"===a.phase)return a;\"DRAGGING\"!==a.phase?m(!1):void 0;return(f=Kd({state:a,type:e.type}))?ab({state:a,impact:f.impact,clientSelection:f.clientSelection,scrollJumpRequest:f.scrollJumpRequest}):a}return\"DROP_PENDING\"===e.type?(e=e.payload.reason,\"COLLECTING\"!==a.phase?\nm(!1):void 0,N({phase:\"DROP_PENDING\"},a,(f={},f.phase=\"DROP_PENDING\",f.isWaiting=!0,f.reason=e,f))):\"DROP_ANIMATE\"===e.type?(k=e.payload,f=k.completed,e=k.dropDuration,k=k.newHomeClientOffset,\"DRAGGING\"!==a.phase&&\"DROP_PENDING\"!==a.phase?m(!1):void 0,{phase:\"DROP_ANIMATING\",completed:f,dropDuration:e,newHomeClientOffset:k,dimensions:a.dimensions}):\"DROP_COMPLETE\"===e.type?{phase:\"IDLE\",completed:e.payload.completed,shouldFlush:!1}:a},Td=function(a){return{type:\"PUBLISH_WHILE_DRAGGING\",payload:a}},\nFe=function(){return{type:\"COLLECTION_STARTING\",payload:null}},Ob=function(a){return{type:\"UPDATE_DROPPABLE_SCROLL\",payload:a}},Ud=function(a){return{type:\"UPDATE_DROPPABLE_IS_ENABLED\",payload:a}},Pb=function(a){return{type:\"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\",payload:a}},Ge=function(a){return{type:\"MOVE\",payload:a}},Xf=function(){return{type:\"MOVE_UP\",payload:null}},Yf=function(){return{type:\"MOVE_DOWN\",payload:null}},ad=function(){return{type:\"MOVE_RIGHT\",payload:null}},$f=function(){return{type:\"MOVE_LEFT\",\npayload:null}},Vd=function(a){return{type:\"DROP_COMPLETE\",payload:a}},cd=function(){return{type:\"DROP_ANIMATION_FINISHED\",payload:null}},ag=function(a){return function(c){var b=c.getState,e=c.dispatch;return function(c){return function(f){if(\"LIFT\"!==f.type)c(f);else{var k=f.payload,h=k.id;f=k.clientSelection;k=k.movementMode;var p=b();\"DROP_ANIMATING\"===p.phase&&e(Vd({completed:p.completed}));\"IDLE\"!==b().phase?m(!1):void 0;e({type:\"FLUSH\",payload:null});h=a.startPublishing({draggableId:h,scrollOptions:{shouldPublishImmediately:\"SNAP\"===\nk}});e({type:\"INITIAL_PUBLISH\",payload:{critical:h.critical,dimensions:h.dimensions,clientSelection:f,movementMode:k,viewport:h.viewport}})}}}}},bg=function(a){return function(){return function(c){return function(b){\"INITIAL_PUBLISH\"===b.type&&a.dragging();\"DROP_ANIMATE\"===b.type&&a.dropping(b.payload.completed.result.reason);\"FLUSH\"!==b.type&&\"DROP_COMPLETE\"!==b.type||a.resting();c(b)}}}},Wd={outOfTheWay:\"cubic-bezier(0.2, 0, 0, 1)\",drop:\"cubic-bezier(.2,1,.1,1)\"},kc={opacity:{drop:0,combining:.7},\nscale:{drop:.75}},bb=\"0.2s \"+Wd.outOfTheWay,Qb={fluid:\"opacity \"+bb,snap:\"transform \"+bb+\", opacity \"+bb,drop:function(a){a=a+\"s \"+Wd.drop;return\"transform \"+a+\", opacity \"+a},outOfTheWay:\"transform \"+bb,placeholder:\"height \"+bb+\", width \"+bb+\", margin \"+bb},He=function(a){return b(a,na)?null:\"translate(\"+a.x+\"px, \"+a.y+\"px)\"},sb={moveTo:He,drop:function(a,b){return(a=He(a))?b?a+\" scale(\"+kc.scale.drop+\")\":a:null}},Je=.55-.33,Kc=function(a){var c=a.getState,e=a.dispatch;return function(a){return function(f){if(\"DROP\"!==\nf.type)a(f);else{var k=c();f=f.payload.reason;if(\"COLLECTING\"===k.phase)e({type:\"DROP_PENDING\",payload:{reason:f}});else if(\"IDLE\"!==k.phase){\"DROP_PENDING\"===k.phase&&k.isWaiting?m(!1):void 0;\"DRAGGING\"!==k.phase&&\"DROP_PENDING\"!==k.phase?m(!1):void 0;var h=k.critical,p=k.dimensions,n=p.draggables[k.critical.draggable.id];var u=k.dimensions.draggables;var q=k.impact;var r=k.dimensions.droppables[k.critical.droppable.id],t=k.viewport,B=k.onLiftImpact;q.at&&\"DROP\"===f?(u=\"REORDER\"===q.at.type?q:N({},\nq,{displaced:gc}),q=!0):(u=Pd({draggables:u,impact:B,destination:r,viewport:t,forceShouldAnimate:!0}),q=!1);q=(r=q)?I(u):null;r=r?F(u):null;h={draggableId:n.descriptor.id,type:n.descriptor.type,source:{index:h.draggable.index,droppableId:h.droppable.id},reason:f,mode:k.movementMode,destination:q,combine:r};q=k.viewport;r=k.afterCritical;t=p.draggables;p=p.droppables;B=ja(u);var v=p[n.descriptor.droppableId];p=De({impact:u,draggable:n,draggables:t,afterCritical:r,droppable:(B?p[B]:null)||v,viewport:q});\nn=pa(p,n.client.borderBox.center);p={critical:k.critical,afterCritical:k.afterCritical,result:h,impact:u};b(k.current.client.offset,n)&&!h.combine?e(Vd({completed:p})):(k=va(k.current.client.offset,n),0>=k?f=.33:1500<=k?f=.55:(k=.33+k/1500*Je,f=Number((\"CANCEL\"===f?.6*k:k).toFixed(2))),e({type:\"DROP_ANIMATE\",payload:{newHomeClientOffset:n,dropDuration:f,completed:p}}))}}}}},fg=function(a){var c=ta({onWindowScroll:function(c){a.dispatch({type:\"MOVE_BY_WINDOW_SCROLL\",payload:{newScroll:c}})}});return function(a){return function(b){c.isActive()||\n\"INITIAL_PUBLISH\"!==b.type||c.start();!c.isActive()||\"DROP_COMPLETE\"!==b.type&&\"DROP_ANIMATE\"!==b.type&&\"FLUSH\"!==b.type||c.stop();a(b)}}},Me=function(a){var c=!1,b=!1,e=setTimeout(function(){b=!0}),f=function(f){c?void 0:b?void 0:(c=!0,a(f),clearTimeout(e))};f.wasCalled=function(){return c};return f},Yd=function(){var a=[],b=function(c){var b=E(a,function(a){return a.timerId===c});-1===b?m(!1):void 0;a.splice(b,1)[0].callback()};return{add:function(c){var e=setTimeout(function(){return b(e)});a.push({timerId:e,\ncallback:c})},flush:function(){if(a.length){var c=[].concat(a);a.length=0;c.forEach(function(a){clearTimeout(a.timerId);a.callback()})}}}},gg=function(a,b){return null==a&&null==b?!0:null==a||null==b?!1:a.droppableId===b.droppableId&&a.index===b.index},cb=function(a,b){return null==a&&null==b?!0:null==a||null==b?!1:a.draggableId===b.draggableId&&a.droppableId===b.droppableId},Ne=function(a,b){if(a===b)return!0;var c=a.droppable.id===b.droppable.id&&a.droppable.type===b.droppable.type;return a.draggable.id===\nb.draggable.id&&a.draggable.droppableId===b.draggable.droppableId&&a.draggable.type===b.draggable.type&&a.draggable.index===b.draggable.index&&c},Lc=function(a,b){b()},dd=function(a,b){return{draggableId:a.draggable.id,type:a.droppable.type,source:{droppableId:a.droppable.id,index:a.draggable.index},mode:b}},Ub=function(a,b,e,f){if(a){var c=Me(e);a(b,{announce:c});c.wasCalled()||e(f(b))}else e(f(b))},ed=function(a,b){var c=Yd(),e=null,f=function(c){e?void 0:m(!1);e=null;Lc(\"onDragEnd\",function(){return Ub(a().onDragEnd,\nc,b,Kb)})};return{beforeStart:function(c,b){e?m(!1):void 0;Lc(\"onBeforeDragStart\",function(){var e=a().onBeforeDragStart;e&&e(dd(c,b))})},start:function(f,k){e?m(!1):void 0;var h=dd(f,k);e={mode:k,lastCritical:f,lastLocation:h.source,lastCombine:null};c.add(function(){Lc(\"onDragStart\",function(){return Ub(a().onDragStart,h,b,Jb)})})},update:function(f,k){var h=I(k);k=F(k);e?void 0:m(!1);var p=!Ne(f,e.lastCritical);p&&(e.lastCritical=f);var n=!gg(e.lastLocation,h);n&&(e.lastLocation=h);var q=!cb(e.lastCombine,\nk);q&&(e.lastCombine=k);if(p||n||q){var u=N({},dd(f,e.mode),{combine:k,destination:h});c.add(function(){Lc(\"onDragUpdate\",function(){return Ub(a().onDragUpdate,u,b,Vc)})})}},flush:function(){e?void 0:m(!1);c.flush()},drop:f,abort:function(){if(e){var a=N({},dd(e.lastCritical,e.mode),{combine:null,destination:null,reason:\"CANCEL\"});f(a)}}}},jg=function(a,b){var c=ed(a,b);return function(a){return function(b){return function(e){if(\"INITIAL_PUBLISH\"===e.type){var f=e.payload.critical;c.beforeStart(f,\ne.payload.movementMode);b(e);c.start(f,e.payload.movementMode)}else\"DROP_COMPLETE\"===e.type?(f=e.payload.completed.result,c.flush(),b(e),c.drop(f)):(b(e),\"FLUSH\"===e.type?c.abort():(e=a.getState(),\"DRAGGING\"===e.phase&&c.update(e.critical,e.impact)))}}}},kg=function(a){return function(c){return function(b){\"DROP_ANIMATION_FINISHED\"!==b.type?c(b):(b=a.getState(),\"DROP_ANIMATING\"!==b.phase?m(!1):void 0,a.dispatch(Vd({completed:b.completed})))}}},Se=function(a){var c=null,b=null;return function(e){return function(f){if(\"FLUSH\"===\nf.type||\"DROP_COMPLETE\"===f.type||\"DROP_ANIMATION_FINISHED\"===f.type)b&&(cancelAnimationFrame(b),b=null),c&&(c(),c=null);e(f);if(\"DROP_ANIMATE\"===f.type){var k={eventName:\"scroll\",options:{capture:!0,passive:!1,once:!0},fn:function(){\"DROP_ANIMATING\"===a.getState().phase&&a.dispatch(cd())}};b=requestAnimationFrame(function(){b=null;c=x(window,[k])})}}}},Te=function(a){return function(){return function(c){return function(b){\"DROP_COMPLETE\"!==b.type&&\"FLUSH\"!==b.type&&\"DROP_ANIMATE\"!==b.type||a.stopPublishing();\nc(b)}}}},Ue=function(a){var c=!1;return function(){return function(b){return function(e){\"INITIAL_PUBLISH\"===e.type?(c=!0,a.tryRecordFocus(e.payload.critical.draggable.id),b(e),a.tryRestoreFocusRecorded()):(b(e),c&&(\"FLUSH\"===e.type?(c=!1,a.tryRestoreFocusRecorded()):\"DROP_COMPLETE\"===e.type&&(c=!1,e=e.payload.completed.result,e.combine&&a.tryShiftRecord(e.draggableId,e.combine.draggableId),a.tryRestoreFocusRecorded())))}}}},lg=function(a){return function(c){return function(b){return function(e){\"DROP_COMPLETE\"===\ne.type||\"DROP_ANIMATE\"===e.type||\"FLUSH\"===e.type?(a.stop(),b(e)):\"INITIAL_PUBLISH\"===e.type?(b(e),e=c.getState(),\"DRAGGING\"!==e.phase?m(!1):void 0,a.start(e)):(b(e),a.scroll(c.getState()))}}}},mg=function(a){return function(c){return function(b){c(b);\"PUBLISH_WHILE_DRAGGING\"===b.type&&(b=a.getState(),\"DROP_PENDING\"===b.phase&&(b.isWaiting||a.dispatch({type:\"DROP\",payload:{reason:b.reason}})))}}},ng=Fb.compose,be=function(){return{additions:{},removals:{},modified:{}}},We=function(a){a=pa({x:a.scrollWidth,\ny:a.scrollHeight},{x:a.width,y:a.height});return{x:Math.max(0,a.x),y:Math.max(0,a.y)}},Xe=function(){var a=document.documentElement;a?void 0:m(!1);return a},Ye=function(){var a=Xe();return We({scrollHeight:a.scrollHeight,scrollWidth:a.scrollWidth,width:a.clientWidth,height:a.clientHeight})},ce=function(){var a={x:window.pageXOffset,y:window.pageYOffset},b=Ye(),e=a.y,f=a.x,h=Xe();return{frame:aa.getRect({top:e,left:f,right:f+h.clientWidth,bottom:e+h.clientHeight}),scroll:{initial:a,current:a,max:b,\ndiff:{value:na,displacement:na}}}},Oa=function(a){var c=a.critical,b=a.scrollOptions,e=a.registry;a=ce();var f=a.scroll.current,h=e.droppable.getAllByType(c.droppable.type).map(function(a){return a.callbacks.getDimensionAndWatchScroll(f,b)});e=e.draggable.getAllByType(c.draggable.type).map(function(a){return a.getDimension(f)});return{dimensions:{draggables:Cd(e),droppables:Bd(h)},critical:c,viewport:a}},og=function(a,b){var c=null,e=Y({callbacks:{publish:b.publishWhileDragging,collectionStarting:b.collectionStarting},\nregistry:a}),f=function(b){c?void 0:m(!1);var f=c.critical.draggable;\"ADDITION\"===b.type&&ea(a,f,b.value)&&e.add(b.value);\"REMOVAL\"===b.type&&ea(a,f,b.value)&&e.remove(b.value)};return{updateDroppableIsEnabled:function(e,f){a.droppable.exists(e)?void 0:m(!1);c&&b.updateDroppableIsEnabled({id:e,isEnabled:f})},updateDroppableIsCombineEnabled:function(e,f){c&&(a.droppable.exists(e)?void 0:m(!1),b.updateDroppableIsCombineEnabled({id:e,isCombineEnabled:f}))},scrollDroppable:function(b,e){c&&a.droppable.getById(b).callbacks.scroll(e)},\nupdateDroppableScroll:function(e,f){c&&(a.droppable.exists(e)?void 0:m(!1),b.updateDroppableScroll({id:e,newScroll:f}))},startPublishing:function(b){c?m(!1):void 0;var e=a.draggable.getById(b.draggableId),k=a.droppable.getById(e.descriptor.droppableId);e={draggable:e.descriptor,droppable:k.descriptor};k=a.subscribe(f);c={critical:e,unsubscribe:k};return Oa({critical:e,registry:a,scrollOptions:b.scrollOptions})},stopPublishing:function(){c&&(e.stop(),a.droppable.getAllByType(c.critical.droppable.type).forEach(function(a){return a.callbacks.dragStopped()}),\nc.unsubscribe(),c=null)}}},Ze=function(a,b){return\"IDLE\"===a.phase?!0:\"DROP_ANIMATING\"!==a.phase||a.completed.result.draggableId===b?!1:\"DROP\"===a.completed.result.reason},pg=function(a){window.scrollBy(a.x,a.y)},qg=oa(function(a){return Ta(a).filter(function(a){return a.isEnabled&&a.frame?!0:!1})}),$e=function(a,b){return z(qg(b),function(c){c.frame?void 0:m(!1);return Ld(c.frame.pageMarginBox)(a)})},ub={startFromPercentage:.25,maxScrollAtPercentage:.05,maxPixelScroll:28,ease:function(a){return Math.pow(a,\n2)},durationDampening:{stopDampeningAt:1200,accelerateAt:360}},fe=function(a){var b=a.startOfRange,c=a.current;a=a.endOfRange-b;return 0===a?(void 0,0):(c-b)/a},rg=function(a,b){if(a>b.startScrollingFrom)return 0;if(a<=b.maxScrollValueAt)return ub.maxPixelScroll;if(a===b.startScrollingFrom)return 1;a=fe({startOfRange:b.maxScrollValueAt,endOfRange:b.startScrollingFrom,current:a});a=ub.maxPixelScroll*ub.ease(1-a);return Math.ceil(a)},af=ub.durationDampening.accelerateAt,ge=ub.durationDampening.stopDampeningAt,\nsg=function(a,b){b=Za()-b;if(b>=ge)return a;if(b<af)return 1;b=fe({startOfRange:af,endOfRange:ge,current:b});a*=ub.ease(b);return Math.ceil(a)},kb=function(a){var b=a.dragStartTime,c=a.shouldUseTimeDampening;a=rg(a.distanceToEdge,a.thresholds);return 0===a?0:c?Math.max(sg(a,b),1):a},fd=function(a){var b=a.container,c=a.distanceToEdges,e=a.dragStartTime,f=a.axis;a=a.shouldUseTimeDampening;b={startScrollingFrom:b[f.size]*ub.startFromPercentage,maxScrollValueAt:b[f.size]*ub.maxScrollAtPercentage};return c[f.end]<\nc[f.start]?kb({distanceToEdge:c[f.end],thresholds:b,dragStartTime:e,shouldUseTimeDampening:a}):-1*kb({distanceToEdge:c[f.start],thresholds:b,dragStartTime:e,shouldUseTimeDampening:a})},wh=zd(function(a){return 0===a?0:a}),he=function(a){var c=a.dragStartTime,e=a.container,f=a.subject,h=a.center;a=a.shouldUseTimeDampening;var m={top:h.y-e.top,right:e.right-h.x,bottom:e.bottom-h.y,left:h.x-e.left};h=fd({container:e,distanceToEdges:m,dragStartTime:c,axis:gb,shouldUseTimeDampening:a});c=fd({container:e,\ndistanceToEdges:m,dragStartTime:c,axis:Ed,shouldUseTimeDampening:a});c=wh({x:c,y:h});if(b(c,na))return null;a=f.height>e.height;e=(e=f.width>e.width)||a?e&&a?null:{x:e?0:c.x,y:a?0:c.y}:c;return e?b(e,na)?null:e:null},bf=zd(function(a){return 0===a?0:0<a?1:-1}),cf=function(){var a=function(a,b){return 0>a?a:a>b?a-b:0};return function(c){var e=c.max;c=M(c.current,c.change);e={x:a(c.x,e.x),y:a(c.y,e.y)};return b(e,na)?null:e}}(),df=function(a){var b=a.max,c=a.current;b={x:Math.max(c.x,b.x),y:Math.max(c.y,\nb.y)};a=bf(a.change);c=cf({max:b,current:c,change:a});return!c||0!==a.x&&0===c.x||0!==a.y&&0===c.y?!0:!1},ef=function(a,b){return df({current:a.scroll.current,max:a.scroll.max,change:b})},rc=function(a,b){return(a=a.frame)?df({current:a.scroll.current,max:a.scroll.max,change:b}):!1},ff=function(a){var b=a.state,c=a.dragStartTime,e=a.shouldUseTimeDampening,f=a.scrollWindow;a=a.scrollDroppable;var h=b.current.page.borderBoxCenter,m=b.dimensions.draggables[b.critical.draggable.id].page.marginBox;if(b.isWindowScrollAllowed){var n=\nb.viewport;var q=he({dragStartTime:c,container:n.frame,subject:m,center:h,shouldUseTimeDampening:e});if(n=q&&ef(n,q)?q:null){f(n);return}}f=ja(b.impact);b=b.dimensions.droppables;f?(b=b[f],b=b.frame?b:null):b=$e(h,b);b&&(f=b,c=(n=f.frame)?(c=he({dragStartTime:c,container:n.pageMarginBox,subject:m,center:h,shouldUseTimeDampening:e}))&&rc(f,c)?c:null:null,c&&a(b.descriptor.id,c))},tg=function(a){var b=a.scrollDroppable,c=Hb(a.scrollWindow),e=Hb(b),f=null,h=function(a){f?void 0:m(!1);var b=f;ff({state:a,\nscrollWindow:c,scrollDroppable:e,dragStartTime:b.dragStartTime,shouldUseTimeDampening:b.shouldUseTimeDampening})};return{start:function(a){f?m(!1):void 0;var b=Za(),c=!1,e=function(){c=!0};ff({state:a,dragStartTime:0,shouldUseTimeDampening:!1,scrollWindow:e,scrollDroppable:e});f={dragStartTime:b,shouldUseTimeDampening:c};c&&h(a)},stop:function(){f&&(c.cancel(),e.cancel(),f=null)},scroll:h}},ug=function(a){var b=a.move,c=a.scrollDroppable,e=a.scrollWindow;return function(a){var f=a.scrollJumpRequest;\nif(f){var h=ja(a.impact);h?void 0:m(!1);h=a.dimensions.droppables[h];if(rc(h,f)){var k;(k=(k=h.frame)&&rc(h,f)?cf({current:k.scroll.current,max:k.scroll.max,change:f}):null)?(k=pa(f,k),c(h.descriptor.id,k),f=pa(f,k)):(c(h.descriptor.id,f),f=null)}f&&(h=a.viewport,a.isWindowScrollAllowed&&ef(h,f)&&((h=ef(h,f)?cf({current:h.scroll.current,max:h.scroll.max,change:f}):null)?(h=pa(f,h),e(h),f=pa(f,h)):(e(f),f=null)),f&&(a=M(a.current.client.selection,f),b({client:a})))}}},vg=function(a){var b=a.scrollDroppable,\nc=a.scrollWindow;a=a.move;var e=tg({scrollWindow:c,scrollDroppable:b}),f=ug({move:a,scrollWindow:c,scrollDroppable:b});return{scroll:function(a){\"DRAGGING\"===a.phase&&(\"FLUID\"===a.movementMode?e.scroll(a):a.scrollJumpRequest&&f(a))},start:e.start,stop:e.stop}},sc={base:\"data-rbd-drag-handle\",draggableId:\"data-rbd-drag-handle-draggable-id\",contextId:\"data-rbd-drag-handle-context-id\"},gd={base:\"data-rbd-draggable\",contextId:\"data-rbd-draggable-context-id\",id:\"data-rbd-draggable-id\"},wg=\"data-rbd-droppable-context-id\",\ngf={contextId:\"data-rbd-scroll-container-context-id\"},yg=function(a){return function(b){return\"[\"+b+'\\x3d\"'+a+'\"]'}},Na=function(a,b){return a.map(function(a){var c=a.styles[b];return c?a.selector+\" { \"+c+\" }\":\"\"}).join(\" \")},wa=\"undefined\"!==typeof window?Q.useLayoutEffect:Q.useEffect,nc=function(){var a=document.querySelector(\"head\");a?void 0:m(!1);return a},hd=function(a){var b=document.createElement(\"style\");a&&b.setAttribute(\"nonce\",a);b.type=\"text/css\";return b},Pc=ia.createContext(null),Ba=\nfunction(){var a=document.body;a?void 0:m(!1);return a},jf={position:\"absolute\",width:\"1px\",height:\"1px\",margin:\"-1px\",border:\"0\",padding:\"0\",overflow:\"hidden\",clip:\"rect(0 0 0 0)\",\"clip-path\":\"inset(100%)\"},Oc=ia.createContext(null),Rc,kf=(Rc={},Rc[13]=!0,Rc[9]=!0,Rc),je=function(){return\"undefined\"===typeof document?\"visibilitychange\":z([\"visibilitychange\",\"msvisibilitychange\",\"webkitvisibilitychange\",\"mozvisibilitychange\",\"ovisibilitychange\"],function(a){return\"on\"+a in document})||\"visibilitychange\"}(),\nnf={type:\"IDLE\"},Vb,Jg=(Vb={},Vb[34]=!0,Vb[33]=!0,Vb[36]=!0,Vb[35]=!0,Vb),xb={type:\"IDLE\"},Cg={input:!0,button:!0,textarea:!0,select:!0,option:!0,optgroup:!0,video:!0,audio:!0},Bg=function(){return\"undefined\"===typeof document?\"matches\":z([\"matches\",\"msMatchesSelector\",\"webkitMatchesSelector\"],function(a){return a in Element.prototype})||\"matches\"}(),Zf=[function(a){var b=Q.useRef(nf),c=Q.useRef(q),e=C.useMemo(function(){return{eventName:\"mousedown\",fn:function(b){if(!(b.defaultPrevented||0!==b.button||\nb.ctrlKey||b.metaKey||b.shiftKey||b.altKey)){var e=a.findClosestDraggableId(b);e&&(e=a.tryGetLock(e,n,{sourceEvent:b}))&&(b.preventDefault(),b={x:b.clientX,y:b.clientY},c.current(),v(e,b))}}}},[a]),f=C.useMemo(function(){return{eventName:\"webkitmouseforcewillbegin\",fn:function(b){if(!b.defaultPrevented){var c=a.findClosestDraggableId(b);if(c){var e=a.findOptionsForDraggable(c);e&&(e.shouldRespectForcePress||a.canGetLock(c)&&b.preventDefault())}}}}},[a]),h=C.useCallback(function(){c.current=x(window,\n[f,e],{passive:!1,capture:!0})},[f,e]),n=C.useCallback(function(){\"IDLE\"!==b.current.type&&(b.current=nf,c.current(),h())},[h]),r=C.useCallback(function(){var a=b.current;n();\"DRAGGING\"===a.type&&a.actions.cancel({shouldBlockNextClick:!0});\"PENDING\"===a.type&&a.actions.abort()},[n]),t=C.useCallback(function(){var a=Ka({cancel:r,completed:n,getPhase:function(){return b.current},setPhase:function(a){b.current=a}});c.current=x(window,a,{capture:!0,passive:!1})},[r,n]),v=C.useCallback(function(a,c){\"IDLE\"!==\nb.current.type?m(!1):void 0;b.current={type:\"PENDING\",point:c,actions:a};t()},[t]);wa(function(){h();return function(){c.current()}},[h])},function(a){var b=Q.useRef(Ra),c=C.useMemo(function(){return{eventName:\"keydown\",fn:function(c){function f(){k?void 0:m(!1);k=!1;b.current();e()}if(!c.defaultPrevented&&32===c.keyCode){var h=a.findClosestDraggableId(c);if(h&&(h=a.tryGetLock(h,f,{sourceEvent:c}))){c.preventDefault();var k=!0;c=h.snapLift();b.current();b.current=x(window,$b(c,f),{capture:!0,passive:!1})}}}}},\n[a]),e=C.useCallback(function(){b.current=x(window,[c],{passive:!1,capture:!0})},[c]);wa(function(){e();return function(){b.current()}},[e])},function(a){var b=Q.useRef(xb),c=Q.useRef(q),e=C.useCallback(function(){return b.current},[]),f=C.useCallback(function(a){b.current=a},[]),h=C.useMemo(function(){return{eventName:\"touchstart\",fn:function(b){if(!b.defaultPrevented){var e=a.findClosestDraggableId(b);e&&(e=a.tryGetLock(e,r,{sourceEvent:b}))&&(b=b.touches[0],b={x:b.clientX,y:b.clientY},c.current(),\nA(e,b))}}}},[a]),n=C.useCallback(function(){c.current=x(window,[h],{capture:!0,passive:!1})},[h]),r=C.useCallback(function(){var a=b.current;\"IDLE\"!==a.type&&(\"PENDING\"===a.type&&clearTimeout(a.longPressTimerId),f(xb),c.current(),n())},[n,f]),t=C.useCallback(function(){var a=b.current;r();\"DRAGGING\"===a.type&&a.actions.cancel({shouldBlockNextClick:!0});\"PENDING\"===a.type&&a.actions.abort()},[r]),v=C.useCallback(function(){var a={capture:!0,passive:!1},b={cancel:t,completed:r,getPhase:e},f=x(window,\nda(b),a),h=x(window,vc(b),a);c.current=function(){f();h()}},[t,e,r]),w=C.useCallback(function(){var a=e();\"PENDING\"!==a.type?m(!1):void 0;a=a.actions.fluidLift(a.point);f({type:\"DRAGGING\",actions:a,hasMoved:!1})},[e,f]),A=C.useCallback(function(a,b){\"IDLE\"!==e().type?m(!1):void 0;var c=setTimeout(w,120);f({type:\"PENDING\",point:b,actions:a,longPressTimerId:c});v()},[v,e,f,w]);wa(function(){n();return function(){c.current();var a=e();\"PENDING\"===a.type&&(clearTimeout(a.longPressTimerId),f(xb))}},[e,\nn,f]);wa(function(){return x(window,[{eventName:\"touchmove\",fn:function(){},options:{capture:!1,passive:!1}}])},[])}],bd=0,ie=function(a){return function(b){return a===b}},Lg=ie(\"scroll\"),lf=ie(\"auto\");ie(\"visible\");var mb=function(a,b){return b(a.overflowX)||b(a.overflowY)},Hh=function p(a){if(null==a)a=null;else if(a===document.body)a=null;else if(a===document.documentElement)a=null;else{var b=window.getComputedStyle(a);b={overflowX:b.overflowX,overflowY:b.overflowY};a=mb(b,Lg)||mb(b,lf)?a:p(a.parentElement)}return a},\npf=function(a){return{x:a.scrollLeft,y:a.scrollTop}},Qc=function u(a){return a?\"fixed\"===window.getComputedStyle(a).position?!0:u(a.parentElement):!1},Og={passive:!1},rf={passive:!0},qc=0,Kg={width:0,height:0,margin:{top:0,right:0,bottom:0,left:0}},zh=function(a){var b=a.placeholder,e=a.animate;a=a.isAnimatingOpenOnMount?Kg:\"close\"===e?Kg:{height:b.client.borderBox.height,width:b.client.borderBox.width,margin:b.client.margin};return{display:b.display,boxSizing:\"border-box\",width:a.width,height:a.height,\nmarginTop:a.margin.top,marginRight:a.margin.right,marginBottom:a.margin.bottom,marginLeft:a.margin.left,flexShrink:\"0\",flexGrow:\"0\",pointerEvents:\"none\",transition:\"none\"!==e?Qb.placeholder:null}},Lh=ia.memo(function(a){var b=Q.useRef(null),e=C.useCallback(function(){b.current&&(clearTimeout(b.current),b.current=null)},[]),f=a.animate,h=a.onTransitionEnd,m=a.onClose,n=a.contextId,p=Q.useState(\"open\"===a.animate),q=p[0],r=p[1];Q.useEffect(function(){if(!q)return bc;if(\"open\"!==f)return e(),r(!1),bc;\nif(b.current)return bc;b.current=setTimeout(function(){b.current=null;r(!1)});return e},[f,q,e]);p=C.useCallback(function(a){\"height\"===a.propertyName&&(h(),\"close\"===f&&m())},[f,m,h]);var t=zh({isAnimatingOpenOnMount:q,animate:a.animate,placeholder:a.placeholder});return ia.createElement(a.placeholder.tagName,{style:t,\"data-rbd-placeholder-context-id\":n,onTransitionEnd:p,ref:a.innerRef})}),sf=ia.createContext(null),jb=function(a){function b(){for(var b,e=arguments.length,f=Array(e),h=0;h<e;h++)f[h]=\narguments[h];b=a.call.apply(a,[this].concat(f))||this;b.state={isVisible:!!b.props.on,data:b.props.on,animate:b.props.shouldAnimate&&b.props.on?\"open\":\"none\"};b.onClose=function(){\"close\"===b.state.animate&&b.setState({isVisible:!1})};return b}Uc(b,a);b.getDerivedStateFromProps=function(a,b){return a.shouldAnimate?a.on?{isVisible:!0,data:a.on,animate:\"open\"}:b.isVisible?{isVisible:!0,data:b.data,animate:\"close\"}:{isVisible:!1,animate:\"close\",data:null}:{isVisible:!!a.on,data:a.on,animate:\"none\"}};\nb.prototype.render=function(){return this.state.isVisible?this.props.children({onClose:this.onClose,data:this.state.data,animate:this.state.animate}):null};return b}(ia.PureComponent),ee=function(a,b){return a===b},Pg=function(a){var b=a.combine;return(a=a.destination)?a.droppableId:b?b.droppableId:null},lc={mapped:{type:\"SECONDARY\",offset:na,combineTargetFor:null,shouldAnimateDisplacement:!0,snapshot:qb(null)}},Xd=Gb.connect(function(){var a=wd(),b=Cb();return function(e,f){return a(e,f)||b(e,f)||\nlc}},{dropAnimationFinished:cd},null,{context:Pc,pure:!0,areStatePropsEqual:ee})(function(a){var b=Q.useRef(null),e=C.useCallback(function(a){b.current=a},[]),f=C.useCallback(function(){return b.current},[]),h=za(Oc),m=h.contextId,n=h.liftInstructionId,p=h.registry;h=za(sf);var q=h.type,r=h.droppableId,t=C.useMemo(function(){return{id:a.draggableId,index:a.index,type:q,droppableId:r}},[a.draggableId,a.index,q,r]);h=a.children;var v=a.draggableId,w=a.isEnabled,x=a.shouldRespectForcePress,A=a.canDragInteractiveElements,\nz=a.mapped,D=a.dropAnimationFinished;if(!a.isClone){var E=C.useMemo(function(){return{descriptor:t,registry:p,getDraggableRef:f,canDragInteractiveElements:A,shouldRespectForcePress:x,isEnabled:w}},[t,p,f,A,x,w]);vd(E)}var F=C.useMemo(function(){return w?{tabIndex:0,\"data-rbd-drag-handle-draggable-id\":v,\"data-rbd-drag-handle-context-id\":m,\"aria-labelledby\":n,draggable:!1,onDragStart:Bb}:null},[m,v,w,n]),G=C.useCallback(function(a){\"DRAGGING\"===z.type&&z.dropping&&\"transform\"===a.propertyName&&D()},\n[D,z]);E=C.useMemo(function(){if(\"DRAGGING\"===z.type){var a=z.dimension.client,b=z.offset,f=z.dropping;var h=!!z.combineWith;var n=null!=z.forceShouldAnimate?z.forceShouldAnimate:\"SNAP\"===z.mode,p=!!f;b=p?sb.drop(b,h):sb.moveTo(b);var q=a.marginBox.top,r=a.marginBox.left,t=a.borderBox.width;a=a.borderBox.height;f=f?Qb.drop(f.duration):n?Qb.snap:Qb.fluid;h={position:\"fixed\",top:q,left:r,boxSizing:\"border-box\",width:t,height:a,transition:f,transform:b,opacity:h?p?kc.opacity.drop:kc.opacity.combining:\nnull,zIndex:p?4500:5E3,pointerEvents:\"none\"}}else h={transform:sb.moveTo(z.offset),transition:z.shouldAnimateDisplacement?null:\"none\"};return{innerRef:e,draggableProps:{\"data-rbd-draggable-context-id\":m,\"data-rbd-draggable-id\":v,style:h,onTransitionEnd:\"DRAGGING\"===z.type&&z.dropping?G:null},dragHandleProps:F}},[m,F,v,z,G,e]);var H=C.useMemo(function(){return{draggableId:t.id,type:t.type,source:{index:t.index,droppableId:t.droppableId}}},[t.droppableId,t.id,t.index,t.type]);return h(E,z.snapshot,\nH)}),rb=Gb.connect(function(){var a={placeholder:null,shouldAnimatePlaceholder:!0,snapshot:{isDraggingOver:!1,draggingOverWith:null,draggingFromThisWith:null,isUsingPlaceholder:!1},useClone:null},b=N({},a,{shouldAnimatePlaceholder:!1}),e=oa(function(a){return{draggableId:a.id,type:a.type,source:{index:a.index,droppableId:a.droppableId}}}),f=oa(function(f,h,m,n,p,q){var r=p.descriptor.id;return p.descriptor.droppableId===f?(f=q?{render:q,dragging:e(p.descriptor)}:null,{placeholder:p.placeholder,shouldAnimatePlaceholder:!1,\nsnapshot:{isDraggingOver:m,draggingOverWith:m?r:null,draggingFromThisWith:r,isUsingPlaceholder:!0},useClone:f}):h?n?{placeholder:p.placeholder,shouldAnimatePlaceholder:!0,snapshot:{isDraggingOver:m,draggingOverWith:r,draggingFromThisWith:null,isUsingPlaceholder:!0},useClone:null}:a:b});return function(e,h){var m=h.droppableId,n=h.type,p=!h.isDropDisabled;h=h.renderClone;if(e.isDragging){var q=e.critical;if(n!==q.droppable.type)return b;n=e.dimensions.draggables[q.draggable.id];e=ja(e.impact)===m;\nreturn f(m,p,e,e,n,h)}if(\"DROP_ANIMATING\"===e.phase){q=e.completed;if(n!==q.critical.droppable.type)return b;e=e.dimensions.draggables[q.critical.draggable.id];return f(m,p,Pg(q.result)===m,ja(q.impact)===m,e,h)}if(\"IDLE\"===e.phase&&e.completed&&!e.shouldFlush){p=e.completed;if(n!==p.critical.droppable.type)return b;h=ja(p.impact)===m;e=!(!p.impact.at||\"COMBINE\"!==p.impact.at.type);if(h)return e?a:b;if(p.critical.droppable.id===m)return a}return b}},{updateViewportMaxScroll:function(a){return{type:\"UPDATE_VIEWPORT_MAX_SCROLL\",\npayload:a}}},null,{context:Pc,pure:!0,areStatePropsEqual:ee})(function(a){var b=Q.useContext(Oc);b?void 0:m(!1);var e=b.contextId,f=b.isMovementAllowed,h=Q.useRef(null),n=Q.useRef(null);b=a.children;var p=a.droppableId,q=a.type,r=a.mode,t=a.direction,v=a.ignoreContainerClipping,w=a.isDropDisabled,x=a.isCombineEnabled,z=a.snapshot,A=a.useClone,D=a.updateViewportMaxScroll,E=a.getContainerForClone,F=C.useCallback(function(){return h.current},[]),G=C.useCallback(function(a){h.current=a},[]);C.useCallback(function(){return n.current},\n[]);var H=C.useCallback(function(a){n.current=a},[]),I=C.useCallback(function(){f()&&D({maxScroll:Ye()})},[f,D]);td({droppableId:p,type:q,mode:r,direction:t,isDropDisabled:w,isCombineEnabled:x,ignoreContainerClipping:v,getDroppableRef:F});var K=ia.createElement(jb,{on:a.placeholder,shouldAnimate:a.shouldAnimatePlaceholder},function(a){return ia.createElement(Lh,{placeholder:a.data,onClose:a.onClose,innerRef:H,animate:a.animate,contextId:e,onTransitionEnd:I})});a=C.useMemo(function(){return{innerRef:G,\nplaceholder:K,droppableProps:{\"data-rbd-droppable-id\":p,\"data-rbd-droppable-context-id\":e}}},[e,p,K,G]);var M=A?A.dragging.draggableId:null;r=C.useMemo(function(){return{droppableId:p,type:q,isUsingCloneFor:M}},[p,M,q]);return ia.createElement(sf.Provider,{value:r},b(a,z),function(){if(!A)return null;var a=A.dragging,b=A.render,e=ia.createElement(Db,{draggableId:a.draggableId,index:a.source.index,isClone:!0,isEnabled:!0,shouldRespectForcePress:!1,canDragInteractiveElements:!0},function(e,f){return b(e,\nf,a)});return ec.createPortal(e,E())}())});rb.defaultProps={mode:\"standard\",type:\"DEFAULT\",direction:\"vertical\",isDropDisabled:!1,isCombineEnabled:!1,ignoreContainerClipping:!1,renderClone:null,getContainerForClone:function(){document.body?void 0:m(!1);return document.body}};f.DragDropContext=function(a){var b=C.useMemo(function(){return\"\"+bd++},[]),e=a.liftInstruction||\"Draggable item. Ensure your screen reader is not in browse mode and then press space bar to lift.\";return ia.createElement(Da,null,\nfunction(f){return ia.createElement(fb,{nonce:a.nonce,contextId:b,setCallbacks:f,liftInstruction:e,enableDefaultSensors:a.enableDefaultSensors,sensors:a.sensors,onBeforeDragStart:a.onBeforeDragStart,onDragStart:a.onDragStart,onDragUpdate:a.onDragUpdate,onDragEnd:a.onDragEnd},a.children)})};f.Draggable=function(a){return ia.createElement(Db,N({},a,{isClone:!1,isEnabled:\"boolean\"===typeof a.isDragDisabled?!a.isDragDisabled:!0,canDragInteractiveElements:!!a.disableInteractiveElementBlocking,shouldRespectForcePress:!!a.shouldRespectForcePress}))};\nf.Droppable=rb;f.resetServerContext=function(){bd=0}}","~:source","shadow$provide[121] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = require('react');\nvar React__default = _interopDefault(React);\nvar useMemoOne = require('use-memo-one');\nvar _inheritsLoose = _interopDefault(require('@babel/runtime-corejs2/helpers/inheritsLoose'));\nvar _extends = _interopDefault(require('@babel/runtime-corejs2/helpers/extends'));\nvar redux = require('redux');\nvar reactRedux = require('react-redux');\nvar cssBoxModel = require('css-box-model');\nvar memoizeOne = _interopDefault(require('memoize-one'));\nvar _Object$values = _interopDefault(require('@babel/runtime-corejs2/core-js/object/values'));\nvar _Object$keys = _interopDefault(require('@babel/runtime-corejs2/core-js/object/keys'));\nvar rafSchd = _interopDefault(require('raf-schd'));\nvar _Date$now = _interopDefault(require('@babel/runtime-corejs2/core-js/date/now'));\nvar _Object$assign = _interopDefault(require('@babel/runtime-corejs2/core-js/object/assign'));\nvar ReactDOM = _interopDefault(require('react-dom'));\nvar _Number$isInteger = _interopDefault(require('@babel/runtime-corejs2/core-js/number/is-integer'));\n\nvar isProduction = process.env.NODE_ENV === 'production';\nvar spacesAndTabs = /[ \\t]{2,}/g;\nvar lineStartWithSpaces = /^[ \\t]*/gm;\n\nvar clean = function clean(value) {\n  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\n};\n\nvar getDevMessage = function getDevMessage(message) {\n  return clean(\"\\n  %creact-beautiful-dnd\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77\\u200D This is a development only message. It will be removed in production builds.\\n\");\n};\n\nvar getFormattedMessage = function getFormattedMessage(message) {\n  return [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];\n};\nvar isDisabledFlag = '__react-beautiful-dnd-disable-dev-warnings';\nfunction log(type, message) {\n  var _console;\n\n  if (isProduction) {\n    return;\n  }\n\n  if (typeof window !== 'undefined' && window[isDisabledFlag]) {\n    return;\n  }\n\n  (_console = console)[type].apply(_console, getFormattedMessage(message));\n}\nvar warning = log.bind(null, 'warn');\nvar error = log.bind(null, 'error');\n\nfunction noop() {}\n\nfunction getOptions(shared, fromBinding) {\n  return _extends({}, shared, {}, fromBinding);\n}\n\nfunction bindEvents(el, bindings, sharedOptions) {\n  var unbindings = bindings.map(function (binding) {\n    var options = getOptions(sharedOptions, binding.options);\n    el.addEventListener(binding.eventName, binding.fn, options);\n    return function unbind() {\n      el.removeEventListener(binding.eventName, binding.fn, options);\n    };\n  });\n  return function unbindAll() {\n    unbindings.forEach(function (unbind) {\n      unbind();\n    });\n  };\n}\n\nvar isProduction$1 = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction RbdInvariant(message) {\n  this.message = message;\n}\n\nRbdInvariant.prototype.toString = function toString() {\n  return this.message;\n};\n\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction$1) {\n    throw new RbdInvariant(prefix);\n  } else {\n    throw new RbdInvariant(prefix + \": \" + (message || ''));\n  }\n}\n\nvar ErrorBoundary = function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.callbacks = null;\n    _this.unbind = noop;\n\n    _this.onWindowError = function (event) {\n      var callbacks = _this.getCallbacks();\n\n      if (callbacks.isDragging()) {\n        callbacks.tryAbort();\n        process.env.NODE_ENV !== \"production\" ? warning(\"\\n        An error was caught by our window 'error' event listener while a drag was occurring.\\n        The active drag has been aborted.\\n      \") : void 0;\n      }\n\n      var err = event.error;\n\n      if (err instanceof RbdInvariant) {\n        event.preventDefault();\n\n        if (process.env.NODE_ENV !== 'production') {\n          error(err.message);\n        }\n      }\n    };\n\n    _this.getCallbacks = function () {\n      if (!_this.callbacks) {\n        throw new Error('Unable to find AppCallbacks in <ErrorBoundary/>');\n      }\n\n      return _this.callbacks;\n    };\n\n    _this.setCallbacks = function (callbacks) {\n      _this.callbacks = callbacks;\n    };\n\n    return _this;\n  }\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.unbind = bindEvents(window, [{\n      eventName: 'error',\n      fn: this.onWindowError\n    }]);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.unbind();\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(err) {\n    if (err instanceof RbdInvariant) {\n      if (process.env.NODE_ENV !== 'production') {\n        error(err.message);\n      }\n\n      this.setState({});\n      return;\n    }\n\n    throw err;\n  };\n\n  _proto.render = function render() {\n    return this.props.children(this.setCallbacks);\n  };\n\n  return ErrorBoundary;\n}(React__default.Component);\n\nvar liftInstruction = \"Draggable item. Ensure your screen reader is not in browse mode and then press space bar to lift.\";\n\nvar position = function position(index) {\n  return index + 1;\n};\n\nvar onDragStart = function onDragStart(start) {\n  return \"\\n  You have lifted an item in position \" + position(start.source.index) + \".\\n  Use the arrow keys to move, space bar to drop, and escape to cancel.\\n\";\n};\n\nvar withLocation = function withLocation(source, destination) {\n  var isInHomeList = source.droppableId === destination.droppableId;\n  var startPosition = position(source.index);\n  var endPosition = position(destination.index);\n\n  if (isInHomeList) {\n    return \"\\n      You have moved the item from position \" + startPosition + \"\\n      to position \" + endPosition + \"\\n    \";\n  }\n\n  return \"\\n    You have moved the item from position \" + startPosition + \"\\n    in list \" + source.droppableId + \"\\n    to list \" + destination.droppableId + \"\\n    in position \" + endPosition + \"\\n  \";\n};\n\nvar withCombine = function withCombine(id, source, combine) {\n  var inHomeList = source.droppableId === combine.droppableId;\n\n  if (inHomeList) {\n    return \"\\n      The item \" + id + \"\\n      has been combined with \" + combine.draggableId;\n  }\n\n  return \"\\n      The item \" + id + \"\\n      in list \" + source.droppableId + \"\\n      has been combined with \" + combine.draggableId + \"\\n      in list \" + combine.droppableId + \"\\n    \";\n};\n\nvar onDragUpdate = function onDragUpdate(update) {\n  var location = update.destination;\n\n  if (location) {\n    return withLocation(update.source, location);\n  }\n\n  var combine = update.combine;\n\n  if (combine) {\n    return withCombine(update.draggableId, update.source, combine);\n  }\n\n  return 'You are over an area that cannot be dropped on';\n};\n\nvar returnedToStart = function returnedToStart(source) {\n  return \"\\n  The item has returned to its starting position\\n  of \" + position(source.index) + \"\\n\";\n};\n\nvar onDragEnd = function onDragEnd(result) {\n  if (result.reason === 'CANCEL') {\n    return \"\\n      Movement cancelled.\\n      \" + returnedToStart(result.source) + \"\\n    \";\n  }\n\n  var location = result.destination;\n  var combine = result.combine;\n\n  if (location) {\n    return \"\\n      You have dropped the item.\\n      \" + withLocation(result.source, location) + \"\\n    \";\n  }\n\n  if (combine) {\n    return \"\\n      You have dropped the item.\\n      \" + withCombine(result.draggableId, result.source, combine) + \"\\n    \";\n  }\n\n  return \"\\n    The item has been dropped while not over a drop area.\\n    \" + returnedToStart(result.source) + \"\\n  \";\n};\n\nvar preset = {\n  liftInstruction: liftInstruction,\n  onDragStart: onDragStart,\n  onDragUpdate: onDragUpdate,\n  onDragEnd: onDragEnd\n};\n\nvar origin = {\n  x: 0,\n  y: 0\n};\nvar add = function add(point1, point2) {\n  return {\n    x: point1.x + point2.x,\n    y: point1.y + point2.y\n  };\n};\nvar subtract = function subtract(point1, point2) {\n  return {\n    x: point1.x - point2.x,\n    y: point1.y - point2.y\n  };\n};\nvar isEqual = function isEqual(point1, point2) {\n  return point1.x === point2.x && point1.y === point2.y;\n};\nvar negate = function negate(point) {\n  return {\n    x: point.x !== 0 ? -point.x : 0,\n    y: point.y !== 0 ? -point.y : 0\n  };\n};\nvar patch = function patch(line, value, otherValue) {\n  var _ref;\n\n  if (otherValue === void 0) {\n    otherValue = 0;\n  }\n\n  return _ref = {}, _ref[line] = value, _ref[line === 'x' ? 'y' : 'x'] = otherValue, _ref;\n};\nvar distance = function distance(point1, point2) {\n  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n};\nvar closest = function closest(target, points) {\n  return Math.min.apply(Math, points.map(function (point) {\n    return distance(target, point);\n  }));\n};\nvar apply = function apply(fn) {\n  return function (point) {\n    return {\n      x: fn(point.x),\n      y: fn(point.y)\n    };\n  };\n};\n\nvar executeClip = (function (frame, subject) {\n  var result = cssBoxModel.getRect({\n    top: Math.max(subject.top, frame.top),\n    right: Math.min(subject.right, frame.right),\n    bottom: Math.min(subject.bottom, frame.bottom),\n    left: Math.max(subject.left, frame.left)\n  });\n\n  if (result.width <= 0 || result.height <= 0) {\n    return null;\n  }\n\n  return result;\n});\n\nvar offsetByPosition = function offsetByPosition(spacing, point) {\n  return {\n    top: spacing.top + point.y,\n    left: spacing.left + point.x,\n    bottom: spacing.bottom + point.y,\n    right: spacing.right + point.x\n  };\n};\nvar getCorners = function getCorners(spacing) {\n  return [{\n    x: spacing.left,\n    y: spacing.top\n  }, {\n    x: spacing.right,\n    y: spacing.top\n  }, {\n    x: spacing.left,\n    y: spacing.bottom\n  }, {\n    x: spacing.right,\n    y: spacing.bottom\n  }];\n};\nvar noSpacing = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n};\n\nvar scroll = function scroll(target, frame) {\n  if (!frame) {\n    return target;\n  }\n\n  return offsetByPosition(target, frame.scroll.diff.displacement);\n};\n\nvar increase = function increase(target, axis, withPlaceholder) {\n  if (withPlaceholder && withPlaceholder.increasedBy) {\n    var _extends2;\n\n    return _extends({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));\n  }\n\n  return target;\n};\n\nvar clip = function clip(target, frame) {\n  if (frame && frame.shouldClipSubject) {\n    return executeClip(frame.pageMarginBox, target);\n  }\n\n  return cssBoxModel.getRect(target);\n};\n\nvar getSubject = (function (_ref) {\n  var page = _ref.page,\n      withPlaceholder = _ref.withPlaceholder,\n      axis = _ref.axis,\n      frame = _ref.frame;\n  var scrolled = scroll(page.marginBox, frame);\n  var increased = increase(scrolled, axis, withPlaceholder);\n  var clipped = clip(increased, frame);\n  return {\n    page: page,\n    withPlaceholder: withPlaceholder,\n    active: clipped\n  };\n});\n\nvar scrollDroppable = (function (droppable, newScroll) {\n  !droppable.frame ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n  var scrollable = droppable.frame;\n  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n  var scrollDisplacement = negate(scrollDiff);\n\n  var frame = _extends({}, scrollable, {\n    scroll: {\n      initial: scrollable.scroll.initial,\n      current: newScroll,\n      diff: {\n        value: scrollDiff,\n        displacement: scrollDisplacement\n      },\n      max: scrollable.scroll.max\n    }\n  });\n\n  var subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: droppable.subject.withPlaceholder,\n    axis: droppable.axis,\n    frame: frame\n  });\n\n  var result = _extends({}, droppable, {\n    frame: frame,\n    subject: subject\n  });\n\n  return result;\n});\n\nfunction values(map) {\n  return _Object$values(map);\n}\nfunction findIndex(list, predicate) {\n  if (list.findIndex) {\n    return list.findIndex(predicate);\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (predicate(list[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n}\nfunction find(list, predicate) {\n  if (list.find) {\n    return list.find(predicate);\n  }\n\n  var index = findIndex(list, predicate);\n\n  if (index !== -1) {\n    return list[index];\n  }\n\n  return undefined;\n}\nfunction toArray(list) {\n  return Array.prototype.slice.call(list);\n}\n\nvar toDroppableMap = memoizeOne(function (droppables) {\n  return droppables.reduce(function (previous, current) {\n    previous[current.descriptor.id] = current;\n    return previous;\n  }, {});\n});\nvar toDraggableMap = memoizeOne(function (draggables) {\n  return draggables.reduce(function (previous, current) {\n    previous[current.descriptor.id] = current;\n    return previous;\n  }, {});\n});\nvar toDroppableList = memoizeOne(function (droppables) {\n  return values(droppables);\n});\nvar toDraggableList = memoizeOne(function (draggables) {\n  return values(draggables);\n});\n\nvar getDraggablesInsideDroppable = memoizeOne(function (droppableId, draggables) {\n  var result = toDraggableList(draggables).filter(function (draggable) {\n    return droppableId === draggable.descriptor.droppableId;\n  }).sort(function (a, b) {\n    return a.descriptor.index - b.descriptor.index;\n  });\n  return result;\n});\n\nvar forward = {\n  vertical: 'down',\n  horizontal: 'right'\n};\nvar backward = {\n  vertical: 'up',\n  horizontal: 'left'\n};\n\nfunction tryGetDestination(impact) {\n  if (impact.at && impact.at.type === 'REORDER') {\n    return impact.at.destination;\n  }\n\n  return null;\n}\nfunction tryGetCombine(impact) {\n  if (impact.at && impact.at.type === 'COMBINE') {\n    return impact.at.combine;\n  }\n\n  return null;\n}\n\nvar removeDraggableFromList = memoizeOne(function (remove, list) {\n  return list.filter(function (item) {\n    return item.descriptor.id !== remove.descriptor.id;\n  });\n});\n\nvar moveToNextCombine = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      previousImpact = _ref.previousImpact;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var location = tryGetDestination(previousImpact);\n\n  if (!location) {\n    return null;\n  }\n\n  function getImpact(target) {\n    var at = {\n      type: 'COMBINE',\n      whenEntered: isMovingForward ? forward : backward,\n      combine: {\n        draggableId: target,\n        droppableId: destination.descriptor.id\n      }\n    };\n    return _extends({}, previousImpact, {\n      at: at\n    });\n  }\n\n  var all = previousImpact.displaced.all;\n  var closestId = all.length ? all[0] : null;\n\n  if (isMovingForward) {\n    return closestId ? getImpact(closestId) : null;\n  }\n\n  var withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n\n  if (!closestId) {\n    if (!withoutDraggable.length) {\n      return null;\n    }\n\n    var last = withoutDraggable[withoutDraggable.length - 1];\n    return getImpact(last.descriptor.id);\n  }\n\n  var indexOfClosest = findIndex(withoutDraggable, function (d) {\n    return d.descriptor.id === closestId;\n  });\n  !(indexOfClosest !== -1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find displaced item in set') : invariant(false) : void 0;\n  var proposedIndex = indexOfClosest - 1;\n\n  if (proposedIndex < 0) {\n    return null;\n  }\n\n  var before = withoutDraggable[proposedIndex];\n  return getImpact(before.descriptor.id);\n});\n\nvar isHomeOf = (function (draggable, destination) {\n  return draggable.descriptor.droppableId === destination.descriptor.id;\n});\n\nvar noDisplacedBy = {\n  point: origin,\n  value: 0\n};\nvar emptyGroups = {\n  invisible: {},\n  visible: {},\n  all: []\n};\nvar noImpact = {\n  displaced: emptyGroups,\n  displacedBy: noDisplacedBy,\n  at: null\n};\n\nvar isWithin = (function (lowerBound, upperBound) {\n  return function (value) {\n    return lowerBound <= value && value <= upperBound;\n  };\n});\n\nvar isPartiallyVisibleThroughFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (subject) {\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n\n    if (isContained) {\n      return true;\n    }\n\n    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n\n    if (isPartiallyContained) {\n      return true;\n    }\n\n    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n\n    if (isTargetBiggerThanFrame) {\n      return true;\n    }\n\n    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n    return isTargetBiggerOnOneAxis;\n  };\n});\n\nvar isTotallyVisibleThroughFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (subject) {\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    return isContained;\n  };\n});\n\nvar vertical = {\n  direction: 'vertical',\n  line: 'y',\n  crossAxisLine: 'x',\n  start: 'top',\n  end: 'bottom',\n  size: 'height',\n  crossAxisStart: 'left',\n  crossAxisEnd: 'right',\n  crossAxisSize: 'width'\n};\nvar horizontal = {\n  direction: 'horizontal',\n  line: 'x',\n  crossAxisLine: 'y',\n  start: 'left',\n  end: 'right',\n  size: 'width',\n  crossAxisStart: 'top',\n  crossAxisEnd: 'bottom',\n  crossAxisSize: 'height'\n};\n\nvar isTotallyVisibleThroughFrameOnAxis = (function (axis) {\n  return function (frame) {\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function (subject) {\n      if (axis === vertical) {\n        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n      }\n\n      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    };\n  };\n});\n\nvar getDroppableDisplaced = function getDroppableDisplaced(target, destination) {\n  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n  return offsetByPosition(target, displacement);\n};\n\nvar isVisibleInDroppable = function isVisibleInDroppable(target, destination, isVisibleThroughFrameFn) {\n  if (!destination.subject.active) {\n    return false;\n  }\n\n  return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\n\nvar isVisibleInViewport = function isVisibleInViewport(target, viewport, isVisibleThroughFrameFn) {\n  return isVisibleThroughFrameFn(viewport)(target);\n};\n\nvar isVisible = function isVisible(_ref) {\n  var toBeDisplaced = _ref.target,\n      destination = _ref.destination,\n      viewport = _ref.viewport,\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\n      isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;\n  var displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\n\nvar isPartiallyVisible = function isPartiallyVisible(args) {\n  return isVisible(_extends({}, args, {\n    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n  }));\n};\nvar isTotallyVisible = function isTotallyVisible(args) {\n  return isVisible(_extends({}, args, {\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n  }));\n};\nvar isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis(args) {\n  return isVisible(_extends({}, args, {\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n  }));\n};\n\nvar getShouldAnimate = function getShouldAnimate(id, last, forceShouldAnimate) {\n  if (typeof forceShouldAnimate === 'boolean') {\n    return forceShouldAnimate;\n  }\n\n  if (!last) {\n    return true;\n  }\n\n  var invisible = last.invisible,\n      visible = last.visible;\n\n  if (invisible[id]) {\n    return false;\n  }\n\n  var previous = visible[id];\n  return previous ? previous.shouldAnimate : true;\n};\n\nfunction getTarget(draggable, displacedBy) {\n  var marginBox = draggable.page.marginBox;\n  var expandBy = {\n    top: displacedBy.point.y,\n    right: 0,\n    bottom: 0,\n    left: displacedBy.point.x\n  };\n  return cssBoxModel.getRect(cssBoxModel.expand(marginBox, expandBy));\n}\n\nfunction getDisplacementGroups(_ref) {\n  var afterDragging = _ref.afterDragging,\n      destination = _ref.destination,\n      displacedBy = _ref.displacedBy,\n      viewport = _ref.viewport,\n      forceShouldAnimate = _ref.forceShouldAnimate,\n      last = _ref.last;\n  return afterDragging.reduce(function process(groups, draggable) {\n    var target = getTarget(draggable, displacedBy);\n    var id = draggable.descriptor.id;\n    groups.all.push(id);\n    var isVisible = isPartiallyVisible({\n      target: target,\n      destination: destination,\n      viewport: viewport,\n      withDroppableDisplacement: true\n    });\n\n    if (!isVisible) {\n      groups.invisible[draggable.descriptor.id] = true;\n      return groups;\n    }\n\n    var shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n    var displacement = {\n      draggableId: id,\n      shouldAnimate: shouldAnimate\n    };\n    groups.visible[id] = displacement;\n    return groups;\n  }, {\n    all: [],\n    visible: {},\n    invisible: {}\n  });\n}\n\nfunction getIndexOfLastItem(draggables, options) {\n  if (!draggables.length) {\n    return 0;\n  }\n\n  var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\n\nfunction goAtEnd(_ref) {\n  var insideDestination = _ref.insideDestination,\n      inHomeList = _ref.inHomeList,\n      displacedBy = _ref.displacedBy,\n      destination = _ref.destination;\n  var newIndex = getIndexOfLastItem(insideDestination, {\n    inHomeList: inHomeList\n  });\n  return {\n    displaced: emptyGroups,\n    displacedBy: displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: newIndex\n      }\n    }\n  };\n}\n\nfunction calculateReorderImpact(_ref2) {\n  var draggable = _ref2.draggable,\n      insideDestination = _ref2.insideDestination,\n      destination = _ref2.destination,\n      viewport = _ref2.viewport,\n      displacedBy = _ref2.displacedBy,\n      last = _ref2.last,\n      index = _ref2.index,\n      forceShouldAnimate = _ref2.forceShouldAnimate;\n  var inHomeList = isHomeOf(draggable, destination);\n\n  if (index == null) {\n    return goAtEnd({\n      insideDestination: insideDestination,\n      inHomeList: inHomeList,\n      displacedBy: displacedBy,\n      destination: destination\n    });\n  }\n\n  var match = find(insideDestination, function (item) {\n    return item.descriptor.index === index;\n  });\n\n  if (!match) {\n    return goAtEnd({\n      insideDestination: insideDestination,\n      inHomeList: inHomeList,\n      displacedBy: displacedBy,\n      destination: destination\n    });\n  }\n\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  var sliceFrom = insideDestination.indexOf(match);\n  var impacted = withoutDragging.slice(sliceFrom);\n  var displaced = getDisplacementGroups({\n    afterDragging: impacted,\n    destination: destination,\n    displacedBy: displacedBy,\n    last: last,\n    viewport: viewport.frame,\n    forceShouldAnimate: forceShouldAnimate\n  });\n  return {\n    displaced: displaced,\n    displacedBy: displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: index\n      }\n    }\n  };\n}\n\nfunction didStartAfterCritical(draggableId, afterCritical) {\n  return Boolean(afterCritical.effected[draggableId]);\n}\n\nvar fromCombine = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      combine = _ref.combine,\n      afterCritical = _ref.afterCritical;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var combineId = combine.draggableId;\n  var combineWith = draggables[combineId];\n  var combineWithIndex = combineWith.descriptor.index;\n  var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n\n  if (didCombineWithStartAfterCritical) {\n    if (isMovingForward) {\n      return combineWithIndex;\n    }\n\n    return combineWithIndex - 1;\n  }\n\n  if (isMovingForward) {\n    return combineWithIndex + 1;\n  }\n\n  return combineWithIndex;\n});\n\nvar fromReorder = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      isInHomeList = _ref.isInHomeList,\n      insideDestination = _ref.insideDestination,\n      location = _ref.location;\n\n  if (!insideDestination.length) {\n    return null;\n  }\n\n  var currentIndex = location.index;\n  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n  var firstIndex = insideDestination[0].descriptor.index;\n  var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n  var upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n\n  if (proposedIndex < firstIndex) {\n    return null;\n  }\n\n  if (proposedIndex > upperBound) {\n    return null;\n  }\n\n  return proposedIndex;\n});\n\nvar moveToNextIndex = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      isInHomeList = _ref.isInHomeList,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var wasAt = previousImpact.at;\n  !wasAt ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot move in direction without previous impact location') : invariant(false) : void 0;\n\n  if (wasAt.type === 'REORDER') {\n    var _newIndex = fromReorder({\n      isMovingForward: isMovingForward,\n      isInHomeList: isInHomeList,\n      location: wasAt.destination,\n      insideDestination: insideDestination\n    });\n\n    if (_newIndex == null) {\n      return null;\n    }\n\n    return calculateReorderImpact({\n      draggable: draggable,\n      insideDestination: insideDestination,\n      destination: destination,\n      viewport: viewport,\n      last: previousImpact.displaced,\n      displacedBy: previousImpact.displacedBy,\n      index: _newIndex\n    });\n  }\n\n  var newIndex = fromCombine({\n    isMovingForward: isMovingForward,\n    destination: destination,\n    displaced: previousImpact.displaced,\n    draggables: draggables,\n    combine: wasAt.combine,\n    afterCritical: afterCritical\n  });\n\n  if (newIndex == null) {\n    return null;\n  }\n\n  return calculateReorderImpact({\n    draggable: draggable,\n    insideDestination: insideDestination,\n    destination: destination,\n    viewport: viewport,\n    last: previousImpact.displaced,\n    displacedBy: previousImpact.displacedBy,\n    index: newIndex\n  });\n});\n\nvar getCombinedItemDisplacement = (function (_ref) {\n  var displaced = _ref.displaced,\n      afterCritical = _ref.afterCritical,\n      combineWith = _ref.combineWith,\n      displacedBy = _ref.displacedBy;\n  var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n\n  if (didStartAfterCritical(combineWith, afterCritical)) {\n    return isDisplaced ? origin : negate(displacedBy.point);\n  }\n\n  return isDisplaced ? displacedBy.point : origin;\n});\n\nvar whenCombining = (function (_ref) {\n  var afterCritical = _ref.afterCritical,\n      impact = _ref.impact,\n      draggables = _ref.draggables;\n  var combine = tryGetCombine(impact);\n  !combine ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n  var combineWith = combine.draggableId;\n  var center = draggables[combineWith].page.borderBox.center;\n  var displaceBy = getCombinedItemDisplacement({\n    displaced: impact.displaced,\n    afterCritical: afterCritical,\n    combineWith: combineWith,\n    displacedBy: impact.displacedBy\n  });\n  return add(center, displaceBy);\n});\n\nvar distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter(axis, box) {\n  return box.margin[axis.start] + box.borderBox[axis.size] / 2;\n};\n\nvar distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter(axis, box) {\n  return box.margin[axis.end] + box.borderBox[axis.size] / 2;\n};\n\nvar getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter(axis, target, isMoving) {\n  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\n};\n\nvar goAfter = function goAfter(_ref) {\n  var axis = _ref.axis,\n      moveRelativeTo = _ref.moveRelativeTo,\n      isMoving = _ref.isMoving;\n  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goBefore = function goBefore(_ref2) {\n  var axis = _ref2.axis,\n      moveRelativeTo = _ref2.moveRelativeTo,\n      isMoving = _ref2.isMoving;\n  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goIntoStart = function goIntoStart(_ref3) {\n  var axis = _ref3.axis,\n      moveInto = _ref3.moveInto,\n      isMoving = _ref3.isMoving;\n  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\n};\n\nvar whenReordering = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      droppable = _ref.droppable,\n      afterCritical = _ref.afterCritical;\n  var insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  var draggablePage = draggable.page;\n  var axis = droppable.axis;\n\n  if (!insideDestination.length) {\n    return goIntoStart({\n      axis: axis,\n      moveInto: droppable.page,\n      isMoving: draggablePage\n    });\n  }\n\n  var displaced = impact.displaced,\n      displacedBy = impact.displacedBy;\n  var closestAfter = displaced.all[0];\n\n  if (closestAfter) {\n    var closest = draggables[closestAfter];\n\n    if (didStartAfterCritical(closestAfter, afterCritical)) {\n      return goBefore({\n        axis: axis,\n        moveRelativeTo: closest.page,\n        isMoving: draggablePage\n      });\n    }\n\n    var withDisplacement = cssBoxModel.offset(closest.page, displacedBy.point);\n    return goBefore({\n      axis: axis,\n      moveRelativeTo: withDisplacement,\n      isMoving: draggablePage\n    });\n  }\n\n  var last = insideDestination[insideDestination.length - 1];\n\n  if (last.descriptor.id === draggable.descriptor.id) {\n    return draggablePage.borderBox.center;\n  }\n\n  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n    var page = cssBoxModel.offset(last.page, negate(afterCritical.displacedBy.point));\n    return goAfter({\n      axis: axis,\n      moveRelativeTo: page,\n      isMoving: draggablePage\n    });\n  }\n\n  return goAfter({\n    axis: axis,\n    moveRelativeTo: last.page,\n    isMoving: draggablePage\n  });\n});\n\nvar withDroppableDisplacement = (function (droppable, point) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return point;\n  }\n\n  return add(point, frame.scroll.diff.displacement);\n});\n\nvar getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement(_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      afterCritical = _ref.afterCritical;\n  var original = draggable.page.borderBox.center;\n  var at = impact.at;\n\n  if (!droppable) {\n    return original;\n  }\n\n  if (!at) {\n    return original;\n  }\n\n  if (at.type === 'REORDER') {\n    return whenReordering({\n      impact: impact,\n      draggable: draggable,\n      draggables: draggables,\n      droppable: droppable,\n      afterCritical: afterCritical\n    });\n  }\n\n  return whenCombining({\n    impact: impact,\n    draggables: draggables,\n    afterCritical: afterCritical\n  });\n};\n\nvar getPageBorderBoxCenterFromImpact = (function (args) {\n  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n  var droppable = args.droppable;\n  var withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n  return withDisplacement;\n});\n\nvar scrollViewport = (function (viewport, newScroll) {\n  var diff = subtract(newScroll, viewport.scroll.initial);\n  var displacement = negate(diff);\n  var frame = cssBoxModel.getRect({\n    top: newScroll.y,\n    bottom: newScroll.y + viewport.frame.height,\n    left: newScroll.x,\n    right: newScroll.x + viewport.frame.width\n  });\n  var updated = {\n    frame: frame,\n    scroll: {\n      initial: viewport.scroll.initial,\n      max: viewport.scroll.max,\n      current: newScroll,\n      diff: {\n        value: diff,\n        displacement: displacement\n      }\n    }\n  };\n  return updated;\n});\n\nfunction getDraggables(ids, draggables) {\n  return ids.map(function (id) {\n    return draggables[id];\n  });\n}\n\nfunction tryGetVisible(id, groups) {\n  for (var i = 0; i < groups.length; i++) {\n    var displacement = groups[i].visible[id];\n\n    if (displacement) {\n      return displacement;\n    }\n  }\n\n  return null;\n}\n\nvar speculativelyIncrease = (function (_ref) {\n  var impact = _ref.impact,\n      viewport = _ref.viewport,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      maxScrollChange = _ref.maxScrollChange;\n  var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n  var last = impact.displaced;\n  var withViewportScroll = getDisplacementGroups({\n    afterDragging: getDraggables(last.all, draggables),\n    destination: destination,\n    displacedBy: impact.displacedBy,\n    viewport: scrolledViewport.frame,\n    last: last,\n    forceShouldAnimate: false\n  });\n  var withDroppableScroll = getDisplacementGroups({\n    afterDragging: getDraggables(last.all, draggables),\n    destination: scrolledDroppable,\n    displacedBy: impact.displacedBy,\n    viewport: viewport.frame,\n    last: last,\n    forceShouldAnimate: false\n  });\n  var invisible = {};\n  var visible = {};\n  var groups = [last, withViewportScroll, withDroppableScroll];\n  last.all.forEach(function (id) {\n    var displacement = tryGetVisible(id, groups);\n\n    if (displacement) {\n      visible[id] = displacement;\n      return;\n    }\n\n    invisible[id] = true;\n  });\n\n  var newImpact = _extends({}, impact, {\n    displaced: {\n      all: last.all,\n      invisible: invisible,\n      visible: visible\n    }\n  });\n\n  return newImpact;\n});\n\nvar withViewportDisplacement = (function (viewport, point) {\n  return add(viewport.scroll.diff.displacement, point);\n});\n\nvar getClientFromPageBorderBoxCenter = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggable = _ref.draggable,\n      viewport = _ref.viewport;\n  var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n  var offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n  return add(draggable.client.borderBox.center, offset);\n});\n\nvar isTotallyVisibleInNewLocation = (function (_ref) {\n  var draggable = _ref.draggable,\n      destination = _ref.destination,\n      newPageBorderBoxCenter = _ref.newPageBorderBoxCenter,\n      viewport = _ref.viewport,\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\n      _ref$onlyOnMainAxis = _ref.onlyOnMainAxis,\n      onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;\n  var changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n  var shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n  var args = {\n    target: shifted,\n    destination: destination,\n    withDroppableDisplacement: withDroppableDisplacement,\n    viewport: viewport\n  };\n  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n});\n\nvar moveToNextPlace = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      previousClientSelection = _ref.previousClientSelection,\n      afterCritical = _ref.afterCritical;\n\n  if (!destination.isEnabled) {\n    return null;\n  }\n\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var isInHomeList = isHomeOf(draggable, destination);\n  var impact = moveToNextCombine({\n    isMovingForward: isMovingForward,\n    draggable: draggable,\n    destination: destination,\n    insideDestination: insideDestination,\n    previousImpact: previousImpact\n  }) || moveToNextIndex({\n    isMovingForward: isMovingForward,\n    isInHomeList: isInHomeList,\n    draggable: draggable,\n    draggables: draggables,\n    destination: destination,\n    insideDestination: insideDestination,\n    previousImpact: previousImpact,\n    viewport: viewport,\n    afterCritical: afterCritical\n  });\n\n  if (!impact) {\n    return null;\n  }\n\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    afterCritical: afterCritical\n  });\n  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n    draggable: draggable,\n    destination: destination,\n    newPageBorderBoxCenter: pageBorderBoxCenter,\n    viewport: viewport.frame,\n    withDroppableDisplacement: false,\n    onlyOnMainAxis: true\n  });\n\n  if (isVisibleInNewLocation) {\n    var clientSelection = getClientFromPageBorderBoxCenter({\n      pageBorderBoxCenter: pageBorderBoxCenter,\n      draggable: draggable,\n      viewport: viewport\n    });\n    return {\n      clientSelection: clientSelection,\n      impact: impact,\n      scrollJumpRequest: null\n    };\n  }\n\n  var distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n  var cautious = speculativelyIncrease({\n    impact: impact,\n    viewport: viewport,\n    destination: destination,\n    draggables: draggables,\n    maxScrollChange: distance\n  });\n  return {\n    clientSelection: previousClientSelection,\n    impact: cautious,\n    scrollJumpRequest: distance\n  };\n});\n\nvar getKnownActive = function getKnownActive(droppable) {\n  var rect = droppable.subject.active;\n  !rect ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get clipped area from droppable') : invariant(false) : void 0;\n  return rect;\n};\n\nvar getBestCrossAxisDroppable = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      source = _ref.source,\n      droppables = _ref.droppables,\n      viewport = _ref.viewport;\n  var active = source.subject.active;\n\n  if (!active) {\n    return null;\n  }\n\n  var axis = source.axis;\n  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n  var candidates = toDroppableList(droppables).filter(function (droppable) {\n    return droppable !== source;\n  }).filter(function (droppable) {\n    return droppable.isEnabled;\n  }).filter(function (droppable) {\n    return Boolean(droppable.subject.active);\n  }).filter(function (droppable) {\n    return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable));\n  }).filter(function (droppable) {\n    var activeOfTarget = getKnownActive(droppable);\n\n    if (isMovingForward) {\n      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n    }\n\n    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n  }).filter(function (droppable) {\n    var activeOfTarget = getKnownActive(droppable);\n    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n  }).sort(function (a, b) {\n    var first = getKnownActive(a)[axis.crossAxisStart];\n    var second = getKnownActive(b)[axis.crossAxisStart];\n\n    if (isMovingForward) {\n      return first - second;\n    }\n\n    return second - first;\n  }).filter(function (droppable, index, array) {\n    return getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];\n  });\n\n  if (!candidates.length) {\n    return null;\n  }\n\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n\n  var contains = candidates.filter(function (droppable) {\n    var isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n    return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n  });\n\n  if (contains.length === 1) {\n    return contains[0];\n  }\n\n  if (contains.length > 1) {\n    return contains.sort(function (a, b) {\n      return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n  }\n\n  return candidates.sort(function (a, b) {\n    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n\n    if (first !== second) {\n      return first - second;\n    }\n\n    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n  })[0];\n});\n\nvar getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter(draggable, afterCritical) {\n  var original = draggable.page.borderBox.center;\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nvar getCurrentPageBorderBox = function getCurrentPageBorderBox(draggable, afterCritical) {\n  var original = draggable.page.borderBox;\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\n\nvar getClosestDraggable = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      viewport = _ref.viewport,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      afterCritical = _ref.afterCritical;\n  var sorted = insideDestination.filter(function (draggable) {\n    return isTotallyVisible({\n      target: getCurrentPageBorderBox(draggable, afterCritical),\n      destination: destination,\n      viewport: viewport.frame,\n      withDroppableDisplacement: true\n    });\n  }).sort(function (a, b) {\n    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n\n    if (distanceToA < distanceToB) {\n      return -1;\n    }\n\n    if (distanceToB < distanceToA) {\n      return 1;\n    }\n\n    return a.descriptor.index - b.descriptor.index;\n  });\n  return sorted[0] || null;\n});\n\nvar getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {\n  var displacement = displaceBy[axis.line];\n  return {\n    value: displacement,\n    point: patch(axis.line, displacement)\n  };\n});\n\nvar getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables) {\n  var axis = droppable.axis;\n\n  if (droppable.descriptor.mode === 'virtual') {\n    return patch(axis.line, placeholderSize[axis.line]);\n  }\n\n  var availableSpace = droppable.subject.page.contentBox[axis.size];\n  var insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  var spaceUsed = insideDroppable.reduce(function (sum, dimension) {\n    return sum + dimension.client.marginBox[axis.size];\n  }, 0);\n  var requiredSpace = spaceUsed + placeholderSize[axis.line];\n  var needsToGrowBy = requiredSpace - availableSpace;\n\n  if (needsToGrowBy <= 0) {\n    return null;\n  }\n\n  return patch(axis.line, needsToGrowBy);\n};\n\nvar withMaxScroll = function withMaxScroll(frame, max) {\n  return _extends({}, frame, {\n    scroll: _extends({}, frame.scroll, {\n      max: max\n    })\n  });\n};\n\nvar addPlaceholder = function addPlaceholder(droppable, draggable, draggables) {\n  var frame = droppable.frame;\n  !!isHomeOf(draggable, droppable) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not add placeholder space to home list') : invariant(false) : void 0;\n  !!droppable.subject.withPlaceholder ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot add placeholder size to a subject when it already has one') : invariant(false) : void 0;\n  var placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n  var added = {\n    placeholderSize: placeholderSize,\n    increasedBy: requiredGrowth,\n    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n  };\n\n  if (!frame) {\n    var _subject = getSubject({\n      page: droppable.subject.page,\n      withPlaceholder: added,\n      axis: droppable.axis,\n      frame: droppable.frame\n    });\n\n    return _extends({}, droppable, {\n      subject: _subject\n    });\n  }\n\n  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n  var newFrame = withMaxScroll(frame, maxScroll);\n  var subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: added,\n    axis: droppable.axis,\n    frame: newFrame\n  });\n  return _extends({}, droppable, {\n    subject: subject,\n    frame: newFrame\n  });\n};\nvar removePlaceholder = function removePlaceholder(droppable) {\n  var added = droppable.subject.withPlaceholder;\n  !added ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot remove placeholder form subject when there was none') : invariant(false) : void 0;\n  var frame = droppable.frame;\n\n  if (!frame) {\n    var _subject2 = getSubject({\n      page: droppable.subject.page,\n      axis: droppable.axis,\n      frame: null,\n      withPlaceholder: null\n    });\n\n    return _extends({}, droppable, {\n      subject: _subject2\n    });\n  }\n\n  var oldMaxScroll = added.oldFrameMaxScroll;\n  !oldMaxScroll ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected droppable with frame to have old max frame scroll when removing placeholder') : invariant(false) : void 0;\n  var newFrame = withMaxScroll(frame, oldMaxScroll);\n  var subject = getSubject({\n    page: droppable.subject.page,\n    axis: droppable.axis,\n    frame: newFrame,\n    withPlaceholder: null\n  });\n  return _extends({}, droppable, {\n    subject: subject,\n    frame: newFrame\n  });\n};\n\nvar moveToNewDroppable = (function (_ref) {\n  var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      moveRelativeTo = _ref.moveRelativeTo,\n      insideDestination = _ref.insideDestination,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n\n  if (!moveRelativeTo) {\n    if (insideDestination.length) {\n      return null;\n    }\n\n    var proposed = {\n      displaced: emptyGroups,\n      displacedBy: noDisplacedBy,\n      at: {\n        type: 'REORDER',\n        destination: {\n          droppableId: destination.descriptor.id,\n          index: 0\n        }\n      }\n    };\n    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n      impact: proposed,\n      draggable: draggable,\n      droppable: destination,\n      draggables: draggables,\n      afterCritical: afterCritical\n    });\n    var withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n      draggable: draggable,\n      destination: withPlaceholder,\n      newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n      viewport: viewport.frame,\n      withDroppableDisplacement: false,\n      onlyOnMainAxis: true\n    });\n    return isVisibleInNewLocation ? proposed : null;\n  }\n\n  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n\n  var proposedIndex = function () {\n    var relativeTo = moveRelativeTo.descriptor.index;\n\n    if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n      return relativeTo;\n    }\n\n    if (isGoingBeforeTarget) {\n      return relativeTo;\n    }\n\n    return relativeTo + 1;\n  }();\n\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  return calculateReorderImpact({\n    draggable: draggable,\n    insideDestination: insideDestination,\n    destination: destination,\n    viewport: viewport,\n    displacedBy: displacedBy,\n    last: emptyGroups,\n    index: proposedIndex\n  });\n});\n\nvar moveCrossAxis = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      draggable = _ref.draggable,\n      isOver = _ref.isOver,\n      draggables = _ref.draggables,\n      droppables = _ref.droppables,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var destination = getBestCrossAxisDroppable({\n    isMovingForward: isMovingForward,\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    source: isOver,\n    droppables: droppables,\n    viewport: viewport\n  });\n\n  if (!destination) {\n    return null;\n  }\n\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var moveRelativeTo = getClosestDraggable({\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    viewport: viewport,\n    destination: destination,\n    insideDestination: insideDestination,\n    afterCritical: afterCritical\n  });\n  var impact = moveToNewDroppable({\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    destination: destination,\n    draggable: draggable,\n    draggables: draggables,\n    moveRelativeTo: moveRelativeTo,\n    insideDestination: insideDestination,\n    viewport: viewport,\n    afterCritical: afterCritical\n  });\n\n  if (!impact) {\n    return null;\n  }\n\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    afterCritical: afterCritical\n  });\n  var clientSelection = getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    draggable: draggable,\n    viewport: viewport\n  });\n  return {\n    clientSelection: clientSelection,\n    impact: impact,\n    scrollJumpRequest: null\n  };\n});\n\nvar whatIsDraggedOver = (function (impact) {\n  var at = impact.at;\n\n  if (!at) {\n    return null;\n  }\n\n  if (at.type === 'REORDER') {\n    return at.destination.droppableId;\n  }\n\n  return at.combine.droppableId;\n});\n\nvar getDroppableOver = function getDroppableOver(impact, droppables) {\n  var id = whatIsDraggedOver(impact);\n  return id ? droppables[id] : null;\n};\n\nvar moveInDirection = (function (_ref) {\n  var state = _ref.state,\n      type = _ref.type;\n  var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);\n  var isMainAxisMovementAllowed = Boolean(isActuallyOver);\n  var home = state.dimensions.droppables[state.critical.droppable.id];\n  var isOver = isActuallyOver || home;\n  var direction = isOver.axis.direction;\n  var isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');\n\n  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n    return null;\n  }\n\n  var isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\n  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n  var _state$dimensions = state.dimensions,\n      draggables = _state$dimensions.draggables,\n      droppables = _state$dimensions.droppables;\n  return isMovingOnMainAxis ? moveToNextPlace({\n    isMovingForward: isMovingForward,\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    draggable: draggable,\n    destination: isOver,\n    draggables: draggables,\n    viewport: state.viewport,\n    previousClientSelection: state.current.client.selection,\n    previousImpact: state.impact,\n    afterCritical: state.afterCritical\n  }) : moveCrossAxis({\n    isMovingForward: isMovingForward,\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    draggable: draggable,\n    isOver: isOver,\n    draggables: draggables,\n    droppables: droppables,\n    viewport: state.viewport,\n    afterCritical: state.afterCritical\n  });\n});\n\nfunction isMovementAllowed(state) {\n  return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';\n}\n\nvar isPositionInFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (point) {\n    return isWithinVertical(point.y) && isWithinVertical(point.y) && isWithinHorizontal(point.x) && isWithinHorizontal(point.x);\n  };\n});\n\nvar getDroppableOver$1 = (function (_ref) {\n  var target = _ref.target,\n      droppables = _ref.droppables;\n  var maybe = find(toDroppableList(droppables), function (droppable) {\n    if (!droppable.isEnabled) {\n      return false;\n    }\n\n    var active = droppable.subject.active;\n\n    if (!active) {\n      return false;\n    }\n\n    return isPositionInFrame(active)(target);\n  });\n  return maybe ? maybe.descriptor.id : null;\n});\n\nvar withDroppableScroll = (function (droppable, point) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return point;\n  }\n\n  return add(point, frame.scroll.diff.value);\n});\n\nvar isUserMovingForward = (function (axis, direction) {\n  return axis === vertical ? direction.vertical === 'down' : direction.horizontal === 'right';\n});\n\nfunction atIndex(_ref) {\n  var draggable = _ref.draggable,\n      closest = _ref.closest,\n      inHomeList = _ref.inHomeList;\n\n  if (!closest) {\n    return null;\n  }\n\n  if (!inHomeList) {\n    return closest.descriptor.index;\n  }\n\n  if (closest.descriptor.index > draggable.descriptor.index) {\n    return closest.descriptor.index - 1;\n  }\n\n  return closest.descriptor.index;\n}\n\nvar getReorderImpact = (function (_ref2) {\n  var currentCenter = _ref2.pageBorderBoxCenterWithDroppableScrollChange,\n      draggable = _ref2.draggable,\n      destination = _ref2.destination,\n      insideDestination = _ref2.insideDestination,\n      last = _ref2.last,\n      viewport = _ref2.viewport,\n      userDirection = _ref2.userDirection,\n      afterCritical = _ref2.afterCritical;\n  var axis = destination.axis;\n  var isMovingForward = isUserMovingForward(destination.axis, userDirection);\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  var targetCenter = currentCenter[axis.line];\n  var displacement = displacedBy.value;\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  var closest = find(withoutDragging, function (child) {\n    var id = child.descriptor.id;\n    var borderBox = child.page.borderBox;\n    var start = borderBox[axis.start];\n    var end = borderBox[axis.end];\n    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n\n    if (isMovingForward) {\n      if (didStartAfterCritical$1) {\n        return targetCenter < start;\n      }\n\n      return targetCenter < start + displacement;\n    }\n\n    if (didStartAfterCritical$1) {\n      return targetCenter <= end - displacement;\n    }\n\n    return targetCenter <= end;\n  });\n  var newIndex = atIndex({\n    draggable: draggable,\n    closest: closest,\n    inHomeList: isHomeOf(draggable, destination)\n  });\n  return calculateReorderImpact({\n    draggable: draggable,\n    insideDestination: insideDestination,\n    destination: destination,\n    viewport: viewport,\n    last: last,\n    displacedBy: displacedBy,\n    index: newIndex\n  });\n});\n\nfunction getWhenEntered(id, current, lastCombineImpact) {\n  if (!lastCombineImpact) {\n    return current;\n  }\n\n  if (id !== lastCombineImpact.combine.draggableId) {\n    return current;\n  }\n\n  return lastCombineImpact.whenEntered;\n}\n\nfunction tryGetCombineImpact(impact) {\n  if (impact.at && impact.at.type === 'COMBINE') {\n    return impact.at;\n  }\n\n  return null;\n}\n\nfunction calculateCombineImpact(_ref) {\n  var combineWithId = _ref.combineWithId,\n      destinationId = _ref.destinationId,\n      userDirection = _ref.userDirection,\n      previousImpact = _ref.previousImpact;\n  var lastCombineImpact = tryGetCombineImpact(previousImpact);\n  var whenEntered = getWhenEntered(combineWithId, userDirection, lastCombineImpact);\n  var impact = {\n    displacedBy: previousImpact.displacedBy,\n    displaced: previousImpact.displaced,\n    at: {\n      type: 'COMBINE',\n      whenEntered: whenEntered,\n      combine: {\n        draggableId: combineWithId,\n        droppableId: destinationId\n      }\n    }\n  };\n  return impact;\n}\n\nfunction getWhenEntered$1(id, current, lastCombineImpact) {\n  if (!lastCombineImpact) {\n    return current;\n  }\n\n  if (id !== lastCombineImpact.combine.draggableId) {\n    return current;\n  }\n\n  return lastCombineImpact.whenEntered;\n}\n\nvar isCombiningWith = function isCombiningWith(_ref) {\n  var id = _ref.id,\n      currentCenter = _ref.currentCenter,\n      axis = _ref.axis,\n      borderBox = _ref.borderBox,\n      displaceBy = _ref.displaceBy,\n      currentUserDirection = _ref.currentUserDirection,\n      lastCombineImpact = _ref.lastCombineImpact;\n  var start = borderBox[axis.start] + displaceBy[axis.line];\n  var end = borderBox[axis.end] + displaceBy[axis.line];\n  var size = borderBox[axis.size];\n  var twoThirdsOfSize = size * 0.666;\n  var whenEntered = getWhenEntered$1(id, currentUserDirection, lastCombineImpact);\n  var isMovingForward = isUserMovingForward(axis, whenEntered);\n  var targetCenter = currentCenter[axis.line];\n\n  if (isMovingForward) {\n    return isWithin(start, start + twoThirdsOfSize)(targetCenter);\n  }\n\n  return isWithin(end - twoThirdsOfSize, end)(targetCenter);\n};\n\nfunction tryGetCombineImpact$1(impact) {\n  if (impact.at && impact.at.type === 'COMBINE') {\n    return impact.at;\n  }\n\n  return null;\n}\n\nvar getCombineImpact = (function (_ref2) {\n  var draggable = _ref2.draggable,\n      currentCenter = _ref2.pageBorderBoxCenterWithDroppableScrollChange,\n      previousImpact = _ref2.previousImpact,\n      destination = _ref2.destination,\n      insideDestination = _ref2.insideDestination,\n      userDirection = _ref2.userDirection,\n      afterCritical = _ref2.afterCritical;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var axis = destination.axis;\n  var displaced = previousImpact.displaced;\n  var canBeDisplacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  var lastCombineImpact = tryGetCombineImpact$1(previousImpact);\n  var combineWith = find(removeDraggableFromList(draggable, insideDestination), function (child) {\n    var id = child.descriptor.id;\n    var displaceBy = getCombinedItemDisplacement({\n      displaced: displaced,\n      afterCritical: afterCritical,\n      combineWith: id,\n      displacedBy: canBeDisplacedBy\n    });\n    return isCombiningWith({\n      id: id,\n      currentCenter: currentCenter,\n      axis: axis,\n      borderBox: child.page.borderBox,\n      displaceBy: displaceBy,\n      currentUserDirection: userDirection,\n      lastCombineImpact: lastCombineImpact\n    });\n  });\n\n  if (!combineWith) {\n    return null;\n  }\n\n  return calculateCombineImpact({\n    combineWithId: combineWith.descriptor.id,\n    destinationId: destination.descriptor.id,\n    previousImpact: previousImpact,\n    userDirection: userDirection\n  });\n});\n\nvar getDragImpact = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      droppables = _ref.droppables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      userDirection = _ref.userDirection,\n      afterCritical = _ref.afterCritical;\n  var destinationId = getDroppableOver$1({\n    target: pageBorderBoxCenter,\n    droppables: droppables\n  });\n\n  if (!destinationId) {\n    return noImpact;\n  }\n\n  var destination = droppables[destinationId];\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var pageBorderBoxCenterWithDroppableScrollChange = withDroppableScroll(destination, pageBorderBoxCenter);\n  return getCombineImpact({\n    pageBorderBoxCenterWithDroppableScrollChange: pageBorderBoxCenterWithDroppableScrollChange,\n    draggable: draggable,\n    previousImpact: previousImpact,\n    destination: destination,\n    insideDestination: insideDestination,\n    userDirection: userDirection,\n    afterCritical: afterCritical\n  }) || getReorderImpact({\n    pageBorderBoxCenterWithDroppableScrollChange: pageBorderBoxCenterWithDroppableScrollChange,\n    draggable: draggable,\n    destination: destination,\n    insideDestination: insideDestination,\n    last: previousImpact.displaced,\n    viewport: viewport,\n    userDirection: userDirection,\n    afterCritical: afterCritical\n  });\n});\n\nvar getVertical = function getVertical(previous, diff) {\n  if (diff === 0) {\n    return previous;\n  }\n\n  return diff > 0 ? 'down' : 'up';\n};\n\nvar getHorizontal = function getHorizontal(previous, diff) {\n  if (diff === 0) {\n    return previous;\n  }\n\n  return diff > 0 ? 'right' : 'left';\n};\n\nvar getUserDirection = (function (previous, oldPageBorderBoxCenter, newPageBorderBoxCenter) {\n  var diff = subtract(newPageBorderBoxCenter, oldPageBorderBoxCenter);\n  return {\n    horizontal: getHorizontal(previous.horizontal, diff.x),\n    vertical: getVertical(previous.vertical, diff.y)\n  };\n});\n\nvar patchDroppableMap = (function (droppables, updated) {\n  var _extends2;\n\n  return _extends({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));\n});\n\nvar clearUnusedPlaceholder = function clearUnusedPlaceholder(_ref) {\n  var previousImpact = _ref.previousImpact,\n      impact = _ref.impact,\n      droppables = _ref.droppables;\n  var last = whatIsDraggedOver(previousImpact);\n  var now = whatIsDraggedOver(impact);\n\n  if (!last) {\n    return droppables;\n  }\n\n  if (last === now) {\n    return droppables;\n  }\n\n  var lastDroppable = droppables[last];\n\n  if (!lastDroppable.subject.withPlaceholder) {\n    return droppables;\n  }\n\n  var updated = removePlaceholder(lastDroppable);\n  return patchDroppableMap(droppables, updated);\n};\n\nvar recomputePlaceholders = (function (_ref2) {\n  var draggable = _ref2.draggable,\n      draggables = _ref2.draggables,\n      droppables = _ref2.droppables,\n      previousImpact = _ref2.previousImpact,\n      impact = _ref2.impact;\n  var cleaned = clearUnusedPlaceholder({\n    previousImpact: previousImpact,\n    impact: impact,\n    droppables: droppables\n  });\n  var isOver = whatIsDraggedOver(impact);\n\n  if (!isOver) {\n    return cleaned;\n  }\n\n  var droppable = droppables[isOver];\n\n  if (isHomeOf(draggable, droppable)) {\n    return cleaned;\n  }\n\n  if (droppable.subject.withPlaceholder) {\n    return cleaned;\n  }\n\n  var patched = addPlaceholder(droppable, draggable, draggables);\n  return patchDroppableMap(cleaned, patched);\n});\n\nvar update = (function (_ref) {\n  var state = _ref.state,\n      forcedClientSelection = _ref.clientSelection,\n      forcedDimensions = _ref.dimensions,\n      forcedViewport = _ref.viewport,\n      forcedImpact = _ref.impact,\n      scrollJumpRequest = _ref.scrollJumpRequest;\n  var viewport = forcedViewport || state.viewport;\n  var currentWindowScroll = viewport.scroll.current;\n  var dimensions = forcedDimensions || state.dimensions;\n  var clientSelection = forcedClientSelection || state.current.client.selection;\n  var offset = subtract(clientSelection, state.initial.client.selection);\n  var client = {\n    offset: offset,\n    selection: clientSelection,\n    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n  };\n  var page = {\n    selection: add(client.selection, currentWindowScroll),\n    borderBoxCenter: add(client.borderBoxCenter, currentWindowScroll)\n  };\n  var current = {\n    client: client,\n    page: page\n  };\n  var userDirection = getUserDirection(state.userDirection, state.current.page.borderBoxCenter, current.page.borderBoxCenter);\n\n  if (state.phase === 'COLLECTING') {\n    return _extends({\n      phase: 'COLLECTING'\n    }, state, {\n      dimensions: dimensions,\n      viewport: viewport,\n      current: current,\n      userDirection: userDirection\n    });\n  }\n\n  var draggable = dimensions.draggables[state.critical.draggable.id];\n  var newImpact = forcedImpact || getDragImpact({\n    pageBorderBoxCenter: page.borderBoxCenter,\n    draggable: draggable,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact: state.impact,\n    viewport: viewport,\n    userDirection: userDirection,\n    afterCritical: state.afterCritical\n  });\n  var withUpdatedPlaceholders = recomputePlaceholders({\n    draggable: draggable,\n    impact: newImpact,\n    previousImpact: state.impact,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables\n  });\n\n  var result = _extends({}, state, {\n    current: current,\n    userDirection: userDirection,\n    dimensions: {\n      draggables: dimensions.draggables,\n      droppables: withUpdatedPlaceholders\n    },\n    impact: newImpact,\n    viewport: viewport,\n    scrollJumpRequest: scrollJumpRequest || null,\n    forceShouldAnimate: scrollJumpRequest ? false : null\n  });\n\n  return result;\n});\n\nfunction getDraggables$1(ids, draggables) {\n  return ids.map(function (id) {\n    return draggables[id];\n  });\n}\n\nvar recompute = (function (_ref) {\n  var impact = _ref.impact,\n      viewport = _ref.viewport,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      forceShouldAnimate = _ref.forceShouldAnimate;\n  var last = impact.displaced;\n  var afterDragging = getDraggables$1(last.all, draggables);\n  var displaced = getDisplacementGroups({\n    afterDragging: afterDragging,\n    destination: destination,\n    displacedBy: impact.displacedBy,\n    viewport: viewport.frame,\n    forceShouldAnimate: forceShouldAnimate,\n    last: last\n  });\n  return _extends({}, impact, {\n    displaced: displaced\n  });\n});\n\nvar getClientBorderBoxCenter = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    draggables: draggables,\n    droppable: droppable,\n    afterCritical: afterCritical\n  });\n  return getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    draggable: draggable,\n    viewport: viewport\n  });\n});\n\nvar refreshSnap = (function (_ref) {\n  var state = _ref.state,\n      forcedDimensions = _ref.dimensions,\n      forcedViewport = _ref.viewport;\n  !(state.movementMode === 'SNAP') ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n  var needsVisibilityCheck = state.impact;\n  var viewport = forcedViewport || state.viewport;\n  var dimensions = forcedDimensions || state.dimensions;\n  var draggables = dimensions.draggables,\n      droppables = dimensions.droppables;\n  var draggable = draggables[state.critical.draggable.id];\n  var isOver = whatIsDraggedOver(needsVisibilityCheck);\n  !isOver ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Must be over a destination in SNAP movement mode') : invariant(false) : void 0;\n  var destination = droppables[isOver];\n  var impact = recompute({\n    impact: needsVisibilityCheck,\n    viewport: viewport,\n    destination: destination,\n    draggables: draggables\n  });\n  var clientSelection = getClientBorderBoxCenter({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    viewport: viewport,\n    afterCritical: state.afterCritical\n  });\n  return update({\n    impact: impact,\n    clientSelection: clientSelection,\n    state: state,\n    dimensions: dimensions,\n    viewport: viewport\n  });\n});\n\nvar getHomeLocation = (function (descriptor) {\n  return {\n    index: descriptor.index,\n    droppableId: descriptor.droppableId\n  };\n});\n\nvar getLiftEffect = (function (_ref) {\n  var draggable = _ref.draggable,\n      home = _ref.home,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport;\n  var displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n  var insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n  var rawIndex = insideHome.indexOf(draggable);\n  !(rawIndex !== -1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected draggable to be inside home list') : invariant(false) : void 0;\n  var afterDragging = insideHome.slice(rawIndex + 1);\n  var effected = afterDragging.reduce(function (previous, item) {\n    previous[item.descriptor.id] = true;\n    return previous;\n  }, {});\n  var afterCritical = {\n    inVirtualList: home.descriptor.mode === 'virtual',\n    displacedBy: displacedBy,\n    effected: effected\n  };\n  var displaced = getDisplacementGroups({\n    afterDragging: afterDragging,\n    destination: home,\n    displacedBy: displacedBy,\n    last: null,\n    viewport: viewport.frame,\n    forceShouldAnimate: false\n  });\n  var impact = {\n    displaced: displaced,\n    displacedBy: displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: getHomeLocation(draggable.descriptor)\n    }\n  };\n  return {\n    impact: impact,\n    afterCritical: afterCritical\n  };\n});\n\nvar patchDimensionMap = (function (dimensions, updated) {\n  return {\n    draggables: dimensions.draggables,\n    droppables: patchDroppableMap(dimensions.droppables, updated)\n  };\n});\n\nvar records = {};\nvar isEnabled = false;\n\nvar isTimingsEnabled = function isTimingsEnabled() {\n  return isEnabled;\n};\nvar start = function start(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isTimingsEnabled()) {\n      return;\n    }\n\n    var now = performance.now();\n    records[key] = now;\n  }\n};\nvar finish = function finish(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isTimingsEnabled()) {\n      return;\n    }\n\n    var now = performance.now();\n    var previous = records[key];\n\n    if (!previous) {\n      console.warn('cannot finish timing as no previous time found', key);\n      return;\n    }\n\n    var result = now - previous;\n    var rounded = result.toFixed(2);\n\n    var style = function () {\n      if (result < 12) {\n        return {\n          textColor: 'green',\n          symbol: ''\n        };\n      }\n\n      if (result < 40) {\n        return {\n          textColor: 'orange',\n          symbol: ''\n        };\n      }\n\n      return {\n        textColor: 'red',\n        symbol: ''\n      };\n    }();\n\n    console.log(style.symbol + \" %cTiming %c\" + rounded + \" %cms %c\" + key, 'color: blue; font-weight: bold;', \"color: \" + style.textColor + \"; font-size: 1.1em;\", 'color: grey;', 'color: purple; font-weight: bold;');\n  }\n};\n\nvar offsetDraggable = (function (_ref) {\n  var draggable = _ref.draggable,\n      offset = _ref.offset,\n      initialWindowScroll = _ref.initialWindowScroll;\n  var client = cssBoxModel.offset(draggable.client, offset);\n  var page = cssBoxModel.withScroll(client, initialWindowScroll);\n\n  var moved = _extends({}, draggable, {\n    placeholder: _extends({}, draggable.placeholder, {\n      client: client\n    }),\n    client: client,\n    page: page\n  });\n\n  return moved;\n});\n\nvar getFrame = (function (droppable) {\n  var frame = droppable.frame;\n  !frame ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected Droppable to have a frame') : invariant(false) : void 0;\n  return frame;\n});\n\nvar adjustAdditionsForScrollChanges = (function (_ref) {\n  var additions = _ref.additions,\n      updatedDroppables = _ref.updatedDroppables,\n      viewport = _ref.viewport;\n  var windowScrollChange = viewport.scroll.diff.value;\n  return additions.map(function (draggable) {\n    var droppableId = draggable.descriptor.droppableId;\n    var modified = updatedDroppables[droppableId];\n    var frame = getFrame(modified);\n    var droppableScrollChange = frame.scroll.diff.value;\n    var totalChange = add(windowScrollChange, droppableScrollChange);\n    var moved = offsetDraggable({\n      draggable: draggable,\n      offset: totalChange,\n      initialWindowScroll: viewport.scroll.initial\n    });\n    return moved;\n  });\n});\n\nvar timingsKey = 'Processing dynamic changes';\nvar publishWhileDraggingInVirtual = (function (_ref) {\n  var _extends2, _extends3;\n\n  var state = _ref.state,\n      published = _ref.published;\n  start(timingsKey);\n  var withScrollChange = published.modified.map(function (update) {\n    var existing = state.dimensions.droppables[update.droppableId];\n    var scrolled = scrollDroppable(existing, update.scroll);\n    return scrolled;\n  });\n\n  var droppables = _extends({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));\n\n  var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n    additions: published.additions,\n    updatedDroppables: droppables,\n    viewport: state.viewport\n  }));\n\n  var draggables = _extends({}, state.dimensions.draggables, {}, updatedAdditions);\n\n  published.removals.forEach(function (id) {\n    delete draggables[id];\n  });\n  var dimensions = {\n    droppables: droppables,\n    draggables: draggables\n  };\n  var wasOverId = whatIsDraggedOver(state.impact);\n  var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n  var draggable = dimensions.draggables[state.critical.draggable.id];\n  var home = dimensions.droppables[state.critical.droppable.id];\n\n  var _getLiftEffect = getLiftEffect({\n    draggable: draggable,\n    home: home,\n    draggables: draggables,\n    viewport: state.viewport\n  }),\n      onLiftImpact = _getLiftEffect.impact,\n      afterCritical = _getLiftEffect.afterCritical;\n\n  var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n  var impact = getDragImpact({\n    pageBorderBoxCenter: state.current.page.borderBoxCenter,\n    draggable: dimensions.draggables[state.critical.draggable.id],\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact: previousImpact,\n    viewport: state.viewport,\n    userDirection: state.userDirection,\n    afterCritical: afterCritical\n  });\n  finish(timingsKey);\n\n  var draggingState = _extends({\n    phase: 'DRAGGING'\n  }, state, (_extends2 = {}, _extends2[\"phase\"] = 'DRAGGING', _extends2.impact = impact, _extends2.onLiftImpact = onLiftImpact, _extends2.dimensions = dimensions, _extends2.afterCritical = afterCritical, _extends2.forceShouldAnimate = false, _extends2));\n\n  if (state.phase === 'COLLECTING') {\n    return draggingState;\n  }\n\n  var dropPending = _extends({\n    phase: 'DROP_PENDING'\n  }, draggingState, (_extends3 = {}, _extends3[\"phase\"] = 'DROP_PENDING', _extends3.reason = state.reason, _extends3.isWaiting = false, _extends3));\n\n  return dropPending;\n});\n\nvar isSnapping = function isSnapping(state) {\n  return state.movementMode === 'SNAP';\n};\n\nvar postDroppableChange = function postDroppableChange(state, updated, isEnabledChanging) {\n  var dimensions = patchDimensionMap(state.dimensions, updated);\n\n  if (!isSnapping(state) || isEnabledChanging) {\n    return update({\n      state: state,\n      dimensions: dimensions\n    });\n  }\n\n  return refreshSnap({\n    state: state,\n    dimensions: dimensions\n  });\n};\n\nfunction removeScrollJumpRequest(state) {\n  if (state.isDragging && state.movementMode === 'SNAP') {\n    return _extends({\n      phase: 'DRAGGING'\n    }, state, {\n      scrollJumpRequest: null\n    });\n  }\n\n  return state;\n}\n\nvar idle = {\n  phase: 'IDLE',\n  completed: null,\n  shouldFlush: false\n};\nvar reducer = (function (state, action) {\n  if (state === void 0) {\n    state = idle;\n  }\n\n  if (action.type === 'FLUSH') {\n    return _extends({}, idle, {\n      shouldFlush: true\n    });\n  }\n\n  if (action.type === 'INITIAL_PUBLISH') {\n    !(state.phase === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INITIAL_PUBLISH must come after a IDLE phase') : invariant(false) : void 0;\n    var _action$payload = action.payload,\n        critical = _action$payload.critical,\n        clientSelection = _action$payload.clientSelection,\n        viewport = _action$payload.viewport,\n        dimensions = _action$payload.dimensions,\n        movementMode = _action$payload.movementMode;\n    var draggable = dimensions.draggables[critical.draggable.id];\n    var home = dimensions.droppables[critical.droppable.id];\n    var client = {\n      selection: clientSelection,\n      borderBoxCenter: draggable.client.borderBox.center,\n      offset: origin\n    };\n    var initial = {\n      client: client,\n      page: {\n        selection: add(client.selection, viewport.scroll.initial),\n        borderBoxCenter: add(client.selection, viewport.scroll.initial)\n      }\n    };\n    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function (item) {\n      return !item.isFixedOnPage;\n    });\n\n    var _getLiftEffect = getLiftEffect({\n      draggable: draggable,\n      home: home,\n      draggables: dimensions.draggables,\n      viewport: viewport\n    }),\n        impact = _getLiftEffect.impact,\n        afterCritical = _getLiftEffect.afterCritical;\n\n    var result = {\n      phase: 'DRAGGING',\n      isDragging: true,\n      critical: critical,\n      movementMode: movementMode,\n      dimensions: dimensions,\n      initial: initial,\n      current: initial,\n      isWindowScrollAllowed: isWindowScrollAllowed,\n      impact: impact,\n      afterCritical: afterCritical,\n      onLiftImpact: impact,\n      viewport: viewport,\n      userDirection: forward,\n      scrollJumpRequest: null,\n      forceShouldAnimate: null\n    };\n    return result;\n  }\n\n  if (action.type === 'COLLECTION_STARTING') {\n    var _extends2;\n\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Collection cannot start from phase \" + state.phase) : invariant(false) : void 0;\n\n    var _result = _extends({\n      phase: 'COLLECTING'\n    }, state, (_extends2 = {}, _extends2[\"phase\"] = 'COLLECTING', _extends2));\n\n    return _result;\n  }\n\n  if (action.type === 'PUBLISH_WHILE_DRAGGING') {\n    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Unexpected \" + action.type + \" received in phase \" + state.phase) : invariant(false) : void 0;\n    return publishWhileDraggingInVirtual({\n      state: state,\n      published: action.payload\n    });\n  }\n\n  if (action.type === 'MOVE') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : invariant(false) : void 0;\n    var _clientSelection = action.payload.client;\n\n    if (isEqual(_clientSelection, state.current.client.selection)) {\n      return state;\n    }\n\n    return update({\n      state: state,\n      clientSelection: _clientSelection,\n      impact: isSnapping(state) ? state.impact : null\n    });\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_SCROLL') {\n    if (state.phase === 'DROP_PENDING') {\n      return removeScrollJumpRequest(state);\n    }\n\n    if (state.phase === 'COLLECTING') {\n      return removeScrollJumpRequest(state);\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload2 = action.payload,\n        id = _action$payload2.id,\n        newScroll = _action$payload2.newScroll;\n    var target = state.dimensions.droppables[id];\n\n    if (!target) {\n      return state;\n    }\n\n    var scrolled = scrollDroppable(target, newScroll);\n    return postDroppableChange(state, scrolled, false);\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload3 = action.payload,\n        _id = _action$payload3.id,\n        isEnabled = _action$payload3.isEnabled;\n    var _target = state.dimensions.droppables[_id];\n    !_target ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find Droppable[id: \" + _id + \"] to toggle its enabled state\") : invariant(false) : void 0;\n    !(_target.isEnabled !== isEnabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Trying to set droppable isEnabled to \" + String(isEnabled) + \"\\n      but it is already \" + String(_target.isEnabled)) : invariant(false) : void 0;\n\n    var updated = _extends({}, _target, {\n      isEnabled: isEnabled\n    });\n\n    return postDroppableChange(state, updated, true);\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload4 = action.payload,\n        _id2 = _action$payload4.id,\n        isCombineEnabled = _action$payload4.isCombineEnabled;\n    var _target2 = state.dimensions.droppables[_id2];\n    !_target2 ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find Droppable[id: \" + _id2 + \"] to toggle its isCombineEnabled state\") : invariant(false) : void 0;\n    !(_target2.isCombineEnabled !== isCombineEnabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Trying to set droppable isCombineEnabled to \" + String(isCombineEnabled) + \"\\n      but it is already \" + String(_target2.isCombineEnabled)) : invariant(false) : void 0;\n\n    var _updated = _extends({}, _target2, {\n      isCombineEnabled: isCombineEnabled\n    });\n\n    return postDroppableChange(state, _updated, true);\n  }\n\n  if (action.type === 'MOVE_BY_WINDOW_SCROLL') {\n    if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot move by window in phase \" + state.phase) : invariant(false) : void 0;\n    !state.isWindowScrollAllowed ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Window scrolling is currently not supported for fixed lists') : invariant(false) : void 0;\n    var _newScroll = action.payload.newScroll;\n\n    if (isEqual(state.viewport.scroll.current, _newScroll)) {\n      return removeScrollJumpRequest(state);\n    }\n\n    var _viewport = scrollViewport(state.viewport, _newScroll);\n\n    if (isSnapping(state)) {\n      return refreshSnap({\n        state: state,\n        viewport: _viewport\n      });\n    }\n\n    return update({\n      state: state,\n      viewport: _viewport\n    });\n  }\n\n  if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {\n    if (!isMovementAllowed(state)) {\n      return state;\n    }\n\n    var maxScroll = action.payload.maxScroll;\n\n    if (isEqual(maxScroll, state.viewport.scroll.max)) {\n      return state;\n    }\n\n    var withMaxScroll = _extends({}, state.viewport, {\n      scroll: _extends({}, state.viewport.scroll, {\n        max: maxScroll\n      })\n    });\n\n    return _extends({\n      phase: 'DRAGGING'\n    }, state, {\n      viewport: withMaxScroll\n    });\n  }\n\n  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" received while not in DRAGGING phase\") : invariant(false) : void 0;\n\n    var _result2 = moveInDirection({\n      state: state,\n      type: action.type\n    });\n\n    if (!_result2) {\n      return state;\n    }\n\n    return update({\n      state: state,\n      impact: _result2.impact,\n      clientSelection: _result2.clientSelection,\n      scrollJumpRequest: _result2.scrollJumpRequest\n    });\n  }\n\n  if (action.type === 'DROP_PENDING') {\n    var _extends3;\n\n    var reason = action.payload.reason;\n    !(state.phase === 'COLLECTING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only move into the DROP_PENDING phase from the COLLECTING phase') : invariant(false) : void 0;\n\n    var newState = _extends({\n      phase: 'DROP_PENDING'\n    }, state, (_extends3 = {}, _extends3[\"phase\"] = 'DROP_PENDING', _extends3.isWaiting = true, _extends3.reason = reason, _extends3));\n\n    return newState;\n  }\n\n  if (action.type === 'DROP_ANIMATE') {\n    var _action$payload5 = action.payload,\n        completed = _action$payload5.completed,\n        dropDuration = _action$payload5.dropDuration,\n        newHomeClientOffset = _action$payload5.newHomeClientOffset;\n    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot animate drop from phase \" + state.phase) : invariant(false) : void 0;\n    var _result3 = {\n      phase: 'DROP_ANIMATING',\n      completed: completed,\n      dropDuration: dropDuration,\n      newHomeClientOffset: newHomeClientOffset,\n      dimensions: state.dimensions\n    };\n    return _result3;\n  }\n\n  if (action.type === 'DROP_COMPLETE') {\n    var _completed = action.payload.completed;\n    return {\n      phase: 'IDLE',\n      completed: _completed,\n      shouldFlush: false\n    };\n  }\n\n  return state;\n});\n\nvar lift = function lift(args) {\n  return {\n    type: 'LIFT',\n    payload: args\n  };\n};\nvar initialPublish = function initialPublish(args) {\n  return {\n    type: 'INITIAL_PUBLISH',\n    payload: args\n  };\n};\nvar publishWhileDragging = function publishWhileDragging(args) {\n  return {\n    type: 'PUBLISH_WHILE_DRAGGING',\n    payload: args\n  };\n};\nvar collectionStarting = function collectionStarting() {\n  return {\n    type: 'COLLECTION_STARTING',\n    payload: null\n  };\n};\nvar updateDroppableScroll = function updateDroppableScroll(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_SCROLL',\n    payload: args\n  };\n};\nvar updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_IS_ENABLED',\n    payload: args\n  };\n};\nvar updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',\n    payload: args\n  };\n};\nvar move = function move(args) {\n  return {\n    type: 'MOVE',\n    payload: args\n  };\n};\nvar moveByWindowScroll = function moveByWindowScroll(args) {\n  return {\n    type: 'MOVE_BY_WINDOW_SCROLL',\n    payload: args\n  };\n};\nvar updateViewportMaxScroll = function updateViewportMaxScroll(args) {\n  return {\n    type: 'UPDATE_VIEWPORT_MAX_SCROLL',\n    payload: args\n  };\n};\nvar moveUp = function moveUp() {\n  return {\n    type: 'MOVE_UP',\n    payload: null\n  };\n};\nvar moveDown = function moveDown() {\n  return {\n    type: 'MOVE_DOWN',\n    payload: null\n  };\n};\nvar moveRight = function moveRight() {\n  return {\n    type: 'MOVE_RIGHT',\n    payload: null\n  };\n};\nvar moveLeft = function moveLeft() {\n  return {\n    type: 'MOVE_LEFT',\n    payload: null\n  };\n};\nvar flush = function flush() {\n  return {\n    type: 'FLUSH',\n    payload: null\n  };\n};\nvar animateDrop = function animateDrop(args) {\n  return {\n    type: 'DROP_ANIMATE',\n    payload: args\n  };\n};\nvar completeDrop = function completeDrop(args) {\n  return {\n    type: 'DROP_COMPLETE',\n    payload: args\n  };\n};\nvar drop = function drop(args) {\n  return {\n    type: 'DROP',\n    payload: args\n  };\n};\nvar dropPending = function dropPending(args) {\n  return {\n    type: 'DROP_PENDING',\n    payload: args\n  };\n};\nvar dropAnimationFinished = function dropAnimationFinished() {\n  return {\n    type: 'DROP_ANIMATION_FINISHED',\n    payload: null\n  };\n};\n\nfunction checkIndexes(insideDestination) {\n  if (insideDestination.length <= 1) {\n    return;\n  }\n\n  var indexes = insideDestination.map(function (d) {\n    return d.descriptor.index;\n  });\n  var errors = {};\n\n  for (var i = 1; i < indexes.length; i++) {\n    var current = indexes[i];\n    var previous = indexes[i - 1];\n\n    if (current !== previous + 1) {\n      errors[current] = true;\n    }\n  }\n\n  if (!_Object$keys(errors).length) {\n    return;\n  }\n\n  var formatted = indexes.map(function (index) {\n    var hasError = Boolean(errors[index]);\n    return hasError ? \"[\\uD83D\\uDD25\" + index + \"]\" : \"\" + index;\n  }).join(', ');\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    Detected non-consecutive <Draggable /> indexes.\\n\\n    (This can cause unexpected bugs)\\n\\n    \" + formatted + \"\\n  \") : void 0;\n}\n\nfunction validateDimensions(critical, dimensions) {\n  if (process.env.NODE_ENV !== 'production') {\n    var insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n    checkIndexes(insideDestination);\n  }\n}\n\nvar lift$1 = (function (marshal) {\n  return function (_ref) {\n    var getState = _ref.getState,\n        dispatch = _ref.dispatch;\n    return function (next) {\n      return function (action) {\n        if (action.type !== 'LIFT') {\n          next(action);\n          return;\n        }\n\n        var _action$payload = action.payload,\n            id = _action$payload.id,\n            clientSelection = _action$payload.clientSelection,\n            movementMode = _action$payload.movementMode;\n        var initial = getState();\n\n        if (initial.phase === 'DROP_ANIMATING') {\n          dispatch(completeDrop({\n            completed: initial.completed\n          }));\n        }\n\n        !(getState().phase === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unexpected phase to start a drag') : invariant(false) : void 0;\n        dispatch(flush());\n        var scrollOptions = {\n          shouldPublishImmediately: movementMode === 'SNAP'\n        };\n        var request = {\n          draggableId: id,\n          scrollOptions: scrollOptions\n        };\n\n        var _marshal$startPublish = marshal.startPublishing(request),\n            critical = _marshal$startPublish.critical,\n            dimensions = _marshal$startPublish.dimensions,\n            viewport = _marshal$startPublish.viewport;\n\n        validateDimensions(critical, dimensions);\n        dispatch(initialPublish({\n          critical: critical,\n          dimensions: dimensions,\n          clientSelection: clientSelection,\n          movementMode: movementMode,\n          viewport: viewport\n        }));\n      };\n    };\n  };\n});\n\nvar style = (function (marshal) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          marshal.dragging();\n        }\n\n        if (action.type === 'DROP_ANIMATE') {\n          marshal.dropping(action.payload.completed.result.reason);\n        }\n\n        if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE') {\n          marshal.resting();\n        }\n\n        next(action);\n      };\n    };\n  };\n});\n\nvar curves = {\n  outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',\n  drop: 'cubic-bezier(.2,1,.1,1)'\n};\nvar combine = {\n  opacity: {\n    drop: 0,\n    combining: 0.7\n  },\n  scale: {\n    drop: 0.75\n  }\n};\nvar timings = {\n  outOfTheWay: 0.2,\n  minDropTime: 0.33,\n  maxDropTime: 0.55\n};\nvar outOfTheWayTiming = timings.outOfTheWay + \"s \" + curves.outOfTheWay;\nvar transitions = {\n  fluid: \"opacity \" + outOfTheWayTiming,\n  snap: \"transform \" + outOfTheWayTiming + \", opacity \" + outOfTheWayTiming,\n  drop: function drop(duration) {\n    var timing = duration + \"s \" + curves.drop;\n    return \"transform \" + timing + \", opacity \" + timing;\n  },\n  outOfTheWay: \"transform \" + outOfTheWayTiming,\n  placeholder: \"height \" + outOfTheWayTiming + \", width \" + outOfTheWayTiming + \", margin \" + outOfTheWayTiming\n};\n\nvar moveTo = function moveTo(offset) {\n  return isEqual(offset, origin) ? null : \"translate(\" + offset.x + \"px, \" + offset.y + \"px)\";\n};\n\nvar transforms = {\n  moveTo: moveTo,\n  drop: function drop(offset, isCombining) {\n    var translate = moveTo(offset);\n\n    if (!translate) {\n      return null;\n    }\n\n    if (!isCombining) {\n      return translate;\n    }\n\n    return translate + \" scale(\" + combine.scale.drop + \")\";\n  }\n};\n\nvar minDropTime = timings.minDropTime,\n    maxDropTime = timings.maxDropTime;\nvar dropTimeRange = maxDropTime - minDropTime;\nvar maxDropTimeAtDistance = 1500;\nvar cancelDropModifier = 0.6;\nvar getDropDuration = (function (_ref) {\n  var current = _ref.current,\n      destination = _ref.destination,\n      reason = _ref.reason;\n  var distance$1 = distance(current, destination);\n\n  if (distance$1 <= 0) {\n    return minDropTime;\n  }\n\n  if (distance$1 >= maxDropTimeAtDistance) {\n    return maxDropTime;\n  }\n\n  var percentage = distance$1 / maxDropTimeAtDistance;\n  var duration = minDropTime + dropTimeRange * percentage;\n  var withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;\n  return Number(withDuration.toFixed(2));\n});\n\nvar getNewHomeClientOffset = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      dimensions = _ref.dimensions,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var draggables = dimensions.draggables,\n      droppables = dimensions.droppables;\n  var droppableId = whatIsDraggedOver(impact);\n  var destination = droppableId ? droppables[droppableId] : null;\n  var home = droppables[draggable.descriptor.droppableId];\n  var newClientCenter = getClientBorderBoxCenter({\n    impact: impact,\n    draggable: draggable,\n    draggables: draggables,\n    afterCritical: afterCritical,\n    droppable: destination || home,\n    viewport: viewport\n  });\n  var offset = subtract(newClientCenter, draggable.client.borderBox.center);\n  return offset;\n});\n\nvar getDropImpact = (function (_ref) {\n  var draggables = _ref.draggables,\n      reason = _ref.reason,\n      lastImpact = _ref.lastImpact,\n      home = _ref.home,\n      viewport = _ref.viewport,\n      onLiftImpact = _ref.onLiftImpact;\n\n  if (!lastImpact.at || reason !== 'DROP') {\n    var recomputedHomeImpact = recompute({\n      draggables: draggables,\n      impact: onLiftImpact,\n      destination: home,\n      viewport: viewport,\n      forceShouldAnimate: true\n    });\n    return {\n      impact: recomputedHomeImpact,\n      didDropInsideDroppable: false\n    };\n  }\n\n  if (lastImpact.at.type === 'REORDER') {\n    return {\n      impact: lastImpact,\n      didDropInsideDroppable: true\n    };\n  }\n\n  var withoutMovement = _extends({}, lastImpact, {\n    displaced: emptyGroups\n  });\n\n  return {\n    impact: withoutMovement,\n    didDropInsideDroppable: true\n  };\n});\n\nvar drop$1 = (function (_ref) {\n  var getState = _ref.getState,\n      dispatch = _ref.dispatch;\n  return function (next) {\n    return function (action) {\n      if (action.type !== 'DROP') {\n        next(action);\n        return;\n      }\n\n      var state = getState();\n      var reason = action.payload.reason;\n\n      if (state.phase === 'COLLECTING') {\n        dispatch(dropPending({\n          reason: reason\n        }));\n        return;\n      }\n\n      if (state.phase === 'IDLE') {\n        return;\n      }\n\n      var isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;\n      !!isWaitingForDrop ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : invariant(false) : void 0;\n      !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot drop in phase: \" + state.phase) : invariant(false) : void 0;\n      var critical = state.critical;\n      var dimensions = state.dimensions;\n      var draggable = dimensions.draggables[state.critical.draggable.id];\n\n      var _getDropImpact = getDropImpact({\n        reason: reason,\n        lastImpact: state.impact,\n        afterCritical: state.afterCritical,\n        onLiftImpact: state.onLiftImpact,\n        home: state.dimensions.droppables[state.critical.droppable.id],\n        viewport: state.viewport,\n        draggables: state.dimensions.draggables\n      }),\n          impact = _getDropImpact.impact,\n          didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;\n\n      var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n      var combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n      var source = {\n        index: critical.draggable.index,\n        droppableId: critical.droppable.id\n      };\n      var result = {\n        draggableId: draggable.descriptor.id,\n        type: draggable.descriptor.type,\n        source: source,\n        reason: reason,\n        mode: state.movementMode,\n        destination: destination,\n        combine: combine\n      };\n      var newHomeClientOffset = getNewHomeClientOffset({\n        impact: impact,\n        draggable: draggable,\n        dimensions: dimensions,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n      });\n      var completed = {\n        critical: state.critical,\n        afterCritical: state.afterCritical,\n        result: result,\n        impact: impact\n      };\n      var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n\n      if (!isAnimationRequired) {\n        dispatch(completeDrop({\n          completed: completed\n        }));\n        return;\n      }\n\n      var dropDuration = getDropDuration({\n        current: state.current.client.offset,\n        destination: newHomeClientOffset,\n        reason: reason\n      });\n      var args = {\n        newHomeClientOffset: newHomeClientOffset,\n        dropDuration: dropDuration,\n        completed: completed\n      };\n      dispatch(animateDrop(args));\n    };\n  };\n});\n\nvar getWindowScroll = (function () {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset\n  };\n});\n\nfunction getWindowScrollBinding(update) {\n  return {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: function fn(event) {\n      if (event.target !== window && event.target !== window.document) {\n        return;\n      }\n\n      update();\n    }\n  };\n}\n\nfunction getScrollListener(_ref) {\n  var onWindowScroll = _ref.onWindowScroll;\n\n  function updateScroll() {\n    onWindowScroll(getWindowScroll());\n  }\n\n  var scheduled = rafSchd(updateScroll);\n  var binding = getWindowScrollBinding(scheduled);\n  var unbind = noop;\n\n  function isActive() {\n    return unbind !== noop;\n  }\n\n  function start() {\n    !!isActive() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start scroll listener when already active') : invariant(false) : void 0;\n    unbind = bindEvents(window, [binding]);\n  }\n\n  function stop() {\n    !isActive() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot stop scroll listener when not active') : invariant(false) : void 0;\n    scheduled.cancel();\n    unbind();\n    unbind = noop;\n  }\n\n  return {\n    start: start,\n    stop: stop,\n    isActive: isActive\n  };\n}\n\nvar shouldEnd = function shouldEnd(action) {\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';\n};\n\nvar scrollListener = (function (store) {\n  var listener = getScrollListener({\n    onWindowScroll: function onWindowScroll(newScroll) {\n      store.dispatch(moveByWindowScroll({\n        newScroll: newScroll\n      }));\n    }\n  });\n  return function (next) {\n    return function (action) {\n      if (!listener.isActive() && action.type === 'INITIAL_PUBLISH') {\n        listener.start();\n      }\n\n      if (listener.isActive() && shouldEnd(action)) {\n        listener.stop();\n      }\n\n      next(action);\n    };\n  };\n});\n\nvar getExpiringAnnounce = (function (announce) {\n  var wasCalled = false;\n  var isExpired = false;\n  var timeoutId = setTimeout(function () {\n    isExpired = true;\n  });\n\n  var result = function result(message) {\n    if (wasCalled) {\n      process.env.NODE_ENV !== \"production\" ? warning('Announcement already made. Not making a second announcement') : void 0;\n      return;\n    }\n\n    if (isExpired) {\n      process.env.NODE_ENV !== \"production\" ? warning(\"\\n        Announcements cannot be made asynchronously.\\n        Default message has already been announced.\\n      \") : void 0;\n      return;\n    }\n\n    wasCalled = true;\n    announce(message);\n    clearTimeout(timeoutId);\n  };\n\n  result.wasCalled = function () {\n    return wasCalled;\n  };\n\n  return result;\n});\n\nvar getAsyncMarshal = (function () {\n  var entries = [];\n\n  var execute = function execute(timerId) {\n    var index = findIndex(entries, function (item) {\n      return item.timerId === timerId;\n    });\n    !(index !== -1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find timer') : invariant(false) : void 0;\n\n    var _entries$splice = entries.splice(index, 1),\n        entry = _entries$splice[0];\n\n    entry.callback();\n  };\n\n  var add = function add(fn) {\n    var timerId = setTimeout(function () {\n      return execute(timerId);\n    });\n    var entry = {\n      timerId: timerId,\n      callback: fn\n    };\n    entries.push(entry);\n  };\n\n  var flush = function flush() {\n    if (!entries.length) {\n      return;\n    }\n\n    var shallow = [].concat(entries);\n    entries.length = 0;\n    shallow.forEach(function (entry) {\n      clearTimeout(entry.timerId);\n      entry.callback();\n    });\n  };\n\n  return {\n    add: add,\n    flush: flush\n  };\n});\n\nvar areLocationsEqual = function areLocationsEqual(first, second) {\n  if (first == null && second == null) {\n    return true;\n  }\n\n  if (first == null || second == null) {\n    return false;\n  }\n\n  return first.droppableId === second.droppableId && first.index === second.index;\n};\nvar isCombineEqual = function isCombineEqual(first, second) {\n  if (first == null && second == null) {\n    return true;\n  }\n\n  if (first == null || second == null) {\n    return false;\n  }\n\n  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nvar isCriticalEqual = function isCriticalEqual(first, second) {\n  if (first === second) {\n    return true;\n  }\n\n  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n  return isDraggableEqual && isDroppableEqual;\n};\n\nvar withTimings = function withTimings(key, fn) {\n  start(key);\n  fn();\n  finish(key);\n};\n\nvar getDragStart = function getDragStart(critical, mode) {\n  return {\n    draggableId: critical.draggable.id,\n    type: critical.droppable.type,\n    source: {\n      droppableId: critical.droppable.id,\n      index: critical.draggable.index\n    },\n    mode: mode\n  };\n};\n\nvar execute = function execute(responder, data, announce, getDefaultMessage) {\n  if (!responder) {\n    announce(getDefaultMessage(data));\n    return;\n  }\n\n  var willExpire = getExpiringAnnounce(announce);\n  var provided = {\n    announce: willExpire\n  };\n  responder(data, provided);\n\n  if (!willExpire.wasCalled()) {\n    announce(getDefaultMessage(data));\n  }\n};\n\nvar getPublisher = (function (getResponders, announce) {\n  var asyncMarshal = getAsyncMarshal();\n  var dragging = null;\n\n  var beforeStart = function beforeStart(critical, mode) {\n    !!dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\n    withTimings('onBeforeDragStart', function () {\n      var fn = getResponders().onBeforeDragStart;\n\n      if (fn) {\n        fn(getDragStart(critical, mode));\n      }\n    });\n  };\n\n  var start = function start(critical, mode) {\n    !!dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\n    var data = getDragStart(critical, mode);\n    dragging = {\n      mode: mode,\n      lastCritical: critical,\n      lastLocation: data.source,\n      lastCombine: null\n    };\n    asyncMarshal.add(function () {\n      withTimings('onDragStart', function () {\n        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);\n      });\n    });\n  };\n\n  var update = function update(critical, impact) {\n    var location = tryGetDestination(impact);\n    var combine = tryGetCombine(impact);\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : invariant(false) : void 0;\n    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n\n    if (hasCriticalChanged) {\n      dragging.lastCritical = critical;\n    }\n\n    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n\n    if (hasLocationChanged) {\n      dragging.lastLocation = location;\n    }\n\n    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n\n    if (hasGroupingChanged) {\n      dragging.lastCombine = combine;\n    }\n\n    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n      return;\n    }\n\n    var data = _extends({}, getDragStart(critical, dragging.mode), {\n      combine: combine,\n      destination: location\n    });\n\n    asyncMarshal.add(function () {\n      withTimings('onDragUpdate', function () {\n        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);\n      });\n    });\n  };\n\n  var flush = function flush() {\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only flush responders while dragging') : invariant(false) : void 0;\n    asyncMarshal.flush();\n  };\n\n  var drop = function drop(result) {\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onDragEnd when there is no matching onDragStart') : invariant(false) : void 0;\n    dragging = null;\n    withTimings('onDragEnd', function () {\n      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);\n    });\n  };\n\n  var abort = function abort() {\n    if (!dragging) {\n      return;\n    }\n\n    var result = _extends({}, getDragStart(dragging.lastCritical, dragging.mode), {\n      combine: null,\n      destination: null,\n      reason: 'CANCEL'\n    });\n\n    drop(result);\n  };\n\n  return {\n    beforeStart: beforeStart,\n    start: start,\n    update: update,\n    flush: flush,\n    drop: drop,\n    abort: abort\n  };\n});\n\nvar responders = (function (getResponders, announce) {\n  var publisher = getPublisher(getResponders, announce);\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          var critical = action.payload.critical;\n          publisher.beforeStart(critical, action.payload.movementMode);\n          next(action);\n          publisher.start(critical, action.payload.movementMode);\n          return;\n        }\n\n        if (action.type === 'DROP_COMPLETE') {\n          var result = action.payload.completed.result;\n          publisher.flush();\n          next(action);\n          publisher.drop(result);\n          return;\n        }\n\n        next(action);\n\n        if (action.type === 'FLUSH') {\n          publisher.abort();\n          return;\n        }\n\n        var state = store.getState();\n\n        if (state.phase === 'DRAGGING') {\n          publisher.update(state.critical, state.impact);\n        }\n      };\n    };\n  };\n});\n\nvar dropAnimationFinish = (function (store) {\n  return function (next) {\n    return function (action) {\n      if (action.type !== 'DROP_ANIMATION_FINISHED') {\n        next(action);\n        return;\n      }\n\n      var state = store.getState();\n      !(state.phase === 'DROP_ANIMATING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot finish a drop animating when no drop is occurring') : invariant(false) : void 0;\n      store.dispatch(completeDrop({\n        completed: state.completed\n      }));\n    };\n  };\n});\n\nvar dropAnimationFlushOnScroll = (function (store) {\n  var unbind = null;\n  var frameId = null;\n\n  function clear() {\n    if (frameId) {\n      cancelAnimationFrame(frameId);\n      frameId = null;\n    }\n\n    if (unbind) {\n      unbind();\n      unbind = null;\n    }\n  }\n\n  return function (next) {\n    return function (action) {\n      if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATION_FINISHED') {\n        clear();\n      }\n\n      next(action);\n\n      if (action.type !== 'DROP_ANIMATE') {\n        return;\n      }\n\n      var binding = {\n        eventName: 'scroll',\n        options: {\n          capture: true,\n          passive: false,\n          once: true\n        },\n        fn: function flushDropAnimation() {\n          var state = store.getState();\n\n          if (state.phase === 'DROP_ANIMATING') {\n            store.dispatch(dropAnimationFinished());\n          }\n        }\n      };\n      frameId = requestAnimationFrame(function () {\n        frameId = null;\n        unbind = bindEvents(window, [binding]);\n      });\n    };\n  };\n});\n\nvar dimensionMarshalStopper = (function (marshal) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' || action.type === 'DROP_ANIMATE') {\n          marshal.stopPublishing();\n        }\n\n        next(action);\n      };\n    };\n  };\n});\n\nvar focus = (function (marshal) {\n  var isWatching = false;\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          isWatching = true;\n          marshal.tryRecordFocus(action.payload.critical.draggable.id);\n          next(action);\n          marshal.tryRestoreFocusRecorded();\n          return;\n        }\n\n        next(action);\n\n        if (!isWatching) {\n          return;\n        }\n\n        if (action.type === 'FLUSH') {\n          isWatching = false;\n          marshal.tryRestoreFocusRecorded();\n          return;\n        }\n\n        if (action.type === 'DROP_COMPLETE') {\n          isWatching = false;\n          var result = action.payload.completed.result;\n\n          if (result.combine) {\n            marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n          }\n\n          marshal.tryRestoreFocusRecorded();\n        }\n      };\n    };\n  };\n});\n\nvar shouldStop = function shouldStop(action) {\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';\n};\n\nvar autoScroll = (function (autoScroller) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (shouldStop(action)) {\n          autoScroller.stop();\n          next(action);\n          return;\n        }\n\n        if (action.type === 'INITIAL_PUBLISH') {\n          next(action);\n          var state = store.getState();\n          !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected phase to be DRAGGING after INITIAL_PUBLISH') : invariant(false) : void 0;\n          autoScroller.start(state);\n          return;\n        }\n\n        next(action);\n        autoScroller.scroll(store.getState());\n      };\n    };\n  };\n});\n\nvar pendingDrop = (function (store) {\n  return function (next) {\n    return function (action) {\n      next(action);\n\n      if (action.type !== 'PUBLISH_WHILE_DRAGGING') {\n        return;\n      }\n\n      var postActionState = store.getState();\n\n      if (postActionState.phase !== 'DROP_PENDING') {\n        return;\n      }\n\n      if (postActionState.isWaiting) {\n        return;\n      }\n\n      store.dispatch(drop({\n        reason: postActionState.reason\n      }));\n    };\n  };\n});\n\nvar composeEnhancers = process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : redux.compose;\nvar createStore = (function (_ref) {\n  var dimensionMarshal = _ref.dimensionMarshal,\n      focusMarshal = _ref.focusMarshal,\n      styleMarshal = _ref.styleMarshal,\n      getResponders = _ref.getResponders,\n      announce = _ref.announce,\n      autoScroller = _ref.autoScroller;\n  return redux.createStore(reducer, composeEnhancers(redux.applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\n});\n\nvar clean$1 = function clean() {\n  return {\n    additions: {},\n    removals: {},\n    modified: {}\n  };\n};\n\nvar timingKey = 'Publish collection from DOM';\nfunction createPublisher(_ref) {\n  var registry = _ref.registry,\n      callbacks = _ref.callbacks;\n  var staging = clean$1();\n  var frameId = null;\n\n  var collect = function collect() {\n    if (frameId) {\n      return;\n    }\n\n    callbacks.collectionStarting();\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      start(timingKey);\n      var _staging = staging,\n          additions = _staging.additions,\n          removals = _staging.removals,\n          modified = _staging.modified;\n\n      var added = _Object$keys(additions).map(function (id) {\n        return registry.draggable.getById(id).getDimension(origin);\n      }).sort(function (a, b) {\n        return a.descriptor.index - b.descriptor.index;\n      });\n\n      var updated = _Object$keys(modified).map(function (id) {\n        var entry = registry.droppable.getById(id);\n        var scroll = entry.callbacks.getScrollWhileDragging();\n        return {\n          droppableId: id,\n          scroll: scroll\n        };\n      });\n\n      var result = {\n        additions: added,\n        removals: _Object$keys(removals),\n        modified: updated\n      };\n      staging = clean$1();\n      finish(timingKey);\n      callbacks.publish(result);\n    });\n  };\n\n  var add = function add(entry) {\n    var id = entry.descriptor.id;\n    staging.additions[id] = entry;\n    staging.modified[entry.descriptor.droppableId] = true;\n\n    if (staging.removals[id]) {\n      delete staging.removals[id];\n    }\n\n    collect();\n  };\n\n  var remove = function remove(entry) {\n    var descriptor = entry.descriptor;\n    staging.removals[descriptor.id] = true;\n    staging.modified[descriptor.droppableId] = true;\n\n    if (staging.additions[descriptor.id]) {\n      delete staging.additions[descriptor.id];\n    }\n\n    collect();\n  };\n\n  var stop = function stop() {\n    if (!frameId) {\n      return;\n    }\n\n    cancelAnimationFrame(frameId);\n    frameId = null;\n    staging = clean$1();\n  };\n\n  return {\n    add: add,\n    remove: remove,\n    stop: stop\n  };\n}\n\nvar getMaxScroll = (function (_ref) {\n  var scrollHeight = _ref.scrollHeight,\n      scrollWidth = _ref.scrollWidth,\n      height = _ref.height,\n      width = _ref.width;\n  var maxScroll = subtract({\n    x: scrollWidth,\n    y: scrollHeight\n  }, {\n    x: width,\n    y: height\n  });\n  var adjustedMaxScroll = {\n    x: Math.max(0, maxScroll.x),\n    y: Math.max(0, maxScroll.y)\n  };\n  return adjustedMaxScroll;\n});\n\nvar getDocumentElement = (function () {\n  var doc = document.documentElement;\n  !doc ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find document.documentElement') : invariant(false) : void 0;\n  return doc;\n});\n\nvar getMaxWindowScroll = (function () {\n  var doc = getDocumentElement();\n  var maxScroll = getMaxScroll({\n    scrollHeight: doc.scrollHeight,\n    scrollWidth: doc.scrollWidth,\n    width: doc.clientWidth,\n    height: doc.clientHeight\n  });\n  return maxScroll;\n});\n\nvar getViewport = (function () {\n  var scroll = getWindowScroll();\n  var maxScroll = getMaxWindowScroll();\n  var top = scroll.y;\n  var left = scroll.x;\n  var doc = getDocumentElement();\n  var width = doc.clientWidth;\n  var height = doc.clientHeight;\n  var right = left + width;\n  var bottom = top + height;\n  var frame = cssBoxModel.getRect({\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom\n  });\n  var viewport = {\n    frame: frame,\n    scroll: {\n      initial: scroll,\n      current: scroll,\n      max: maxScroll,\n      diff: {\n        value: origin,\n        displacement: origin\n      }\n    }\n  };\n  return viewport;\n});\n\nvar getInitialPublish = (function (_ref) {\n  var critical = _ref.critical,\n      scrollOptions = _ref.scrollOptions,\n      registry = _ref.registry;\n  var timingKey = 'Initial collection from DOM';\n  start(timingKey);\n  var viewport = getViewport();\n  var windowScroll = viewport.scroll.current;\n  var home = critical.droppable;\n  var droppables = registry.droppable.getAllByType(home.type).map(function (entry) {\n    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);\n  });\n  var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function (entry) {\n    return entry.getDimension(windowScroll);\n  });\n  var dimensions = {\n    draggables: toDraggableMap(draggables),\n    droppables: toDroppableMap(droppables)\n  };\n  finish(timingKey);\n  var result = {\n    dimensions: dimensions,\n    critical: critical,\n    viewport: viewport\n  };\n  return result;\n});\n\nfunction shouldPublishUpdate(registry, dragging, entry) {\n  if (entry.descriptor.id === dragging.id) {\n    return false;\n  }\n\n  if (entry.descriptor.type !== dragging.type) {\n    return false;\n  }\n\n  var home = registry.droppable.getById(entry.descriptor.droppableId);\n\n  if (home.descriptor.mode !== 'virtual') {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      You are attempting to add or remove a Draggable [id: \" + entry.descriptor.id + \"]\\n      while a drag is occurring. This is only supported for virtual lists.\\n\\n      See https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/patterns/virtual-lists.md\\n    \") : void 0;\n    return false;\n  }\n\n  return true;\n}\n\nvar createDimensionMarshal = (function (registry, callbacks) {\n  var collection = null;\n  var publisher = createPublisher({\n    callbacks: {\n      publish: callbacks.publishWhileDragging,\n      collectionStarting: callbacks.collectionStarting\n    },\n    registry: registry\n  });\n\n  var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update is enabled flag of Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (!collection) {\n      return;\n    }\n\n    callbacks.updateDroppableIsEnabled({\n      id: id,\n      isEnabled: isEnabled\n    });\n  };\n\n  var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(id, isCombineEnabled) {\n    if (!collection) {\n      return;\n    }\n\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update isCombineEnabled flag of Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n    callbacks.updateDroppableIsCombineEnabled({\n      id: id,\n      isCombineEnabled: isCombineEnabled\n    });\n  };\n\n  var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {\n    if (!collection) {\n      return;\n    }\n\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update the scroll on Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n    callbacks.updateDroppableScroll({\n      id: id,\n      newScroll: newScroll\n    });\n  };\n\n  var scrollDroppable = function scrollDroppable(id, change) {\n    if (!collection) {\n      return;\n    }\n\n    registry.droppable.getById(id).callbacks.scroll(change);\n  };\n\n  var stopPublishing = function stopPublishing() {\n    if (!collection) {\n      return;\n    }\n\n    publisher.stop();\n    var home = collection.critical.droppable;\n    registry.droppable.getAllByType(home.type).forEach(function (entry) {\n      return entry.callbacks.dragStopped();\n    });\n    collection.unsubscribe();\n    collection = null;\n  };\n\n  var subscriber = function subscriber(event) {\n    !collection ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should only be subscribed when a collection is occurring') : invariant(false) : void 0;\n    var dragging = collection.critical.draggable;\n\n    if (event.type === 'ADDITION') {\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\n        publisher.add(event.value);\n      }\n    }\n\n    if (event.type === 'REMOVAL') {\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\n        publisher.remove(event.value);\n      }\n    }\n  };\n\n  var startPublishing = function startPublishing(request) {\n    !!collection ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start capturing critical dimensions as there is already a collection') : invariant(false) : void 0;\n    var entry = registry.draggable.getById(request.draggableId);\n    var home = registry.droppable.getById(entry.descriptor.droppableId);\n    var critical = {\n      draggable: entry.descriptor,\n      droppable: home.descriptor\n    };\n    var unsubscribe = registry.subscribe(subscriber);\n    collection = {\n      critical: critical,\n      unsubscribe: unsubscribe\n    };\n    return getInitialPublish({\n      critical: critical,\n      registry: registry,\n      scrollOptions: request.scrollOptions\n    });\n  };\n\n  var marshal = {\n    updateDroppableIsEnabled: updateDroppableIsEnabled,\n    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n    scrollDroppable: scrollDroppable,\n    updateDroppableScroll: updateDroppableScroll,\n    startPublishing: startPublishing,\n    stopPublishing: stopPublishing\n  };\n  return marshal;\n});\n\nvar canStartDrag = (function (state, id) {\n  if (state.phase === 'IDLE') {\n    return true;\n  }\n\n  if (state.phase !== 'DROP_ANIMATING') {\n    return false;\n  }\n\n  if (state.completed.result.draggableId === id) {\n    return false;\n  }\n\n  return state.completed.result.reason === 'DROP';\n});\n\nvar scrollWindow = (function (change) {\n  window.scrollBy(change.x, change.y);\n});\n\nvar getScrollableDroppables = memoizeOne(function (droppables) {\n  return toDroppableList(droppables).filter(function (droppable) {\n    if (!droppable.isEnabled) {\n      return false;\n    }\n\n    if (!droppable.frame) {\n      return false;\n    }\n\n    return true;\n  });\n});\n\nvar getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {\n  var maybe = find(getScrollableDroppables(droppables), function (droppable) {\n    !droppable.frame ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid result') : invariant(false) : void 0;\n    return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n  });\n  return maybe;\n};\n\nvar getBestScrollableDroppable = (function (_ref) {\n  var center = _ref.center,\n      destination = _ref.destination,\n      droppables = _ref.droppables;\n\n  if (destination) {\n    var _dimension = droppables[destination];\n\n    if (!_dimension.frame) {\n      return null;\n    }\n\n    return _dimension;\n  }\n\n  var dimension = getScrollableDroppableOver(center, droppables);\n  return dimension;\n});\n\nvar config = {\n  startFromPercentage: 0.25,\n  maxScrollAtPercentage: 0.05,\n  maxPixelScroll: 28,\n  ease: function ease(percentage) {\n    return Math.pow(percentage, 2);\n  },\n  durationDampening: {\n    stopDampeningAt: 1200,\n    accelerateAt: 360\n  }\n};\n\nvar getDistanceThresholds = (function (container, axis) {\n  var startScrollingFrom = container[axis.size] * config.startFromPercentage;\n  var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;\n  var thresholds = {\n    startScrollingFrom: startScrollingFrom,\n    maxScrollValueAt: maxScrollValueAt\n  };\n  return thresholds;\n});\n\nvar getPercentage = (function (_ref) {\n  var startOfRange = _ref.startOfRange,\n      endOfRange = _ref.endOfRange,\n      current = _ref.current;\n  var range = endOfRange - startOfRange;\n\n  if (range === 0) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Detected distance range of 0 in the fluid auto scroller\\n      This is unexpected and would cause a divide by 0 issue.\\n      Not allowing an auto scroll\\n    \") : void 0;\n    return 0;\n  }\n\n  var currentInRange = current - startOfRange;\n  var percentage = currentInRange / range;\n  return percentage;\n});\n\nvar minScroll = 1;\n\nvar getValueFromDistance = (function (distanceToEdge, thresholds) {\n  if (distanceToEdge > thresholds.startScrollingFrom) {\n    return 0;\n  }\n\n  if (distanceToEdge <= thresholds.maxScrollValueAt) {\n    return config.maxPixelScroll;\n  }\n\n  if (distanceToEdge === thresholds.startScrollingFrom) {\n    return minScroll;\n  }\n\n  var percentageFromMaxScrollValueAt = getPercentage({\n    startOfRange: thresholds.maxScrollValueAt,\n    endOfRange: thresholds.startScrollingFrom,\n    current: distanceToEdge\n  });\n  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n  var scroll = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);\n  return Math.ceil(scroll);\n});\n\nvar accelerateAt = config.durationDampening.accelerateAt;\nvar stopAt = config.durationDampening.stopDampeningAt;\nvar dampenValueByTime = (function (proposedScroll, dragStartTime) {\n  var startOfRange = dragStartTime;\n  var endOfRange = stopAt;\n\n  var now = _Date$now();\n\n  var runTime = now - startOfRange;\n\n  if (runTime >= stopAt) {\n    return proposedScroll;\n  }\n\n  if (runTime < accelerateAt) {\n    return minScroll;\n  }\n\n  var betweenAccelerateAtAndStopAtPercentage = getPercentage({\n    startOfRange: accelerateAt,\n    endOfRange: endOfRange,\n    current: runTime\n  });\n  var scroll = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);\n  return Math.ceil(scroll);\n});\n\nvar getValue = (function (_ref) {\n  var distanceToEdge = _ref.distanceToEdge,\n      thresholds = _ref.thresholds,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var scroll = getValueFromDistance(distanceToEdge, thresholds);\n\n  if (scroll === 0) {\n    return 0;\n  }\n\n  if (!shouldUseTimeDampening) {\n    return scroll;\n  }\n\n  return Math.max(dampenValueByTime(scroll, dragStartTime), minScroll);\n});\n\nvar getScrollOnAxis = (function (_ref) {\n  var container = _ref.container,\n      distanceToEdges = _ref.distanceToEdges,\n      dragStartTime = _ref.dragStartTime,\n      axis = _ref.axis,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var thresholds = getDistanceThresholds(container, axis);\n  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n\n  if (isCloserToEnd) {\n    return getValue({\n      distanceToEdge: distanceToEdges[axis.end],\n      thresholds: thresholds,\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n  }\n\n  return -1 * getValue({\n    distanceToEdge: distanceToEdges[axis.start],\n    thresholds: thresholds,\n    dragStartTime: dragStartTime,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n});\n\nvar adjustForSizeLimits = (function (_ref) {\n  var container = _ref.container,\n      subject = _ref.subject,\n      proposedScroll = _ref.proposedScroll;\n  var isTooBigVertically = subject.height > container.height;\n  var isTooBigHorizontally = subject.width > container.width;\n\n  if (!isTooBigHorizontally && !isTooBigVertically) {\n    return proposedScroll;\n  }\n\n  if (isTooBigHorizontally && isTooBigVertically) {\n    return null;\n  }\n\n  return {\n    x: isTooBigHorizontally ? 0 : proposedScroll.x,\n    y: isTooBigVertically ? 0 : proposedScroll.y\n  };\n});\n\nvar clean$2 = apply(function (value) {\n  return value === 0 ? 0 : value;\n});\nvar getScroll = (function (_ref) {\n  var dragStartTime = _ref.dragStartTime,\n      container = _ref.container,\n      subject = _ref.subject,\n      center = _ref.center,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var distanceToEdges = {\n    top: center.y - container.top,\n    right: container.right - center.x,\n    bottom: container.bottom - center.y,\n    left: center.x - container.left\n  };\n  var y = getScrollOnAxis({\n    container: container,\n    distanceToEdges: distanceToEdges,\n    dragStartTime: dragStartTime,\n    axis: vertical,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  var x = getScrollOnAxis({\n    container: container,\n    distanceToEdges: distanceToEdges,\n    dragStartTime: dragStartTime,\n    axis: horizontal,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  var required = clean$2({\n    x: x,\n    y: y\n  });\n\n  if (isEqual(required, origin)) {\n    return null;\n  }\n\n  var limited = adjustForSizeLimits({\n    container: container,\n    subject: subject,\n    proposedScroll: required\n  });\n\n  if (!limited) {\n    return null;\n  }\n\n  return isEqual(limited, origin) ? null : limited;\n});\n\nvar smallestSigned = apply(function (value) {\n  if (value === 0) {\n    return 0;\n  }\n\n  return value > 0 ? 1 : -1;\n});\nvar getOverlap = function () {\n  var getRemainder = function getRemainder(target, max) {\n    if (target < 0) {\n      return target;\n    }\n\n    if (target > max) {\n      return target - max;\n    }\n\n    return 0;\n  };\n\n  return function (_ref) {\n    var current = _ref.current,\n        max = _ref.max,\n        change = _ref.change;\n    var targetScroll = add(current, change);\n    var overlap = {\n      x: getRemainder(targetScroll.x, max.x),\n      y: getRemainder(targetScroll.y, max.y)\n    };\n\n    if (isEqual(overlap, origin)) {\n      return null;\n    }\n\n    return overlap;\n  };\n}();\nvar canPartiallyScroll = function canPartiallyScroll(_ref2) {\n  var rawMax = _ref2.max,\n      current = _ref2.current,\n      change = _ref2.change;\n  var max = {\n    x: Math.max(current.x, rawMax.x),\n    y: Math.max(current.y, rawMax.y)\n  };\n  var smallestChange = smallestSigned(change);\n  var overlap = getOverlap({\n    max: max,\n    current: current,\n    change: smallestChange\n  });\n\n  if (!overlap) {\n    return true;\n  }\n\n  if (smallestChange.x !== 0 && overlap.x === 0) {\n    return true;\n  }\n\n  if (smallestChange.y !== 0 && overlap.y === 0) {\n    return true;\n  }\n\n  return false;\n};\nvar canScrollWindow = function canScrollWindow(viewport, change) {\n  return canPartiallyScroll({\n    current: viewport.scroll.current,\n    max: viewport.scroll.max,\n    change: change\n  });\n};\nvar getWindowOverlap = function getWindowOverlap(viewport, change) {\n  if (!canScrollWindow(viewport, change)) {\n    return null;\n  }\n\n  var max = viewport.scroll.max;\n  var current = viewport.scroll.current;\n  return getOverlap({\n    current: current,\n    max: max,\n    change: change\n  });\n};\nvar canScrollDroppable = function canScrollDroppable(droppable, change) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return false;\n  }\n\n  return canPartiallyScroll({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change: change\n  });\n};\nvar getDroppableOverlap = function getDroppableOverlap(droppable, change) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return null;\n  }\n\n  if (!canScrollDroppable(droppable, change)) {\n    return null;\n  }\n\n  return getOverlap({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change: change\n  });\n};\n\nvar getWindowScrollChange = (function (_ref) {\n  var viewport = _ref.viewport,\n      subject = _ref.subject,\n      center = _ref.center,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var scroll = getScroll({\n    dragStartTime: dragStartTime,\n    container: viewport.frame,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n});\n\nvar getDroppableScrollChange = (function (_ref) {\n  var droppable = _ref.droppable,\n      subject = _ref.subject,\n      center = _ref.center,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return null;\n  }\n\n  var scroll = getScroll({\n    dragStartTime: dragStartTime,\n    container: frame.pageMarginBox,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n});\n\nvar scroll$1 = (function (_ref) {\n  var state = _ref.state,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening,\n      scrollWindow = _ref.scrollWindow,\n      scrollDroppable = _ref.scrollDroppable;\n  var center = state.current.page.borderBoxCenter;\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\n  var subject = draggable.page.marginBox;\n\n  if (state.isWindowScrollAllowed) {\n    var viewport = state.viewport;\n\n    var _change = getWindowScrollChange({\n      dragStartTime: dragStartTime,\n      viewport: viewport,\n      subject: subject,\n      center: center,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n\n    if (_change) {\n      scrollWindow(_change);\n      return;\n    }\n  }\n\n  var droppable = getBestScrollableDroppable({\n    center: center,\n    destination: whatIsDraggedOver(state.impact),\n    droppables: state.dimensions.droppables\n  });\n\n  if (!droppable) {\n    return;\n  }\n\n  var change = getDroppableScrollChange({\n    dragStartTime: dragStartTime,\n    droppable: droppable,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n\n  if (change) {\n    scrollDroppable(droppable.descriptor.id, change);\n  }\n});\n\nvar createFluidScroller = (function (_ref) {\n  var scrollWindow = _ref.scrollWindow,\n      scrollDroppable = _ref.scrollDroppable;\n  var scheduleWindowScroll = rafSchd(scrollWindow);\n  var scheduleDroppableScroll = rafSchd(scrollDroppable);\n  var dragging = null;\n\n  var tryScroll = function tryScroll(state) {\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fluid scroll if not dragging') : invariant(false) : void 0;\n    var _dragging = dragging,\n        shouldUseTimeDampening = _dragging.shouldUseTimeDampening,\n        dragStartTime = _dragging.dragStartTime;\n    scroll$1({\n      state: state,\n      scrollWindow: scheduleWindowScroll,\n      scrollDroppable: scheduleDroppableScroll,\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n  };\n\n  var start$1 = function start$1(state) {\n    start('starting fluid scroller');\n    !!dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start auto scrolling when already started') : invariant(false) : void 0;\n\n    var dragStartTime = _Date$now();\n\n    var wasScrollNeeded = false;\n\n    var fakeScrollCallback = function fakeScrollCallback() {\n      wasScrollNeeded = true;\n    };\n\n    scroll$1({\n      state: state,\n      dragStartTime: 0,\n      shouldUseTimeDampening: false,\n      scrollWindow: fakeScrollCallback,\n      scrollDroppable: fakeScrollCallback\n    });\n    dragging = {\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: wasScrollNeeded\n    };\n    finish('starting fluid scroller');\n\n    if (wasScrollNeeded) {\n      tryScroll(state);\n    }\n  };\n\n  var stop = function stop() {\n    if (!dragging) {\n      return;\n    }\n\n    scheduleWindowScroll.cancel();\n    scheduleDroppableScroll.cancel();\n    dragging = null;\n  };\n\n  return {\n    start: start$1,\n    stop: stop,\n    scroll: tryScroll\n  };\n});\n\nvar createJumpScroller = (function (_ref) {\n  var move = _ref.move,\n      scrollDroppable = _ref.scrollDroppable,\n      scrollWindow = _ref.scrollWindow;\n\n  var moveByOffset = function moveByOffset(state, offset) {\n    var client = add(state.current.client.selection, offset);\n    move({\n      client: client\n    });\n  };\n\n  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {\n    if (!canScrollDroppable(droppable, change)) {\n      return change;\n    }\n\n    var overlap = getDroppableOverlap(droppable, change);\n\n    if (!overlap) {\n      scrollDroppable(droppable.descriptor.id, change);\n      return null;\n    }\n\n    var whatTheDroppableCanScroll = subtract(change, overlap);\n    scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n    var remainder = subtract(change, whatTheDroppableCanScroll);\n    return remainder;\n  };\n\n  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(isWindowScrollAllowed, viewport, change) {\n    if (!isWindowScrollAllowed) {\n      return change;\n    }\n\n    if (!canScrollWindow(viewport, change)) {\n      return change;\n    }\n\n    var overlap = getWindowOverlap(viewport, change);\n\n    if (!overlap) {\n      scrollWindow(change);\n      return null;\n    }\n\n    var whatTheWindowCanScroll = subtract(change, overlap);\n    scrollWindow(whatTheWindowCanScroll);\n    var remainder = subtract(change, whatTheWindowCanScroll);\n    return remainder;\n  };\n\n  var jumpScroller = function jumpScroller(state) {\n    var request = state.scrollJumpRequest;\n\n    if (!request) {\n      return;\n    }\n\n    var destination = whatIsDraggedOver(state.impact);\n    !destination ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : invariant(false) : void 0;\n    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n\n    if (!droppableRemainder) {\n      return;\n    }\n\n    var viewport = state.viewport;\n    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n\n    if (!windowRemainder) {\n      return;\n    }\n\n    moveByOffset(state, windowRemainder);\n  };\n\n  return jumpScroller;\n});\n\nvar createAutoScroller = (function (_ref) {\n  var scrollDroppable = _ref.scrollDroppable,\n      scrollWindow = _ref.scrollWindow,\n      move = _ref.move;\n  var fluidScroller = createFluidScroller({\n    scrollWindow: scrollWindow,\n    scrollDroppable: scrollDroppable\n  });\n  var jumpScroll = createJumpScroller({\n    move: move,\n    scrollWindow: scrollWindow,\n    scrollDroppable: scrollDroppable\n  });\n\n  var scroll = function scroll(state) {\n    if (state.phase !== 'DRAGGING') {\n      return;\n    }\n\n    if (state.movementMode === 'FLUID') {\n      fluidScroller.scroll(state);\n      return;\n    }\n\n    if (!state.scrollJumpRequest) {\n      return;\n    }\n\n    jumpScroll(state);\n  };\n\n  var scroller = {\n    scroll: scroll,\n    start: fluidScroller.start,\n    stop: fluidScroller.stop\n  };\n  return scroller;\n});\n\nvar prefix$1 = 'data-rbd';\nvar dragHandle = function () {\n  var base = prefix$1 + \"-drag-handle\";\n  return {\n    base: base,\n    draggableId: base + \"-draggable-id\",\n    contextId: base + \"-context-id\"\n  };\n}();\nvar draggable = function () {\n  var base = prefix$1 + \"-draggable\";\n  return {\n    base: base,\n    contextId: base + \"-context-id\",\n    id: base + \"-id\"\n  };\n}();\nvar droppable = function () {\n  var base = prefix$1 + \"-droppable\";\n  return {\n    base: base,\n    contextId: base + \"-context-id\",\n    id: base + \"-id\"\n  };\n}();\nvar scrollContainer = {\n  contextId: prefix$1 + \"-scroll-container-context-id\"\n};\n\nvar makeGetSelector = function makeGetSelector(context) {\n  return function (attribute) {\n    return \"[\" + attribute + \"=\\\"\" + context + \"\\\"]\";\n  };\n};\n\nvar getStyles = function getStyles(rules, property) {\n  return rules.map(function (rule) {\n    var value = rule.styles[property];\n\n    if (!value) {\n      return '';\n    }\n\n    return rule.selector + \" { \" + value + \" }\";\n  }).join(' ');\n};\n\nvar noPointerEvents = 'pointer-events: none;';\nvar getStyles$1 = (function (contextId) {\n  var getSelector = makeGetSelector(contextId);\n\n  var dragHandle$1 = function () {\n    var grabCursor = \"\\n      cursor: -webkit-grab;\\n      cursor: grab;\\n    \";\n    return {\n      selector: getSelector(dragHandle.contextId),\n      styles: {\n        always: \"\\n          -webkit-touch-callout: none;\\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\\n          touch-action: manipulation;\\n        \",\n        resting: grabCursor,\n        dragging: noPointerEvents,\n        dropAnimating: grabCursor\n      }\n    };\n  }();\n\n  var draggable$1 = function () {\n    var transition = \"\\n      transition: \" + transitions.outOfTheWay + \";\\n    \";\n    return {\n      selector: getSelector(draggable.contextId),\n      styles: {\n        dragging: transition,\n        dropAnimating: transition,\n        userCancel: transition\n      }\n    };\n  }();\n\n  var droppable$1 = {\n    selector: getSelector(droppable.contextId),\n    styles: {\n      always: \"overflow-anchor: none;\"\n    }\n  };\n  var body = {\n    selector: 'body',\n    styles: {\n      dragging: \"\\n        cursor: grabbing;\\n        cursor: -webkit-grabbing;\\n        user-select: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        overflow-anchor: none;\\n      \"\n    }\n  };\n  var rules = [draggable$1, dragHandle$1, droppable$1, body];\n  return {\n    always: getStyles(rules, 'always'),\n    resting: getStyles(rules, 'resting'),\n    dragging: getStyles(rules, 'dragging'),\n    dropAnimating: getStyles(rules, 'dropAnimating'),\n    userCancel: getStyles(rules, 'userCancel')\n  };\n});\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nvar getHead = function getHead() {\n  var head = document.querySelector('head');\n  !head ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find the head to append a style to') : invariant(false) : void 0;\n  return head;\n};\n\nvar createStyleEl = function createStyleEl(nonce) {\n  var el = document.createElement('style');\n\n  if (nonce) {\n    el.setAttribute('nonce', nonce);\n  }\n\n  el.type = 'text/css';\n  return el;\n};\n\nfunction useStyleMarshal(contextId, nonce) {\n  var styles = useMemoOne.useMemo(function () {\n    return getStyles$1(contextId);\n  }, [contextId]);\n  var alwaysRef = React.useRef(null);\n  var dynamicRef = React.useRef(null);\n  var setDynamicStyle = useMemoOne.useCallback(memoizeOne(function (proposed) {\n    var el = dynamicRef.current;\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;\n    el.textContent = proposed;\n  }), []);\n  var setAlwaysStyle = useMemoOne.useCallback(function (proposed) {\n    var el = alwaysRef.current;\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;\n    el.textContent = proposed;\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    !(!alwaysRef.current && !dynamicRef.current) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'style elements already mounted') : invariant(false) : void 0;\n    var always = createStyleEl(nonce);\n    var dynamic = createStyleEl(nonce);\n    alwaysRef.current = always;\n    dynamicRef.current = dynamic;\n    always.setAttribute(prefix$1 + \"-always\", contextId);\n    dynamic.setAttribute(prefix$1 + \"-dynamic\", contextId);\n    getHead().appendChild(always);\n    getHead().appendChild(dynamic);\n    setAlwaysStyle(styles.always);\n    setDynamicStyle(styles.resting);\n    return function () {\n      var remove = function remove(ref) {\n        var current = ref.current;\n        !current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot unmount ref as it is not set') : invariant(false) : void 0;\n        getHead().removeChild(current);\n        ref.current = null;\n      };\n\n      remove(alwaysRef);\n      remove(dynamicRef);\n    };\n  }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);\n  var dragging = useMemoOne.useCallback(function () {\n    return setDynamicStyle(styles.dragging);\n  }, [setDynamicStyle, styles.dragging]);\n  var dropping = useMemoOne.useCallback(function (reason) {\n    if (reason === 'DROP') {\n      setDynamicStyle(styles.dropAnimating);\n      return;\n    }\n\n    setDynamicStyle(styles.userCancel);\n  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);\n  var resting = useMemoOne.useCallback(function () {\n    if (!dynamicRef.current) {\n      return;\n    }\n\n    setDynamicStyle(styles.resting);\n  }, [setDynamicStyle, styles.resting]);\n  var marshal = useMemoOne.useMemo(function () {\n    return {\n      dragging: dragging,\n      dropping: dropping,\n      resting: resting\n    };\n  }, [dragging, dropping, resting]);\n  return marshal;\n}\n\nvar getWindowFromEl = (function (el) {\n  return el && el.ownerDocument ? el.ownerDocument.defaultView : window;\n});\n\nfunction isHtmlElement(el) {\n  return el instanceof getWindowFromEl(el).HTMLElement;\n}\n\nfunction findDragHandle(contextId, draggableId) {\n  var selector = \"[\" + dragHandle.contextId + \"=\\\"\" + contextId + \"\\\"]\";\n  var possible = toArray(document.querySelectorAll(selector));\n\n  if (!possible.length) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"Unable to find any drag handles in the context \\\"\" + contextId + \"\\\"\") : void 0;\n    return null;\n  }\n\n  var handle = find(possible, function (el) {\n    return el.getAttribute(dragHandle.draggableId) === draggableId;\n  });\n\n  if (!handle) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"Unable to find drag handle with id \\\"\" + draggableId + \"\\\" as no handle with a matching id was found\") : void 0;\n    return null;\n  }\n\n  if (!isHtmlElement(handle)) {\n    process.env.NODE_ENV !== \"production\" ? warning('drag handle needs to be a HTMLElement') : void 0;\n    return null;\n  }\n\n  return handle;\n}\n\nfunction useFocusMarshal(contextId) {\n  var entriesRef = React.useRef({});\n  var recordRef = React.useRef(null);\n  var restoreFocusFrameRef = React.useRef(null);\n  var isMountedRef = React.useRef(false);\n  var register = useMemoOne.useCallback(function register(id, focus) {\n    var entry = {\n      id: id,\n      focus: focus\n    };\n    entriesRef.current[id] = entry;\n    return function unregister() {\n      var entries = entriesRef.current;\n      var current = entries[id];\n\n      if (current !== entry) {\n        delete entries[id];\n      }\n    };\n  }, []);\n  var tryGiveFocus = useMemoOne.useCallback(function tryGiveFocus(tryGiveFocusTo) {\n    var handle = findDragHandle(contextId, tryGiveFocusTo);\n\n    if (handle && handle !== document.activeElement) {\n      handle.focus();\n    }\n  }, [contextId]);\n  var tryShiftRecord = useMemoOne.useCallback(function tryShiftRecord(previous, redirectTo) {\n    if (recordRef.current === previous) {\n      recordRef.current = redirectTo;\n    }\n  }, []);\n  var tryRestoreFocusRecorded = useMemoOne.useCallback(function tryRestoreFocusRecorded() {\n    if (restoreFocusFrameRef.current) {\n      return;\n    }\n\n    if (!isMountedRef.current) {\n      return;\n    }\n\n    restoreFocusFrameRef.current = requestAnimationFrame(function () {\n      restoreFocusFrameRef.current = null;\n      var record = recordRef.current;\n\n      if (record) {\n        tryGiveFocus(record);\n      }\n    });\n  }, [tryGiveFocus]);\n  var tryRecordFocus = useMemoOne.useCallback(function tryRecordFocus(id) {\n    recordRef.current = null;\n    var focused = document.activeElement;\n\n    if (!focused) {\n      return;\n    }\n\n    if (focused.getAttribute(dragHandle.draggableId) !== id) {\n      return;\n    }\n\n    recordRef.current = id;\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    isMountedRef.current = true;\n    return function clearFrameOnUnmount() {\n      isMountedRef.current = false;\n      var frameId = restoreFocusFrameRef.current;\n\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }, []);\n  var marshal = useMemoOne.useMemo(function () {\n    return {\n      register: register,\n      tryRecordFocus: tryRecordFocus,\n      tryRestoreFocusRecorded: tryRestoreFocusRecorded,\n      tryShiftRecord: tryShiftRecord\n    };\n  }, [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);\n  return marshal;\n}\n\nfunction createRegistry() {\n  var entries = {\n    draggables: {},\n    droppables: {}\n  };\n  var subscribers = [];\n\n  function subscribe(cb) {\n    subscribers.push(cb);\n    return function unsubscribe() {\n      var index = subscribers.indexOf(cb);\n\n      if (index === -1) {\n        return;\n      }\n\n      subscribers.splice(index, 1);\n    };\n  }\n\n  function notify(event) {\n    if (subscribers.length) {\n      subscribers.forEach(function (cb) {\n        return cb(event);\n      });\n    }\n  }\n\n  function findDraggableById(id) {\n    return entries.draggables[id] || null;\n  }\n\n  function getDraggableById(id) {\n    var entry = findDraggableById(id);\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find draggable entry with id [\" + id + \"]\") : invariant(false) : void 0;\n    return entry;\n  }\n\n  var draggableAPI = {\n    register: function register(entry) {\n      entries.draggables[entry.descriptor.id] = entry;\n      notify({\n        type: 'ADDITION',\n        value: entry\n      });\n    },\n    update: function update(entry, last) {\n      var current = entries.draggables[last.descriptor.id];\n\n      if (!current) {\n        return;\n      }\n\n      if (current.uniqueId !== entry.uniqueId) {\n        return;\n      }\n\n      delete entries.draggables[last.descriptor.id];\n      entries.draggables[entry.descriptor.id] = entry;\n    },\n    unregister: function unregister(entry) {\n      var draggableId = entry.descriptor.id;\n      var current = findDraggableById(draggableId);\n\n      if (!current) {\n        return;\n      }\n\n      if (entry.uniqueId !== current.uniqueId) {\n        return;\n      }\n\n      delete entries.draggables[draggableId];\n      notify({\n        type: 'REMOVAL',\n        value: entry\n      });\n    },\n    getById: getDraggableById,\n    findById: findDraggableById,\n    exists: function exists(id) {\n      return Boolean(findDraggableById(id));\n    },\n    getAllByType: function getAllByType(type) {\n      return values(entries.draggables).filter(function (entry) {\n        return entry.descriptor.type === type;\n      });\n    }\n  };\n\n  function findDroppableById(id) {\n    return entries.droppables[id] || null;\n  }\n\n  function getDroppableById(id) {\n    var entry = findDroppableById(id);\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find droppable entry with id [\" + id + \"]\") : invariant(false) : void 0;\n    return entry;\n  }\n\n  var droppableAPI = {\n    register: function register(entry) {\n      entries.droppables[entry.descriptor.id] = entry;\n    },\n    unregister: function unregister(entry) {\n      var current = findDroppableById(entry.descriptor.id);\n\n      if (!current) {\n        return;\n      }\n\n      if (entry.uniqueId !== current.uniqueId) {\n        return;\n      }\n\n      delete entries.droppables[entry.descriptor.id];\n    },\n    getById: getDroppableById,\n    findById: findDroppableById,\n    exists: function exists(id) {\n      return Boolean(findDroppableById(id));\n    },\n    getAllByType: function getAllByType(type) {\n      return values(entries.droppables).filter(function (entry) {\n        return entry.descriptor.type === type;\n      });\n    }\n  };\n\n  function clean() {\n    entries.draggables = {};\n    entries.droppables = {};\n    subscribers.length = 0;\n  }\n\n  return {\n    draggable: draggableAPI,\n    droppable: droppableAPI,\n    subscribe: subscribe,\n    clean: clean\n  };\n}\n\nfunction useRegistry() {\n  var registry = useMemoOne.useMemo(createRegistry, []);\n  React.useEffect(function () {\n    return function unmount() {\n      requestAnimationFrame(registry.clean);\n    };\n  }, [registry]);\n  return registry;\n}\n\nvar StoreContext = React__default.createContext(null);\n\nvar getBodyElement = (function () {\n  var body = document.body;\n  !body ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find document.body') : invariant(false) : void 0;\n  return body;\n});\n\nvar visuallyHidden = {\n  position: 'absolute',\n  width: '1px',\n  height: '1px',\n  margin: '-1px',\n  border: '0',\n  padding: '0',\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  'clip-path': 'inset(100%)'\n};\n\nvar getId = function getId(contextId) {\n  return \"rbd-announcement-\" + contextId;\n};\nfunction useAnnouncer(contextId) {\n  var id = useMemoOne.useMemo(function () {\n    return getId(contextId);\n  }, [contextId]);\n  var ref = React.useRef(null);\n  React.useEffect(function () {\n    !!ref.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Announcement node already mounted') : invariant(false) : void 0;\n    var el = document.createElement('div');\n    ref.current = el;\n    el.id = id;\n    el.setAttribute('aria-live', 'assertive');\n    el.setAttribute('role', 'log');\n    el.setAttribute('aria-atomic', 'true');\n\n    _Object$assign(el.style, visuallyHidden);\n\n    getBodyElement().appendChild(el);\n    return function () {\n      setTimeout(function remove() {\n        var toBeRemoved = ref.current;\n        !toBeRemoved ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot unmount announcement node') : invariant(false) : void 0;\n        getBodyElement().removeChild(toBeRemoved);\n        ref.current = null;\n      });\n    };\n  }, [id]);\n  var announce = useMemoOne.useCallback(function (message) {\n    var el = ref.current;\n\n    if (el) {\n      el.textContent = message;\n      return;\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      A screen reader message was trying to be announced but it was unable to do so.\\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\\n      Consider calling provided.announce() before the unmount so that the instruction will\\n      not be lost for users relying on a screen reader.\\n\\n      Message not passed to screen reader:\\n\\n      \\\"\" + message + \"\\\"\\n    \") : void 0;\n  }, []);\n  return announce;\n}\n\nvar getId$1 = function getId(contextId) {\n  return \"rbd-lift-instruction-\" + contextId;\n};\nfunction useLiftInstruction(contextId, liftInstruction) {\n  var id = useMemoOne.useMemo(function () {\n    return getId$1(contextId);\n  }, [contextId]);\n  React.useEffect(function mount() {\n    var el = document.createElement('div');\n    el.id = id;\n    el.textContent = liftInstruction;\n\n    _Object$assign(el.style, visuallyHidden);\n\n    getBodyElement().appendChild(el);\n    return function unmount() {\n      getBodyElement().removeChild(el);\n    };\n  }, [id, liftInstruction]);\n  return id;\n}\n\nvar AppContext = React__default.createContext(null);\n\nvar peerDependencies = {\n\treact: \"^16.8.5\",\n\t\"react-dom\": \"^16.8.5\"\n};\n\nvar semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\n\nvar getVersion = function getVersion(value) {\n  var result = semver.exec(value);\n  !(result != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Unable to parse React version \" + value) : invariant(false) : void 0;\n  var major = Number(result[1]);\n  var minor = Number(result[2]);\n  var patch = Number(result[3]);\n  return {\n    major: major,\n    minor: minor,\n    patch: patch,\n    raw: value\n  };\n};\n\nvar isSatisfied = function isSatisfied(expected, actual) {\n  if (actual.major > expected.major) {\n    return true;\n  }\n\n  if (actual.major < expected.major) {\n    return false;\n  }\n\n  if (actual.minor > expected.minor) {\n    return true;\n  }\n\n  if (actual.minor < expected.minor) {\n    return false;\n  }\n\n  return actual.patch >= expected.patch;\n};\n\nvar checkReactVersion = (function (peerDepValue, actualValue) {\n  var peerDep = getVersion(peerDepValue);\n  var actual = getVersion(actualValue);\n\n  if (isSatisfied(peerDep, actual)) {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    React version: [\" + actual.raw + \"]\\n    does not satisfy expected peer dependency version: [\" + peerDep.raw + \"]\\n\\n    This can result in run time bugs, and even fatal crashes\\n  \") : void 0;\n});\n\nvar suffix = \"\\n  We expect a html5 doctype: <!doctype html>\\n  This is to ensure consistent browser layout and measurement\\n\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\n\";\nvar checkDoctype = (function (doc) {\n  var doctype = doc.doctype;\n\n  if (!doctype) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      No <!doctype html> found.\\n\\n      \" + suffix + \"\\n    \") : void 0;\n    return;\n  }\n\n  if (doctype.name.toLowerCase() !== 'html') {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Unexpected <!doctype> found: (\" + doctype.name + \")\\n\\n      \" + suffix + \"\\n    \") : void 0;\n  }\n\n  if (doctype.publicId !== '') {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Unexpected <!doctype> publicId found: (\" + doctype.publicId + \")\\n      A html5 doctype does not have a publicId\\n\\n      \" + suffix + \"\\n    \") : void 0;\n  }\n});\n\nfunction useDev(useHook) {\n  if (process.env.NODE_ENV !== 'production') {\n    useHook();\n  }\n}\n\nfunction useDevSetupWarning(fn, inputs) {\n  useDev(function () {\n    React.useEffect(function () {\n      try {\n        fn();\n      } catch (e) {\n        error(\"\\n          A setup problem was encountered.\\n\\n          > \" + e.message + \"\\n        \");\n      }\n    }, inputs);\n  });\n}\n\nfunction useStartupValidation() {\n  useDevSetupWarning(function () {\n    checkReactVersion(peerDependencies.react, React__default.version);\n    checkDoctype(document);\n  }, []);\n}\n\nfunction usePrevious(current) {\n  var ref = React.useRef(current);\n  React.useEffect(function () {\n    ref.current = current;\n  });\n  return ref;\n}\n\nfunction create() {\n  var lock = null;\n\n  function isClaimed() {\n    return Boolean(lock);\n  }\n\n  function isActive(value) {\n    return value === lock;\n  }\n\n  function claim(abandon) {\n    !!lock ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot claim lock as it is already claimed') : invariant(false) : void 0;\n    var newLock = {\n      abandon: abandon\n    };\n    lock = newLock;\n    return newLock;\n  }\n\n  function release() {\n    !lock ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot release lock when there is no lock') : invariant(false) : void 0;\n    lock = null;\n  }\n\n  function tryAbandon() {\n    if (lock) {\n      lock.abandon();\n      release();\n    }\n  }\n\n  return {\n    isClaimed: isClaimed,\n    isActive: isActive,\n    claim: claim,\n    release: release,\n    tryAbandon: tryAbandon\n  };\n}\n\nvar tab = 9;\nvar enter = 13;\nvar escape = 27;\nvar space = 32;\nvar pageUp = 33;\nvar pageDown = 34;\nvar end = 35;\nvar home = 36;\nvar arrowLeft = 37;\nvar arrowUp = 38;\nvar arrowRight = 39;\nvar arrowDown = 40;\n\nvar _preventedKeys;\nvar preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);\nvar preventStandardKeyEvents = (function (event) {\n  if (preventedKeys[event.keyCode]) {\n    event.preventDefault();\n  }\n});\n\nvar supportedEventName = function () {\n  var base = 'visibilitychange';\n\n  if (typeof document === 'undefined') {\n    return base;\n  }\n\n  var candidates = [base, \"ms\" + base, \"webkit\" + base, \"moz\" + base, \"o\" + base];\n  var supported = find(candidates, function (eventName) {\n    return \"on\" + eventName in document;\n  });\n  return supported || base;\n}();\n\nvar primaryButton = 0;\nvar sloppyClickThreshold = 5;\n\nfunction isSloppyClickThresholdExceeded(original, current) {\n  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\n\nvar idle$1 = {\n  type: 'IDLE'\n};\n\nfunction getCaptureBindings(_ref) {\n  var cancel = _ref.cancel,\n      completed = _ref.completed,\n      getPhase = _ref.getPhase,\n      setPhase = _ref.setPhase;\n  return [{\n    eventName: 'mousemove',\n    fn: function fn(event) {\n      var button = event.button,\n          clientX = event.clientX,\n          clientY = event.clientY;\n\n      if (button !== primaryButton) {\n        return;\n      }\n\n      var point = {\n        x: clientX,\n        y: clientY\n      };\n      var phase = getPhase();\n\n      if (phase.type === 'DRAGGING') {\n        event.preventDefault();\n        phase.actions.move(point);\n        return;\n      }\n\n      !(phase.type === 'PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot be IDLE') : invariant(false) : void 0;\n      var pending = phase.point;\n\n      if (!isSloppyClickThresholdExceeded(pending, point)) {\n        return;\n      }\n\n      event.preventDefault();\n      var actions = phase.actions.fluidLift(point);\n      setPhase({\n        type: 'DRAGGING',\n        actions: actions\n      });\n    }\n  }, {\n    eventName: 'mouseup',\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n      phase.actions.drop({\n        shouldBlockNextClick: true\n      });\n      completed();\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: function fn(event) {\n      if (getPhase().type === 'DRAGGING') {\n        event.preventDefault();\n      }\n\n      cancel();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type === 'PENDING') {\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: function fn() {\n      if (getPhase().type === 'PENDING') {\n        cancel();\n      }\n    }\n  }, {\n    eventName: 'webkitmouseforcedown',\n    fn: function fn(event) {\n      var phase = getPhase();\n      !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unexpected phase') : invariant(false) : void 0;\n\n      if (phase.actions.shouldRespectForcePress()) {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction useMouseSensor(api) {\n  var phaseRef = React.useRef(idle$1);\n  var unbindEventsRef = React.useRef(noop);\n  var startCaptureBinding = useMemoOne.useMemo(function () {\n    return {\n      eventName: 'mousedown',\n      fn: function onMouseDown(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        if (event.button !== primaryButton) {\n          return;\n        }\n\n        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n          return;\n        }\n\n        var draggableId = api.findClosestDraggableId(event);\n\n        if (!draggableId) {\n          return;\n        }\n\n        var actions = api.tryGetLock(draggableId, stop, {\n          sourceEvent: event\n        });\n\n        if (!actions) {\n          return;\n        }\n\n        event.preventDefault();\n        var point = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        unbindEventsRef.current();\n        startPendingDrag(actions, point);\n      }\n    };\n  }, [api]);\n  var preventForcePressBinding = useMemoOne.useMemo(function () {\n    return {\n      eventName: 'webkitmouseforcewillbegin',\n      fn: function fn(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        var id = api.findClosestDraggableId(event);\n\n        if (!id) {\n          return;\n        }\n\n        var options = api.findOptionsForDraggable(id);\n\n        if (!options) {\n          return;\n        }\n\n        if (options.shouldRespectForcePress) {\n          return;\n        }\n\n        if (!api.canGetLock(id)) {\n          return;\n        }\n\n        event.preventDefault();\n      }\n    };\n  }, [api]);\n  var listenForCapture = useMemoOne.useCallback(function listenForCapture() {\n    var options = {\n      passive: false,\n      capture: true\n    };\n    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);\n  }, [preventForcePressBinding, startCaptureBinding]);\n  var stop = useMemoOne.useCallback(function () {\n    var current = phaseRef.current;\n\n    if (current.type === 'IDLE') {\n      return;\n    }\n\n    phaseRef.current = idle$1;\n    unbindEventsRef.current();\n    listenForCapture();\n  }, [listenForCapture]);\n  var cancel = useMemoOne.useCallback(function () {\n    var phase = phaseRef.current;\n    stop();\n\n    if (phase.type === 'DRAGGING') {\n      phase.actions.cancel({\n        shouldBlockNextClick: true\n      });\n    }\n\n    if (phase.type === 'PENDING') {\n      phase.actions.abort();\n    }\n  }, [stop]);\n  var bindCapturingEvents = useMemoOne.useCallback(function bindCapturingEvents() {\n    var options = {\n      capture: true,\n      passive: false\n    };\n    var bindings = getCaptureBindings({\n      cancel: cancel,\n      completed: stop,\n      getPhase: function getPhase() {\n        return phaseRef.current;\n      },\n      setPhase: function setPhase(phase) {\n        phaseRef.current = phase;\n      }\n    });\n    unbindEventsRef.current = bindEvents(window, bindings, options);\n  }, [cancel, stop]);\n  var startPendingDrag = useMemoOne.useCallback(function startPendingDrag(actions, point) {\n    !(phaseRef.current.type === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected to move from IDLE to PENDING drag') : invariant(false) : void 0;\n    phaseRef.current = {\n      type: 'PENDING',\n      point: point,\n      actions: actions\n    };\n    bindCapturingEvents();\n  }, [bindCapturingEvents]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n    };\n  }, [listenForCapture]);\n}\n\nvar _scrollJumpKeys;\n\nfunction noop$1() {}\n\nvar scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);\n\nfunction getDraggingBindings(actions, stop) {\n  function cancel() {\n    stop();\n    actions.cancel();\n  }\n\n  function drop() {\n    stop();\n    actions.drop();\n  }\n\n  return [{\n    eventName: 'keydown',\n    fn: function fn(event) {\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === space) {\n        event.preventDefault();\n        drop();\n        return;\n      }\n\n      if (event.keyCode === arrowDown) {\n        event.preventDefault();\n        actions.moveDown();\n        return;\n      }\n\n      if (event.keyCode === arrowUp) {\n        event.preventDefault();\n        actions.moveUp();\n        return;\n      }\n\n      if (event.keyCode === arrowRight) {\n        event.preventDefault();\n        actions.moveRight();\n        return;\n      }\n\n      if (event.keyCode === arrowLeft) {\n        event.preventDefault();\n        actions.moveLeft();\n        return;\n      }\n\n      if (scrollJumpKeys[event.keyCode]) {\n        event.preventDefault();\n        return;\n      }\n\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: cancel\n  }, {\n    eventName: 'mouseup',\n    fn: cancel\n  }, {\n    eventName: 'click',\n    fn: cancel\n  }, {\n    eventName: 'touchstart',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'wheel',\n    fn: cancel,\n    options: {\n      passive: true\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction useKeyboardSensor(api) {\n  var unbindEventsRef = React.useRef(noop$1);\n  var startCaptureBinding = useMemoOne.useMemo(function () {\n    return {\n      eventName: 'keydown',\n      fn: function onKeyDown(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        if (event.keyCode !== space) {\n          return;\n        }\n\n        var draggableId = api.findClosestDraggableId(event);\n\n        if (!draggableId) {\n          return;\n        }\n\n        var preDrag = api.tryGetLock(draggableId, stop, {\n          sourceEvent: event\n        });\n\n        if (!preDrag) {\n          return;\n        }\n\n        event.preventDefault();\n        var isCapturing = true;\n        var actions = preDrag.snapLift();\n        unbindEventsRef.current();\n\n        function stop() {\n          !isCapturing ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot stop capturing a keyboard drag when not capturing') : invariant(false) : void 0;\n          isCapturing = false;\n          unbindEventsRef.current();\n          listenForCapture();\n        }\n\n        unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n          capture: true,\n          passive: false\n        });\n      }\n    };\n  }, [api]);\n  var listenForCapture = useMemoOne.useCallback(function tryStartCapture() {\n    var options = {\n      passive: false,\n      capture: true\n    };\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\n  }, [startCaptureBinding]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n    };\n  }, [listenForCapture]);\n}\n\nvar idle$2 = {\n  type: 'IDLE'\n};\nvar timeForLongPress = 120;\nvar forcePressThreshold = 0.15;\n\nfunction getWindowBindings(_ref) {\n  var cancel = _ref.cancel,\n      getPhase = _ref.getPhase;\n  return [{\n    eventName: 'orientationchange',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'contextmenu',\n    fn: function fn(event) {\n      event.preventDefault();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: function fn(event) {\n      if (getPhase().type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === escape) {\n        event.preventDefault();\n      }\n\n      cancel();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction getHandleBindings(_ref2) {\n  var cancel = _ref2.cancel,\n      completed = _ref2.completed,\n      getPhase = _ref2.getPhase;\n  return [{\n    eventName: 'touchmove',\n    options: {\n      capture: false\n    },\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      phase.hasMoved = true;\n      var _event$touches$ = event.touches[0],\n          clientX = _event$touches$.clientX,\n          clientY = _event$touches$.clientY;\n      var point = {\n        x: clientX,\n        y: clientY\n      };\n      event.preventDefault();\n      phase.actions.move(point);\n    }\n  }, {\n    eventName: 'touchend',\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n      phase.actions.drop({\n        shouldBlockNextClick: true\n      });\n      completed();\n    }\n  }, {\n    eventName: 'touchcancel',\n    fn: function fn(event) {\n      if (getPhase().type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n      cancel();\n    }\n  }, {\n    eventName: 'touchforcechange',\n    fn: function fn(event) {\n      var phase = getPhase();\n      !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n      var touch = event.touches[0];\n\n      if (!touch) {\n        return;\n      }\n\n      var isForcePress = touch.force >= forcePressThreshold;\n\n      if (!isForcePress) {\n        return;\n      }\n\n      var shouldRespect = phase.actions.shouldRespectForcePress();\n\n      if (phase.type === 'PENDING') {\n        if (shouldRespect) {\n          cancel();\n        }\n\n        return;\n      }\n\n      if (shouldRespect) {\n        if (phase.hasMoved) {\n          event.preventDefault();\n          return;\n        }\n\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction useMouseSensor$1(api) {\n  var phaseRef = React.useRef(idle$2);\n  var unbindEventsRef = React.useRef(noop);\n  var getPhase = useMemoOne.useCallback(function getPhase() {\n    return phaseRef.current;\n  }, []);\n  var setPhase = useMemoOne.useCallback(function setPhase(phase) {\n    phaseRef.current = phase;\n  }, []);\n  var startCaptureBinding = useMemoOne.useMemo(function () {\n    return {\n      eventName: 'touchstart',\n      fn: function onTouchStart(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        var draggableId = api.findClosestDraggableId(event);\n\n        if (!draggableId) {\n          return;\n        }\n\n        var actions = api.tryGetLock(draggableId, stop, {\n          sourceEvent: event\n        });\n\n        if (!actions) {\n          return;\n        }\n\n        var touch = event.touches[0];\n        var clientX = touch.clientX,\n            clientY = touch.clientY;\n        var point = {\n          x: clientX,\n          y: clientY\n        };\n        unbindEventsRef.current();\n        startPendingDrag(actions, point);\n      }\n    };\n  }, [api]);\n  var listenForCapture = useMemoOne.useCallback(function listenForCapture() {\n    var options = {\n      capture: true,\n      passive: false\n    };\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\n  }, [startCaptureBinding]);\n  var stop = useMemoOne.useCallback(function () {\n    var current = phaseRef.current;\n\n    if (current.type === 'IDLE') {\n      return;\n    }\n\n    if (current.type === 'PENDING') {\n      clearTimeout(current.longPressTimerId);\n    }\n\n    setPhase(idle$2);\n    unbindEventsRef.current();\n    listenForCapture();\n  }, [listenForCapture, setPhase]);\n  var cancel = useMemoOne.useCallback(function () {\n    var phase = phaseRef.current;\n    stop();\n\n    if (phase.type === 'DRAGGING') {\n      phase.actions.cancel({\n        shouldBlockNextClick: true\n      });\n    }\n\n    if (phase.type === 'PENDING') {\n      phase.actions.abort();\n    }\n  }, [stop]);\n  var bindCapturingEvents = useMemoOne.useCallback(function bindCapturingEvents() {\n    var options = {\n      capture: true,\n      passive: false\n    };\n    var args = {\n      cancel: cancel,\n      completed: stop,\n      getPhase: getPhase\n    };\n    var unbindTarget = bindEvents(window, getHandleBindings(args), options);\n    var unbindWindow = bindEvents(window, getWindowBindings(args), options);\n\n    unbindEventsRef.current = function unbindAll() {\n      unbindTarget();\n      unbindWindow();\n    };\n  }, [cancel, getPhase, stop]);\n  var startDragging = useMemoOne.useCallback(function startDragging() {\n    var phase = getPhase();\n    !(phase.type === 'PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot start dragging from phase \" + phase.type) : invariant(false) : void 0;\n    var actions = phase.actions.fluidLift(phase.point);\n    setPhase({\n      type: 'DRAGGING',\n      actions: actions,\n      hasMoved: false\n    });\n  }, [getPhase, setPhase]);\n  var startPendingDrag = useMemoOne.useCallback(function startPendingDrag(actions, point) {\n    !(getPhase().type === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected to move from IDLE to PENDING drag') : invariant(false) : void 0;\n    var longPressTimerId = setTimeout(startDragging, timeForLongPress);\n    setPhase({\n      type: 'PENDING',\n      point: point,\n      actions: actions,\n      longPressTimerId: longPressTimerId\n    });\n    bindCapturingEvents();\n  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n      var phase = getPhase();\n\n      if (phase.type === 'PENDING') {\n        clearTimeout(phase.longPressTimerId);\n        setPhase(idle$2);\n      }\n    };\n  }, [getPhase, listenForCapture, setPhase]);\n  useIsomorphicLayoutEffect(function webkitHack() {\n    var unbind = bindEvents(window, [{\n      eventName: 'touchmove',\n      fn: function fn() {},\n      options: {\n        capture: false,\n        passive: false\n      }\n    }]);\n    return unbind;\n  }, []);\n}\n\nfunction useValidateSensorHooks(sensorHooks) {\n  useDev(function () {\n    var previousRef = usePrevious(sensorHooks);\n    useDevSetupWarning(function () {\n      !(previousRef.current.length === sensorHooks.length) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot change the amount of sensor hooks after mounting') : invariant(false) : void 0;\n    });\n  });\n}\n\nvar interactiveTagNames = {\n  input: true,\n  button: true,\n  textarea: true,\n  select: true,\n  option: true,\n  optgroup: true,\n  video: true,\n  audio: true\n};\n\nfunction isAnInteractiveElement(parent, current) {\n  if (current == null) {\n    return false;\n  }\n\n  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);\n\n  if (hasAnInteractiveTag) {\n    return true;\n  }\n\n  var attribute = current.getAttribute('contenteditable');\n\n  if (attribute === 'true' || attribute === '') {\n    return true;\n  }\n\n  if (current === parent) {\n    return false;\n  }\n\n  return isAnInteractiveElement(parent, current.parentElement);\n}\n\nfunction isEventInInteractiveElement(draggable, event) {\n  var target = event.target;\n\n  if (!isHtmlElement(target)) {\n    return false;\n  }\n\n  return isAnInteractiveElement(draggable, target);\n}\n\nvar getBorderBoxCenterPosition = (function (el) {\n  return cssBoxModel.getRect(el.getBoundingClientRect()).center;\n});\n\nfunction isElement(el) {\n  return el instanceof getWindowFromEl(el).Element;\n}\n\nvar supportedMatchesName = function () {\n  var base = 'matches';\n\n  if (typeof document === 'undefined') {\n    return base;\n  }\n\n  var candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];\n  var value = find(candidates, function (name) {\n    return name in Element.prototype;\n  });\n  return value || base;\n}();\n\nfunction closestPonyfill(el, selector) {\n  if (el == null) {\n    return null;\n  }\n\n  if (el[supportedMatchesName](selector)) {\n    return el;\n  }\n\n  return closestPonyfill(el.parentElement, selector);\n}\n\nfunction closest$1(el, selector) {\n  if (el.closest) {\n    return el.closest(selector);\n  }\n\n  return closestPonyfill(el, selector);\n}\n\nfunction getSelector(contextId) {\n  return \"[\" + dragHandle.contextId + \"=\\\"\" + contextId + \"\\\"]\";\n}\n\nfunction findClosestDragHandleFromEvent(contextId, event) {\n  var target = event.target;\n\n  if (!isElement(target)) {\n    process.env.NODE_ENV !== \"production\" ? warning('event.target must be a Element') : void 0;\n    return null;\n  }\n\n  var selector = getSelector(contextId);\n  var handle = closest$1(target, selector);\n\n  if (!handle) {\n    return null;\n  }\n\n  if (!isHtmlElement(handle)) {\n    process.env.NODE_ENV !== \"production\" ? warning('drag handle must be a HTMLElement') : void 0;\n    return null;\n  }\n\n  return handle;\n}\n\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n  var handle = findClosestDragHandleFromEvent(contextId, event);\n\n  if (!handle) {\n    return null;\n  }\n\n  return handle.getAttribute(dragHandle.draggableId);\n}\n\nfunction findDraggable(contextId, draggableId) {\n  var selector = \"[\" + draggable.contextId + \"=\\\"\" + contextId + \"\\\"]\";\n  var possible = toArray(document.querySelectorAll(selector));\n  var draggable$1 = find(possible, function (el) {\n    return el.getAttribute(draggable.id) === draggableId;\n  });\n\n  if (!draggable$1) {\n    return null;\n  }\n\n  if (!isHtmlElement(draggable$1)) {\n    process.env.NODE_ENV !== \"production\" ? warning('Draggable element is not a HTMLElement') : void 0;\n    return null;\n  }\n\n  return draggable$1;\n}\n\nfunction preventDefault(event) {\n  event.preventDefault();\n}\n\nfunction _isActive(_ref) {\n  var expected = _ref.expected,\n      phase = _ref.phase,\n      isLockActive = _ref.isLockActive,\n      shouldWarn = _ref.shouldWarn;\n\n  if (!isLockActive()) {\n    if (shouldWarn) {\n      process.env.NODE_ENV !== \"production\" ? warning(\"\\n        Cannot perform action.\\n        The sensor no longer has an action lock.\\n\\n        Tips:\\n\\n        - Throw away your action handlers when forceStop() is called\\n        - Check actions.isActive() if you really need to\\n      \") : void 0;\n    }\n\n    return false;\n  }\n\n  if (expected !== phase) {\n    if (shouldWarn) {\n      process.env.NODE_ENV !== \"production\" ? warning(\"\\n        Cannot perform action.\\n        The actions you used belong to an outdated phase\\n\\n        Current phase: \" + expected + \"\\n        You called an action from outdated phase: \" + phase + \"\\n\\n        Tips:\\n\\n        - Do not use preDragActions actions after calling preDragActions.lift()\\n      \") : void 0;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction canStart(_ref2) {\n  var lockAPI = _ref2.lockAPI,\n      store = _ref2.store,\n      registry = _ref2.registry,\n      draggableId = _ref2.draggableId;\n\n  if (lockAPI.isClaimed()) {\n    return false;\n  }\n\n  var entry = registry.draggable.findById(draggableId);\n\n  if (!entry) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"Unable to find draggable with id: \" + draggableId) : void 0;\n    return false;\n  }\n\n  if (!entry.options.isEnabled) {\n    return false;\n  }\n\n  if (!canStartDrag(store.getState(), draggableId)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction tryStart(_ref3) {\n  var lockAPI = _ref3.lockAPI,\n      contextId = _ref3.contextId,\n      store = _ref3.store,\n      registry = _ref3.registry,\n      draggableId = _ref3.draggableId,\n      forceSensorStop = _ref3.forceSensorStop,\n      sourceEvent = _ref3.sourceEvent;\n  var shouldStart = canStart({\n    lockAPI: lockAPI,\n    store: store,\n    registry: registry,\n    draggableId: draggableId\n  });\n\n  if (!shouldStart) {\n    return null;\n  }\n\n  var entry = registry.draggable.getById(draggableId);\n  var el = findDraggable(contextId, entry.descriptor.id);\n\n  if (!el) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"Unable to find draggable element with id: \" + draggableId) : void 0;\n    return null;\n  }\n\n  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n    return null;\n  }\n\n  var lock = lockAPI.claim(forceSensorStop || noop);\n  var phase = 'PRE_DRAG';\n\n  function getShouldRespectForcePress() {\n    return entry.options.shouldRespectForcePress;\n  }\n\n  function isLockActive() {\n    return lockAPI.isActive(lock);\n  }\n\n  function tryDispatch(expected, getAction) {\n    if (_isActive({\n      expected: expected,\n      phase: phase,\n      isLockActive: isLockActive,\n      shouldWarn: true\n    })) {\n      store.dispatch(getAction());\n    }\n  }\n\n  var tryDispatchWhenDragging = tryDispatch.bind(this, 'DRAGGING');\n\n  function lift$1(args) {\n    function completed() {\n      lockAPI.release();\n      phase = 'COMPLETED';\n    }\n\n    if (phase !== 'PRE_DRAG') {\n      completed();\n      !(phase === 'PRE_DRAG') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot lift in phase \" + phase) : invariant(false) : void 0;\n    }\n\n    store.dispatch(lift(args.liftActionArgs));\n    phase = 'DRAGGING';\n\n    function finish(reason, options) {\n      if (options === void 0) {\n        options = {\n          shouldBlockNextClick: false\n        };\n      }\n\n      args.cleanup();\n\n      if (options.shouldBlockNextClick) {\n        var unbind = bindEvents(window, [{\n          eventName: 'click',\n          fn: preventDefault,\n          options: {\n            once: true,\n            passive: false,\n            capture: true\n          }\n        }]);\n        setTimeout(unbind);\n      }\n\n      completed();\n      store.dispatch(drop({\n        reason: reason\n      }));\n    }\n\n    return _extends({\n      isActive: function isActive() {\n        return _isActive({\n          expected: 'DRAGGING',\n          phase: phase,\n          isLockActive: isLockActive,\n          shouldWarn: false\n        });\n      },\n      shouldRespectForcePress: getShouldRespectForcePress,\n      drop: function drop(options) {\n        return finish('DROP', options);\n      },\n      cancel: function cancel(options) {\n        return finish('CANCEL', options);\n      }\n    }, args.actions);\n  }\n\n  function fluidLift(clientSelection) {\n    var move$1 = rafSchd(function (client) {\n      tryDispatchWhenDragging(function () {\n        return move({\n          client: client\n        });\n      });\n    });\n    var api = lift$1({\n      liftActionArgs: {\n        id: draggableId,\n        clientSelection: clientSelection,\n        movementMode: 'FLUID'\n      },\n      cleanup: function cleanup() {\n        return move$1.cancel();\n      },\n      actions: {\n        move: move$1\n      }\n    });\n    return _extends({}, api, {\n      move: move$1\n    });\n  }\n\n  function snapLift() {\n    var actions = {\n      moveUp: function moveUp$1() {\n        return tryDispatchWhenDragging(moveUp);\n      },\n      moveRight: function moveRight$1() {\n        return tryDispatchWhenDragging(moveRight);\n      },\n      moveDown: function moveDown$1() {\n        return tryDispatchWhenDragging(moveDown);\n      },\n      moveLeft: function moveLeft$1() {\n        return tryDispatchWhenDragging(moveLeft);\n      }\n    };\n    return lift$1({\n      liftActionArgs: {\n        id: draggableId,\n        clientSelection: getBorderBoxCenterPosition(el),\n        movementMode: 'SNAP'\n      },\n      cleanup: noop,\n      actions: actions\n    });\n  }\n\n  function abortPreDrag() {\n    var shouldRelease = _isActive({\n      expected: 'PRE_DRAG',\n      phase: phase,\n      isLockActive: isLockActive,\n      shouldWarn: true\n    });\n\n    if (shouldRelease) {\n      lockAPI.release();\n    }\n  }\n\n  var preDrag = {\n    isActive: function isActive() {\n      return _isActive({\n        expected: 'PRE_DRAG',\n        phase: phase,\n        isLockActive: isLockActive,\n        shouldWarn: false\n      });\n    },\n    shouldRespectForcePress: getShouldRespectForcePress,\n    fluidLift: fluidLift,\n    snapLift: snapLift,\n    abort: abortPreDrag\n  };\n  return preDrag;\n}\n\nvar defaultSensors = [useMouseSensor, useKeyboardSensor, useMouseSensor$1];\nfunction useSensorMarshal(_ref4) {\n  var contextId = _ref4.contextId,\n      store = _ref4.store,\n      registry = _ref4.registry,\n      customSensors = _ref4.customSensors,\n      enableDefaultSensors = _ref4.enableDefaultSensors;\n  var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);\n  var lockAPI = React.useState(function () {\n    return create();\n  })[0];\n  var tryAbandonLock = useMemoOne.useCallback(function tryAbandonLock(previous, current) {\n    if (previous.isDragging && !current.isDragging) {\n      lockAPI.tryAbandon();\n    }\n  }, [lockAPI]);\n  useIsomorphicLayoutEffect(function listenToStore() {\n    var previous = store.getState();\n    var unsubscribe = store.subscribe(function () {\n      var current = store.getState();\n      tryAbandonLock(previous, current);\n      previous = current;\n    });\n    return unsubscribe;\n  }, [lockAPI, store, tryAbandonLock]);\n  useIsomorphicLayoutEffect(function () {\n    return lockAPI.tryAbandon;\n  }, [lockAPI.tryAbandon]);\n  var canGetLock = useMemoOne.useCallback(function (draggableId) {\n    return canStart({\n      lockAPI: lockAPI,\n      registry: registry,\n      store: store,\n      draggableId: draggableId\n    });\n  }, [lockAPI, registry, store]);\n  var tryGetLock = useMemoOne.useCallback(function (draggableId, forceStop, options) {\n    return tryStart({\n      lockAPI: lockAPI,\n      registry: registry,\n      contextId: contextId,\n      store: store,\n      draggableId: draggableId,\n      forceSensorStop: forceStop,\n      sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n    });\n  }, [contextId, lockAPI, registry, store]);\n  var findClosestDraggableId = useMemoOne.useCallback(function (event) {\n    return tryGetClosestDraggableIdFromEvent(contextId, event);\n  }, [contextId]);\n  var findOptionsForDraggable = useMemoOne.useCallback(function (id) {\n    var entry = registry.draggable.findById(id);\n    return entry ? entry.options : null;\n  }, [registry.draggable]);\n  var tryReleaseLock = useMemoOne.useCallback(lockAPI.tryAbandon, [lockAPI]);\n  var isLockClaimed = useMemoOne.useCallback(lockAPI.isClaimed, [lockAPI]);\n  var api = useMemoOne.useMemo(function () {\n    return {\n      canGetLock: canGetLock,\n      tryGetLock: tryGetLock,\n      findClosestDraggableId: findClosestDraggableId,\n      findOptionsForDraggable: findOptionsForDraggable,\n      tryReleaseLock: tryReleaseLock,\n      isLockClaimed: isLockClaimed\n    };\n  }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);\n  useValidateSensorHooks(useSensors);\n\n  for (var i = 0; i < useSensors.length; i++) {\n    useSensors[i](api);\n  }\n}\n\nvar createResponders = function createResponders(props) {\n  return {\n    onBeforeDragStart: props.onBeforeDragStart,\n    onDragStart: props.onDragStart,\n    onDragEnd: props.onDragEnd,\n    onDragUpdate: props.onDragUpdate\n  };\n};\n\nfunction getStore(lazyRef) {\n  !lazyRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find store from lazy ref') : invariant(false) : void 0;\n  return lazyRef.current;\n}\n\nfunction App(props) {\n  var contextId = props.contextId,\n      setCallbacks = props.setCallbacks,\n      sensors = props.sensors,\n      nonce = props.nonce,\n      liftInstruction = props.liftInstruction;\n  var lazyStoreRef = React.useRef(null);\n  useStartupValidation();\n  var lastPropsRef = usePrevious(props);\n  var getResponders = useMemoOne.useCallback(function () {\n    return createResponders(lastPropsRef.current);\n  }, [lastPropsRef]);\n  var announce = useAnnouncer(contextId);\n  var liftInstructionId = useLiftInstruction(contextId, liftInstruction);\n  var styleMarshal = useStyleMarshal(contextId, nonce);\n  var lazyDispatch = useMemoOne.useCallback(function (action) {\n    getStore(lazyStoreRef).dispatch(action);\n  }, []);\n  var marshalCallbacks = useMemoOne.useMemo(function () {\n    return redux.bindActionCreators({\n      publishWhileDragging: publishWhileDragging,\n      updateDroppableScroll: updateDroppableScroll,\n      updateDroppableIsEnabled: updateDroppableIsEnabled,\n      updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n      collectionStarting: collectionStarting\n    }, lazyDispatch);\n  }, [lazyDispatch]);\n  var registry = useRegistry();\n  var dimensionMarshal = useMemoOne.useMemo(function () {\n    return createDimensionMarshal(registry, marshalCallbacks);\n  }, [registry, marshalCallbacks]);\n  var autoScroller = useMemoOne.useMemo(function () {\n    return createAutoScroller(_extends({\n      scrollWindow: scrollWindow,\n      scrollDroppable: dimensionMarshal.scrollDroppable\n    }, redux.bindActionCreators({\n      move: move\n    }, lazyDispatch)));\n  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);\n  var focusMarshal = useFocusMarshal(contextId);\n  var store = useMemoOne.useMemo(function () {\n    return createStore({\n      announce: announce,\n      autoScroller: autoScroller,\n      dimensionMarshal: dimensionMarshal,\n      focusMarshal: focusMarshal,\n      getResponders: getResponders,\n      styleMarshal: styleMarshal\n    });\n  }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n      process.env.NODE_ENV !== \"production\" ? warning('unexpected store change') : void 0;\n    }\n  }\n\n  lazyStoreRef.current = store;\n  var tryResetStore = useMemoOne.useCallback(function () {\n    var current = getStore(lazyStoreRef);\n    var state = current.getState();\n\n    if (state.phase !== 'IDLE') {\n      current.dispatch(flush());\n    }\n  }, []);\n  var isDragging = useMemoOne.useCallback(function () {\n    var state = getStore(lazyStoreRef).getState();\n    return state.isDragging || state.phase === 'DROP_ANIMATING';\n  }, []);\n  var appCallbacks = useMemoOne.useMemo(function () {\n    return {\n      isDragging: isDragging,\n      tryAbort: tryResetStore\n    };\n  }, [isDragging, tryResetStore]);\n  setCallbacks(appCallbacks);\n  var getCanLift = useMemoOne.useCallback(function (id) {\n    return canStartDrag(getStore(lazyStoreRef).getState(), id);\n  }, []);\n  var getIsMovementAllowed = useMemoOne.useCallback(function () {\n    return isMovementAllowed(getStore(lazyStoreRef).getState());\n  }, []);\n  var appContext = useMemoOne.useMemo(function () {\n    return {\n      marshal: dimensionMarshal,\n      focus: focusMarshal,\n      contextId: contextId,\n      canLift: getCanLift,\n      isMovementAllowed: getIsMovementAllowed,\n      liftInstructionId: liftInstructionId,\n      registry: registry\n    };\n  }, [contextId, dimensionMarshal, focusMarshal, getCanLift, getIsMovementAllowed, liftInstructionId, registry]);\n  useSensorMarshal({\n    contextId: contextId,\n    store: store,\n    registry: registry,\n    customSensors: sensors,\n    enableDefaultSensors: props.enableDefaultSensors !== false\n  });\n  React.useEffect(function () {\n    return tryResetStore;\n  }, [tryResetStore]);\n  return React__default.createElement(AppContext.Provider, {\n    value: appContext\n  }, React__default.createElement(reactRedux.Provider, {\n    context: StoreContext,\n    store: store\n  }, props.children));\n}\n\nvar instanceCount = 0;\nfunction resetServerContext() {\n  instanceCount = 0;\n}\nfunction DragDropContext(props) {\n  var contextId = useMemoOne.useMemo(function () {\n    return \"\" + instanceCount++;\n  }, []);\n  var liftInstruction = props.liftInstruction || preset.liftInstruction;\n  return React__default.createElement(ErrorBoundary, null, function (setCallbacks) {\n    return React__default.createElement(App, {\n      nonce: props.nonce,\n      contextId: contextId,\n      setCallbacks: setCallbacks,\n      liftInstruction: liftInstruction,\n      enableDefaultSensors: props.enableDefaultSensors,\n      sensors: props.sensors,\n      onBeforeDragStart: props.onBeforeDragStart,\n      onDragStart: props.onDragStart,\n      onDragUpdate: props.onDragUpdate,\n      onDragEnd: props.onDragEnd\n    }, props.children);\n  });\n}\n\nvar isEqual$1 = function isEqual(base) {\n  return function (value) {\n    return base === value;\n  };\n};\n\nvar isScroll = isEqual$1('scroll');\nvar isAuto = isEqual$1('auto');\nvar isVisible$1 = isEqual$1('visible');\n\nvar isEither = function isEither(overflow, fn) {\n  return fn(overflow.overflowX) || fn(overflow.overflowY);\n};\n\nvar isBoth = function isBoth(overflow, fn) {\n  return fn(overflow.overflowX) && fn(overflow.overflowY);\n};\n\nvar isElementScrollable = function isElementScrollable(el) {\n  var style = window.getComputedStyle(el);\n  var overflow = {\n    overflowX: style.overflowX,\n    overflowY: style.overflowY\n  };\n  return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\n\nvar isBodyScrollable = function isBodyScrollable() {\n  if (process.env.NODE_ENV === 'production') {\n    return false;\n  }\n\n  var body = getBodyElement();\n  var html = document.documentElement;\n  !html ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n\n  if (!isElementScrollable(body)) {\n    return false;\n  }\n\n  var htmlStyle = window.getComputedStyle(html);\n  var htmlOverflow = {\n    overflowX: htmlStyle.overflowX,\n    overflowY: htmlStyle.overflowY\n  };\n\n  if (isBoth(htmlOverflow, isVisible$1)) {\n    return false;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    We have detected that your <body> element might be a scroll container.\\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\\n\\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\\n    we will be treating the <body> as *not* a scroll container\\n\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\\n  \") : void 0;\n  return false;\n};\n\nvar getClosestScrollable = function getClosestScrollable(el) {\n  if (el == null) {\n    return null;\n  }\n\n  if (el === document.body) {\n    return isBodyScrollable() ? el : null;\n  }\n\n  if (el === document.documentElement) {\n    return null;\n  }\n\n  if (!isElementScrollable(el)) {\n    return getClosestScrollable(el.parentElement);\n  }\n\n  return el;\n};\n\nvar checkForNestedScrollContainers = (function (scrollable) {\n  if (!scrollable) {\n    return;\n  }\n\n  var anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n\n  if (!anotherScrollParent) {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    Droppable: unsupported nested scroll container detected.\\n    A Droppable can only have one scroll parent (which can be itself)\\n    Nested scroll containers are currently not supported.\\n\\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\\n  \") : void 0;\n});\n\nvar getScroll$1 = (function (el) {\n  return {\n    x: el.scrollLeft,\n    y: el.scrollTop\n  };\n});\n\nvar getIsFixed = function getIsFixed(el) {\n  if (!el) {\n    return false;\n  }\n\n  var style = window.getComputedStyle(el);\n\n  if (style.position === 'fixed') {\n    return true;\n  }\n\n  return getIsFixed(el.parentElement);\n};\n\nvar getEnv = (function (start) {\n  var closestScrollable = getClosestScrollable(start);\n  var isFixedOnPage = getIsFixed(start);\n  return {\n    closestScrollable: closestScrollable,\n    isFixedOnPage: isFixedOnPage\n  };\n});\n\nvar getDroppableDimension = (function (_ref) {\n  var descriptor = _ref.descriptor,\n      isEnabled = _ref.isEnabled,\n      isCombineEnabled = _ref.isCombineEnabled,\n      isFixedOnPage = _ref.isFixedOnPage,\n      direction = _ref.direction,\n      client = _ref.client,\n      page = _ref.page,\n      closest = _ref.closest;\n\n  var frame = function () {\n    if (!closest) {\n      return null;\n    }\n\n    var scrollSize = closest.scrollSize,\n        frameClient = closest.client;\n    var maxScroll = getMaxScroll({\n      scrollHeight: scrollSize.scrollHeight,\n      scrollWidth: scrollSize.scrollWidth,\n      height: frameClient.paddingBox.height,\n      width: frameClient.paddingBox.width\n    });\n    return {\n      pageMarginBox: closest.page.marginBox,\n      frameClient: frameClient,\n      scrollSize: scrollSize,\n      shouldClipSubject: closest.shouldClipSubject,\n      scroll: {\n        initial: closest.scroll,\n        current: closest.scroll,\n        max: maxScroll,\n        diff: {\n          value: origin,\n          displacement: origin\n        }\n      }\n    };\n  }();\n\n  var axis = direction === 'vertical' ? vertical : horizontal;\n  var subject = getSubject({\n    page: page,\n    withPlaceholder: null,\n    axis: axis,\n    frame: frame\n  });\n  var dimension = {\n    descriptor: descriptor,\n    isCombineEnabled: isCombineEnabled,\n    isFixedOnPage: isFixedOnPage,\n    axis: axis,\n    isEnabled: isEnabled,\n    client: client,\n    page: page,\n    frame: frame,\n    subject: subject\n  };\n  return dimension;\n});\n\nvar getClient = function getClient(targetRef, closestScrollable) {\n  var base = cssBoxModel.getBox(targetRef);\n\n  if (!closestScrollable) {\n    return base;\n  }\n\n  if (targetRef !== closestScrollable) {\n    return base;\n  }\n\n  var top = base.paddingBox.top - closestScrollable.scrollTop;\n  var left = base.paddingBox.left - closestScrollable.scrollLeft;\n  var bottom = top + closestScrollable.scrollHeight;\n  var right = left + closestScrollable.scrollWidth;\n  var paddingBox = {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n  var borderBox = cssBoxModel.expand(paddingBox, base.border);\n  var client = cssBoxModel.createBox({\n    borderBox: borderBox,\n    margin: base.margin,\n    border: base.border,\n    padding: base.padding\n  });\n  return client;\n};\n\nvar getDimension = (function (_ref) {\n  var ref = _ref.ref,\n      descriptor = _ref.descriptor,\n      env = _ref.env,\n      windowScroll = _ref.windowScroll,\n      direction = _ref.direction,\n      isDropDisabled = _ref.isDropDisabled,\n      isCombineEnabled = _ref.isCombineEnabled,\n      shouldClipSubject = _ref.shouldClipSubject;\n  var closestScrollable = env.closestScrollable;\n  var client = getClient(ref, closestScrollable);\n  var page = cssBoxModel.withScroll(client, windowScroll);\n\n  var closest = function () {\n    if (!closestScrollable) {\n      return null;\n    }\n\n    var frameClient = cssBoxModel.getBox(closestScrollable);\n    var scrollSize = {\n      scrollHeight: closestScrollable.scrollHeight,\n      scrollWidth: closestScrollable.scrollWidth\n    };\n    return {\n      client: frameClient,\n      page: cssBoxModel.withScroll(frameClient, windowScroll),\n      scroll: getScroll$1(closestScrollable),\n      scrollSize: scrollSize,\n      shouldClipSubject: shouldClipSubject\n    };\n  }();\n\n  var dimension = getDroppableDimension({\n    descriptor: descriptor,\n    isEnabled: !isDropDisabled,\n    isCombineEnabled: isCombineEnabled,\n    isFixedOnPage: env.isFixedOnPage,\n    direction: direction,\n    client: client,\n    page: page,\n    closest: closest\n  });\n  return dimension;\n});\n\nvar immediate = {\n  passive: false\n};\nvar delayed = {\n  passive: true\n};\nvar getListenerOptions = (function (options) {\n  return options.shouldPublishImmediately ? immediate : delayed;\n});\n\nfunction useRequiredContext(Context) {\n  var result = React.useContext(Context);\n  !result ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find required context') : invariant(false) : void 0;\n  return result;\n}\n\nvar count = 0;\nfunction useUniqueId(prefix) {\n  var countRef = React.useRef(count++);\n  return prefix + \"::\" + countRef.current;\n}\n\nvar getClosestScrollableFromDrag = function getClosestScrollableFromDrag(dragging) {\n  return dragging && dragging.env.closestScrollable || null;\n};\n\nfunction useDroppablePublisher(args) {\n  var whileDraggingRef = React.useRef(null);\n  var appContext = useRequiredContext(AppContext);\n  var uniqueId = useUniqueId('droppable');\n  var registry = appContext.registry,\n      marshal = appContext.marshal;\n  var previousRef = usePrevious(args);\n  var descriptor = useMemoOne.useMemo(function () {\n    return {\n      id: args.droppableId,\n      type: args.type,\n      mode: args.mode\n    };\n  }, [args.droppableId, args.mode, args.type]);\n  var publishedDescriptorRef = React.useRef(descriptor);\n  var memoizedUpdateScroll = useMemoOne.useMemo(function () {\n    return memoizeOne(function (x, y) {\n      !whileDraggingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only update scroll when dragging') : invariant(false) : void 0;\n      var scroll = {\n        x: x,\n        y: y\n      };\n      marshal.updateDroppableScroll(descriptor.id, scroll);\n    });\n  }, [descriptor.id, marshal]);\n  var getClosestScroll = useMemoOne.useCallback(function () {\n    var dragging = whileDraggingRef.current;\n\n    if (!dragging || !dragging.env.closestScrollable) {\n      return origin;\n    }\n\n    return getScroll$1(dragging.env.closestScrollable);\n  }, []);\n  var updateScroll = useMemoOne.useCallback(function () {\n    var scroll = getClosestScroll();\n    memoizedUpdateScroll(scroll.x, scroll.y);\n  }, [getClosestScroll, memoizedUpdateScroll]);\n  var scheduleScrollUpdate = useMemoOne.useMemo(function () {\n    return rafSchd(updateScroll);\n  }, [updateScroll]);\n  var onClosestScroll = useMemoOne.useCallback(function () {\n    var dragging = whileDraggingRef.current;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find scroll options while scrolling') : invariant(false) : void 0;\n    var options = dragging.scrollOptions;\n\n    if (options.shouldPublishImmediately) {\n      updateScroll();\n      return;\n    }\n\n    scheduleScrollUpdate();\n  }, [scheduleScrollUpdate, updateScroll]);\n  var getDimensionAndWatchScroll = useMemoOne.useCallback(function (windowScroll, options) {\n    !!whileDraggingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot collect a droppable while a drag is occurring') : invariant(false) : void 0;\n    var previous = previousRef.current;\n    var ref = previous.getDroppableRef();\n    !ref ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot collect without a droppable ref') : invariant(false) : void 0;\n    var env = getEnv(ref);\n    var dragging = {\n      ref: ref,\n      descriptor: descriptor,\n      env: env,\n      scrollOptions: options\n    };\n    whileDraggingRef.current = dragging;\n    var dimension = getDimension({\n      ref: ref,\n      descriptor: descriptor,\n      env: env,\n      windowScroll: windowScroll,\n      direction: previous.direction,\n      isDropDisabled: previous.isDropDisabled,\n      isCombineEnabled: previous.isCombineEnabled,\n      shouldClipSubject: !previous.ignoreContainerClipping\n    });\n    var scrollable = env.closestScrollable;\n\n    if (scrollable) {\n      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n      scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkForNestedScrollContainers(scrollable);\n      }\n    }\n\n    return dimension;\n  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);\n  var getScrollWhileDragging = useMemoOne.useCallback(function () {\n    var dragging = whileDraggingRef.current;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only recollect Droppable client for Droppables that have a scroll container') : invariant(false) : void 0;\n    return getScroll$1(closest);\n  }, []);\n  var dragStopped = useMemoOne.useCallback(function () {\n    var dragging = whileDraggingRef.current;\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot stop drag when no active drag') : invariant(false) : void 0;\n    var closest = getClosestScrollableFromDrag(dragging);\n    whileDraggingRef.current = null;\n\n    if (!closest) {\n      return;\n    }\n\n    scheduleScrollUpdate.cancel();\n    closest.removeAttribute(scrollContainer.contextId);\n    closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n  }, [onClosestScroll, scheduleScrollUpdate]);\n  var scroll = useMemoOne.useCallback(function (change) {\n    var dragging = whileDraggingRef.current;\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot scroll when there is no drag') : invariant(false) : void 0;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !closest ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : invariant(false) : void 0;\n    closest.scrollTop += change.y;\n    closest.scrollLeft += change.x;\n  }, []);\n  var callbacks = useMemoOne.useMemo(function () {\n    return {\n      getDimensionAndWatchScroll: getDimensionAndWatchScroll,\n      getScrollWhileDragging: getScrollWhileDragging,\n      dragStopped: dragStopped,\n      scroll: scroll\n    };\n  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll]);\n  var entry = useMemoOne.useMemo(function () {\n    return {\n      uniqueId: uniqueId,\n      descriptor: descriptor,\n      callbacks: callbacks\n    };\n  }, [callbacks, descriptor, uniqueId]);\n  useIsomorphicLayoutEffect(function () {\n    publishedDescriptorRef.current = entry.descriptor;\n    registry.droppable.register(entry);\n    return function () {\n      if (whileDraggingRef.current) {\n        process.env.NODE_ENV !== \"production\" ? warning('Unsupported: changing the droppableId or type of a Droppable during a drag') : void 0;\n        dragStopped();\n      }\n\n      registry.droppable.unregister(entry);\n    };\n  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);\n  useIsomorphicLayoutEffect(function () {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n\n    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n  }, [args.isDropDisabled, marshal]);\n  useIsomorphicLayoutEffect(function () {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n\n    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n  }, [args.isCombineEnabled, marshal]);\n}\n\nfunction noop$2() {}\n\nvar empty = {\n  width: 0,\n  height: 0,\n  margin: noSpacing\n};\n\nvar getSize = function getSize(_ref) {\n  var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount,\n      placeholder = _ref.placeholder,\n      animate = _ref.animate;\n\n  if (isAnimatingOpenOnMount) {\n    return empty;\n  }\n\n  if (animate === 'close') {\n    return empty;\n  }\n\n  return {\n    height: placeholder.client.borderBox.height,\n    width: placeholder.client.borderBox.width,\n    margin: placeholder.client.margin\n  };\n};\n\nvar getStyle = function getStyle(_ref2) {\n  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount,\n      placeholder = _ref2.placeholder,\n      animate = _ref2.animate;\n  var size = getSize({\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n    placeholder: placeholder,\n    animate: animate\n  });\n  return {\n    display: placeholder.display,\n    boxSizing: 'border-box',\n    width: size.width,\n    height: size.height,\n    marginTop: size.margin.top,\n    marginRight: size.margin.right,\n    marginBottom: size.margin.bottom,\n    marginLeft: size.margin.left,\n    flexShrink: '0',\n    flexGrow: '0',\n    pointerEvents: 'none',\n    transition: animate !== 'none' ? transitions.placeholder : null\n  };\n};\n\nfunction Placeholder(props) {\n  var animateOpenTimerRef = React.useRef(null);\n  var tryClearAnimateOpenTimer = useMemoOne.useCallback(function () {\n    if (!animateOpenTimerRef.current) {\n      return;\n    }\n\n    clearTimeout(animateOpenTimerRef.current);\n    animateOpenTimerRef.current = null;\n  }, []);\n  var animate = props.animate,\n      onTransitionEnd = props.onTransitionEnd,\n      onClose = props.onClose,\n      contextId = props.contextId;\n\n  var _useState = React.useState(props.animate === 'open'),\n      isAnimatingOpenOnMount = _useState[0],\n      setIsAnimatingOpenOnMount = _useState[1];\n\n  React.useEffect(function () {\n    if (!isAnimatingOpenOnMount) {\n      return noop$2;\n    }\n\n    if (animate !== 'open') {\n      tryClearAnimateOpenTimer();\n      setIsAnimatingOpenOnMount(false);\n      return noop$2;\n    }\n\n    if (animateOpenTimerRef.current) {\n      return noop$2;\n    }\n\n    animateOpenTimerRef.current = setTimeout(function () {\n      animateOpenTimerRef.current = null;\n      setIsAnimatingOpenOnMount(false);\n    });\n    return tryClearAnimateOpenTimer;\n  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);\n  var onSizeChangeEnd = useMemoOne.useCallback(function (event) {\n    if (event.propertyName !== 'height') {\n      return;\n    }\n\n    onTransitionEnd();\n\n    if (animate === 'close') {\n      onClose();\n    }\n  }, [animate, onClose, onTransitionEnd]);\n  var style = getStyle({\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n    animate: props.animate,\n    placeholder: props.placeholder\n  });\n  return React__default.createElement(props.placeholder.tagName, {\n    style: style,\n    'data-rbd-placeholder-context-id': contextId,\n    onTransitionEnd: onSizeChangeEnd,\n    ref: props.innerRef\n  });\n}\n\nvar Placeholder$1 = React__default.memo(Placeholder);\n\nvar DroppableContext = React__default.createContext(null);\n\nfunction checkIsValidInnerRef(el) {\n  !(el && isHtmlElement(el)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"\\n    provided.innerRef has not been provided with a HTMLElement.\\n\\n    You can find a guide on using the innerRef callback functions at:\\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\\n  \") : invariant(false) : void 0;\n}\n\nfunction isBoolean(value) {\n  return typeof value === 'boolean';\n}\n\nfunction runChecks(args, checks) {\n  checks.forEach(function (check) {\n    return check(args);\n  });\n}\n\nvar shared = [function required(_ref) {\n  var props = _ref.props;\n  !props.droppableId ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'A Droppable requires a droppableId prop') : invariant(false) : void 0;\n  !(typeof props.droppableId === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"A Droppable requires a [string] droppableId. Provided: [\" + typeof props.droppableId + \"]\") : invariant(false) : void 0;\n}, function _boolean(_ref2) {\n  var props = _ref2.props;\n  !isBoolean(props.isDropDisabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isDropDisabled must be a boolean') : invariant(false) : void 0;\n  !isBoolean(props.isCombineEnabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isCombineEnabled must be a boolean') : invariant(false) : void 0;\n  !isBoolean(props.ignoreContainerClipping) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ignoreContainerClipping must be a boolean') : invariant(false) : void 0;\n}, function ref(_ref3) {\n  var getDroppableRef = _ref3.getDroppableRef;\n  checkIsValidInnerRef(getDroppableRef());\n}];\nvar standard = [function placeholder(_ref4) {\n  var props = _ref4.props,\n      getPlaceholderRef = _ref4.getPlaceholderRef;\n\n  if (!props.placeholder) {\n    return;\n  }\n\n  var ref = getPlaceholderRef();\n\n  if (ref) {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Droppable setup issue [droppableId: \\\"\" + props.droppableId + \"\\\"]:\\n      DroppableProvided > placeholder could not be found.\\n\\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\\n    \") : void 0;\n}];\nvar virtual = [function hasClone(_ref5) {\n  var props = _ref5.props;\n  !props.renderClone ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Must provide a clone render function (renderClone) for virtual lists') : invariant(false) : void 0;\n}, function hasNoPlaceholder(_ref6) {\n  var getPlaceholderRef = _ref6.getPlaceholderRef;\n  !!getPlaceholderRef() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected virtual list to not have a placeholder') : invariant(false) : void 0;\n}];\nfunction useValidation(args) {\n  useDevSetupWarning(function () {\n    runChecks(args, shared);\n\n    if (args.props.mode === 'standard') {\n      runChecks(args, standard);\n    }\n\n    if (args.props.mode === 'virtual') {\n      runChecks(args, virtual);\n    }\n  });\n}\n\nvar AnimateInOut = function (_React$PureComponent) {\n  _inheritsLoose(AnimateInOut, _React$PureComponent);\n\n  function AnimateInOut() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\n    _this.state = {\n      isVisible: Boolean(_this.props.on),\n      data: _this.props.on,\n      animate: _this.props.shouldAnimate && _this.props.on ? 'open' : 'none'\n    };\n\n    _this.onClose = function () {\n      if (_this.state.animate !== 'close') {\n        return;\n      }\n\n      _this.setState({\n        isVisible: false\n      });\n    };\n\n    return _this;\n  }\n\n  AnimateInOut.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    if (!props.shouldAnimate) {\n      return {\n        isVisible: Boolean(props.on),\n        data: props.on,\n        animate: 'none'\n      };\n    }\n\n    if (props.on) {\n      return {\n        isVisible: true,\n        data: props.on,\n        animate: 'open'\n      };\n    }\n\n    if (state.isVisible) {\n      return {\n        isVisible: true,\n        data: state.data,\n        animate: 'close'\n      };\n    }\n\n    return {\n      isVisible: false,\n      animate: 'close',\n      data: null\n    };\n  };\n\n  var _proto = AnimateInOut.prototype;\n\n  _proto.render = function render() {\n    if (!this.state.isVisible) {\n      return null;\n    }\n\n    var provided = {\n      onClose: this.onClose,\n      data: this.state.data,\n      animate: this.state.animate\n    };\n    return this.props.children(provided);\n  };\n\n  return AnimateInOut;\n}(React__default.PureComponent);\n\nvar zIndexOptions = {\n  dragging: 5000,\n  dropAnimating: 4500\n};\n\nvar getDraggingTransition = function getDraggingTransition(shouldAnimateDragMovement, dropping) {\n  if (dropping) {\n    return transitions.drop(dropping.duration);\n  }\n\n  if (shouldAnimateDragMovement) {\n    return transitions.snap;\n  }\n\n  return transitions.fluid;\n};\n\nvar getDraggingOpacity = function getDraggingOpacity(isCombining, isDropAnimating) {\n  if (!isCombining) {\n    return null;\n  }\n\n  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\n\nvar getShouldDraggingAnimate = function getShouldDraggingAnimate(dragging) {\n  if (dragging.forceShouldAnimate != null) {\n    return dragging.forceShouldAnimate;\n  }\n\n  return dragging.mode === 'SNAP';\n};\n\nfunction getDraggingStyle(dragging) {\n  var dimension = dragging.dimension;\n  var box = dimension.client;\n  var offset = dragging.offset,\n      combineWith = dragging.combineWith,\n      dropping = dragging.dropping;\n  var isCombining = Boolean(combineWith);\n  var shouldAnimate = getShouldDraggingAnimate(dragging);\n  var isDropAnimating = Boolean(dropping);\n  var transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n  var style = {\n    position: 'fixed',\n    top: box.marginBox.top,\n    left: box.marginBox.left,\n    boxSizing: 'border-box',\n    width: box.borderBox.width,\n    height: box.borderBox.height,\n    transition: getDraggingTransition(shouldAnimate, dropping),\n    transform: transform,\n    opacity: getDraggingOpacity(isCombining, isDropAnimating),\n    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n    pointerEvents: 'none'\n  };\n  return style;\n}\n\nfunction getSecondaryStyle(secondary) {\n  return {\n    transform: transforms.moveTo(secondary.offset),\n    transition: secondary.shouldAnimateDisplacement ? null : 'none'\n  };\n}\n\nfunction getStyle$1(mapped) {\n  return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\n\nfunction getDimension$1(descriptor, el, windowScroll) {\n  if (windowScroll === void 0) {\n    windowScroll = origin;\n  }\n\n  var computedStyles = window.getComputedStyle(el);\n  var borderBox = el.getBoundingClientRect();\n  var client = cssBoxModel.calculateBox(borderBox, computedStyles);\n  var page = cssBoxModel.withScroll(client, windowScroll);\n  var placeholder = {\n    client: client,\n    tagName: el.tagName.toLowerCase(),\n    display: computedStyles.display\n  };\n  var displaceBy = {\n    x: client.marginBox.width,\n    y: client.marginBox.height\n  };\n  var dimension = {\n    descriptor: descriptor,\n    placeholder: placeholder,\n    displaceBy: displaceBy,\n    client: client,\n    page: page\n  };\n  return dimension;\n}\n\nfunction useDraggablePublisher(args) {\n  var uniqueId = useUniqueId('draggable');\n  var descriptor = args.descriptor,\n      registry = args.registry,\n      getDraggableRef = args.getDraggableRef,\n      canDragInteractiveElements = args.canDragInteractiveElements,\n      shouldRespectForcePress = args.shouldRespectForcePress,\n      isEnabled = args.isEnabled;\n  var options = useMemoOne.useMemo(function () {\n    return {\n      canDragInteractiveElements: canDragInteractiveElements,\n      shouldRespectForcePress: shouldRespectForcePress,\n      isEnabled: isEnabled\n    };\n  }, [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);\n  var getDimension = useMemoOne.useCallback(function (windowScroll) {\n    var el = getDraggableRef();\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get dimension when no ref is set') : invariant(false) : void 0;\n    return getDimension$1(descriptor, el, windowScroll);\n  }, [descriptor, getDraggableRef]);\n  var entry = useMemoOne.useMemo(function () {\n    return {\n      uniqueId: uniqueId,\n      descriptor: descriptor,\n      options: options,\n      getDimension: getDimension\n    };\n  }, [descriptor, getDimension, options, uniqueId]);\n  var publishedRef = React.useRef(entry);\n  var isFirstPublishRef = React.useRef(true);\n  useIsomorphicLayoutEffect(function () {\n    registry.draggable.register(publishedRef.current);\n    return function () {\n      return registry.draggable.unregister(publishedRef.current);\n    };\n  }, [registry.draggable]);\n  useIsomorphicLayoutEffect(function () {\n    if (isFirstPublishRef.current) {\n      isFirstPublishRef.current = false;\n      return;\n    }\n\n    var last = publishedRef.current;\n    publishedRef.current = entry;\n    registry.draggable.update(entry, last);\n  }, [entry, registry.draggable]);\n}\n\nfunction useValidation$1(props, contextId, getRef) {\n  useDevSetupWarning(function () {\n    function prefix(id) {\n      return \"Draggable[id: \" + id + \"]: \";\n    }\n\n    var id = props.draggableId;\n    !id ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Draggable requires a draggableId') : invariant(false) : void 0;\n    !(typeof id === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Draggable requires a [string] draggableId.\\n      Provided: [type: \" + typeof id + \"] (value: \" + id + \")\") : invariant(false) : void 0;\n    !_Number$isInteger(props.index) ? process.env.NODE_ENV !== \"production\" ? invariant(false, prefix(id) + \" requires an integer index prop\") : invariant(false) : void 0;\n\n    if (props.mapped.type === 'DRAGGING') {\n      return;\n    }\n\n    checkIsValidInnerRef(getRef());\n\n    if (props.isEnabled) {\n      !findDragHandle(contextId, id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, prefix(id) + \" Unable to find drag handle\") : invariant(false) : void 0;\n    }\n  });\n}\nfunction useClonePropValidation(isClone) {\n  useDev(function () {\n    var initialRef = React.useRef(isClone);\n    useDevSetupWarning(function () {\n      !(isClone === initialRef.current) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Draggable isClone prop value changed during component life') : invariant(false) : void 0;\n    }, [isClone]);\n  });\n}\n\nfunction preventHtml5Dnd(event) {\n  event.preventDefault();\n}\n\nfunction Draggable(props) {\n  var ref = React.useRef(null);\n  var setRef = useMemoOne.useCallback(function (el) {\n    ref.current = el;\n  }, []);\n  var getRef = useMemoOne.useCallback(function () {\n    return ref.current;\n  }, []);\n\n  var _useRequiredContext = useRequiredContext(AppContext),\n      contextId = _useRequiredContext.contextId,\n      liftInstructionId = _useRequiredContext.liftInstructionId,\n      registry = _useRequiredContext.registry;\n\n  var _useRequiredContext2 = useRequiredContext(DroppableContext),\n      type = _useRequiredContext2.type,\n      droppableId = _useRequiredContext2.droppableId;\n\n  var descriptor = useMemoOne.useMemo(function () {\n    return {\n      id: props.draggableId,\n      index: props.index,\n      type: type,\n      droppableId: droppableId\n    };\n  }, [props.draggableId, props.index, type, droppableId]);\n  var children = props.children,\n      draggableId = props.draggableId,\n      isEnabled = props.isEnabled,\n      shouldRespectForcePress = props.shouldRespectForcePress,\n      canDragInteractiveElements = props.canDragInteractiveElements,\n      isClone = props.isClone,\n      mapped = props.mapped,\n      dropAnimationFinishedAction = props.dropAnimationFinished;\n  useValidation$1(props, contextId, getRef);\n  useClonePropValidation(isClone);\n\n  if (!isClone) {\n    var forPublisher = useMemoOne.useMemo(function () {\n      return {\n        descriptor: descriptor,\n        registry: registry,\n        getDraggableRef: getRef,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress,\n        isEnabled: isEnabled\n      };\n    }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);\n    useDraggablePublisher(forPublisher);\n  }\n\n  var dragHandleProps = useMemoOne.useMemo(function () {\n    return isEnabled ? {\n      tabIndex: 0,\n      'data-rbd-drag-handle-draggable-id': draggableId,\n      'data-rbd-drag-handle-context-id': contextId,\n      'aria-labelledby': liftInstructionId,\n      draggable: false,\n      onDragStart: preventHtml5Dnd\n    } : null;\n  }, [contextId, draggableId, isEnabled, liftInstructionId]);\n  var onMoveEnd = useMemoOne.useCallback(function (event) {\n    if (mapped.type !== 'DRAGGING') {\n      return;\n    }\n\n    if (!mapped.dropping) {\n      return;\n    }\n\n    if (event.propertyName !== 'transform') {\n      return;\n    }\n\n    dropAnimationFinishedAction();\n  }, [dropAnimationFinishedAction, mapped]);\n  var provided = useMemoOne.useMemo(function () {\n    var style = getStyle$1(mapped);\n    var onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : null;\n    var result = {\n      innerRef: setRef,\n      draggableProps: {\n        'data-rbd-draggable-context-id': contextId,\n        'data-rbd-draggable-id': draggableId,\n        style: style,\n        onTransitionEnd: onTransitionEnd\n      },\n      dragHandleProps: dragHandleProps\n    };\n    return result;\n  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);\n  var rubric = useMemoOne.useMemo(function () {\n    return {\n      draggableId: descriptor.id,\n      type: descriptor.type,\n      source: {\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n      }\n    };\n  }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);\n  return children(provided, mapped.snapshot, rubric);\n}\n\nvar isStrictEqual = (function (a, b) {\n  return a === b;\n});\n\nvar whatIsDraggedOverFromResult = (function (result) {\n  var combine = result.combine,\n      destination = result.destination;\n\n  if (destination) {\n    return destination.droppableId;\n  }\n\n  if (combine) {\n    return combine.droppableId;\n  }\n\n  return null;\n});\n\nvar getCombineWithFromResult = function getCombineWithFromResult(result) {\n  return result.combine ? result.combine.draggableId : null;\n};\n\nvar getCombineWithFromImpact = function getCombineWithFromImpact(impact) {\n  return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;\n};\n\nfunction getDraggableSelector() {\n  var memoizedOffset = memoizeOne(function (x, y) {\n    return {\n      x: x,\n      y: y\n    };\n  });\n  var getMemoizedSnapshot = memoizeOne(function (mode, isClone, draggingOver, combineWith, dropping) {\n    return {\n      isDragging: true,\n      isClone: isClone,\n      isDropAnimating: Boolean(dropping),\n      dropAnimation: dropping,\n      mode: mode,\n      draggingOver: draggingOver,\n      combineWith: combineWith,\n      combineTargetFor: null\n    };\n  });\n  var getMemoizedProps = memoizeOne(function (offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {\n    return {\n      mapped: {\n        type: 'DRAGGING',\n        dropping: null,\n        draggingOver: draggingOver,\n        combineWith: combineWith,\n        mode: mode,\n        offset: offset,\n        dimension: dimension,\n        forceShouldAnimate: forceShouldAnimate,\n        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n      }\n    };\n  });\n\n  var selector = function selector(state, ownProps) {\n    if (state.isDragging) {\n      if (state.critical.draggable.id !== ownProps.draggableId) {\n        return null;\n      }\n\n      var offset = state.current.client.offset;\n      var dimension = state.dimensions.draggables[ownProps.draggableId];\n      var draggingOver = whatIsDraggedOver(state.impact);\n      var combineWith = getCombineWithFromImpact(state.impact);\n      var forceShouldAnimate = state.forceShouldAnimate;\n      return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (completed.result.draggableId !== ownProps.draggableId) {\n        return null;\n      }\n\n      var isClone = ownProps.isClone;\n      var _dimension = state.dimensions.draggables[ownProps.draggableId];\n      var result = completed.result;\n      var mode = result.mode;\n\n      var _draggingOver = whatIsDraggedOverFromResult(result);\n\n      var _combineWith = getCombineWithFromResult(result);\n\n      var duration = state.dropDuration;\n      var dropping = {\n        duration: duration,\n        curve: curves.drop,\n        moveTo: state.newHomeClientOffset,\n        opacity: _combineWith ? combine.opacity.drop : null,\n        scale: _combineWith ? combine.scale.drop : null\n      };\n      return {\n        mapped: {\n          type: 'DRAGGING',\n          offset: state.newHomeClientOffset,\n          dimension: _dimension,\n          dropping: dropping,\n          draggingOver: _draggingOver,\n          combineWith: _combineWith,\n          mode: mode,\n          forceShouldAnimate: null,\n          snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)\n        }\n      };\n    }\n\n    return null;\n  };\n\n  return selector;\n}\n\nfunction getSecondarySnapshot(combineTargetFor) {\n  return {\n    isDragging: false,\n    isDropAnimating: false,\n    isClone: false,\n    dropAnimation: null,\n    mode: null,\n    draggingOver: null,\n    combineTargetFor: combineTargetFor,\n    combineWith: null\n  };\n}\n\nvar atRest = {\n  mapped: {\n    type: 'SECONDARY',\n    offset: origin,\n    combineTargetFor: null,\n    shouldAnimateDisplacement: true,\n    snapshot: getSecondarySnapshot(null)\n  }\n};\n\nfunction getSecondarySelector() {\n  var memoizedOffset = memoizeOne(function (x, y) {\n    return {\n      x: x,\n      y: y\n    };\n  });\n  var getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);\n  var getMemoizedProps = memoizeOne(function (offset, combineTargetFor, shouldAnimateDisplacement) {\n    if (combineTargetFor === void 0) {\n      combineTargetFor = null;\n    }\n\n    return {\n      mapped: {\n        type: 'SECONDARY',\n        offset: offset,\n        combineTargetFor: combineTargetFor,\n        shouldAnimateDisplacement: shouldAnimateDisplacement,\n        snapshot: getMemoizedSnapshot(combineTargetFor)\n      }\n    };\n  });\n\n  var getFallback = function getFallback(combineTargetFor) {\n    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n  };\n\n  var getProps = function getProps(ownId, draggingId, impact, afterCritical) {\n    var visualDisplacement = impact.displaced.visible[ownId];\n    var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n    var combine = tryGetCombine(impact);\n    var combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n\n    if (!visualDisplacement) {\n      if (!isAfterCriticalInVirtualList) {\n        return getFallback(combineTargetFor);\n      }\n\n      if (impact.displaced.invisible[ownId]) {\n        return null;\n      }\n\n      var change = negate(afterCritical.displacedBy.point);\n\n      var _offset = memoizedOffset(change.x, change.y);\n\n      return getMemoizedProps(_offset, combineTargetFor, true);\n    }\n\n    if (isAfterCriticalInVirtualList) {\n      return getFallback(combineTargetFor);\n    }\n\n    var displaceBy = impact.displacedBy.point;\n    var offset = memoizedOffset(displaceBy.x, displaceBy.y);\n    return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n  };\n\n  var selector = function selector(state, ownProps) {\n    if (state.isDragging) {\n      if (state.critical.draggable.id === ownProps.draggableId) {\n        return null;\n      }\n\n      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (completed.result.draggableId === ownProps.draggableId) {\n        return null;\n      }\n\n      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n    }\n\n    return null;\n  };\n\n  return selector;\n}\n\nvar makeMapStateToProps = function makeMapStateToProps() {\n  var draggingSelector = getDraggableSelector();\n  var secondarySelector = getSecondarySelector();\n\n  var selector = function selector(state, ownProps) {\n    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n  };\n\n  return selector;\n};\nvar mapDispatchToProps = {\n  dropAnimationFinished: dropAnimationFinished\n};\nvar ConnectedDraggable = reactRedux.connect(makeMapStateToProps, mapDispatchToProps, null, {\n  context: StoreContext,\n  pure: true,\n  areStatePropsEqual: isStrictEqual\n})(Draggable);\n\nfunction PrivateDraggable(props) {\n  var droppableContext = useRequiredContext(DroppableContext);\n  var isUsingCloneFor = droppableContext.isUsingCloneFor;\n\n  if (isUsingCloneFor === props.draggableId && !props.isClone) {\n    return null;\n  }\n\n  return React__default.createElement(ConnectedDraggable, props);\n}\nfunction PublicDraggable(props) {\n  var isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;\n  var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n  var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n  return React__default.createElement(PrivateDraggable, _extends({}, props, {\n    isClone: false,\n    isEnabled: isEnabled,\n    canDragInteractiveElements: canDragInteractiveElements,\n    shouldRespectForcePress: shouldRespectForcePress\n  }));\n}\n\nfunction Droppable(props) {\n  var appContext = React.useContext(AppContext);\n  !appContext ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find app context') : invariant(false) : void 0;\n  var contextId = appContext.contextId,\n      isMovementAllowed = appContext.isMovementAllowed;\n  var droppableRef = React.useRef(null);\n  var placeholderRef = React.useRef(null);\n  var children = props.children,\n      droppableId = props.droppableId,\n      type = props.type,\n      mode = props.mode,\n      direction = props.direction,\n      ignoreContainerClipping = props.ignoreContainerClipping,\n      isDropDisabled = props.isDropDisabled,\n      isCombineEnabled = props.isCombineEnabled,\n      snapshot = props.snapshot,\n      useClone = props.useClone,\n      updateViewportMaxScroll = props.updateViewportMaxScroll,\n      getContainerForClone = props.getContainerForClone;\n  var getDroppableRef = useMemoOne.useCallback(function () {\n    return droppableRef.current;\n  }, []);\n  var setDroppableRef = useMemoOne.useCallback(function (value) {\n    droppableRef.current = value;\n  }, []);\n  var getPlaceholderRef = useMemoOne.useCallback(function () {\n    return placeholderRef.current;\n  }, []);\n  var setPlaceholderRef = useMemoOne.useCallback(function (value) {\n    placeholderRef.current = value;\n  }, []);\n  useValidation({\n    props: props,\n    getDroppableRef: getDroppableRef,\n    getPlaceholderRef: getPlaceholderRef\n  });\n  var onPlaceholderTransitionEnd = useMemoOne.useCallback(function () {\n    if (isMovementAllowed()) {\n      updateViewportMaxScroll({\n        maxScroll: getMaxWindowScroll()\n      });\n    }\n  }, [isMovementAllowed, updateViewportMaxScroll]);\n  useDroppablePublisher({\n    droppableId: droppableId,\n    type: type,\n    mode: mode,\n    direction: direction,\n    isDropDisabled: isDropDisabled,\n    isCombineEnabled: isCombineEnabled,\n    ignoreContainerClipping: ignoreContainerClipping,\n    getDroppableRef: getDroppableRef\n  });\n  var placeholder = React__default.createElement(AnimateInOut, {\n    on: props.placeholder,\n    shouldAnimate: props.shouldAnimatePlaceholder\n  }, function (_ref) {\n    var onClose = _ref.onClose,\n        data = _ref.data,\n        animate = _ref.animate;\n    return React__default.createElement(Placeholder$1, {\n      placeholder: data,\n      onClose: onClose,\n      innerRef: setPlaceholderRef,\n      animate: animate,\n      contextId: contextId,\n      onTransitionEnd: onPlaceholderTransitionEnd\n    });\n  });\n  var provided = useMemoOne.useMemo(function () {\n    return {\n      innerRef: setDroppableRef,\n      placeholder: placeholder,\n      droppableProps: {\n        'data-rbd-droppable-id': droppableId,\n        'data-rbd-droppable-context-id': contextId\n      }\n    };\n  }, [contextId, droppableId, placeholder, setDroppableRef]);\n  var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n  var droppableContext = useMemoOne.useMemo(function () {\n    return {\n      droppableId: droppableId,\n      type: type,\n      isUsingCloneFor: isUsingCloneFor\n    };\n  }, [droppableId, isUsingCloneFor, type]);\n\n  function getClone() {\n    if (!useClone) {\n      return null;\n    }\n\n    var dragging = useClone.dragging,\n        render = useClone.render;\n    var node = React__default.createElement(PrivateDraggable, {\n      draggableId: dragging.draggableId,\n      index: dragging.source.index,\n      isClone: true,\n      isEnabled: true,\n      shouldRespectForcePress: false,\n      canDragInteractiveElements: true\n    }, function (draggableProvided, draggableSnapshot) {\n      return render(draggableProvided, draggableSnapshot, dragging);\n    });\n    return ReactDOM.createPortal(node, getContainerForClone());\n  }\n\n  return React__default.createElement(DroppableContext.Provider, {\n    value: droppableContext\n  }, children(provided, snapshot), getClone());\n}\n\nvar isMatchingType = function isMatchingType(type, critical) {\n  return type === critical.droppable.type;\n};\n\nvar getDraggable = function getDraggable(critical, dimensions) {\n  return dimensions.draggables[critical.draggable.id];\n};\n\nvar makeMapStateToProps$1 = function makeMapStateToProps() {\n  var idleWithAnimation = {\n    placeholder: null,\n    shouldAnimatePlaceholder: true,\n    snapshot: {\n      isDraggingOver: false,\n      draggingOverWith: null,\n      draggingFromThisWith: null,\n      isUsingPlaceholder: false\n    },\n    useClone: null\n  };\n\n  var idleWithoutAnimation = _extends({}, idleWithAnimation, {\n    shouldAnimatePlaceholder: false\n  });\n\n  var getDraggableRubric = memoizeOne(function (descriptor) {\n    return {\n      draggableId: descriptor.id,\n      type: descriptor.type,\n      source: {\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n      }\n    };\n  });\n  var getMapProps = memoizeOne(function (id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {\n    var draggableId = dragging.descriptor.id;\n    var isHome = dragging.descriptor.droppableId === id;\n\n    if (isHome) {\n      var useClone = renderClone ? {\n        render: renderClone,\n        dragging: getDraggableRubric(dragging.descriptor)\n      } : null;\n      var _snapshot = {\n        isDraggingOver: isDraggingOverForConsumer,\n        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n        draggingFromThisWith: draggableId,\n        isUsingPlaceholder: true\n      };\n      return {\n        placeholder: dragging.placeholder,\n        shouldAnimatePlaceholder: false,\n        snapshot: _snapshot,\n        useClone: useClone\n      };\n    }\n\n    if (!isEnabled) {\n      return idleWithoutAnimation;\n    }\n\n    if (!isDraggingOverForImpact) {\n      return idleWithAnimation;\n    }\n\n    var snapshot = {\n      isDraggingOver: isDraggingOverForConsumer,\n      draggingOverWith: draggableId,\n      draggingFromThisWith: null,\n      isUsingPlaceholder: true\n    };\n    return {\n      placeholder: dragging.placeholder,\n      shouldAnimatePlaceholder: true,\n      snapshot: snapshot,\n      useClone: null\n    };\n  });\n\n  var selector = function selector(state, ownProps) {\n    var id = ownProps.droppableId;\n    var type = ownProps.type;\n    var isEnabled = !ownProps.isDropDisabled;\n    var renderClone = ownProps.renderClone;\n\n    if (state.isDragging) {\n      var critical = state.critical;\n\n      if (!isMatchingType(type, critical)) {\n        return idleWithoutAnimation;\n      }\n\n      var dragging = getDraggable(critical, state.dimensions);\n      var isDraggingOver = whatIsDraggedOver(state.impact) === id;\n      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (!isMatchingType(type, completed.critical)) {\n        return idleWithoutAnimation;\n      }\n\n      var _dragging = getDraggable(completed.critical, state.dimensions);\n\n      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);\n    }\n\n    if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {\n      var _completed = state.completed;\n\n      if (!isMatchingType(type, _completed.critical)) {\n        return idleWithoutAnimation;\n      }\n\n      var wasOver = whatIsDraggedOver(_completed.impact) === id;\n      var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === 'COMBINE');\n      var isHome = _completed.critical.droppable.id === id;\n\n      if (wasOver) {\n        return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n      }\n\n      if (isHome) {\n        return idleWithAnimation;\n      }\n\n      return idleWithoutAnimation;\n    }\n\n    return idleWithoutAnimation;\n  };\n\n  return selector;\n};\nvar mapDispatchToProps$1 = {\n  updateViewportMaxScroll: updateViewportMaxScroll\n};\n\nfunction getBody() {\n  !document.body ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'document.body is not ready') : invariant(false) : void 0;\n  return document.body;\n}\n\nvar defaultProps = {\n  mode: 'standard',\n  type: 'DEFAULT',\n  direction: 'vertical',\n  isDropDisabled: false,\n  isCombineEnabled: false,\n  ignoreContainerClipping: false,\n  renderClone: null,\n  getContainerForClone: getBody\n};\nvar ConnectedDroppable = reactRedux.connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n  context: StoreContext,\n  pure: true,\n  areStatePropsEqual: isStrictEqual\n})(Droppable);\nConnectedDroppable.defaultProps = defaultProps;\n\nexports.DragDropContext = DragDropContext;\nexports.Draggable = PublicDraggable;\nexports.Droppable = ConnectedDroppable;\nexports.resetServerContext = resetServerContext;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$redux$lib$redux","~$module$node_modules$$babel$runtime_corejs2$core_js$date$now","~$module$node_modules$memoize_one$dist$memoize_one_cjs","~$module$node_modules$raf_schd$dist$raf_schd_cjs","~$module$node_modules$css_box_model$dist$css_box_model_cjs","~$module$node_modules$react_redux$lib$index","~$module$node_modules$react_dom$index","~$module$node_modules$$babel$runtime_corejs2$core_js$number$is_integer","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$$babel$runtime_corejs2$core_js$object$keys","~$module$node_modules$$babel$runtime_corejs2$helpers$extends","~$module$node_modules$$babel$runtime_corejs2$helpers$inheritsLoose","~$module$node_modules$$babel$runtime_corejs2$core_js$object$values","~$module$node_modules$use_memo_one$dist$use_memo_one_cjs","~$module$node_modules$$babel$runtime_corejs2$core_js$object$assign"]],"~:properties",["^5",["abandon","release","resting","stop","contextId","scrollWidth","overflowX","callback","isVisibleThroughFrameFn","getDimensionAndWatchScroll","combineWithId","updateDroppableScroll","draggingFromThisWith","thresholds","message","isDropAnimating","updateDroppableIsEnabled","startPublishing","isUsingPlaceholder","getDraggableRef","unbind","pageBorderBoxCenterWithDroppableScrollChange","tryRecordFocus","shouldPublishImmediately","droppableProps","isActive","marginBottom","getScrollWhileDragging","crossAxisStart","snap","onLiftImpact","collectionStarting","cleanup","width","timerId","setPhase","combineWith","getDerivedStateFromProps","displaced","durationDampening","shouldUseTimeDampening","right","lastLocation","startScrollingFrom","passive","isWindowScrollAllowed","isDragging","uniqueId","top","isDraggingOver","getContainerForClone","curve","unregister","onWindowError","optgroup","destination","onClose","index","Draggable","once","offset","resetServerContext","cancel","callbacks","viewport","destinationId","isClaimed","height","margin","scale","combineTargetFor","tabIndex","distanceToEdges","overflowY","getCallbacks","marshal","draggingOverWith","shouldAnimate","stopPublishing","clip","dragging","wasCalled","closestScrollable","displaceBy","scrollLeft","ease","droppableId","scroll","tryAbort","findClosestDraggableId","placeholder","stopDampeningAt","textContent","borderBox","border","x","focus","startOfRange","placeholderSize","__esModule","isWaiting","removals","dragHandleProps","max","fluid","marginTop","outOfTheWay","padding","isAnimatingOpenOnMount","axis","isUsingCloneFor","option","combining","vertical","video","longPressTimerId","draggingOver","id","fn","flush","completed","dragStopped","transform","scrollSize","toString","shouldBlockNextClick","diff","snapshot","maxScroll","base","isMovementAllowed","lastCritical","update","withPlaceholder","innerRef","movementMode","increasedBy","droppable","withDroppableDisplacement","renderClone","getDimension","distanceToEdge","customSensors","mode","onBeforeDragStart","expected","getPhase","pageBorderBoxCenter","position","displacedBy","claim","scrollDroppable","dropAnimation","accelerateAt","getAllByType","eventName","crossAxisSize","findById","animate","dragStartTime","style","dropAnimationFinished","flexGrow","value","published","fluidLift","center","dimensions","areStatePropsEqual","drop","visible","moveDown","always","getDroppableRef","registry","previousClientSelection","shouldRespectForcePress","canGetLock","boxSizing","enableDefaultSensors","context","pageMarginBox","tryGetLock","onWindowScroll","liftInstruction","userDirection","isMoving","direction","previousImpact","pure","liftInstructionId","announce","initial","select","crossAxisLine","afterDragging","moveRight","inHomeList","sensors","start","critical","impact","droppables","afterCritical","closest","onDragUpdate","remove","dropping","scrollWindow","DragDropContext","marginLeft","draggableProps","moveUp","ignoreContainerClipping","draggables","on","subject","shouldAnimatePlaceholder","styles","current","publish","mapped","endOfRange","register","lastCombine","forceSensorStop","onDragEnd","draggable","length","shouldClipSubject","componentDidMount","input","line","defaultProps","hasMoved","duration","last","textarea","move","maxScrollAtPercentage","env","source","moveTo","audio","shouldWarn","type","overflow","home","beforeStart","dropAnimating","render","descriptor","y","horizontal","tagName","maxScrollChange","tryAbandon","state","shouldFlush","isVisible","ref","zIndex","modified","flexShrink","maxScrollValueAt","target","componentDidCatch","isMovingForward","isLockActive","scrollJumpRequest","sourceEvent","scrollOptions","reason","isCombineEnabled","isFixedOnPage","display","publishWhileDragging","capture","whenEntered","getById","updateDroppableIsCombineEnabled","add","onTransitionEnd","componentWillUnmount","clientSelection","bottom","isDropDisabled","tryShiftRecord","isClone","nonce","dropDuration","onlyOnMainAxis","onDragStart","all","selection","clean","abort","exists","isLockClaimed","size","effected","selector","previousPageBorderBoxCenter","active","newScroll","startFromPercentage","page","frame","combine","payload","phase","updatedDroppables","canDragInteractiveElements","tryReleaseLock","client","borderBoxCenter","newHomeClientOffset","options","useClone","transition","scrollTop","dimension","subscribe","data","shouldAnimateDisplacement","scrollHeight","Droppable","draggableId","canLift","userCancel","displacement","frameClient","inVirtualList","store","lockAPI","crossAxisEnd","moveRelativeTo","oldFrameMaxScroll","opacity","end","moveLeft","forceShouldAnimate","at","point","liftActionArgs","left","pointerEvents","snapLift","container","change","actions","isEnabled","result","button","findOptionsForDraggable","invisible","setCallbacks","newPageBorderBoxCenter","updateViewportMaxScroll","additions","unsubscribe","insideDestination","marginRight","maxPixelScroll","tryRestoreFocusRecorded"]],"~:compiled-at",1579150619411,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_beautiful_dnd$dist$react_beautiful_dnd_cjs.js\",\n\"lineCount\":159,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAK9DC,QAASA,EAAgB,CAACC,CAAD,CAAK,CAAE,MAAQA,EAAD,EAAsB,QAAtB,GAAQ,MAAOA,EAAf,EAAmC,SAAnC,EAAgDA,EAAhD,CAAsDA,CAAA,CAAG,SAAH,CAAtD,CAAsEA,CAA/E,CAmC9BC,QAASA,EAAG,CAACC,CAAD,CAAOC,CAAP,CAAgB,EAgB5BC,QAASA,EAAI,EAAG,EAMhBC,QAASA,EAAU,CAACC,CAAD,CAAKC,CAAL,CAAeC,CAAf,CAA8B,CAC/C,IAAIC,EAAaF,CAAAG,IAAA,CAAa,QAAS,CAACC,CAAD,CAAU,CAC/C,IAAIC,EALCC,CAAA,CAAS,EAAT,CAKoBL,CALpB,CAAqB,EAArB,CAKmCG,CAAAC,QALnC,CAMLN,EAAAQ,iBAAA,CAAoBH,CAAAI,UAApB,CAAuCJ,CAAAK,GAAvC,CAAmDJ,CAAnD,CACA,OAAOK,SAAe,EAAG,CACvBX,CAAAY,oBAAA,CAAuBP,CAAAI,UAAvB,CAA0CJ,CAAAK,GAA1C,CAAsDJ,CAAtD,CADuB,CAHsB,CAAhC,CAOjB,OAAOO,SAAkB,EAAG,CAC1BV,CAAAW,QAAA,CAAmB,QAAS,CAACH,CAAD,CAAS,CACnCA,CAAA,EADmC,CAArC,CAD0B,CARmB,CAiBjDI,QAASA,EAAY,CAAClB,CAAD,CAAU,CAC7B,IAAAA,QAAA,CAAeA,CADc,CAQ/BmB,QAASA,EAAS,CAACC,CAAD,CAAYpB,CAAZ,CAAqB,CACrC,GAAIoB,CAAAA,CAAJ,CAAA,CAKE,KAAM,KAAIF,CAAJ,CAfGG,kBAeH,CAAN,CAEA,KAAM,KAAIH,CAAJ,CAAiB,oBAAjB,EAAkClB,CAAlC,EAA6C,EAA7C,EAAN,CAPF,CADqC,CAwVvCsB,QAASA,EAAS,CAACC,CAAD;AAAOC,CAAP,CAAkB,CAClC,GAAID,CAAAD,UAAJ,CACE,MAAOC,EAAAD,UAAA,CAAeE,CAAf,CAGT,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBF,CAAAG,OAApB,CAAiCD,CAAA,EAAjC,CACE,GAAID,CAAA,CAAUD,CAAA,CAAKE,CAAL,CAAV,CAAJ,CACE,MAAOA,EAIX,OAAQ,EAX0B,CAapCE,QAASA,EAAI,CAACJ,CAAD,CAAOC,CAAP,CAAkB,CAC7B,GAAID,CAAAI,KAAJ,CACE,MAAOJ,EAAAI,KAAA,CAAUH,CAAV,CAGLI,EAAAA,CAAQN,CAAA,CAAUC,CAAV,CAAgBC,CAAhB,CAEZ,IAAe,EAAf,GAAII,CAAJ,CACE,MAAOL,EAAA,CAAKK,CAAL,CARoB,CAsD/BC,QAASA,EAAiB,CAACC,CAAD,CAAS,CACjC,MAAIA,EAAAC,GAAJ,EAAoC,SAApC,GAAiBD,CAAAC,GAAAhC,KAAjB,CACS+B,CAAAC,GAAAC,YADT,CAIO,IAL0B,CAOnCC,QAASA,EAAa,CAACH,CAAD,CAAS,CAC7B,MAAIA,EAAAC,GAAJ,EAAoC,SAApC,GAAiBD,CAAAC,GAAAhC,KAAjB,CACS+B,CAAAC,GAAAG,QADT,CAIO,IALsB,CA6P/BC,QAASA,EAAqB,CAACC,CAAD,CAAO,CAAA,IAE/BJ,EAAcI,CAAAJ,YAFiB,CAG/BK,EAAcD,CAAAC,YAHiB,CAI/BC,EAAWF,CAAAE,SAJoB,CAK/BC,EAAqBH,CAAAG,mBALU,CAM/BC,EAAOJ,CAAAI,KACX,OANoBJ,EAAAK,cAMbC,OAAA,CAAqBC,QAAgB,CAACC,CAAD,CAASC,CAAT,CAAoB,CAVhE,IAAA,EAAOC,EAAAC,QAAA,CAAoBD,EAAAE,OAAA,CAWFH,CAlBTI,KAAAC,UAOW,CANZC,CACbC,IAgBkCf,CAhB7BgB,MAAAC,EADQH;AAEbI,MAAO,CAFMJ,CAGbK,OAAQ,CAHKL,CAIbM,KAakCpB,CAb5BgB,MAAAK,EAJOP,CAMY,CAApB,CAYL,KAAIQ,EAAKd,CAAAe,WAAAD,GACTf,EAAAiB,IAAAC,KAAA,CAAgBH,CAAhB,CAQA,IAAI,CAhECI,EAAAA,CAAUrD,CAAA,CAAS,EAAT,CAyDoBsD,CACjCC,OAAQA,CADyBD,CAEjChC,YAAaA,CAFoBgC,CAGjC1B,SAAUA,CAHuB0B,CAIjCE,0BAA2B,CAAA,CAJMF,CAzDpB,CAAmB,CAClCG,wBAAyBC,EADS,CAAnB,CAAVL,CAgEL,CAEE,MADAnB,EAAAyB,UAAA,CAAiBxB,CAAAe,WAAAD,GAAjB,CACOf,CADqC,CAAA,CACrCA,CAAAA,CAlDuB,UAAlC,GAAI,MAqD6CL,EArDjD,CACE,CADF,CAqDiDA,CArDjD,CAqD2CC,CAjD3C,EAKI8B,CAGF,CAyCyC9B,CA5C7B8B,QAGZ,CAAA,CAAA,CAyCyC9B,CA7C3B6B,UAGZ,CA0CmCV,CA1CnC,CAAJ,CACS,CAAA,CADT,CAKO,CADHY,CACG,CADQD,CAAA,CAsCwBX,CAtCxB,CACR,EAAWY,CAAAC,cAAX,CAAoC,CAAA,CAZ3C,EACE,CADF,CACS,CAAA,CAqDP5B,EAAA0B,QAAA,CAAeX,CAAf,CAAA,CAJmBc,CACjBC,YAAaf,CADIc,CAEjBD,cAAeA,CAFEC,CAKnB,OAAO7B,EAtBuD,CAAzD,CAuBJ,CACDiB,IAAK,EADJ,CAEDS,QAAS,EAFR,CAGDD,UAAW,EAHV,CAvBI,CAP4B,CA8CrCM,QAASA,EAAO,CAACvC,CAAD,CAAO,CAAA,IACjBwC,EAAoBxC,CAAAwC,kBADH,CAGjBvC,EAAcD,CAAAC,YAHG,CAIjBL,EAAcI,CAAAJ,YAFD6C,EAAAA,CAAAzC,CAAAyC,WAGiBD,EAb7BlD,OAAL,EAIIoD,CACJ;AAQkCF,CATZ,CASYA,CATDlD,OAAX,CAA+B,CAA/B,CAAAkC,WAAAhC,MACtB,CAAA,CAAA,CAAOiD,CAAA,CAAqBC,CAArB,CAAuCA,CAAvC,CAAyD,CALhE,EACE,CADF,CACS,CAeT,OAAO,CACLC,UAAWC,EADN,CAEL3C,YAAaA,CAFR,CAGLN,GAAI,CACFhC,KAAM,SADJ,CAEFiC,YAAa,CACXiD,YAAajD,CAAA4B,WAAAD,GADF,CAEX/B,MAAOsD,CAFI,CAFX,CAHC,CARc,CAqBvBC,QAASA,EAAsB,CAACC,CAAD,CAAQ,CAAA,IACjCvC,EAAYuC,CAAAvC,UADqB,CAEjC+B,EAAoBQ,CAAAR,kBAFa,CAGjC5C,EAAcoD,CAAApD,YAHmB,CAIjCM,EAAW8C,CAAA9C,SAJsB,CAKjCD,EAAc+C,CAAA/C,YALmB,CAMjCG,EAAO4C,CAAA5C,KAN0B,CAOjCZ,EAAQwD,CAAAxD,MACRW,EAAAA,CAAqB6C,CAAA7C,mBACzB,KAAIsC,EAAaQ,EAAA,CAASxC,CAAT,CAAoBb,CAApB,CAEjB,IAAa,IAAb,EAAIJ,CAAJ,CACE,MAAO+C,EAAA,CAAQ,CACbC,kBAAmBA,CADN,CAEbC,WAAYA,CAFC,CAGbxC,YAAaA,CAHA,CAIbL,YAAaA,CAJA,CAAR,CAQT,KAAIsD,EAAQ3D,CAAA,CAAKiD,CAAL,CAAwB,QAAS,CAACW,CAAD,CAAO,CAClD,MAAOA,EAAA3B,WAAAhC,MAAP,GAAiCA,CADiB,CAAxC,CAIZ,IAAI,CAAC0D,CAAL,CACE,MAAOX,EAAA,CAAQ,CACbC,kBAAmBA,CADN,CAEbC,WAAYA,CAFC,CAGbxC,YAAaA,CAHA;AAIbL,YAAaA,CAJA,CAAR,CAQLwD,EAAAA,CAAkBC,EAAA,CAAwB5C,CAAxB,CAAmC+B,CAAnC,CAClBc,EAAAA,CAAYd,CAAAe,QAAA,CAA0BL,CAA1B,CACZM,EAAAA,CAAWJ,CAAAK,MAAA,CAAsBH,CAAtB,CASf,OAAO,CACLX,UATc5C,CAAA4C,CAAsB,CACpCtC,cAAemD,CADqB,CAEpC5D,YAAaA,CAFuB,CAGpCK,YAAaA,CAHuB,CAIpCG,KAAMA,CAJ8B,CAKpCF,SAAUA,CAAAwD,MAL0B,CAMpCvD,mBAAoBA,CANgB,CAAtBwC,CAQT,CAEL1C,YAAaA,CAFR,CAGLN,GAAI,CACFhC,KAAM,SADJ,CAEFiC,YAAa,CACXiD,YAAajD,CAAA4B,WAAAD,GADF,CAEX/B,MAAOA,CAFI,CAFX,CAHC,CA5C8B,CA2XvCmE,QAASA,EAAa,CAACC,CAAD,CAAMC,CAAN,CAAkB,CACtC,MAAOD,EAAAzF,IAAA,CAAQ,QAAS,CAACoD,CAAD,CAAK,CAC3B,MAAOsC,EAAA,CAAWtC,CAAX,CADoB,CAAtB,CAD+B,CAwmBxCuC,QAASA,EAAiB,CAACC,CAAD,CAAQ,CAChC,MAAuB,UAAvB,GAAOA,CAAAC,MAAP,EAAqD,YAArD,GAAqCD,CAAAC,MADL,CA6ClCC,QAASA,EAAO,CAACjE,CAAD,CAAO,CAAA,IAEjBkE,EAAUlE,CAAAkE,QAGd,OAAKA,EAAL,CAFiBlE,CAAAyC,WAMjB,CAIIyB,CAAA1C,WAAAhC,MAAJ,CAZgBQ,CAAAS,UAYee,WAAAhC,MAA/B,CACS0E,CAAA1C,WAAAhC,MADT,CACoC,CADpC,CAIO0E,CAAA1C,WAAAhC,MARP;AACS0E,CAAA1C,WAAAhC,MALT,CACS,IANY,CA4FvB2E,QAASA,EAAsB,CAACnE,CAAD,CAAO,CAAA,IAChCoE,EAAgBpE,CAAAoE,cADgB,CAEhCC,EAAgBrE,CAAAqE,cAFgB,CAGhCC,EAAgBtE,CAAAsE,cAChBC,EAAAA,CAAiBvE,CAAAuE,eAVnB,KAAA,EAW0CA,CAZxC5E,GAAJ,EAAoC,SAApC,GAY4C4E,CAZ3B5E,GAAAhC,KAAjB,CAY4C4G,CAXnC5E,GADT,CAIO,IAXL,EAAA,CAoB6D6E,CAzB/D,CAyBiCJ,CArBjC,GAqB+DI,CArBpD1E,QAAAwC,YAAX,CAqBgDgC,CArBhD,CAqB+DE,CAjBxDC,YARP,CAyBgDH,CAahD,OAZa5E,CACXO,YAAasE,CAAAtE,YADFP,CAEXiD,UAAW4B,CAAA5B,UAFAjD,CAGXC,GAAI,CACFhC,KAAM,SADJ,CAEF8G,YAAaA,CAFX,CAGF3E,QAAS,CACPwC,YAAa8B,CADN,CAEPvB,YAAawB,CAFN,CAHP,CAHO3E,CAPuB,CAyTtCgF,QAASA,EAAe,CAACd,CAAD,CAAMC,CAAN,CAAkB,CACxC,MAAOD,EAAAzF,IAAA,CAAQ,QAAS,CAACoD,CAAD,CAAK,CAC3B,MAAOsC,EAAA,CAAWtC,CAAX,CADoB,CAAtB,CADiC,CA8U1CoD,QAASA,EAAuB,CAACZ,CAAD,CAAQ,CACtC,MAAIA,EAAAa,WAAJ,EAA+C,MAA/C,GAAwBb,CAAAc,aAAxB,CACSvG,CAAA,CAAS,CACd0F,MAAO,UADO,CAAT,CAEJD,CAFI,CAEG,CACRe,kBAAmB,IADX,CAFH,CADT,CAQOf,CAT+B,CAywBxCgB,QAASA,GAAsB,CAACC,CAAD,CAAS,CACtC,MAAO,CACLxG,UAAW,QADN;AAELH,QAAS,CACP4G,QAAS,CAAA,CADF,CAEPC,QAAS,CAAA,CAFF,CAFJ,CAMLzG,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACjBA,CAAAtD,OAAJ,GAAqBuD,MAArB,EAA+BD,CAAAtD,OAA/B,GAAgDuD,MAAAC,SAAhD,EAIAL,CAAA,EALqB,CANlB,CAD+B,CAiBxCM,QAASA,GAAiB,CAACtF,CAAD,CAAO,CAW/BuF,QAASA,EAAQ,EAAG,CAClB,MAAO7G,EAAP,GAAkBb,CADA,CAVpB,IAAI2H,EAAiBxF,CAAAwF,eAArB,CAMIC,EAAYC,EAAA,CAJhBC,QAAqB,EAAG,CACtBH,CAAA,CA3BK,CACLlE,EAAG8D,MAAAQ,YADE,CAEL1E,EAAGkE,MAAAS,YAFE,CA2BL,CADsB,CAIR,CANhB,CAOIzH,EAAU2G,EAAA,CAAuBU,CAAvB,CAPd,CAQI/G,EAASb,CAkBb,OAAO,CACLiI,MAbFA,QAAc,EAAG,CACbP,CAAA,EAAF,CAA8HxG,CAAA,CAAU,CAAA,CAAV,CAA9H,CAAiJ,IAAK,EACtJL,EAAA,CAASZ,CAAA,CAAWsH,MAAX,CAAmB,CAAChH,CAAD,CAAnB,CAFM,CAYV,CAEL2H,KATFA,QAAa,EAAG,CACbR,CAAA,EAAD,CAA2I,IAAK,EAAhJ,CAAwHxG,CAAA,CAAU,CAAA,CAAV,CACxH0G,EAAAO,OAAA,EACAtH,EAAA,EACAA,EAAA,CAASb,CAJK,CAOT,CAGL0H,SAAUA,CAHL,CA3BwB,CAgiBjCU,QAASA,EAAe,CAACjG,CAAD,CAAO,CAAA,IACzBkG,EAAWlG,CAAAkG,SADc,CAEzBC,EAAYnG,CAAAmG,UAFa,CAGzBC,EAAUC,EAAA,EAHe,CAIzBC,EAAU,IAJe,CAMzBC,EAAUA,QAAgB,EAAG,CAC3BD,CAAJ,GAIAH,CAAAK,mBAAA,EACA,CAAAF,CAAA,CAAUG,qBAAA,CAAsB,QAAS,EAAG,CAC1CH,CAAA,CAAU,IADgC;IAGtCI,EAAWN,CAH2B,CAKtCO,EAAWD,CAAAC,SAL2B,CAMtCC,EAAWF,CAAAE,SAEXC,EAAAA,CAAQC,EAAA,CAJIJ,CAAAK,UAIJ,CAAA5I,IAAA,CAA4B,QAAS,CAACoD,CAAD,CAAK,CACpD,MAAO2E,EAAAzF,UAAAuG,QAAA,CAA2BzF,CAA3B,CAAA0F,aAAA,CAA4CC,EAA5C,CAD6C,CAA1C,CAAAC,KAAA,CAEJ,QAAS,CAACC,CAAD,CAAIC,CAAJ,CAAO,CACtB,MAAOD,EAAA5F,WAAAhC,MAAP,CAA4B6H,CAAA7F,WAAAhC,MADN,CAFZ,CAMR8H,EAAAA,CAAUR,EAAA,CAAaF,CAAb,CAAAzI,IAAA,CAA2B,QAAS,CAACoD,CAAD,CAAK,CAErD,IAAIgG,EADQrB,CAAAsB,UAAAR,QAAAS,CAA2BlG,CAA3BkG,CACCtB,UAAAuB,uBAAA,EACb,OAAO,CACL7E,YAAatB,CADR,CAELgG,OAAQA,CAFH,CAH8C,CAAzC,CASVI,EAAAA,CAAS,CACXZ,UAAWF,CADA,CAEXF,SAAUG,EAAA,CAAaH,CAAb,CAFC,CAGXC,SAAUU,CAHC,CAKblB,EAAA,CAAUC,EAAA,EAEVF,EAAAyB,QAAA,CAAkBD,CAAlB,CA9B0C,CAAlC,CALV,CAD+B,CA0EjC,OAAO,CACLE,IAnCQA,QAAY,CAACJ,CAAD,CAAQ,CAC5B,IAAIlG,EAAKkG,CAAAjG,WAAAD,GACT6E,EAAAW,UAAA,CAAkBxF,CAAlB,CAAA,CAAwBkG,CACxBrB,EAAAQ,SAAA,CAAiBa,CAAAjG,WAAAqB,YAAjB,CAAA,CAAiD,CAAA,CAE7CuD,EAAAO,SAAA,CAAiBpF,CAAjB,CAAJ,EACE,OAAO6E,CAAAO,SAAA,CAAiBpF,CAAjB,CAGTgF;CAAA,EAT4B,CAkCvB,CAELuB,OAxBWA,QAAe,CAACL,CAAD,CAAQ,CAC9BjG,CAAAA,CAAaiG,CAAAjG,WACjB4E,EAAAO,SAAA,CAAiBnF,CAAAD,GAAjB,CAAA,CAAkC,CAAA,CAClC6E,EAAAQ,SAAA,CAAiBpF,CAAAqB,YAAjB,CAAA,CAA2C,CAAA,CAEvCuD,EAAAW,UAAA,CAAkBvF,CAAAD,GAAlB,CAAJ,EACE,OAAO6E,CAAAW,UAAA,CAAkBvF,CAAAD,GAAlB,CAGTgF,EAAA,EATkC,CAsB7B,CAGLR,KAbSA,QAAa,EAAG,CACpBO,CAAL,GAIAyB,oBAAA,CAAqBzB,CAArB,CAEA,CADAA,CACA,CADU,IACV,CAAAF,CAAA,CAAUC,EAAA,EANV,CADyB,CAUpB,CAhFsB,CAsL/B2B,QAASA,GAAmB,CAAC9B,CAAD,CAAW+B,CAAX,CAAqBR,CAArB,CAA4B,CAKtD,MAJIA,EAAAjG,WAAAD,GAIJ,GAJ4B0G,CAAA1G,GAI5B,EAAIkG,CAAAjG,WAAA7D,KAAJ,GAA8BsK,CAAAtK,KAA9B,CACS,CAAA,CADT,CAM6B,SAA7B,GAFWuI,CAAAsB,UAAAR,QAAAkB,CAA2BT,CAAAjG,WAAAqB,YAA3BqF,CAEP1G,WAAA2G,KAAJ,EAC4U,IAAK,EACxU,CAAA,CAAA,CAFT,EAKO,CAAA,CAhB+C,CAi5BxDC,QAASA,GAAe,CAACC,CAAD,CAAYC,CAAZ,CAAmB,CACzC,IAAIC,EAASC,CAAAC,QAAA,CAAmB,QAAS,EAAG,CArE5C,IAAIC,EAAcC,EAAA,CAsEGN,CAtEH,CAAlB,CAEIO,EAEK,CACLC,SAAUH,CAAA,CAAYI,EAAAT,UAAZ,CADL,CAELE,OAAQ,CACNQ,OAAQ,kJADF;AAENC,QALaC,0DAGP,CAGNhB,SAXciB,uBAQR,CAINC,cAPaF,0DAGP,CAFH,CAYHG,KAAAA,EAAa,sBAAbA,CAAsCC,EAAAC,YAAtCF,CAAgE,SACpE,EAAA,CAAO,CACLP,SAAUH,CAAA,CAAYjI,EAAA4H,UAAZ,CADL,CAELE,OAAQ,CACNN,SAAUmB,CADJ,CAEND,cAAeC,CAFT,CAGNG,WAAYH,CAHN,CAFH,CAULI,EAAAA,CAAc,CAChBX,SAAUH,CAAA,CAAYL,EAAZ,CADM,CAEhBE,OAAQ,CACNQ,OAAQ,wBADF,CAFQ,CAYdU,EAAAA,CAAQ,CAACC,CAAD,CAAcd,CAAd,CAA4BY,CAA5B,CANDG,CACTd,SAAU,MADDc,CAETpB,OAAQ,CACNN,SAAU,yOADJ,CAFC0B,CAMC,CA+BV;MA9BK,CACLZ,OAAQa,EAAA,CAAUH,CAAV,CAAiB,QAAjB,CADH,CAELT,QAASY,EAAA,CAAUH,CAAV,CAAiB,SAAjB,CAFJ,CAGLxB,SAAU2B,EAAA,CAAUH,CAAV,CAAiB,UAAjB,CAHL,CAILN,cAAeS,EAAA,CAAUH,CAAV,CAAiB,eAAjB,CAJV,CAKLF,WAAYK,EAAA,CAAUH,CAAV,CAAiB,YAAjB,CALP,CA6BqC,CAA/B,CAEV,CAACpB,CAAD,CAFU,CAAb,CAGIwB,EAAYC,CAAAC,OAAA,CAAa,IAAb,CAHhB,CAIIC,EAAaF,CAAAC,OAAA,CAAa,IAAb,CAJjB,CAKIE,EAAkBzB,CAAA0B,YAAA,CAAuBC,EAAA,CAAW,QAAS,CAACC,CAAD,CAAW,CAC1E,IAAIrM,EAAKiM,CAAAK,QACRtM,EAAD,CAAyI,IAAK,EAA9I,CAAsHgB,CAAA,CAAU,CAAA,CAAV,CACtHhB,EAAAuM,YAAA,CAAiBF,CAHyD,CAA/B,CAAvB,CAIlB,EAJkB,CALtB,CAUIG,EAAiB/B,CAAA0B,YAAA,CAAuB,QAAS,CAACE,CAAD,CAAW,CAC9D,IAAIrM,EAAK8L,CAAAQ,QACRtM,EAAD,CAAyI,IAAK,EAA9I,CAAsHgB,CAAA,CAAU,CAAA,CAAV,CACtHhB,EAAAuM,YAAA,CAAiBF,CAH6C,CAA3C,CAIlB,EAJkB,CAKrBI,GAAA,CAA0B,QAAS,EAAG,CACjCX,CAAAQ,QAAH,EAAyBL,CAAAK,QAAzB,CAA4ItL,CAAA,CAAU,CAAA,CAAV,CAA5I,CAA+J,IAAK,EACpK,KAAIgK,EAAS0B,EAAA,CAAcnC,CAAd,CAAb,CACIoC,EAAUD,EAAA,CAAcnC,CAAd,CACduB,EAAAQ,QAAA,CAAoBtB,CACpBiB,EAAAK,QAAA,CAAqBK,CACrB3B,EAAA4B,aAAA,CAAoB,iBAApB,CAA0CtC,CAA1C,CACAqC,EAAAC,aAAA,CAAqB,kBAArB;AAA4CtC,CAA5C,CACAuC,GAAA,EAAAC,YAAA,CAAsB9B,CAAtB,CACA6B,GAAA,EAAAC,YAAA,CAAsBH,CAAtB,CACAH,EAAA,CAAehC,CAAAQ,OAAf,CACAkB,EAAA,CAAgB1B,CAAAS,QAAhB,CACA,OAAO,SAAS,EAAG,CACjB,IAAIlB,EAASA,QAAe,CAACgD,CAAD,CAAM,CAChC,IAAIT,EAAUS,CAAAT,QACbA,EAAD,CAAgI,IAAK,EAArI,CAA6GtL,CAAA,CAAU,CAAA,CAAV,CAC7G6L,GAAA,EAAAG,YAAA,CAAsBV,CAAtB,CACAS,EAAAT,QAAA,CAAc,IAJkB,CAOlCvC,EAAA,CAAO+B,CAAP,CACA/B,EAAA,CAAOkC,CAAP,CATiB,CAZiB,CAAtC,CAuBG,CAAC1B,CAAD,CAAQiC,CAAR,CAAwBN,CAAxB,CAAyC1B,CAAAQ,OAAzC,CAAwDR,CAAAS,QAAxD,CAAwEX,CAAxE,CAvBH,CAwBA,KAAIJ,EAAWO,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAChD,MAAOD,EAAA,CAAgB1B,CAAAN,SAAhB,CADyC,CAAnC,CAEZ,CAACgC,CAAD,CAAkB1B,CAAAN,SAAlB,CAFY,CAAf,CAGI+C,EAAWxC,CAAA0B,YAAA,CAAuB,QAAS,CAACe,CAAD,CAAS,CACvC,MAAf,GAAIA,CAAJ,CACEhB,CAAA,CAAgB1B,CAAAY,cAAhB,CADF,CAKAc,CAAA,CAAgB1B,CAAAgB,WAAhB,CANsD,CAAzC,CAOZ,CAACU,CAAD,CAAkB1B,CAAAY,cAAlB,CAAwCZ,CAAAgB,WAAxC,CAPY,CAHf,CAWIP,EAAUR,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAC1CF,CAAAK,QAAL,EAIAJ,CAAA,CAAgB1B,CAAAS,QAAhB,CAL+C,CAAnC,CAMX,CAACiB,CAAD,CAAkB1B,CAAAS,QAAlB,CANW,CAcd,OAPcR,EAAAC,QAAAyC,CAAmB,QAAS,EAAG,CAC3C,MAAO,CACLjD,SAAUA,CADL;AAEL+C,SAAUA,CAFL,CAGLhC,QAASA,CAHJ,CADoC,CAA/BkC,CAMX,CAACjD,CAAD,CAAW+C,CAAX,CAAqBhC,CAArB,CANWkC,CA1D2B,CAwE3CC,QAASA,GAAa,CAACpN,CAAD,CAAK,CACzB,MAAOA,EAAP,WAAqBqN,CAAgBrN,CAJ9B,EAI8BA,CAJxBsN,cAAN,CAI8BtN,CAJLsN,cAAAC,YAAzB,CAAwDlG,MAI1CgG,aADI,CAI3BG,QAASA,EAAc,CAAClD,CAAD,CAAY/F,CAAZ,CAAyB,CAE1CkJ,CAAAA,CAjjJGC,KAAAC,UAAAjI,MAAAkI,KAAA,CAijJgBtG,QAAAuG,iBAAAzM,CADR,GACQA,CADF2J,EAAAT,UACElJ,CADqB,OACrBA,CAD6BkJ,CAC7BlJ,CADyC,IACzCA,CAjjJhB,CAmjJP,IAAI,CAACqM,CAAAlM,OAAL,CAEE,MAD0H,KAAK,EACxH,CAAA,IAGLuM,EAAAA,CAAStM,CAAA,CAAKiM,CAAL,CAAe,QAAS,CAACzN,CAAD,CAAK,CACxC,MAAOA,EAAA+N,aAAA,CAAgBhD,EAAAxG,YAAhB,CAAP,GAAmDA,CADX,CAA7B,CASb,OALKuJ,EAKL,EAAKV,EAAA,CAAcU,CAAd,CAAL,CAKOA,CALP,EAC6F,IAAK,EACzF,CAAA,IAFT,CAlB8C,CA0BhDE,QAASA,EAAe,CAAC1D,CAAD,CAAY,CAClC,IAAI2D,EAAalC,CAAAC,OAAA,CAAa,EAAb,CAAjB,CACIkC,EAAYnC,CAAAC,OAAA,CAAa,IAAb,CADhB,CAEImC,EAAuBpC,CAAAC,OAAA,CAAa,IAAb,CAF3B,CAGIoC,EAAerC,CAAAC,OAAA,CAAa,CAAA,CAAb,CAHnB,CAIIqC,EAAW5D,CAAA0B,YAAA,CAAuBkC,QAAiB,CAAC7K,CAAD,CAAK8K,CAAL,CAAY,CACjE,IAAI5E,EAAQ,CACVlG,GAAIA,CADM,CAEV8K,MAAOA,CAFG,CAIZL,EAAA3B,QAAA,CAAmB9I,CAAnB,CAAA;AAAyBkG,CACzB,OAAO6E,SAAmB,EAAG,CAC3B,IAAIC,EAAUP,CAAA3B,QACAkC,EAAAlC,CAAQ9I,CAAR8I,CAEd,GAAgB5C,CAAhB,EACE,OAAO8E,CAAA,CAAQhL,CAAR,CALkB,CANoC,CAApD,CAcZ,EAdY,CAJf,CAmBIiL,EAAehE,CAAA0B,YAAA,CAAuBsC,QAAqB,CAACC,CAAD,CAAiB,CAG9E,CAFIZ,CAEJ,CAFaN,CAAA,CAAelD,CAAf,CAA0BoE,CAA1B,CAEb,GAAcZ,CAAd,GAAyBxG,QAAAqH,cAAzB,EACEb,CAAAQ,MAAA,EAJ4E,CAA7D,CAMhB,CAAChE,CAAD,CANgB,CAnBnB,CA0BIsE,EAAiBnE,CAAA0B,YAAA,CAAuByC,QAAuB,CAACxK,CAAD,CAAWyK,CAAX,CAAuB,CACpFX,CAAA5B,QAAJ,GAA0BlI,CAA1B,GACE8J,CAAA5B,QADF,CACsBuC,CADtB,CADwF,CAArE,CAIlB,EAJkB,CA1BrB,CA+BIC,EAA0BrE,CAAA0B,YAAA,CAAuB2C,QAAgC,EAAG,CAClFxC,CAAA6B,CAAA7B,QAAJ,EAIK8B,CAAA9B,QAJL,GAQA6B,CAAA7B,QARA,CAQ+B5D,qBAAA,CAAsB,QAAS,EAAG,CAC/DyF,CAAA7B,QAAA,CAA+B,IAC/B,KAAIyC,EAASb,CAAA5B,QAETyC,EAAJ,EACEN,CAAA,CAAaM,CAAb,CAL6D,CAAlC,CAR/B,CADsF,CAA1D,CAiB3B,CAACN,CAAD,CAjB2B,CA/B9B,CAiDIO,EAAiBvE,CAAA0B,YAAA,CAAuB6C,QAAuB,CAACxL,CAAD,CAAK,CACtE0K,CAAA5B,QAAA,CAAoB,IACpB,KAAI2C,EAAU3H,QAAAqH,cAETM,EAAL,EAIIA,CAAAlB,aAAA,CAAqBhD,EAAAxG,YAArB,CAJJ,GAIqDf,CAJrD,GAQA0K,CAAA5B,QARA,CAQoB9I,CARpB,CAJsE,CAAnD,CAalB,EAbkB,CAcrBiJ,GAAA,CAA0B,QAAS,EAAG,CACpC2B,CAAA9B,QAAA;AAAuB,CAAA,CACvB,OAAO4C,SAA4B,EAAG,CACpCd,CAAA9B,QAAA,CAAuB,CAAA,CACvB,KAAI/D,EAAU4F,CAAA7B,QAEV/D,EAAJ,EACEyB,oBAAA,CAAqBzB,CAArB,CALkC,CAFF,CAAtC,CAUG,EAVH,CAmBA,OARckC,EAAAC,QAAAyC,CAAmB,QAAS,EAAG,CAC3C,MAAO,CACLkB,SAAUA,CADL,CAELW,eAAgBA,CAFX,CAGLF,wBAAyBA,CAHpB,CAILF,eAAgBA,CAJX,CADoC,CAA/BzB,CAOX,CAACkB,CAAD,CAAWW,CAAX,CAA2BF,CAA3B,CAAoDF,CAApD,CAPWzB,CA3EoB,CAsFpCgC,QAASA,GAAc,EAAG,CAoBxBC,QAASA,EAAM,CAAChI,CAAD,CAAQ,CACjBiI,CAAA9N,OAAJ,EACE8N,CAAAvO,QAAA,CAAoB,QAAS,CAACwO,CAAD,CAAK,CAChC,MAAOA,EAAA,CAAGlI,CAAH,CADyB,CAAlC,CAFmB,CAQvBmI,QAASA,EAAiB,CAAC/L,CAAD,CAAK,CAC7B,MAAOgL,EAAA1I,WAAA,CAAmBtC,CAAnB,CAAP,EAAiC,IADJ,CA8D/BgM,QAASA,EAAiB,CAAChM,CAAD,CAAK,CAC7B,MAAOgL,EAAAiB,WAAA,CAAmBjM,CAAnB,CAAP,EAAiC,IADJ,CAzF/B,IAAIgL,EAAU,CACZ1I,WAAY,EADA,CAEZ2J,WAAY,EAFA,CAAd,CAIIJ,EAAc,EAkIlB,OAAO,CACL3M,UAlGiBgN,CACjBrB,SAAUA,QAAiB,CAAC3E,CAAD,CAAQ,CACjC8E,CAAA1I,WAAA,CAAmB4D,CAAAjG,WAAAD,GAAnB,CAAA,CAA0CkG,CAC1C0F,EAAA,CAAO,CACLxP,KAAM,UADD,CAEL+P,MAAOjG,CAFF,CAAP,CAFiC,CADlBgG;AAQjBzI,OAAQA,QAAe,CAACyC,CAAD,CAAQrH,CAAR,CAAc,CACnC,IAAIiK,EAAUkC,CAAA1I,WAAA,CAAmBzD,CAAAoB,WAAAD,GAAnB,CAET8I,EAAL,EAIIA,CAAAsD,SAJJ,GAIyBlG,CAAAkG,SAJzB,GAQA,OAAOpB,CAAA1I,WAAA,CAAmBzD,CAAAoB,WAAAD,GAAnB,CACP,CAAAgL,CAAA1I,WAAA,CAAmB4D,CAAAjG,WAAAD,GAAnB,CAAA,CAA0CkG,CAT1C,CAHmC,CARpBgG,CAsBjBnB,WAAYA,QAAmB,CAAC7E,CAAD,CAAQ,CACrC,IAAInF,EAAcmF,CAAAjG,WAAAD,GAAlB,CACI8I,EAAUiD,CAAA,CAAkBhL,CAAlB,CAET+H,EAAL,EAII5C,CAAAkG,SAJJ,GAIuBtD,CAAAsD,SAJvB,GAQA,OAAOpB,CAAA1I,WAAA,CAAmBvB,CAAnB,CACP,CAAA6K,CAAA,CAAO,CACLxP,KAAM,SADD,CAEL+P,MAAOjG,CAFF,CAAP,CATA,CAJqC,CAtBtBgG,CAwCjBzG,QA9CF4G,QAAyB,CAACrM,CAAD,CAAK,CAE5B,CADIkG,CACJ,CADY6F,CAAA,CAAkB/L,CAAlB,CACZ,EAA2I,IAAK,EAAhJ,CAAwHxC,CAAA,CAAU,CAAA,CAAV,CACxH,OAAO0I,EAHqB,CAMXgG,CAyCjBI,SAAUP,CAzCOG,CA0CjBK,OAAQA,QAAe,CAACvM,CAAD,CAAK,CAC1B,MAAO,CAAA,CAAQ+L,CAAA,CAAkB/L,CAAlB,CADW,CA1CXkM,CA6CjBM,aAAcA,QAAqB,CAACpQ,CAAD,CAAO,CACxC,MAhxJGqQ,GAAA,CAgxJWzB,CAAA1I,WAhxJX,CAgxJIoK,OAAA,CAAkC,QAAS,CAACxG,CAAD,CAAQ,CACxD,MAAOA,EAAAjG,WAAA7D,KAAP,GAAiCA,CADuB,CAAnD,CADiC,CA7CzB8P,CAiGZ,CAELjG,UArCiB0G,CACjB9B,SAAUA,QAAiB,CAAC3E,CAAD,CAAQ,CACjC8E,CAAAiB,WAAA,CAAmB/F,CAAAjG,WAAAD,GAAnB,CAAA;AAA0CkG,CADT,CADlByG,CAIjB5B,WAAYA,QAAmB,CAAC7E,CAAD,CAAQ,CACrC,IAAI4C,EAAUkD,CAAA,CAAkB9F,CAAAjG,WAAAD,GAAlB,CAET8I,EAAL,EAII5C,CAAAkG,SAJJ,GAIuBtD,CAAAsD,SAJvB,EAQA,OAAOpB,CAAAiB,WAAA,CAAmB/F,CAAAjG,WAAAD,GAAnB,CAX8B,CAJtB2M,CAiBjBlH,QAvBFmH,QAAyB,CAAC5M,CAAD,CAAK,CAE5B,CADIkG,CACJ,CADY8F,CAAA,CAAkBhM,CAAlB,CACZ,EAA2I,IAAK,EAAhJ,CAAwHxC,CAAA,CAAU,CAAA,CAAV,CACxH,OAAO0I,EAHqB,CAMXyG,CAkBjBL,SAAUN,CAlBOW,CAmBjBJ,OAAQA,QAAe,CAACvM,CAAD,CAAK,CAC1B,MAAO,CAAA,CAAQgM,CAAA,CAAkBhM,CAAlB,CADW,CAnBX2M,CAsBjBH,aAAcA,QAAqB,CAACpQ,CAAD,CAAO,CACxC,MAvzJGqQ,GAAA,CAuzJWzB,CAAAiB,WAvzJX,CAuzJIS,OAAA,CAAkC,QAAS,CAACxG,CAAD,CAAQ,CACxD,MAAOA,EAAAjG,WAAA7D,KAAP,GAAiCA,CADuB,CAAnD,CADiC,CAtBzBuQ,CAmCZ,CAGLE,UAnIFA,QAAkB,CAACf,CAAD,CAAK,CACrBD,CAAA1L,KAAA,CAAiB2L,CAAjB,CACA,OAAOgB,SAAoB,EAAG,CAC5B,IAAI7O,EAAQ4N,CAAA7J,QAAA,CAAoB8J,CAApB,CAEG,GAAf,GAAI7N,CAAJ,EAIA4N,CAAAkB,OAAA,CAAmB9O,CAAnB,CAA0B,CAA1B,CAP4B,CAFT,CAgIhB,CAIL+O,MAVFA,QAAc,EAAG,CACfhC,CAAA1I,WAAA,CAAqB,EACrB0I,EAAAiB,WAAA,CAAqB,EACrBJ,EAAA9N,OAAA,CAAqB,CAHN,CAMV,CAvIiB,CA+I1BkP,QAASA,GAAW,EAAG,CACrB,IAAItI,EAAWsC,CAAAC,QAAA,CAAmByE,EAAnB;AAAmC,EAAnC,CACfpD,EAAA2E,UAAA,CAAgB,QAAS,EAAG,CAC1B,MAAOC,SAAgB,EAAG,CACxBjI,qBAAA,CAAsBP,CAAAqI,MAAtB,CADwB,CADA,CAA5B,CAIG,CAACrI,CAAD,CAJH,CAKA,OAAOA,EAPc,CAiCvByI,QAASA,GAAY,CAACtG,CAAD,CAAY,CAC/B,IAAI9G,EAAKiH,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACtC,MAJK,mBAIL,CAAaJ,CADyB,CAA/B,CAEN,CAACA,CAAD,CAFM,CAAT,CAGIyC,EAAMhB,CAAAC,OAAA,CAAa,IAAb,CACVD,EAAA2E,UAAA,CAAgB,QAAS,EAAG,CACxB3D,CAAAT,QAAF,CAAgHtL,CAAA,CAAU,CAAA,CAAV,CAAhH,CAAmI,IAAK,EACxI,KAAIhB,EAAKsH,QAAAuJ,cAAA,CAAuB,KAAvB,CACT9D,EAAAT,QAAA,CAActM,CACdA,EAAAwD,GAAA,CAAQA,CACRxD,EAAA4M,aAAA,CAAgB,WAAhB,CAA6B,WAA7B,CACA5M,EAAA4M,aAAA,CAAgB,MAAhB,CAAwB,KAAxB,CACA5M,EAAA4M,aAAA,CAAgB,aAAhB,CAA+B,MAA/B,CAEAkE,GAAA,CAAe9Q,CAAA+Q,MAAf,CAAyBC,EAAzB,CAEAC,GAAA,EAAAnE,YAAA,CAA6B9M,CAA7B,CACA,OAAO,SAAS,EAAG,CACjBkR,UAAA,CAAWnH,QAAe,EAAG,CAC3B,IAAIoH,EAAcpE,CAAAT,QACjB6E,EAAD,CAAiI,IAAK,EAAtI,CAA8GnQ,CAAA,CAAU,CAAA,CAAV,CAC9GiQ,GAAA,EAAAjE,YAAA,CAA6BmE,CAA7B,CACApE;CAAAT,QAAA,CAAc,IAJa,CAA7B,CADiB,CAZO,CAA5B,CAoBG,CAAC9I,CAAD,CApBH,CA+BA,OAVeiH,EAAA0B,YAAAiF,CAAuB,QAAS,CAACvR,CAAD,CAAU,CACvD,IAAIG,EAAK+M,CAAAT,QAELtM,EAAJ,CACEA,CAAAuM,YADF,CACmB1M,CADnB,CAKmc,IAAK,EARjZ,CAA1CuR,CASZ,EATYA,CA1BgB,CA0CjCC,QAASA,GAAkB,CAAC/G,CAAD,CAAYgH,CAAZ,CAA6B,CACtD,IAAI9N,EAAKiH,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACtC,MAJK,uBAIL,CAAeJ,CADuB,CAA/B,CAEN,CAACA,CAAD,CAFM,CAGTyB,EAAA2E,UAAA,CAAgBa,QAAc,EAAG,CAC/B,IAAIvR,EAAKsH,QAAAuJ,cAAA,CAAuB,KAAvB,CACT7Q,EAAAwD,GAAA,CAAQA,CACRxD,EAAAuM,YAAA,CAAiB+E,CAEjBR,GAAA,CAAe9Q,CAAA+Q,MAAf,CAAyBC,EAAzB,CAEAC,GAAA,EAAAnE,YAAA,CAA6B9M,CAA7B,CACA,OAAO2Q,SAAgB,EAAG,CACxBM,EAAA,EAAAjE,YAAA,CAA6BhN,CAA7B,CADwB,CARK,CAAjC,CAWG,CAACwD,CAAD,CAAK8N,CAAL,CAXH,CAYA,OAAO9N,EAhB+C,CAoHxDgO,QAASA,GAAW,CAAClF,CAAD,CAAU,CAC5B,IAAIS,EAAMhB,CAAAC,OAAA,CAAaM,CAAb,CACVP,EAAA2E,UAAA,CAAgB,QAAS,EAAG,CAC1B3D,CAAAT,QAAA,CAAcA,CADY,CAA5B,CAGA,OAAOS,EALqB,CAQ9B0E,QAASA,GAAM,EAAG,CAoBhBC,QAASA,EAAO,EAAG,CAChBC,CAAD,CAAmI,IAAK,EAAxI,CAAgH3Q,CAAA,CAAU,CAAA,CAAV,CAChH2Q,EAAA,CAAO,IAFU,CAnBnB,IAAIA,EAAO,IA+BX,OAAO,CACLC,UA9BFA,QAAkB,EAAG,CACnB,MAAO,CAAA,CAAQD,CADI,CA6Bd;AAELnK,SA3BFA,QAAiB,CAACmI,CAAD,CAAQ,CACvB,MAAOA,EAAP,GAAiBgC,CADM,CAyBlB,CAGLE,MAxBFA,QAAc,CAACC,CAAD,CAAU,CACpBH,CAAF,CAAkH3Q,CAAA,CAAU,CAAA,CAAV,CAAlH,CAAqI,IAAK,EAK1I,OADA2Q,EACA,CAJII,CAIJ,CAJc,CACZD,QAASA,CADG,CAFQ,CAqBjB,CAILJ,QAASA,CAJJ,CAKLM,WAZFA,QAAmB,EAAG,CAChBL,CAAJ,GACEA,CAAAG,QAAA,EACA,CAAAJ,CAAA,EAFF,CADoB,CAOf,CAhCS,CAuFlBO,QAASA,GAAkB,CAAChQ,CAAD,CAAO,CAAA,IAC5BgG,EAAShG,CAAAgG,OADmB,CAE5BiK,EAAYjQ,CAAAiQ,UAFgB,CAG5BC,EAAWlQ,CAAAkQ,SAHiB,CAI5BC,EAAWnQ,CAAAmQ,SACf,OAAO,CAAC,CACN3R,UAAW,WADL,CAENC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CAKrB,GAvBciL,CAuBd,GAJajL,CAAAkL,OAIb,CAAA,CAIA,IAAIpP,EAAQ,CACVK,EARY6D,CAAAmL,QAOF,CAEVpP,EARYiE,CAAAoL,QAMF,CAAZ,CAIIvM,EAAQkM,CAAA,EAEZ,IAAmB,UAAnB,GAAIlM,CAAArG,KAAJ,CACEwH,CAAAqL,eAAA,EACA,CAAAxM,CAAAyM,QAAAC,KAAA,CAAmBzP,CAAnB,CAFF,KAAA,CAMiB,SAAjB,GAAE+C,CAAArG,KAAF,CAA2GoB,CAAA,CAAU,CAAA,CAAV,CAA3G,CAA8H,IAAK,EACnI,KAAI4R,EAAU3M,CAAA/C,MAEd,IAzCqB2P,CAyCrB,EAtCGC,IAAAC,IAAA,CAsC0C7P,CAtCjCK,EAAT,CAsCiCqP,CAtCZrP,EAArB,CAsCH,EAzCqBsP,CAyCrB,EAtC+DC,IAAAC,IAAA,CAsClB7P,CAtC2BC,EAAT,CAsC3ByP,CAtCgDzP,EAArB,CAsC/D,CAIAiE,CAAAqL,eAAA,EAEA,CADIC,CACJ,CADczM,CAAAyM,QAAAM,UAAA,CAAwB9P,CAAxB,CACd;AAAAkP,CAAA,CAAS,CACPxS,KAAM,UADC,CAEP8S,QAASA,CAFF,CAAT,CAfA,CAVA,CALqB,CAFjB,CAAD,CAqCJ,CACDjS,UAAW,SADV,CAEDC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACrB,IAAInB,EAAQkM,CAAA,EAEO,WAAnB,GAAIlM,CAAArG,KAAJ,CACEqI,CAAA,EADF,EAKAb,CAAAqL,eAAA,EAIA,CAHAxM,CAAAyM,QAAAO,KAAA,CAAmB,CACjBC,qBAAsB,CAAA,CADL,CAAnB,CAGA,CAAAhB,CAAA,EATA,CAHqB,CAFtB,CArCI,CAqDJ,CACDzR,UAAW,WADV,CAEDC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACG,UAAxB,GAAI+K,CAAA,EAAAvS,KAAJ,EACEwH,CAAAqL,eAAA,EAGFxK,EAAA,EALqB,CAFtB,CArDI,CA8DJ,CACDxH,UAAW,SADV,CAEDC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CAGF,SAAnB,GAFY+K,CAAAlM,EAERrG,KAAJ,CACEqI,CAAA,EADF,CApHOkL,EAyHP,GAAI/L,CAAAgM,QAAJ,EACEhM,CAAAqL,eAAA,EACA,CAAAxK,CAAA,EAFF,EA3GAoL,EAAA,CAiHyBjM,CAjHXgM,QAAd,CA2GA,EAMyBhM,CAhH3BqL,eAAA,EAkGuB,CAFtB,CA9DI,CAgFJ,CACDhS,UAAW,QADV,CAEDC,GAAIuH,CAFH,CAhFI,CAmFJ,CACDxH,UAAW,QADV,CAEDH,QAAS,CACP4G,QAAS,CAAA,CADF,CAEPC,QAAS,CAAA,CAFF,CAFR,CAMDzG,GAAIA,QAAW,EAAG,CACQ,SAAxB;AAAIyR,CAAA,EAAAvS,KAAJ,EACEqI,CAAA,EAFc,CANjB,CAnFI,CA8FJ,CACDxH,UAAW,sBADV,CAEDC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACrB,IAAInB,EAAQkM,CAAA,EACK,OAAjB,GAAElM,CAAArG,KAAF,CAA0GoB,CAAA,CAAU,CAAA,CAAV,CAA1G,CAA6H,IAAK,EAE9HiF,EAAAyM,QAAAY,wBAAA,EAAJ,CACErL,CAAA,EADF,CAKAb,CAAAqL,eAAA,EATqB,CAFtB,CA9FI,CA2GJ,CACDhS,UAAW8S,EADV,CAED7S,GAAIuH,CAFH,CA3GI,CALyB,CAqQlCuL,QAASA,GAAM,EAAG,EAIlBC,QAASA,GAAmB,CAACf,CAAD,CAAU1K,CAAV,CAAgB,CAC1CC,QAASA,EAAM,EAAG,CAChBD,CAAA,EACA0K,EAAAzK,OAAA,EAFgB,CAUlB,MAAO,CAAC,CACNxH,UAAW,SADL,CAENC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CAlUd+L,EAmUP,GAAI/L,CAAAgM,QAAJ,EACEhM,CAAAqL,eAAA,EACA,CAAAxK,CAAA,EAFF,EAlUMyL,EAwUN,GAAItM,CAAAgM,QAAJ,EACEhM,CAAAqL,eAAA,EAbJ,CADAzK,CAAA,EACA,CAAA0K,CAAAO,KAAA,EAYE,EAhUUU,EAsUV,GAAIvM,CAAAgM,QAAJ,EACEhM,CAAAqL,eAAA,EACA,CAAAC,CAAAkB,SAAA,EAFF,EAxUQC,EA8UR,GAAIzM,CAAAgM,QAAJ,EACEhM,CAAAqL,eAAA,EACA,CAAAC,CAAAoB,OAAA,EAFF,EA7UWC,EAmVX,GAAI3M,CAAAgM,QAAJ,EACEhM,CAAAqL,eAAA,EACA;AAAAC,CAAAsB,UAAA,EAFF,EArVUC,EA2VV,GAAI7M,CAAAgM,QAAJ,EACEhM,CAAAqL,eAAA,EACA,CAAAC,CAAAwB,SAAA,EAFF,EAMIC,EAAA,CAAe/M,CAAAgM,QAAf,CAAJ,CACEhM,CAAAqL,eAAA,EADF,CAzVAY,EAAA,CA8VyBjM,CA9VXgM,QAAd,CAyVA,EAKyBhM,CA7V3BqL,eAAA,EAmTuB,CAFjB,CAAD,CA8CJ,CACDhS,UAAW,WADV,CAEDC,GAAIuH,CAFH,CA9CI,CAiDJ,CACDxH,UAAW,SADV,CAEDC,GAAIuH,CAFH,CAjDI,CAoDJ,CACDxH,UAAW,OADV,CAEDC,GAAIuH,CAFH,CApDI,CAuDJ,CACDxH,UAAW,YADV,CAEDC,GAAIuH,CAFH,CAvDI,CA0DJ,CACDxH,UAAW,QADV,CAEDC,GAAIuH,CAFH,CA1DI,CA6DJ,CACDxH,UAAW,OADV,CAEDC,GAAIuH,CAFH,CAGD3H,QAAS,CACP4G,QAAS,CAAA,CADF,CAHR,CA7DI,CAmEJ,CACDzG,UAAW8S,EADV,CAED7S,GAAIuH,CAFH,CAnEI,CAXmC,CAwJ5CmM,QAASA,GAAiB,CAACnS,CAAD,CAAO,CAAA,IAC3BgG,EAAShG,CAAAgG,OADkB,CAE3BkK,EAAWlQ,CAAAkQ,SACf,OAAO,CAAC,CACN1R,UAAW,mBADL,CAENC,GAAIuH,CAFE,CAAD,CAGJ,CACDxH,UAAW,QADV,CAEDC,GAAIuH,CAFH,CAHI,CAMJ,CACDxH,UAAW,aADV,CAEDC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACrBA,CAAAqL,eAAA,EADqB,CAFtB,CANI;AAWJ,CACDhS,UAAW,SADV,CAEDC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACG,UAAxB,GAAI+K,CAAA,EAAAvS,KAAJ,EA9dOuT,EA8dP,GAKI/L,CAAAgM,QALJ,EAMEhM,CAAAqL,eAAA,EALAxK,EAAA,EAFmB,CAFtB,CAXI,CAyBJ,CACDxH,UAAW8S,EADV,CAED7S,GAAIuH,CAFH,CAzBI,CAHwB,CAkCjCoM,QAASA,GAAiB,CAACpP,CAAD,CAAQ,CAAA,IAC5BgD,EAAShD,CAAAgD,OADmB,CAE5BiK,EAAYjN,CAAAiN,UAFgB,CAG5BC,EAAWlN,CAAAkN,SACf,OAAO,CAAC,CACN1R,UAAW,WADL,CAENH,QAAS,CACP6G,QAAS,CAAA,CADF,CAFH,CAKNzG,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACrB,IAAInB,EAAQkM,CAAA,EAEZ,IAAmB,UAAnB,GAAIlM,CAAArG,KAAJ,CACEqI,CAAA,EADF,KAAA,CAKAhC,CAAAqO,SAAA,CAAiB,CAAA,CARI,KASjBC,EAAkBnN,CAAAoN,QAAA,CAAc,CAAd,CAGlBtR,EAAAA,CAAQ,CACVK,EAHYgR,CAAAhC,QAEF,CAEVpP,EAHYoR,CAAA/B,QACF,CAIZpL,EAAAqL,eAAA,EACAxM,EAAAyM,QAAAC,KAAA,CAAmBzP,CAAnB,CAdA,CAHqB,CALjB,CAAD,CAwBJ,CACDzC,UAAW,UADV,CAEDC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACrB,IAAInB,EAAQkM,CAAA,EAEO,WAAnB,GAAIlM,CAAArG,KAAJ,CACEqI,CAAA,EADF,EAKAb,CAAAqL,eAAA,EAIA,CAHAxM,CAAAyM,QAAAO,KAAA,CAAmB,CACjBC,qBAAsB,CAAA,CADL,CAAnB,CAGA;AAAAhB,CAAA,EATA,CAHqB,CAFtB,CAxBI,CAwCJ,CACDzR,UAAW,aADV,CAEDC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACG,UAAxB,GAAI+K,CAAA,EAAAvS,KAAJ,EAKAwH,CAAAqL,eAAA,EAJExK,EAAA,EAFmB,CAFtB,CAxCI,CAmDJ,CACDxH,UAAW,kBADV,CAEDC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACrB,IAAInB,EAAQkM,CAAA,EACK,OAAjB,GAAElM,CAAArG,KAAF,CAAsFoB,CAAA,CAAU,CAAA,CAAV,CAAtF,CAAyG,IAAK,EAC9G,KAAIyT,EAAQrN,CAAAoN,QAAA,CAAc,CAAd,CAEPC,EAAL,EAlGoBC,GAkGpB,EAImBD,CAAAE,MAJnB,GAUIC,CAEJ,CAFoB3O,CAAAyM,QAAAY,wBAAA,EAEpB,CAAmB,SAAnB,GAAIrN,CAAArG,KAAJ,CACMgV,CADN,EAEI3M,CAAA,EAFJ,CAQI2M,CAAJ,CACM3O,CAAAqO,SAAJ,CACElN,CAAAqL,eAAA,EADF,CAKAxK,CAAA,EANF,CAUAb,CAAAqL,eAAA,EA9BA,CALqB,CAFtB,CAnDI,CA0FJ,CACDhS,UAAW8S,EADV,CAED7S,GAAIuH,CAFH,CA1FI,CAJyB,CAuQlC4M,QAASA,GAAsB,CAACC,CAAD,CAASxI,CAAT,CAAkB,CAC/C,GAAe,IAAf,EAAIA,CAAJ,CACE,MAAO,CAAA,CAKT,IAFkCyI,EAAAC,CAAoB1I,CAAA2I,QAAAC,YAAA,EAApBF,CAElC,CACE,MAAO,CAAA,CAGT,KAAIG,EAAY7I,CAAAyB,aAAA,CAAqB,iBAArB,CAEhB,OAAkB,MAAlB,GAAIoH,CAAJ,EAA0C,EAA1C,GAA4BA,CAA5B;AACS,CAAA,CADT,CAII7I,CAAJ,GAAgBwI,CAAhB,CACS,CAAA,CADT,CAIOD,EAAA,CAAuBC,CAAvB,CAA+BxI,CAAA8I,cAA/B,CArBwC,CAwBjDC,QAASA,GAA2B,CAAC3S,CAAD,CAAY0E,CAAZ,CAAmB,CACjDtD,CAAAA,CAASsD,CAAAtD,OAEb,OAAKsJ,GAAA,CAActJ,CAAd,CAAL,CAIO+Q,EAAA,CAAuBnS,CAAvB,CAAkCoB,CAAlC,CAJP,CACS,CAAA,CAJ4C,CAgCvDwR,QAASA,GAAe,CAACtV,CAAD,CAAK8K,CAAL,CAAe,CACrC,MAAU,KAAV,EAAI9K,CAAJ,CACS,IADT,CAIIA,CAAA,CAAGuV,EAAH,CAAA,CAAyBzK,CAAzB,CAAJ,CACS9K,CADT,CAIOsV,EAAA,CAAgBtV,CAAAoV,cAAhB,CAAkCtK,CAAlC,CAT8B,CAwBvC0K,QAASA,GAA8B,CAAClL,CAAD,CAAYlD,CAAZ,CAAmB,CACpDtD,CAAAA,CAASsD,CAAAtD,OAEb,IAAI,EAAWA,CAAX,WA5CiB2R,CA4CN3R,CAj0CR,EAi0CQA,CAj0CFwJ,cAAN,CAi0CQxJ,CAj0CiBwJ,cAAAC,YAAzB,CAAwDlG,MAqxC1CoO,SA4CjB,CAAJ,CAEE,MADoF,KAAK,EAClF,CAAA,IAIsB3K,EAAAA,CAZxB,GAYwBA,CAZlBC,EAAAT,UAYkBQ,CAZK,OAYLA,CADJR,CACIQ,CAZyB,IAPtD,EAAA,CAmBqBhH,CApBnBqC,QAAJ,CAoBuBrC,CAnBdqC,QAAA,CAAW2E,CAAX,CADT,CAIOwK,EAAA,CAgBgBxR,CAhBhB,CAAoBgH,CAApB,CAkBP,OAAKgD,EAAL,CAIKV,EAAA,CAAcU,CAAd,CAAL,CAKOA,CALP,EACyF,IAAK,EACrF,CAAA,IAFT,CAJA,CACS,IAZ+C,CAiC1D4H,QAASA,GAAa,CAACpL,CAAD,CAAY/F,CAAZ,CAAyB,CAEzCkJ,CAAAA,CAz4LGC,KAAAC,UAAAjI,MAAAkI,KAAA,CAy4LgBtG,QAAAuG,iBAAAzM,CADR,GACQA,CADFsB,EAAA4H,UACElJ,CADoB,OACpBA,CAD4BkJ,CAC5BlJ,CADwC,IACxCA,CAz4LhB,CA04LHuK,EAAAA,CAAcnK,CAAA,CAAKiM,CAAL,CAAe,QAAS,CAACzN,CAAD,CAAK,CAC7C,MAAOA,EAAA+N,aAAA,CAAgBrL,EAAAc,GAAhB,CAAP;AAAyCe,CADI,CAA7B,CAIlB,OAAKoH,EAAL,CAIKyB,EAAA,CAAczB,CAAd,CAAL,CAKOA,CALP,EAC8F,IAAK,EAC1F,CAAA,IAFT,CAJA,CACS,IARoC,CAmB/C8G,QAASA,GAAc,CAACrL,CAAD,CAAQ,CAC7BA,CAAAqL,eAAA,EAD6B,CAI/BkD,QAASA,GAAS,CAAC1T,CAAD,CAAO,CAAA,IACnB2T,EAAW3T,CAAA2T,SADQ,CAEnB3P,EAAQhE,CAAAgE,MAFW,CAGnB4P,EAAe5T,CAAA4T,aACfC,EAAAA,CAAa7T,CAAA6T,WAUjB,OARKD,EAAA,EAQL,EAAID,CAAJ,GAAiB3P,CAAjB,CAQO,CAAA,CARP,EACM6P,CAIG,EAHmW,IAAK,EAGxW,CAAA,CAAA,CALT,CAduB,CAyBzBC,QAASA,GAAQ,CAAC9Q,CAAD,CAAQ,CAAA,IAEnB+Q,EAAQ/Q,CAAA+Q,MAFW,CAGnB7N,EAAWlD,CAAAkD,SAHQ,CAInB5D,EAAcU,CAAAV,YAElB,IALcU,CAAAgR,QAKVrE,UAAA,EAAJ,CACE,MAAO,CAAA,CAGLlI,EAAAA,CAAQvB,CAAAzF,UAAAoN,SAAA,CAA4BvL,CAA5B,CAEZ,OAAKmF,EAAL,CAKKA,CAAApJ,QAAA4V,UAIL,EAAKC,EAAA,CAAaH,CAAAI,SAAA,EAAb,CAA+B7R,CAA/B,CAAL,CAIO,CAAA,CAJP,CACS,CAAA,CAVT,EACwG,IAAK,EACpG,CAAA,CAAA,CAFT,CAZuB,CA4BzB8R,QAASA,GAAQ,CAACC,CAAD,CAAQ,CAkCvBC,QAASA,EAA0B,EAAG,CACpC,MAAO7M,GAAApJ,QAAAgT,wBAD6B,CAItCuC,QAASA,EAAY,EAAG,CACtB,MAAOI,EAAAzO,SAAA,CAAiBmK,EAAjB,CADe,CAiBxB6E,QAASA,EAAM,CAAC3S,CAAD,CAAO,CAcpB4S,QAASA,EAAM,CAACvJ,CAAD;AAAS5M,CAAT,CAAkB,CACf,IAAK,EAArB,GAAIA,CAAJ,GACEA,CADF,CACY,CACR4S,qBAAsB,CAAA,CADd,CADZ,CAMArP,EAAA6S,QAAA,EAEIpW,EAAA4S,qBAAJ,GACMvS,CASJ,CATaZ,CAAA,CAAWsH,MAAX,CAAmB,CAAC,CAC/B5G,UAAW,OADoB,CAE/BC,GAAI+R,EAF2B,CAG/BnS,QAAS,CACPqW,KAAM,CAAA,CADC,CAEPzP,QAAS,CAAA,CAFF,CAGPC,QAAS,CAAA,CAHF,CAHsB,CAAD,CAAnB,CASb,CAAA+J,UAAA,CAAWvQ,CAAX,CAVF,CArBAsV,EAAAvE,QAAA,EACAzL,EAAA,CAAQ,WAkCR+P,EAAAY,SAAA,CApjHG,CACLhX,KAAM,MADD,CAELiX,QAkjHsBhT,CAClBqJ,OAAQA,CADUrJ,CApjHjB,CAojHH,CAvB+B,CARnB,UAAd,GAAIoC,CAAJ,GAJEgQ,CAAAvE,QAAA,EAMA,CALAzL,CAKA,CALQ,WAKR,CAAY,UAAZ,GAAEA,CAAF,CAAsHjF,CAAA,CAAU,CAAA,CAAV,CAAtH,CAAyI,IAAK,EAFhJ,CAKAgV,EAAAY,SAAA,CAhoHK,CACLhX,KAAM,MADD,CAELiX,QA8nHoBhT,CAAAiT,eAhoHf,CAgoHL,CACA7Q,EAAA,CAAQ,UA8BR,OAAO1F,EAAA,CAAS,CACdiH,SAAUA,QAAiB,EAAG,CAC5B,MAAOmO,GAAA,CAAU,CACfC,SAAU,UADK,CAEf3P,MAAOA,CAFQ,CAGf4P,aAAcA,CAHC,CAIfC,WAAY,CAAA,CAJG,CAAV,CADqB,CADhB,CASdxC,wBAAyBiD,CATX;AAUdtD,KAAMA,QAAa,CAAC3S,CAAD,CAAU,CAC3B,MAAOmW,EAAA,CAAO,MAAP,CAAenW,CAAf,CADoB,CAVf,CAad2H,OAAQA,QAAe,CAAC3H,CAAD,CAAU,CAC/B,MAAOmW,EAAA,CAAO,QAAP,CAAiBnW,CAAjB,CADwB,CAbnB,CAAT,CAgBJuD,CAAA6O,QAhBI,CA1Ca,CAvDC,IACnBuD,EAAUK,CAAAL,QADS,CAEnB3L,EAAYgM,CAAAhM,UAFO,CAGnB0L,EAAQM,CAAAN,MAHW,CAInB7N,EAAWmO,CAAAnO,SAJQ,CAKnB5D,EAAc+R,CAAA/R,YALK,CAMnBwS,EAAkBT,CAAAS,gBAClBC,EAAAA,CAAcV,CAAAU,YAQlB,IAAI,CAPcjB,EAAAkB,CAAS,CACzBhB,QAASA,CADgB,CAEzBD,MAAOA,CAFkB,CAGzB7N,SAAUA,CAHe,CAIzB5D,YAAaA,CAJY,CAAT0S,CAOlB,CACE,MAAO,KAGT,KAAIvN,GAAQvB,CAAAzF,UAAAuG,QAAA,CAA2B1E,CAA3B,CAAZ,CACIvE,EAAK0V,EAAA,CAAcpL,CAAd,CAAyBZ,EAAAjG,WAAAD,GAAzB,CAET,IAAI,CAACxD,CAAL,CAEE,MAD8G,KAAK,EAC5G,CAAA,IAGT,IAAIgX,CAAJ,EAAmB,CAACtN,EAAApJ,QAAA4W,2BAApB,EAAgE7B,EAAA,CAA4BrV,CAA5B,CAAgCgX,CAAhC,CAAhE,CACE,MAAO,KAGT,KAAIrF,GAAOsE,CAAApE,MAAA,CAAckF,CAAd,EAAiCjX,CAAjC,CAAX,CACImG,EAAQ,UADZ,CAsBIkR,EAXJC,QAAoB,CAACxB,CAAD,CAAWyB,CAAX,CAAsB,CACpC1B,EAAA,CAAU,CACZC,SAAUA,CADE,CAEZ3P,MAAOA,CAFK,CAGZ4P,aAAcA,CAHF,CAIZC,WAAY,CAAA,CAJA,CAAV,CAAJ;AAMEE,CAAAY,SAAA,CAAeS,CAAA,EAAf,CAPsC,CAWZC,KAAA,CAAiB,IAAjB,CAAuB,UAAvB,CA8I9B,OAdcC,CACZ/P,SAAUA,QAAiB,EAAG,CAC5B,MAAOmO,GAAA,CAAU,CACfC,SAAU,UADK,CAEf3P,MAAOA,CAFQ,CAGf4P,aAAcA,CAHC,CAIfC,WAAY,CAAA,CAJG,CAAV,CADqB,CADlByB,CASZjE,wBAAyBiD,CATbgB,CAUZvE,UA3EFA,QAAkB,CAACwE,CAAD,CAAkB,CAClC,IAAIC,EAAS9P,EAAA,CAAQ,QAAS,CAAC+P,CAAD,CAAS,CACrCP,CAAA,CAAwB,QAAS,EAAG,CAClC,MAAOxE,GAAA,CAAK,CACV+E,OAAQA,CADE,CAAL,CAD2B,CAApC,CADqC,CAA1B,CAOTC,EAAAA,CAAMnB,CAAA,CAAO,CACfM,eAAgB,CACdtT,GAAIe,CADU,CAEdiT,gBAAiBA,CAFH,CAGd1Q,aAAc,OAHA,CADD,CAMf4P,QAASA,QAAgB,EAAG,CAC1B,MAAOe,EAAAxP,OAAA,EADmB,CANb,CASfyK,QAAS,CACPC,KAAM8E,CADC,CATM,CAAP,CAaV,OAAOlX,EAAA,CAAS,EAAT,CAAaoX,CAAb,CAAkB,CACvBhF,KAAM8E,CADiB,CAAlB,CArB2B,CAiEtBF,CAWZK,SAlDFA,QAAiB,EAAG,CAelB,MAAOpB,EAAA,CAAO,CACZM,eAAgB,CACdtT,GAAIe,CADU,CAEdiT,gBA1TC7U,EAAAC,QAAA,CA0T2C5C,CA1TvB6X,sBAAA,EAApB,CAAAC,OAwTa;AAGdhR,aAAc,MAHA,CADJ,CAMZ4P,QAAS5W,CANG,CAOZ4S,QArBYA,CACZoB,OAAQiE,QAAiB,EAAG,CAC1B,MAAOZ,EAAA,CAAwBrD,EAAxB,CADmB,CADhBpB,CAIZsB,UAAWgE,QAAoB,EAAG,CAChC,MAAOb,EAAA,CAAwBnD,EAAxB,CADyB,CAJtBtB,CAOZkB,SAAUqE,QAAmB,EAAG,CAC9B,MAAOd,EAAA,CAAwBvD,EAAxB,CADuB,CAPpBlB,CAUZwB,SAAUgE,QAAmB,EAAG,CAC9B,MAAOf,EAAA,CAAwBjD,EAAxB,CADuB,CAVpBxB,CAcA,CAAP,CAfW,CAuCN6E,CAYZY,MAzBFC,QAAqB,EAAG,CACFzC,EAAA0C,CAAU,CAC5BzC,SAAU,UADkB,CAE5B3P,MAAOA,CAFqB,CAG5B4P,aAAcA,CAHc,CAI5BC,WAAY,CAAA,CAJgB,CAAVuC,CAOpB,EACEpC,CAAAvE,QAAA,EAToB,CAaV6F,CArLS,CAuMzBe,QAASA,GAAgB,CAACC,CAAD,CAAQ,CAAA,IAC3BjO,EAAYiO,CAAAjO,UADe,CAE3B0L,EAAQuC,CAAAvC,MAFmB,CAG3B7N,EAAWoQ,CAAApQ,SAGXqQ,EAAAA,CAAa,EAAAC,OAAA,CADUF,CAAAG,qBACA,CAAuBC,EAAvB,CAAwC,EAAlD,CAFGJ,CAAAK,cAEH,EAAuE,EAAvE,CACjB,KAAI3C,EAAUlK,CAAA8M,SAAA,CAAe,QAAS,EAAG,CACvC,MAAOpH,GAAA,EADgC,CAA3B,CAAA,CAEX,CAFW,CAAd,CAGIqH,EAAiBrO,CAAA0B,YAAA,CAAuB2M,QAAuB,CAAC1U,CAAD,CAAWkI,CAAX,CAAoB,CACjFlI,CAAAyC,WAAJ,EAA2B,CAACyF,CAAAzF,WAA5B,EACEoP,CAAAjE,WAAA,EAFmF,CAAlE;AAIlB,CAACiE,CAAD,CAJkB,CAKrBxJ,GAAA,CAA0BsM,QAAsB,EAAG,CACjD,IAAI3U,EAAW4R,CAAAI,SAAA,EAMf,OALkBJ,EAAA3F,UAAAC,CAAgB,QAAS,EAAG,CAC5C,IAAIhE,EAAU0J,CAAAI,SAAA,EACd0C,EAAA,CAAe1U,CAAf,CAAyBkI,CAAzB,CACAlI,EAAA,CAAWkI,CAHiC,CAA5BgE,CAF+B,CAAnD,CAQG,CAAC2F,CAAD,CAAUD,CAAV,CAAiB8C,CAAjB,CARH,CASArM,GAAA,CAA0B,QAAS,EAAG,CACpC,MAAOwJ,EAAAjE,WAD6B,CAAtC,CAEG,CAACiE,CAAAjE,WAAD,CAFH,CA2CA,KAxCA,IAAIgH,EAAavO,CAAA0B,YAAA,CAAuB,QAAS,CAAC5H,CAAD,CAAc,CAC7D,MAAOwR,GAAA,CAAS,CACdE,QAASA,CADK,CAEd9N,SAAUA,CAFI,CAGd6N,MAAOA,CAHO,CAIdzR,YAAaA,CAJC,CAAT,CADsD,CAA9C,CAOd,CAAC0R,CAAD,CAAU9N,CAAV,CAAoB6N,CAApB,CAPc,CAAjB,CAQIiD,EAAaxO,CAAA0B,YAAA,CAAuB,QAAS,CAAC5H,CAAD,CAAc2U,CAAd,CAAyB5Y,CAAzB,CAAkC,CACjF,MAAO+V,GAAA,CAAS,CACdJ,QAASA,CADK,CAEd9N,SAAUA,CAFI,CAGdmC,UAAWA,CAHG,CAId0L,MAAOA,CAJO,CAKdzR,YAAaA,CALC,CAMdwS,gBAAiBmC,CANH,CAOdlC,YAAa1W,CAAA,EAAWA,CAAA0W,YAAX,CAAiC1W,CAAA0W,YAAjC,CAAuD,IAPtD,CAAT,CAD0E,CAAlE,CAUd,CAAC1M,CAAD,CAAY2L,CAAZ,CAAqB9N,CAArB,CAA+B6N,CAA/B,CAVc,CARjB,CAmBImD,EAAyB1O,CAAA0B,YAAA,CAAuB,QAAS,CAAC/E,CAAD,CAAQ,CApUrE,CAAA,CAJA,CAFI0G,CAEJ,CAFa0H,EAAA,CA2U8BlL,CA3U9B,CA2UyClD,CA3UzC,CAEb,EAIO0G,CAAAC,aAAA,CAAoBhD,EAAAxG,YAApB,CAJP;AACS,IAwUP,OAAO,EAD4D,CAAxC,CAE1B,CAAC+F,CAAD,CAF0B,CAnB7B,CAsBI8O,EAA0B3O,CAAA0B,YAAA,CAAuB,QAAS,CAAC3I,CAAD,CAAK,CAEjE,MAAO,CADHkG,CACG,CADKvB,CAAAzF,UAAAoN,SAAA,CAA4BtM,CAA5B,CACL,EAAQkG,CAAApJ,QAAR,CAAwB,IAFkC,CAArC,CAG3B,CAAC6H,CAAAzF,UAAD,CAH2B,CAtB9B,CA0BI2W,EAAiB5O,CAAA0B,YAAA,CAAuB8J,CAAAjE,WAAvB,CAA2C,CAACiE,CAAD,CAA3C,CA1BrB,CA2BIqD,EAAgB7O,CAAA0B,YAAA,CAAuB8J,CAAArE,UAAvB,CAA0C,CAACqE,CAAD,CAA1C,CA3BpB,CA4BI0B,EAAMlN,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACvC,MAAO,CACLsO,WAAYA,CADP,CAELC,WAAYA,CAFP,CAGLE,uBAAwBA,CAHnB,CAILC,wBAAyBA,CAJpB,CAKLC,eAAgBA,CALX,CAMLC,cAAeA,CANV,CADgC,CAA/B,CASP,CAACN,CAAD,CAAaC,CAAb,CAAyBE,CAAzB,CAAiDC,CAAjD,CAA0EC,CAA1E,CAA0FC,CAA1F,CATO,CA5BV,CAwCShY,EAAI,CAAb,CAAgBA,CAAhB,CAAoBkX,CAAAjX,OAApB,CAAuCD,CAAA,EAAvC,CACEkX,CAAA,CAAWlX,CAAX,CAAA,CAAcqW,CAAd,CApE6B,CAiFjC4B,QAASA,GAAQ,CAACC,CAAD,CAAU,CACxBA,CAAAlN,QAAD,CAAuI,IAAK,EAA5I,CAAoHtL,CAAA,CAAU,CAAA,CAAV,CACpH,OAAOwY,EAAAlN,QAFkB,CAK3BmN,QAASA,GAAG,CAACC,CAAD,CAAQ,CAAA,IACdpP,EAAYoP,CAAApP,UADE,CAEdqP,EAAeD,CAAAC,aAFD,CAGdC,EAAUF,CAAAE,QAHI,CAIdrP,EAAQmP,CAAAnP,MAJM,CAKd+G,EAAkBoI,CAAApI,gBALJ;AAMduI,EAAe9N,CAAAC,OAAA,CAAa,IAAb,CAND,CAQd8N,EAAetI,EAAA,CAAYkI,CAAZ,CARD,CASdK,EAAgBtP,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAC7BG,IAAAA,EAAAwN,CAAAxN,QAAxB,OAvBK,CACL0N,kBAAmBN,CAAAM,kBADd,CAELC,YAAaP,CAAAO,YAFR,CAGLC,UAAWR,CAAAQ,UAHN,CAILC,aAAcT,CAAAS,aAJT,CAsBgD,CAAnC,CAEjB,CAACL,CAAD,CAFiB,CATF,CAYd1I,EAAWR,EAAA,CAAatG,CAAb,CAZG,CAad8P,EAAoB/I,EAAA,CAAmB/G,CAAnB,CAA8BgH,CAA9B,CAbN,CAcd+I,EAAehQ,EAAA,CAAgBC,CAAhB,CAA2BC,CAA3B,CAdD,CAed+P,EAAe7P,CAAA0B,YAAA,CAAuB,QAAS,CAACoO,CAAD,CAAS,CAC1DhB,EAAA,CAASM,CAAT,CAAAjD,SAAA,CAAgC2D,CAAhC,CAD0D,CAAzC,CAEhB,EAFgB,CAfD,CAkBdC,EAAmB/P,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACpD,MAAO+P,GAAAC,mBAAA,CAAyB,CAC9BC,qBAAsBA,EADQ,CAE9BC,sBAAuBA,EAFO,CAG9BC,yBAA0BA,EAHI,CAI9BC,gCAAiCA,EAJH,CAK9BrS,mBAAoBA,EALU,CAAzB,CAMJ6R,CANI,CAD6C,CAA/B,CAQpB,CAACA,CAAD,CARoB,CAlBL,CA2BdnS,EAAWsI,EAAA,EA3BG,CA4BdsK,EAAmBtQ,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACpD,MAAOsQ,GAAA,CAAuB7S,CAAvB;AAAiCqS,CAAjC,CAD6C,CAA/B,CAEpB,CAACrS,CAAD,CAAWqS,CAAX,CAFoB,CA5BL,CA+BdS,EAAexQ,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAChD,MAAOwQ,GAAA,CAAmB3a,CAAA,CAAS,CACjC4a,aAAcA,EADmB,CAEjCC,gBAAiBL,CAAAK,gBAFgB,CAAT,CAGvBX,EAAAC,mBAAA,CAAyB,CAC1B/H,KAAMA,EADoB,CAAzB,CAEA2H,CAFA,CAHuB,CAAnB,CADyC,CAA/B,CAOhB,CAACS,CAAAK,gBAAD,CAAmCd,CAAnC,CAPgB,CA/BD,CAuCde,EAAerN,CAAA,CAAgB1D,CAAhB,CACf0L,EAAAA,CAAQvL,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACzC,MAz4FK+P,GAAAa,YAAA,CAAkBC,EAAlB,CAA2BC,EAAA,CAAiBf,EAAAgB,gBAAA,CAAsB1K,EAAA,CA+4FvDsJ,CA/4FuD,CAAtB,CAA2CqB,EAAA,CA44FxEX,CA54FwE,CAA3C,CAAsFvE,EAAA,CA44FnHuE,CA54FmH,CAAtF,CAAgHY,EAAhH,CAAwHC,EAAxH,CAA6IC,EAA7I,CAAyKC,EAAzK,CAAsLC,EAAA,CA24FvNd,CA34FuN,CAAtL,CAAgNe,EAAhN,CAAgO1N,EAAA,CA64FjQ+M,CA74FiQ,CAAhO,CAAqPY,EAAA,CA84FrRlC,CA94FqR,CA04F1R3I,CA14F0R,CAArP,CAAjB,CAA3B,CAw4FoC,CAA/B,CAST,CAACA,CAAD,CAAW6J,CAAX,CAAyBF,CAAzB,CAA2CM,CAA3C,CAAyDtB,CAAzD,CAAwEM,CAAxE,CATS,CAiBZR,EAAAvN,QAAA,CAAuB0J,CACvB,KAAIkG,EAAgBzR,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CACrD,IAAIG,EAAUiN,EAAA,CAASM,CAAT,CAGM,OAApB,GAFYvN,CAAA8J,SAAApQ,EAERC,MAAJ,EACEqG,CAAAsK,SAAA,CAt0HG,CACLhX,KAAM,OADD,CAELiX,QAAS,IAFJ,CAs0HH,CALmD,CAAnC,CAOjB,EAPiB,CAApB,CAQIhQ,EAAa4D,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAClD,IAAInG,EAAQuT,EAAA,CAASM,CAAT,CAAAzD,SAAA,EACZ,OAAOpQ,EAAAa,WAAP;AAA2C,gBAA3C,GAA2Bb,CAAAC,MAFuB,CAAnC,CAGd,EAHc,CAIbkW,EAAAA,CAAe1R,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAChD,MAAO,CACL7D,WAAYA,CADP,CAELuV,SAAUF,CAFL,CADyC,CAA/B,CAKhB,CAACrV,CAAD,CAAaqV,CAAb,CALgB,CAMnBvC,EAAA,CAAawC,CAAb,CACA,KAAIE,EAAa5R,CAAA0B,YAAA,CAAuB,QAAS,CAAC3I,CAAD,CAAK,CACpD,MAAO2S,GAAA,CAAaoD,EAAA,CAASM,CAAT,CAAAzD,SAAA,EAAb,CAAgD5S,CAAhD,CAD6C,CAArC,CAEd,EAFc,CAAjB,CAGI8Y,EAAuB7R,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAC5D,MAAOpG,EAAA,CAAkBwT,EAAA,CAASM,CAAT,CAAAzD,SAAA,EAAlB,CADqD,CAAnC,CAExB,EAFwB,CAGvBmG,EAAAA,CAAa9R,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAC9C,MAAO,CACLyC,QAAS4N,CADJ,CAELzM,MAAO+M,CAFF,CAGL/Q,UAAWA,CAHN,CAILkS,QAASH,CAJJ,CAKLtW,kBAAmBuW,CALd,CAMLlC,kBAAmBA,CANd,CAOLjS,SAAUA,CAPL,CADuC,CAA/B,CAUd,CAACmC,CAAD,CAAYyQ,CAAZ,CAA8BM,CAA9B,CAA4CgB,CAA5C,CAAwDC,CAAxD,CAA8ElC,CAA9E,CAAiGjS,CAAjG,CAVc,CAWjBmQ,GAAA,CAAiB,CACfhO,UAAWA,CADI,CAEf0L,MAAOA,CAFQ,CAGf7N,SAAUA,CAHK,CAIfyQ,cAAegB,CAJA,CAKflB,qBAAqD,CAAA,CAArDA,GAAsBgB,CAAAhB,qBALP,CAAjB,CAOA3M,EAAA2E,UAAA,CAAgB,QAAS,EAAG,CAC1B,MAAOwL,EADmB,CAA5B;AAEG,CAACA,CAAD,CAFH,CAGA,OAAOO,GAAA5L,cAAA,CAA6B6L,EAAAC,SAA7B,CAAkD,CACvDhN,MAAO4M,CADgD,CAAlD,CAEJE,EAAA5L,cAAA,CAA6B+L,EAAAD,SAA7B,CAAkD,CACnDE,QAASC,EAD0C,CAEnD9G,MAAOA,CAF4C,CAAlD,CAGA0D,CAAAqD,SAHA,CAFI,CAxGW,CAkZpBC,QAASA,GAAkB,CAACC,CAAD,CAAU,CAEnC,CADIrT,CACJ,CADamC,CAAAmR,WAAA,CAAiBD,CAAjB,CACb,EAA2H,IAAK,EAAhI,CAAwGjc,CAAA,CAAU,CAAA,CAAV,CACxG,OAAO4I,EAH4B,CAOrCuT,QAASA,GAAW,CAACjc,CAAD,CAAS,CAC3B,IAAIkc,EAAWrR,CAAAC,OAAA,CAAaqR,EAAA,EAAb,CACf,OAAOnc,EAAP,CAAgB,IAAhB,CAAuBkc,CAAA9Q,QAFI,CAS7BgR,QAASA,GAAqB,CAACzZ,CAAD,CAAO,CACnC,IAAI0Z,EAAmBxR,CAAAC,OAAA,CAAa,IAAb,CAAvB,CACIuQ,EAAaS,EAAA,CAAmBN,EAAnB,CADjB,CAEI9M,EAAWuN,EAAA,CAAY,WAAZ,CAFf,CAGIhV,EAAWoU,CAAApU,SAHf,CAIIgF,EAAUoP,CAAApP,QAJd,CAKIqQ,EAAchM,EAAA,CAAY3N,CAAZ,CALlB,CAMIJ,EAAagH,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAC9C,MAAO,CACLlH,GAAIK,CAAAiB,YADC,CAELlF,KAAMiE,CAAAjE,KAFD,CAGLwK,KAAMvG,CAAAuG,KAHD,CADuC,CAA/B,CAMd,CAACvG,CAAAiB,YAAD,CAAmBjB,CAAAuG,KAAnB,CAA8BvG,CAAAjE,KAA9B,CANc,CANjB,CAaI6d,EAAyB1R,CAAAC,OAAA,CAAavI,CAAb,CAb7B,CAcIia,EAAuBjT,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACxD,MAAO0B,GAAA,CAAW,QAAS,CAAC7I,CAAD,CAAIJ,CAAJ,CAAO,CAC/Boa,CAAAjR,QAAD;AAAkJ,IAAK,EAAvJ,CAA+HtL,CAAA,CAAU,CAAA,CAAV,CAK/HmM,EAAAyN,sBAAA,CAA8BnX,CAAAD,GAA9B,CAJagG,CACXjG,EAAGA,CADQiG,CAEXrG,EAAGA,CAFQqG,CAIb,CANgC,CAA3B,CADiD,CAA/B,CASxB,CAAC/F,CAAAD,GAAD,CAAgB2J,CAAhB,CATwB,CAd3B,CAwBIwQ,EAAmBlT,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CACxD,IAAIjC,EAAWqT,CAAAjR,QAEf,OAAKpC,EAAL,EAAkBA,CAAA0T,IAAAC,kBAAlB,CAIOC,EAAA,CAAY5T,CAAA0T,IAAAC,kBAAZ,CAJP,CACS1U,EAJ+C,CAAnC,CAQpB,EARoB,CAxBvB,CAiCIvB,EAAe6C,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CACpD,IAAI3C,EAASmU,CAAA,EACbD,EAAA,CAAqBlU,CAAAjG,EAArB,CAA+BiG,CAAArG,EAA/B,CAFoD,CAAnC,CAGhB,CAACwa,CAAD,CAAmBD,CAAnB,CAHgB,CAjCnB,CAqCIK,EAAuBtT,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACxD,MAAO/C,GAAA,CAAQC,CAAR,CADiD,CAA/B,CAExB,CAACA,CAAD,CAFwB,CArC3B,CAwCIoW,EAAkBvT,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CACvD,IAAIjC,EAAWqT,CAAAjR,QAAf,CACInG,EAAuC+D,CAAvC/D,EAAuC+D,CA9C1B0T,IAAAC,kBA8Cb1X,EA9C+C,IA+CjD+D,EAAF,EAAc/D,CAAd,CAAwJ,IAAK,EAA7J,CAAqInF,CAAA,CAAU,CAAA,CAAV,CACvHkJ,EAAA+T,cAEVC,yBAAJ,CACEtW,CAAA,EADF,CAKAmW,CAAA,EAXuD,CAAnC,CAYnB,CAACA,CAAD,CAAuBnW,CAAvB,CAZmB,CAxCtB,CAqDIuW,EAA6B1T,CAAA0B,YAAA,CAAuB,QAAS,CAACiS,CAAD,CAAe9d,CAAf,CAAwB,CACrFid,CAAAjR,QAAF,CAAgJtL,CAAA,CAAU,CAAA,CAAV,CAAhJ,CAAmK,IAAK,EACxK,KAAIoD,EAAWoZ,CAAAlR,QAAf,CACIS;AAAM3I,CAAAia,gBAAA,EACTtR,EAAD,CAA+H,IAAK,EAApI,CAA4G/L,CAAA,CAAU,CAAA,CAAV,CArO1G6c,KAAAA,EAAoBS,EAAA,CAsOLvR,CAtOK,CACxB,KAAIwR,EAAgBC,EAAA,CAqODzR,CArOC,CACpB,EAAA,CAAO,CACL8Q,kBAAmBA,CADd,CAELU,cAAeA,CAFV,CAqODrU,EAAAA,CAAW,CACb6C,IAAKA,CADQ,CAEbtJ,WAAYA,CAFC,CAGbma,IAAKA,CAHQ,CAIbK,cAAe3d,CAJF,CAMfid,EAAAjR,QAAA,CAA2BpC,CAzIK,KAK9BuU,EA0IWra,CAAAqa,UA/ImB,CAM9BC,EA0IgBta,CAAAsa,eAzIhBC,EAAAA,CA0IkBva,CAAAua,iBAzIlBC,EAAAA,CA0ImBA,CAACxa,CAAAya,wBAzIxB,KAAIhB,EAoIKD,CApIeC,kBAvCpBiB,KAAAA,EAAOnc,EAAAoc,OAAA,CAyKFhS,CAzKE,CAMX,IAkC4B8Q,CAlC5B,EAmKS9Q,CAnKT,GAkC4B8Q,CAlC5B,CAAA,CAII5a,CAAAA,CAAM6b,CAAAE,WAAA/b,IAANA,CA8BwB4a,CA9BIoB,UAChC,KAAI3b,EAAOwb,CAAAE,WAAA1b,KAAPA,CA6BwBua,CA7BMqB,WAS9BC,EAAAA,CAAYxc,EAAAE,OAAA,CANCmc,CACf/b,IAAKA,CADU+b,CAEf5b,MAHUE,CAGVF,CAwB0Bya,CA3BTuB,YACFJ,CAGf3b,OALWJ,CAKXI,CAuB0Bwa,CA5BTwB,aAEFL,CAIf1b,KAAMA,CAJS0b,CAMD,CAA+BF,CAAAQ,OAA/B,CAOhB,EAAA,CANa3c,EAAA4c,UAAA7H,CAAsB,CACjCyH,UAAWA,CADsB,CAEjCK,OAAQV,CAAAU,OAFyB,CAGjCF,OAAQR,CAAAQ,OAHyB;AAIjCG,QAASX,CAAAW,QAJwB,CAAtB/H,CAfb,CAmCI5U,CAAAA,CAAOH,EAAA+c,WAAA,CAAuBhI,CAAvB,CAmIO0G,CAnIP,CAGT,IAAKP,CAAL,CAAA,CAII8B,CAAAA,CAAchd,EAAAoc,OAAA,CAAmBlB,CAAnB,CAClB,KAAI+B,EAAa,CACfP,aAAcxB,CAAAwB,aADC,CAEfD,YAAavB,CAAAuB,YAFE,CAIjB,EAAA,CAAO,CACL1H,OAAQiI,CADH,CAEL7c,KAAMH,EAAA+c,WAAA,CAAuBC,CAAvB,CAqHQvB,CArHR,CAFD,CAGL5U,OAAQsU,EAAA,CAAYD,CAAZ,CAHH,CAIL+B,WAAYA,CAJP,CAKLhB,kBAAmBA,CALd,CATP,CAAA,IACE,EAAA,CAAO,IAzGP1I,EAAAA,CA4HSA,CAACwI,CA1HVH,EAAAA,CAqOKX,CAzGQW,cA1Hb7G,EAAAA,CA4HMA,CAvHHvR,EAAL,EAIIyZ,CAQJ,CARiBzZ,CAAAyZ,WAQjB,CAPID,CAOJ,CAPkBxZ,CAAAuR,OAOlB,CANImI,CAMJ,CANgBC,EAAA,CAAa,CAC3BT,aAAcO,CAAAP,aADa,CAE3BD,YAAaQ,CAAAR,YAFc,CAG3BW,OAAQJ,CAAAX,WAAAe,OAHmB,CAI3BC,MAAOL,CAAAX,WAAAgB,MAJoB,CAAb,CAMhB,CAAA,CAAA,CAAO,CACLC,cAAe9Z,CAAArD,KAAAC,UADV,CAEL4c,YAAaA,CAFR,CAGLC,WAAYA,CAHP,CAILhB,kBAAmBzY,CAAAyY,kBAJd,CAKLpV,OAAQ,CACN0W,QAAS/Z,CAAAqD,OADH;AAEN8C,QAASnG,CAAAqD,OAFH,CAGN2W,IAAKN,CAHC,CAINO,KAAM,CACJzQ,MAAOxG,EADH,CAEJ7E,aAAc6E,EAFV,CAJA,CALH,CAZP,EACE,CADF,CACS,IA4BPkX,EAAAA,CAAqB,UAAd,GAyFE5B,CAzFF,CAA2B6B,EAA3B,CAAsCC,EAC7CC,EAAAA,CAAUC,EAAA,CAAW,CACvB3d,KAyFMA,CA1FiB,CAEvB4d,gBAAiB,IAFM,CAGvBL,KAAMA,CAHiB,CAIvB1a,MAAOA,CAJgB,CAAX,CAiBd,EAAA,CAXgBgb,CACdld,WAwLcA,CAzLAkd,CAEdhC,iBA8EkBA,CAhFJgC,CAGdpC,cAAeA,CAHDoC,CAIdN,KAAMA,CAJQM,CAKdzK,UAAWA,CALGyK,CAMdjJ,OAAQA,CANMiJ,CAOd7d,KA6EMA,CApFQ6d,CAQdhb,MAAOA,CAROgb,CASdH,QAASA,CATKG,CAmMd,IAFIC,CAEJ,CAFiBhD,CAAAC,kBAEjB,CACE+C,CAAAhU,aAAA,CAAwBiU,EAAAvW,UAAxB,CAAmDiS,CAAAjS,UAAnD,CACA,CAAAsW,CAAApgB,iBAAA,CAA4B,QAA5B,CAAsCwd,CAAtC,CAA0E9T,CAAA+T,cApGvEC,yBAAA,CAAmC4C,EAAnC,CAA+CC,EAoGlD,CAOF,OAAOJ,EAlCgF,CAAxD,CAmC9B,CAACpE,CAAAjS,UAAD,CAAuB7G,CAAvB,CAAmCua,CAAnC,CAAoDR,CAApD,CAnC8B,CArDjC,CAyFI7T,EAAyBc,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAC9D,IAAIjC,EAAWqT,CAAAjR,QAAf,CACInG,EAAuC+D,CAAvC/D,EAAuC+D,CA/F1B0T,IAAAC,kBA+Fb1X,EA/F+C,IAgGjD+D,EAAF,EAAc/D,CAAd;AAA0L,IAAK,EAA/L,CAAuKnF,CAAA,CAAU,CAAA,CAAV,CACvK,OAAO8c,GAAA,CAAY3X,CAAZ,CAJuD,CAAnC,CAK1B,EAL0B,CAzF7B,CA+FI6a,EAAcvW,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CACnD,IAAIjC,EAAWqT,CAAAjR,QACdpC,EAAD,CAAkI,IAAK,EAAvI,CAA+GlJ,CAAA,CAAU,CAAA,CAAV,CAC/G,KAAImF,EAAuC+D,CAAvC/D,EAAuC+D,CAtG1B0T,IAAAC,kBAsGb1X,EAtG+C,IAuGnDoX,EAAAjR,QAAA,CAA2B,IAEtBnG,EAAL,GAIA4X,CAAA9V,OAAA,EAEA,CADA9B,CAAA8a,gBAAA,CAAwBJ,EAAAvW,UAAxB,CACA,CAAAnE,CAAAvF,oBAAA,CAA4B,QAA5B,CAAsCod,CAAtC,CAA0E9T,CAAA+T,cA/HrEC,yBAAA,CAAmC4C,EAAnC,CAA+CC,EA+HpD,CANA,CANmD,CAAnC,CAaf,CAAC/C,CAAD,CAAkBD,CAAlB,CAbe,CA/FlB,CA6GIvU,EAASiB,CAAA0B,YAAA,CAAuB,QAAS,CAAC+U,CAAD,CAAS,CACpD,IAAIhX,EAAWqT,CAAAjR,QACdpC,EAAD,CAAiI,IAAK,EAAtI,CAA8GlJ,CAAA,CAAU,CAAA,CAAV,CAE9G,EADImF,CACJ,CAD2C+D,CAC3C,EAD2CA,CApH1B0T,IAAAC,kBAqHjB,EArHmD,IAqHnD,EAAiJ,IAAK,EAAtJ,CAA8H7c,CAAA,CAAU,CAAA,CAAV,CAC9HmF,EAAA8Y,UAAA,EAAqBiC,CAAA/d,EACrBgD,EAAA+Y,WAAA,EAAsBgC,CAAA3d,EAN8B,CAAzC,CAOV,EAPU,CA7Gb,CAqHI6E,EAAYqC,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAC7C,MAAO,CACLyT,2BAA4BA,CADvB,CAELxU,uBAAwBA,CAFnB;AAGLqX,YAAaA,CAHR,CAILxX,OAAQA,CAJH,CADsC,CAA/B,CAOb,CAACwX,CAAD,CAAc7C,CAAd,CAA0CxU,CAA1C,CAAkEH,CAAlE,CAPa,CArHhB,CA6HIE,EAAQe,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACzC,MAAO,CACLkF,SAAUA,CADL,CAELnM,WAAYA,CAFP,CAGL2E,UAAWA,CAHN,CADkC,CAA/B,CAMT,CAACA,CAAD,CAAY3E,CAAZ,CAAwBmM,CAAxB,CANS,CAOZnD,GAAA,CAA0B,QAAS,EAAG,CACpCgR,CAAAnR,QAAA,CAAiC5C,CAAAjG,WACjC0E,EAAAsB,UAAA4E,SAAA,CAA4B3E,CAA5B,CACA,OAAO,SAAS,EAAG,CACb6T,CAAAjR,QAAJ,GACkI,IAAK,EACrI,CAAA0U,CAAA,EAFF,CAKA7Y,EAAAsB,UAAA8E,WAAA,CAA8B7E,CAA9B,CANiB,CAHiB,CAAtC,CAWG,CAACtB,CAAD,CAAY3E,CAAZ,CAAwBud,CAAxB,CAAqCtX,CAArC,CAA4CyD,CAA5C,CAAqDhF,CAAAsB,UAArD,CAXH,CAYAgD,GAAA,CAA0B,QAAS,EAAG,CAC/B8Q,CAAAjR,QAAL,EAIAa,CAAA0N,yBAAA,CAAiC4C,CAAAnR,QAAA9I,GAAjC,CAAoE,CAACK,CAAA6a,eAArE,CALoC,CAAtC,CAMG,CAAC7a,CAAA6a,eAAD,CAAsBvR,CAAtB,CANH,CAOAV,GAAA,CAA0B,QAAS,EAAG,CAC/B8Q,CAAAjR,QAAL,EAIAa,CAAA2N,gCAAA,CAAwC2C,CAAAnR,QAAA9I,GAAxC,CAA2EK,CAAA8a,iBAA3E,CALoC,CAAtC,CAMG,CAAC9a,CAAA8a,iBAAD,CAAwBxR,CAAxB,CANH,CAxJmC,CAiKrCgU,QAASA,GAAM,EAAG;AA2WlBC,QAASA,GAAqB,CAACvd,CAAD,CAAO,CACnC,IAAI+L,EAAWuN,EAAA,CAAY,WAAZ,CAAf,CACI1Z,EAAaI,CAAAJ,WADjB,CAEI0E,EAAWtE,CAAAsE,SAFf,CAGIkZ,EAAkBxd,CAAAwd,gBAHtB,CAIInK,EAA6BrT,CAAAqT,2BAJjC,CAKI5D,EAA0BzP,CAAAyP,wBAL9B,CAMI4C,EAAYrS,CAAAqS,UANhB,CAOI5V,EAAUmK,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAC3C,MAAO,CACLwM,2BAA4BA,CADvB,CAEL5D,wBAAyBA,CAFpB,CAGL4C,UAAWA,CAHN,CADoC,CAA/B,CAMX,CAACgB,CAAD,CAA6BhB,CAA7B,CAAwC5C,CAAxC,CANW,CAPd,CAcIpK,EAAeuB,CAAA0B,YAAA,CAAuB,QAAS,CAACiS,CAAD,CAAe,CAChE,IAAIpe,EAAKqhB,CAAA,EACRrhB,EAAD,CAA+H,IAAK,EAApI,CAA4GgB,CAAA,CAAU,CAAA,CAAV,CACtEod,KAAAA,EAAAA,CA7CnB,KAAK,EAA1B,GAAIA,CAAJ,GACEA,CADF,CACiBjV,EADjB,CAIImY,EAAAA,CAAiBja,MAAAka,iBAAA,CAyCevhB,CAzCf,CACrB,KAAImf,EAwCgCnf,CAxCpB6X,sBAAA,EACZH,EAAAA,CAAS/U,EAAA6e,aAAA,CAAyBrC,CAAzB,CAAoCmC,CAApC,CACTxe,EAAAA,CAAOH,EAAA+c,WAAA,CAAuBhI,CAAvB,CAA+B0G,CAA/B,CACPqD,EAAAA,CAAc,CAChB/J,OAAQA,CADQ,CAEhBzC,QAmCkCjV,CAnCzBiV,QAAAC,YAAA,EAFO,CAGhBwM,QAASJ,CAAAI,QAHO,CAqChB;MA5Bcf,CACdld,WA2BsBA,CA5BRkd,CAEdc,YAAaA,CAFCd,CAGdgB,WAPeA,CACfpe,EAAGmU,CAAA3U,UAAAid,MADY2B,CAEfxe,EAAGuU,CAAA3U,UAAAgd,OAFY4B,CAIDhB,CAIdjJ,OAAQA,CAJMiJ,CAKd7d,KAAMA,CALQ6d,CAyBkD,CAA/C,CAIhB,CAACld,CAAD,CAAa4d,CAAb,CAJgB,CAdnB,CAmBI3X,EAAQe,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACzC,MAAO,CACLkF,SAAUA,CADL,CAELnM,WAAYA,CAFP,CAGLnD,QAASA,CAHJ,CAIL4I,aAAcA,CAJT,CADkC,CAA/B,CAOT,CAACzF,CAAD,CAAayF,CAAb,CAA2B5I,CAA3B,CAAoCsP,CAApC,CAPS,CAnBZ,CA2BIgS,EAAe7V,CAAAC,OAAA,CAAatC,CAAb,CA3BnB,CA4BImY,EAAoB9V,CAAAC,OAAA,CAAa,CAAA,CAAb,CACxBS,GAAA,CAA0B,QAAS,EAAG,CACpCtE,CAAAzF,UAAA2L,SAAA,CAA4BuT,CAAAtV,QAA5B,CACA,OAAO,SAAS,EAAG,CACjB,MAAOnE,EAAAzF,UAAA6L,WAAA,CAA8BqT,CAAAtV,QAA9B,CADU,CAFiB,CAAtC,CAKG,CAACnE,CAAAzF,UAAD,CALH,CAMA+J,GAAA,CAA0B,QAAS,EAAG,CACpC,GAAIoV,CAAAvV,QAAJ,CACEuV,CAAAvV,QAAA,CAA4B,CAAA,CAD9B,KAAA,CAKA,IAAIjK,EAAOuf,CAAAtV,QACXsV,EAAAtV,QAAA,CAAuB5C,CACvBvB,EAAAzF,UAAAuE,OAAA,CAA0ByC,CAA1B,CAAiCrH,CAAjC,CAPA,CADoC,CAAtC,CASG,CAACqH,CAAD,CAAQvB,CAAAzF,UAAR,CATH,CApCmC,CA+ErCof,QAASA,GAAe,CAAC1a,CAAD,CAAQ,CAC9BA,CAAAqL,eAAA,EAD8B;AAuIhCsP,QAASA,GAAoB,EAAG,CAC9B,IAAIC,EAAiB5V,EAAA,CAAW,QAAS,CAAC7I,CAAD,CAAIJ,CAAJ,CAAO,CAC9C,MAAO,CACLI,EAAGA,CADE,CAELJ,EAAGA,CAFE,CADuC,CAA3B,CAArB,CAMI8e,EAAsB7V,EAAA,CAAW,QAAS,CAAChC,CAAD,CAAO8X,CAAP,CAAgBC,CAAhB,CAA8BC,CAA9B,CAA2CnV,CAA3C,CAAqD,CACjG,MAAO,CACLpG,WAAY,CAAA,CADP,CAELqb,QAASA,CAFJ,CAGLG,gBAAiB,CAAA,CAAQpV,CAHpB,CAILqV,cAAerV,CAJV,CAKL7C,KAAMA,CALD,CAML+X,aAAcA,CANT,CAOLC,YAAaA,CAPR,CAQLG,iBAAkB,IARb,CAD0F,CAAzE,CAN1B,CAkBIC,EAAmBpW,EAAA,CAAW,QAAS,CAACqW,CAAD,CAASrY,CAAT,CAAeuW,CAAf,CAA0BuB,CAA1B,CAAmCC,CAAnC,CAAiDC,CAAjD,CAA8DhgB,CAA9D,CAAkF,CAC3H,MAAO,CACLsgB,OAAQ,CACN9iB,KAAM,UADA,CAENqN,SAAU,IAFJ,CAGNkV,aAAcA,CAHR,CAINC,YAAaA,CAJP,CAKNhY,KAAMA,CALA,CAMNqY,OAAQA,CANF,CAON9B,UAAWA,CAPL,CAQNve,mBAAoBA,CARd,CASNugB,SAAUV,CAAA,CAAoB7X,CAApB,CAA0B8X,CAA1B,CAAmCC,CAAnC,CAAiDC,CAAjD,CAA8D,IAA9D,CATJ,CADH,CADoH,CAAtG,CAwEvB,OAxDetX,SAAiB,CAAC9E,CAAD,CAAQ4c,CAAR,CAAkB,CAChD,GAAI5c,CAAAa,WAAJ,CAAsB,CACpB,GAAIb,CAAA6c,SAAAngB,UAAAc,GAAJ,GAAoCof,CAAAre,YAApC,CACE,MAAO,KAGT,KAAIke,EAASzc,CAAAsG,QAAAoL,OAAA+K,OAAb;AACI9B,EAAY3a,CAAA8c,WAAAhd,WAAA,CAA4B8c,CAAAre,YAA5B,CADhB,CAEI4d,EAAeY,EAAA,CAAkB/c,CAAArE,OAAlB,CACwBA,KAAAA,EAAAqE,CAAArE,OA/C/C,EAAA,CAAOA,CAAAC,GAAA,EAAgC,SAAhC,GAAaD,CAAAC,GAAAhC,KAAb,CAA4C+B,CAAAC,GAAAG,QAAAwC,YAA5C,CAA4E,IAgD/E,KAAInC,EAAqB4D,CAAA5D,mBACzB,OAAOogB,EAAA,CAAiBR,CAAA,CAAeS,CAAAlf,EAAf,CAAyBkf,CAAAtf,EAAzB,CAAjB,CAAqD6C,CAAAc,aAArD,CAAyE6Z,CAAzE,CAAoFiC,CAAAV,QAApF,CAAsGC,CAAtG,CAAoHC,CAApH,CAAiIhgB,CAAjI,CAVa,CAatB,GAAoB,gBAApB,GAAI4D,CAAAC,MAAJ,CAAsC,CAChCiM,CAAAA,CAAYlM,CAAAkM,UAEhB,IAAIA,CAAAtI,OAAArF,YAAJ,GAAqCqe,CAAAre,YAArC,CACE,MAAO,KAGL2d,EAAAA,CAAUU,CAAAV,QACVc,EAAAA,CAAahd,CAAA8c,WAAAhd,WAAA,CAA4B8c,CAAAre,YAA5B,CACbqF,EAAAA,CAASsI,CAAAtI,OACTQ,EAAAA,CAAOR,CAAAQ,KAEP6Y,EAAAA,CAAgBC,EAAA,CAA4BtZ,CAA5B,CAEhBuZ,EAAAA,CAAwCvZ,CAtEzC7H,QAAA,CAsEyC6H,CAtExB7H,QAAAwC,YAAjB,CAA8C,IAyE7C0I,EAAAA,CAAW,CACbmW,SAFapd,CAAAqd,aACA,CAEbC,MAAOC,EAAAtQ,KAFM,CAGbuQ,OAAQxd,CAAAyd,oBAHK,CAIbC,QAASP,CAAA;AAAephB,EAAA2hB,QAAAzQ,KAAf,CAAsC,IAJlC,CAKb0Q,MAAOR,CAAA,CAAephB,EAAA4hB,MAAA1Q,KAAf,CAAoC,IAL9B,CAOf,OAAO,CACLyP,OAAQ,CACN9iB,KAAM,UADA,CAEN6iB,OAAQzc,CAAAyd,oBAFF,CAGN9C,UAAWqC,CAHL,CAIN/V,SAAUA,CAJJ,CAKNkV,aAAcc,CALR,CAMNb,YAAae,CANP,CAON/Y,KAAMA,CAPA,CAQNhI,mBAAoB,IARd,CASNugB,SAAUV,CAAA,CAAoB7X,CAApB,CAA0B8X,CAA1B,CAAmCe,CAAnC,CAAkDE,CAAlD,CAAgElW,CAAhE,CATJ,CADH,CAxB6B,CAuCtC,MAAO,KArDyC,CAnCpB,CA8FhC2W,QAASA,GAAoB,CAACrB,CAAD,CAAmB,CAC9C,MAAO,CACL1b,WAAY,CAAA,CADP,CAELwb,gBAAiB,CAAA,CAFZ,CAGLH,QAAS,CAAA,CAHJ,CAILI,cAAe,IAJV,CAKLlY,KAAM,IALD,CAML+X,aAAc,IANT,CAOLI,iBAAkBA,CAPb,CAQLH,YAAa,IARR,CADuC,CAuBhDyB,QAASA,GAAoB,EAAG,CAC9B,IAAI7B,EAAiB5V,EAAA,CAAW,QAAS,CAAC7I,CAAD,CAAIJ,CAAJ,CAAO,CAC9C,MAAO,CACLI,EAAGA,CADE,CAELJ,EAAGA,CAFE,CADuC,CAA3B,CAArB,CAMI8e,EAAsB7V,EAAA,CAAWwX,EAAX,CAN1B,CAOIpB,EAAmBpW,EAAA,CAAW,QAAS,CAACqW,CAAD,CAASF,CAAT,CAA2BuB,CAA3B,CAAsD,CACtE,IAAK,EAA9B,GAAIvB,CAAJ,GACEA,CADF,CACqB,IADrB,CAIA,OAAO,CACLG,OAAQ,CACN9iB,KAAM,WADA;AAEN6iB,OAAQA,CAFF,CAGNF,iBAAkBA,CAHZ,CAINuB,0BAA2BA,CAJrB,CAKNnB,SAAUV,CAAA,CAAoBM,CAApB,CALJ,CADH,CALwF,CAA1E,CAPvB,CA2BIwB,EAAWA,QAAiB,CAACC,CAAD,CAAQC,CAAR,CAAoBtiB,CAApB,CAA4BuiB,CAA5B,CAA2C,CACzE,IAAIC,EAAqBxiB,CAAAiD,UAAAT,QAAA,CAAyB6f,CAAzB,CAAzB,CACII,EAA+B,EAAQC,CAAAH,CAAAG,cAAR,EAAuC,CAAAH,CAAAI,SAAA,CAAuBN,CAAvB,CAAvC,CADnC,CAEIjiB,EAAUD,CAAA,CAAcH,CAAd,CACV4gB,EAAAA,CAAmBxgB,CAAA,EAAWA,CAAAwC,YAAX,GAAmCyf,CAAnC,CAA2CC,CAA3C,CAAwD,IAE/E,IAAI,CAACE,CAAL,CAAyB,CACvB,GAAI,CAACC,CAAL,CACE,MAAmB7B,EAXhB,CAAmBC,CAAA,CAAiBrZ,EAAjB,CAWHoZ,CAXG,CAA2C,CAAA,CAA3C,CAAnB,CAAsE,IAc3E,IAAI5gB,CAAAiD,UAAAV,UAAA,CAA2B8f,CAA3B,CAAJ,CACE,MAAO,KAGL9C,EAAAA,CAASqD,EAAA,CAAOL,CAAAhiB,YAAAgB,MAAP,CAETshB,EAAAA,CAAUxC,CAAA,CAAed,CAAA3d,EAAf,CAAyB2d,CAAA/d,EAAzB,CAEd,OAAOqf,EAAA,CAAiBgC,CAAjB,CAA0BjC,CAA1B,CAA4C,CAAA,CAA5C,CAbgB,CAgBzB,GAAI6B,CAAJ,CACE,MAAmB7B,EA1Bd,CAAmBC,CAAA,CAAiBrZ,EAAjB,CA0BLoZ,CA1BK,CAA2C,CAAA,CAA3C,CAAnB,CAAsE,IA6BzEZ,EAAAA,CAAahgB,CAAAO,YAAAgB,MACbuf,EAAAA,CAAST,CAAA,CAAeL,CAAApe,EAAf,CAA6Boe,CAAAxe,EAA7B,CACb,OAAOqf,EAAA,CAAiBC,CAAjB,CAAyBF,CAAzB,CAA2C4B,CAAA9f,cAA3C,CA5BkE,CAqD3E,OAtBeyG,SAAiB,CAAC9E,CAAD,CAAQ4c,CAAR,CAAkB,CAChD,MAAI5c,EAAAa,WAAJ,CACMb,CAAA6c,SAAAngB,UAAAc,GAAJ,GAAoCof,CAAAre,YAApC;AACS,IADT,CAIOwf,CAAA,CAASnB,CAAAre,YAAT,CAA+ByB,CAAA6c,SAAAngB,UAAAc,GAA/B,CAA4DwC,CAAArE,OAA5D,CAA0EqE,CAAAke,cAA1E,CALT,CAQoB,gBAApB,GAAIle,CAAAC,MAAJ,EACMiM,CAEJ,CAFgBlM,CAAAkM,UAEhB,CAAIA,CAAAtI,OAAArF,YAAJ,GAAqCqe,CAAAre,YAArC,CACS,IADT,CAIOwf,CAAA,CAASnB,CAAAre,YAAT,CAA+B2N,CAAAtI,OAAArF,YAA/B,CAA6D2N,CAAAvQ,OAA7D,CAA+EuQ,CAAAgS,cAA/E,CAPT,EAUO,IAnByC,CA3DpB,CAuGhCO,QAASA,GAAgB,CAAC/K,CAAD,CAAQ,CAI/B,MAHuBsD,GAAA0H,CAAmBC,EAAnBD,CACDE,gBAEtB,GAAwBlL,CAAAnV,YAAxB,EAA8CmV,CAAAwI,QAA9C,CAIOzF,EAAA5L,cAAA,CAA6BgU,EAA7B,CAAiDnL,CAAjD,CAJP,CACS,IALsB,CAvhQjCoL,MAAAC,eAAA,CAAsBvlB,CAAtB,CAA+B,YAA/B,CAA6C,CAAEmQ,MAAO,CAAA,CAAT,CAA7C,CAIA,KAAI5D,EAAQzM,CAAA,CAAQ,CAAR,CAAZ,CACImd,GAAiBhd,CAAA,CAAgBsM,CAAhB,CADrB,CAEItB,EAAanL,CAAA,CAAQ,EAAR,CAFjB,CAGI0lB,GAAiBvlB,CAAA,CAAgBH,CAAA,CAAQ,EAAR,CAAhB,CAHrB,CAIIiB,EAAWd,CAAA,CAAgBH,CAAA,CAAQ,EAAR,CAAhB,CAJf,CAKImb,GAAQnb,CAAA,CAAQ,EAAR,CALZ,CAMIsd,GAAatd,CAAA,CAAQ,GAAR,CANjB,CAOIqD,GAAcrD,CAAA,CAAQ,GAAR,CAPlB,CAQI8M,GAAa3M,CAAA,CAAgBH,CAAA,CAAQ,GAAR,CAAhB,CARjB,CASI2Q,GAAiBxQ,CAAA,CAAgBH,CAAA,CAAQ,GAAR,CAAhB,CATrB,CAUIyJ,GAAetJ,CAAA,CAAgBH,CAAA,CAAQ,GAAR,CAAhB,CAVnB,CAWIqI,GAAUlI,CAAA,CAAgBH,CAAA,CAAQ,GAAR,CAAhB,CAXd;AAYI2lB,GAAYxlB,CAAA,CAAgBH,CAAA,CAAQ,GAAR,CAAhB,CAZhB,CAaIwR,GAAiBrR,CAAA,CAAgBH,CAAA,CAAQ,EAAR,CAAhB,CAbrB,CAcI4lB,GAAWzlB,CAAA,CAAgBH,CAAA,CAAQ,EAAR,CAAhB,CACSG,EAAA,CAAgBH,CAAA,CAAQ,GAAR,CAAhB,CA+BVK,EAAA2X,KAAA,CAAS,IAAT,CAAe,MAAf,CACF3X,EAAA2X,KAAA,CAAS,IAAT,CAAe,OAAf,CA6BZvW,EAAA4M,UAAAwX,SAAA,CAAkCC,QAAiB,EAAG,CACpD,MAAO,KAAAvlB,QAD6C,CAgBtD,KAAIwlB,GAAgB,QAAS,CAACC,CAAD,CAAmB,CAG9CD,QAASA,EAAa,EAAG,CAGvB,IAFA,IAAIE,CAAJ,CAESC,EAAOC,SAAAlkB,OAFhB,CAEkCsC,EAAW6J,KAAJ,CAAU8X,CAAV,CAFzC,CAE0DE,EAAO,CAAjE,CAAoEA,CAApE,CAA2EF,CAA3E,CAAiFE,CAAA,EAAjF,CACE7hB,CAAA,CAAK6hB,CAAL,CAAA,CAAaD,SAAA,CAAUC,CAAV,CAGfH,EAAA,CAAQD,CAAA1X,KAAA+X,MAAA,CAA4BL,CAA5B,CAA8C,CAAC,IAAD,CAAA7M,OAAA,CAAc5U,CAAd,CAA9C,CAAR,EAA8E,IAC9E0hB,EAAAnd,UAAA,CAAkB,IAClBmd,EAAA5kB,OAAA,CAAeb,CAEfylB,EAAAK,cAAA,CAAsBC,QAAS,CAACze,CAAD,CAAQ,CACrC,IAAIgB,EAAYmd,CAAAO,aAAA,EAEZ1d,EAAAvB,WAAA,EAAJ,GACEuB,CAAAgU,SAAA,EACuM,CAAA,IAAK,EAF9M,CAKUhV,EAAA2e,MAEV,WAAmBhlB,EAAnB,EACEqG,CAAAqL,eAAA,EAXmC,CAmBvC8S,EAAAO,aAAA,CAAqBE,QAAS,EAAG,CAC/B,GAAI,CAACT,CAAAnd,UAAL,CACE,KAAU6d,MAAJ,CAAU,uDAAV,CAAN;AAGF,MAAOV,EAAAnd,UALwB,CAQjCmd,EAAA5L,aAAA,CAAqBuM,QAAS,CAAC9d,CAAD,CAAY,CACxCmd,CAAAnd,UAAA,CAAkBA,CADsB,CAI1C,OAAOmd,EA1CgB,CAFzBP,EAAA,CAAeK,CAAf,CAA8BC,CAA9B,CA+CA,KAAIa,EAASd,CAAA1X,UAEbwY,EAAAC,kBAAA,CAA2BC,QAA0B,EAAG,CACtD,IAAA1lB,OAAA,CAAcZ,CAAA,CAAWsH,MAAX,CAAmB,CAAC,CAChC5G,UAAW,OADqB,CAEhCC,GAAI,IAAAklB,cAF4B,CAAD,CAAnB,CADwC,CAOxDO,EAAAG,qBAAA,CAA8BC,QAA6B,EAAG,CAC5D,IAAA5lB,OAAA,EAD4D,CAI9DwlB,EAAAK,kBAAA,CAA2BC,QAA0B,CAACC,CAAD,CAAM,CACzD,GAAIA,CAAJ,WAAmB3lB,EAAnB,CAKE,IAAA4lB,SAAA,CAAc,EAAd,CALF,KASA,MAAMD,EAAN,CAVyD,CAa3DP,EAAAS,OAAA,CAAgBC,QAAe,EAAG,CAChC,MAAO,KAAAnN,MAAAqD,SAAA,CAAoB,IAAApD,aAApB,CADyB,CAIlC,OAAO0L,EA9EuC,CAA5B,CA+ElB5I,EAAAqK,UA/EkB,CAApB,CA2FIC,GAAeA,QAAqB,CAACC,CAAD,CAASnlB,CAAT,CAAsB,CAE5D,IAAIolB,EAAyBD,CAAAvlB,MAAzBwlB,CATW,CASf,CACIC,EAAuBrlB,CAAAJ,MAAvBylB,CAVW,CAYf,OAJmBF,EAAAliB,YAInB,GAJ0CjD,CAAAiD,YAI1C,CACS,gDADT;AAC4DmiB,CAD5D,CAC4E,sBAD5E,CACqGC,CADrG,CACmH,QADnH,CAIO,8CAJP,CAIwDD,CAJxD,CAIwE,gBAJxE,CAI2FD,CAAAliB,YAJ3F,CAIgH,gBAJhH,CAImIjD,CAAAiD,YAJnI,CAI6J,oBAJ7J,CAIoLoiB,CAJpL,CAIkM,MATtI,CA3F9D,CAuGIC,GAAcA,QAAoB,CAAC3jB,CAAD,CAAKwjB,CAAL,CAAajlB,CAAb,CAAsB,CAG1D,MAFiBilB,EAAAliB,YAEjB,GAFwC/C,CAAA+C,YAExC,CACS,mBADT,CAC+BtB,CAD/B,CACoC,iCADpC,CACwEzB,CAAAwC,YADxE,CAIO,mBAJP,CAI6Bf,CAJ7B,CAIkC,kBAJlC,CAIuDwjB,CAAAliB,YAJvD,CAI4E,iCAJ5E,CAIgH/C,CAAAwC,YAJhH,CAIsI,kBAJtI,CAI2JxC,CAAA+C,YAJ3J,CAIiL,QAPvH,CAvG5D,CAiIIsiB,GAAkBA,QAAwB,CAACJ,CAAD,CAAS,CACrD,MAAO,2DAAP;CAA8EA,CAAAvlB,MAA9E,CA9Ce,CA8Cf,EAA8F,IADzC,CAjIvD,CAuFkBwY,GAAAA,QAAoB,CAAClS,CAAD,CAAQ,CAC5C,MAAO,0CAAP,EAA6DA,CAAAif,OAAAvlB,MAA7D,CAJe,CAIf,EAAmF,6EADvC,CAvF9C,CAiHmB0Y,GAAAA,QAAqB,CAAClT,CAAD,CAAS,CAC/C,IAAIogB,EAAWpgB,CAAApF,YAEf,OAAIwlB,EAAJ,CACSN,EAAA,CAAa9f,CAAA+f,OAAb,CAA4BK,CAA5B,CADT,CAMA,CAFItlB,CAEJ,CAFckF,CAAAlF,QAEd,EACSolB,EAAA,CAAYlgB,CAAA1C,YAAZ,CAAgC0C,CAAA+f,OAAhC,CAA+CjlB,CAA/C,CADT,CAIO,gDAbwC,CAjHjD,CAqIgBmY,GAAAA,QAAkB,CAACtQ,CAAD,CAAS,CACzC,GAAsB,QAAtB,GAAIA,CAAAsD,OAAJ,CACE,MAAO,qCAAP,CAA+Cka,EAAA,CAAgBxd,CAAAod,OAAhB,CAA/C,CAAgF,QAGlF,KAAIK,EAAWzd,CAAA/H,YAAf,CACIE,EAAU6H,CAAA7H,QAEd,OAAIslB,EAAJ,CACS,4CADT;AACwDN,EAAA,CAAand,CAAAod,OAAb,CAA4BK,CAA5B,CADxD,CACgG,QADhG,CAIItlB,CAAJ,CACS,4CADT,CACwDolB,EAAA,CAAYvd,CAAArF,YAAZ,CAAgCqF,CAAAod,OAAhC,CAA+CjlB,CAA/C,CADxD,CACkH,QADlH,CAIO,mEAJP,CAI6EqlB,EAAA,CAAgBxd,CAAAod,OAAhB,CAJ7E,CAI8G,MAhBrE,CArI3C,CA+JI7d,GAAS,CACX5F,EAAG,CADQ,CAEXJ,EAAG,CAFQ,CA/Jb,CAmKI2G,EAAMA,QAAY,CAACwd,CAAD,CAASC,CAAT,CAAiB,CACrC,MAAO,CACLhkB,EAAG+jB,CAAA/jB,EAAHA,CAAcgkB,CAAAhkB,EADT,CAELJ,EAAGmkB,CAAAnkB,EAAHA,CAAcokB,CAAApkB,EAFT,CAD8B,CAnKvC,CAyKIqkB,GAAWA,QAAiB,CAACF,CAAD,CAASC,CAAT,CAAiB,CAC/C,MAAO,CACLhkB,EAAG+jB,CAAA/jB,EAAHA,CAAcgkB,CAAAhkB,EADT,CAELJ,EAAGmkB,CAAAnkB,EAAHA,CAAcokB,CAAApkB,EAFT,CADwC,CAzKjD,CA+KIskB,EAAUA,QAAgB,CAACH,CAAD,CAASC,CAAT,CAAiB,CAC7C,MAAOD,EAAA/jB,EAAP,GAAoBgkB,CAAAhkB,EAApB,EAAgC+jB,CAAAnkB,EAAhC,GAA6CokB,CAAApkB,EADA,CA/K/C,CAkLIohB,GAASA,QAAe,CAACrhB,CAAD,CAAQ,CAClC,MAAO,CACLK,EAAe,CAAZ,GAAAL,CAAAK,EAAA,CAAgB,CAACL,CAAAK,EAAjB,CAA2B,CADzB,CAELJ,EAAe,CAAZ,GAAAD,CAAAC,EAAA,CAAgB,CAACD,CAAAC,EAAjB,CAA2B,CAFzB,CAD2B,CAlLpC,CAwLIukB,EAAQA,QAAc,CAACC,CAAD,CAAOhY,CAAP,CAAciY,CAAd,CAA0B,CAClD,IAAI3lB,CAEe,KAAK,EAAxB,GAAI2lB,CAAJ,GACEA,CADF,CACe,CADf,CAIA,OAAO3lB,EAAA,CAAO,EAAP,CAAWA,CAAA,CAAK0lB,CAAL,CAAX,CAAwBhY,CAAxB,CAA+B1N,CAAA,CAAc,GAAT,GAAA0lB,CAAA,CAAe,GAAf,CAAqB,GAA1B,CAA/B,CAAgEC,CAAhE,CAA4E3lB,CAPjC,CAxLpD,CAiMI4lB,GAAWA,QAAiB,CAACP,CAAD;AAASC,CAAT,CAAiB,CAC/C,MAAOzU,KAAAgV,KAAA,CAAUhV,IAAAiV,IAAA,CAASR,CAAAhkB,EAAT,CAAoB+jB,CAAA/jB,EAApB,CAA8B,CAA9B,CAAV,CAA6CuP,IAAAiV,IAAA,CAASR,CAAApkB,EAAT,CAAoBmkB,CAAAnkB,EAApB,CAA8B,CAA9B,CAA7C,CADwC,CAjMjD,CAoMIgD,GAAUA,QAAgB,CAACrC,CAAD,CAASkkB,CAAT,CAAiB,CAC7C,MAAOlV,KAAAmV,IAAAtC,MAAA,CAAe7S,IAAf,CAAqBkV,CAAA5nB,IAAA,CAAW,QAAS,CAAC8C,CAAD,CAAQ,CACtD,MAAO2kB,GAAA,CAAS/jB,CAAT,CAAiBZ,CAAjB,CAD+C,CAA5B,CAArB,CADsC,CApM/C,CAyMIyiB,GAAQA,QAAc,CAACjlB,CAAD,CAAK,CAC7B,MAAO,SAAS,CAACwC,CAAD,CAAQ,CACtB,MAAO,CACLK,EAAG7C,CAAA,CAAGwC,CAAAK,EAAH,CADE,CAELJ,EAAGzC,CAAA,CAAGwC,CAAAC,EAAH,CAFE,CADe,CADK,CAzM/B,CAiOI+kB,GAAmBA,QAAyB,CAACC,CAAD,CAAUjlB,CAAV,CAAiB,CAC/D,MAAO,CACLD,IAAKklB,CAAAllB,IAALA,CAAmBC,CAAAC,EADd,CAELG,KAAM6kB,CAAA7kB,KAANA,CAAqBJ,CAAAK,EAFhB,CAGLF,OAAQ8kB,CAAA9kB,OAARA,CAAyBH,CAAAC,EAHpB,CAILC,MAAO+kB,CAAA/kB,MAAPA,CAAuBF,CAAAK,EAJlB,CADwD,CAjOjE,CAyOI6kB,GAAaA,QAAmB,CAACD,CAAD,CAAU,CAC5C,MAAO,CAAC,CACN5kB,EAAG4kB,CAAA7kB,KADG,CAENH,EAAGglB,CAAAllB,IAFG,CAAD,CAGJ,CACDM,EAAG4kB,CAAA/kB,MADF,CAEDD,EAAGglB,CAAAllB,IAFF,CAHI,CAMJ,CACDM,EAAG4kB,CAAA7kB,KADF,CAEDH,EAAGglB,CAAA9kB,OAFF,CANI,CASJ,CACDE,EAAG4kB,CAAA/kB,MADF,CAEDD,EAAGglB,CAAA9kB,OAFF,CATI,CADqC,CAzO9C,CAyRIod,GAAcA,QAAS,CAACxe,CAAD,CAAO,CAAA,IAC5Ba,EAAOb,CAAAa,KADqB,CAE5B4d,EAAkBze,CAAAye,gBAFU,CAG5BL,EAAOpe,CAAAoe,KACP1a,EAAAA,CAAQ1D,CAAA0D,MACU5C,KAAAA,EAAAD,CAAAC,UA1BtB,EAAA,CA0BsC4C,CA9BtC,CAIOuiB,EAAA,CAAiBpkB,CAAjB;AA0B+B6B,CA1BN6D,OAAA4W,KAAA9b,aAAzB,CAJP,CACSR,CAOT,IAuByC4c,CAvBzC,EAuByCA,CAvBlB2H,YAAvB,CAAoD,CAClD,IAAIC,CAEJ,EAAA,CAAO/nB,CAAA,CAAS,EAAT,CAoBgBgoB,CApBhB,EAAsBD,CAAA,CAAY,EAAZ,CAAgBA,CAAA,CAoBZjI,CApBsBmI,IAAV,CAAhB,CAoBND,CApB4C,CAoBlClI,CApByCmI,IAAP,CAAtC,CAoBU9H,CApB+C2H,YAAA,CAoBrDhI,CApBiFsH,KAA5B,CAAzD,CAAiGW,CAAvH,EAH2C,CAApD,IAMA,EAAA,CAiByBC,CACNE,EAAAA,CAAAA,CAAW9iB,EAd9B,EAc8BA,CAdjBiZ,kBAAb,EACS,CAzDT,CAyDS,CAAA,cAzDT,CAPIhV,CAOJ,CAPajH,EAAAC,QAAA,CAAoB,CAC/BK,IAAK6P,IAAAqN,IAAA,CA+DEK,CA/DOvd,IAAT,CAAsB0C,CAAA1C,IAAtB,CAD0B,CAE/BG,MAAO0P,IAAAmV,IAAA,CA8DAzH,CA9DSpd,MAAT,CAAwBuC,CAAAvC,MAAxB,CAFwB,CAG/BC,OAAQyP,IAAAmV,IAAA,CA6DDzH,CA7DUnd,OAAT,CAAyBsC,CAAAtC,OAAzB,CAHuB,CAI/BC,KAAMwP,IAAAqN,IAAA,CA4DCK,CA5DQld,KAAT,CAAuBqC,CAAArC,KAAvB,CAJyB,CAApB,CAOb,CAAA,CAAA,CAAoB,CAApB,EAAIsG,CAAAoW,MAAJ,EAA0C,CAA1C,EAAyBpW,CAAAmW,OAAzB,CACS,IADT,CAIOnW,CAoDP,EAIO,CAJP,CAIO,EAAA,QAAA,CAAA,CAAA,CAWP,OAAO,CACL9G,KAAMA,CADD,CAEL4d,gBAAiBA,CAFZ,CAGLgI,OAlBFC,CAeO,CARyB,CAzRlC,CAwSIvN,GAAmBA,QAAS,CAAC3R,CAAD,CAAYmf,CAAZ,CAAuB,CACpDnf,CAAA9D,MAAD,CAAiG,IAAK,EAAtG,CAA8E3E,CAAA,CAAU,CAAA,CAAV,CAC9E,KAAI4f,EAAanX,CAAA9D,MAAjB,CACIkjB,EAAarB,EAAA,CAASoB,CAAT,CAAoBhI,CAAApX,OAAA0W,QAApB,CADjB,CAEI4I,EAAqBvE,EAAA,CAAOsE,CAAP,CAErBljB,EAAAA,CAAQpF,CAAA,CAAS,EAAT,CAAaqgB,CAAb,CAAyB,CACnCpX,OAAQ,CACN0W,QAASU,CAAApX,OAAA0W,QADH;AAEN5T,QAASsc,CAFH,CAGNxI,KAAM,CACJzQ,MAAOkZ,CADH,CAEJvkB,aAAcwkB,CAFV,CAHA,CAON3I,IAAKS,CAAApX,OAAA2W,IAPC,CAD2B,CAAzB,CAYRK,EAAAA,CAAUC,EAAA,CAAW,CACvB3d,KAAM2G,CAAA+W,QAAA1d,KADiB,CAEvB4d,gBAAiBjX,CAAA+W,QAAAE,gBAFM,CAGvBL,KAAM5W,CAAA4W,KAHiB,CAIvB1a,MAAOA,CAJgB,CAAX,CAYd,OALapF,EAAAqJ,CAAS,EAATA,CAAaH,CAAbG,CAAwB,CACnCjE,MAAOA,CAD4B,CAEnC6a,QAASA,CAF0B,CAAxB5W,CAzBwC,CAxSvD,CA0WImf,GAAiB3c,EAAA,CAAW,QAAS,CAACqD,CAAD,CAAa,CACpD,MAAOA,EAAAlN,OAAA,CAAkB,QAAS,CAAC6B,CAAD,CAAWkI,CAAX,CAAoB,CACpDlI,CAAA,CAASkI,CAAA7I,WAAAD,GAAT,CAAA,CAAkC8I,CAClC,OAAOlI,EAF6C,CAA/C,CAGJ,EAHI,CAD6C,CAAjC,CA1WrB,CAgXI4kB,GAAiB5c,EAAA,CAAW,QAAS,CAACtG,CAAD,CAAa,CACpD,MAAOA,EAAAvD,OAAA,CAAkB,QAAS,CAAC6B,CAAD,CAAWkI,CAAX,CAAoB,CACpDlI,CAAA,CAASkI,CAAA7I,WAAAD,GAAT,CAAA,CAAkC8I,CAClC,OAAOlI,EAF6C,CAA/C,CAGJ,EAHI,CAD6C,CAAjC,CAhXrB,CAsXI6kB,GAAkB7c,EAAA,CAAW,QAAS,CAACqD,CAAD,CAAa,CACrD,MA7COQ,GAAA,CA6COR,CA7CP,CA4C8C,CAAjC,CAtXtB,CAyXIyZ,GAAkB9c,EAAA,CAAW,QAAS,CAACtG,CAAD,CAAa,CACrD,MAhDOmK,GAAA,CAgDOnK,CAhDP,CA+C8C,CAAjC,CAzXtB,CA6XIqjB,GAA+B/c,EAAA,CAAW,QAAS,CAACtH,CAAD,CAAcgB,CAAd,CAA0B,CAM/E,MALaojB,GAAA,CAAgBpjB,CAAhB,CAAAoK,OAAA,CAAmC,QAAS,CAACxN,CAAD,CAAY,CACnE,MAAOoC,EAAP,GAAuBpC,CAAAe,WAAAqB,YAD4C,CAAxD,CAAAsE,KAAAQ,CAEL,QAAS,CAACP,CAAD;AAAIC,CAAJ,CAAO,CACtB,MAAOD,EAAA5F,WAAAhC,MAAP,CAA4B6H,CAAA7F,WAAAhC,MADN,CAFXmI,CADkE,CAA9C,CA7XnC,CAsYIwf,GAAU,CACZ9I,SAAU,MADE,CAEZC,WAAY,OAFA,CAtYd,CA0YI8I,GAAW,CACb/I,SAAU,IADG,CAEbC,WAAY,MAFC,CA1Yf,CA8ZIjb,GAA0B8G,EAAA,CAAW,QAAS,CAACrC,CAAD,CAAS3I,CAAT,CAAe,CAC/D,MAAOA,EAAA8O,OAAA,CAAY,QAAS,CAAC9K,CAAD,CAAO,CACjC,MAAOA,EAAA3B,WAAAD,GAAP,GAA8BuG,CAAAtG,WAAAD,GADG,CAA5B,CADwD,CAAnC,CA9Z9B,CAoaI8lB,GAAqBA,QAAS,CAACrnB,CAAD,CAAO,CAiBvCsnB,QAASA,EAAS,CAACzlB,CAAD,CAAS,CASzB,MAAOvD,EAAA,CAAS,EAAT,CAAaiG,CAAb,CAA6B,CAClC5E,GATOA,CACPhC,KAAM,SADCgC,CAEP8E,YAAa8iB,CAAA,CAAkBJ,EAAlB,CAA4BC,EAFlCznB,CAGPG,QAAS,CACPwC,YAAaT,CADN,CAEPgB,YAAajD,CAAA4B,WAAAD,GAFN,CAHF5B,CAQ2B,CAA7B,CATkB,CAjBY,IACnC4nB,EAAkBvnB,CAAAunB,gBADiB,CAEnC9mB,EAAYT,CAAAS,UAFuB,CAGnCb,EAAcI,CAAAJ,YAHqB,CAInC4C,EAAoBxC,CAAAwC,kBAJe,CAKnC+B,EAAiBvE,CAAAuE,eAQrB,IANI,CAAC3E,CAAA8c,iBAML,EAAI,CAFWjd,CAAA2lB,CAAkB7gB,CAAlB6gB,CAEf,CACE,MAAO,KAiBL3jB,EAAAA,CAAM8C,CAAA5B,UAAAlB,IACV;IAAI+lB,EAAY/lB,CAAAnC,OAAA,CAAamC,CAAA,CAAI,CAAJ,CAAb,CAAsB,IAEtC,IAAI8lB,CAAJ,CACE,MAAOC,EAAA,CAAYF,CAAA,CAAUE,CAAV,CAAZ,CAAmC,IAGxCC,EAAAA,CAAmBpkB,EAAA,CAAwB5C,CAAxB,CAAmC+B,CAAnC,CAEvB,IAAI,CAACglB,CAAL,CACE,MAAKC,EAAAnoB,OAAL,CAKOgoB,CAAA,CADIG,CAAArnB,CAAiBqnB,CAAAnoB,OAAjBc,CAA2C,CAA3CA,CACMoB,WAAAD,GAAV,CALP,CACS,IAOPmmB,EAAAA,CAAiBxoB,CAAA,CAAUuoB,CAAV,CAA4B,QAAS,CAACE,CAAD,CAAI,CAC5D,MAAOA,EAAAnmB,WAAAD,GAAP,GAA2BimB,CADiC,CAAzC,CAGC,GAAtB,GAAEE,CAAF,CAA8H3oB,CAAA,CAAU,CAAA,CAAV,CAA9H,CAAiJ,IAAK,EAClI6oB,GAAAF,CAEpB,OAAoB,EAApB,CAAIE,CAAJ,CACS,IADT,CAKON,CAAA,CADMG,CAAAI,CAAiBD,CAAjBC,CACIrmB,WAAAD,GAAV,CA5DgC,CApazC,CAmeI0B,GAAYA,QAAS,CAACxC,CAAD,CAAYb,CAAZ,CAAyB,CAChD,MAAOa,EAAAe,WAAAqB,YAAP,GAA4CjD,CAAA4B,WAAAD,GADI,CAnelD,CAueIumB,GAAgB,CAClB7mB,MAAOiG,EADW,CAElBwG,MAAO,CAFW,CAvepB,CA2eI9K,GAAc,CAChBX,UAAW,EADK,CAEhBC,QAAS,EAFO,CAGhBT,IAAK,EAHW,CA3elB,CAgfIsmB,GAAW,CACbplB,UAAWC,EADE,CAEb3C,YAAa6nB,EAFA,CAGbnoB,GAAI,IAHS,CAhff,CAsfIqoB,GAAYA,QAAS,CAACC,CAAD,CAAaC,CAAb,CAAyB,CAChD,MAAO,SAAS,CAACxa,CAAD,CAAQ,CACtB,MAAOua,EAAP,EAAqBva,CAArB,EAA8BA,CAA9B,EAAuCwa,CADjB,CADwB,CAtflD,CA4fIlmB,GAAkCA,QAAS,CAAC0B,CAAD,CAAQ,CACrD,IAAIykB,EAAmBH,EAAA,CAAStkB,CAAA1C,IAAT,CAAoB0C,CAAAtC,OAApB,CAAvB,CACIgnB,EAAqBJ,EAAA,CAAStkB,CAAArC,KAAT;AAAqBqC,CAAAvC,MAArB,CACzB,OAAO,SAAS,CAACod,CAAD,CAAU,CAGxB,GAFkB4J,CAAA,CAAiB5J,CAAAvd,IAAjB,CAElB,EAFmDmnB,CAAA,CAAiB5J,CAAAnd,OAAjB,CAEnD,EAFuFgnB,CAAA,CAAmB7J,CAAAld,KAAnB,CAEvF,EAF2H+mB,CAAA,CAAmB7J,CAAApd,MAAnB,CAE3H,CACE,MAAO,CAAA,CAGT,KAAIknB,EAA+BF,CAAA,CAAiB5J,CAAAvd,IAAjB,CAA/BqnB,EAAgEF,CAAA,CAAiB5J,CAAAnd,OAAjB,CAApE,CACIknB,EAAiCF,CAAA,CAAmB7J,CAAAld,KAAnB,CAAjCinB,EAAqEF,CAAA,CAAmB7J,CAAApd,MAAnB,CAGzE,IAF2BknB,CAE3B,EAF2DC,CAE3D,CACE,MAAO,CAAA,CAGT,KAAIC,EAAqBhK,CAAAvd,IAArBunB,CAAmC7kB,CAAA1C,IAAnCunB,EAAgDhK,CAAAnd,OAAhDmnB,CAAiE7kB,CAAAtC,OACjEonB,EAAAA,CAAuBjK,CAAAld,KAAvBmnB,CAAsC9kB,CAAArC,KAAtCmnB,EAAoDjK,CAAApd,MAApDqnB,CAAoE9kB,CAAAvC,MAGxE,OAF8BonB,EAE9B,EAFoDC,CAEpD,CACS,CAAA,CADT,CAI8BD,CAJ9B,EAIoDD,CAJpD,EAIsFE,CAJtF,EAI8GH,CAvBtF,CAH2B,CA5fvD,CA2hBII,GAAgCA,QAAS,CAAC/kB,CAAD,CAAQ,CACnD,IAAIykB,EAAmBH,EAAA,CAAStkB,CAAA1C,IAAT,CAAoB0C,CAAAtC,OAApB,CAAvB,CACIgnB,EAAqBJ,EAAA,CAAStkB,CAAArC,KAAT,CAAqBqC,CAAAvC,MAArB,CACzB,OAAO,SAAS,CAACod,CAAD,CAAU,CAExB,MADkB4J,EAAA,CAAiB5J,CAAAvd,IAAjB,CAClB,EADmDmnB,CAAA,CAAiB5J,CAAAnd,OAAjB,CACnD,EADuFgnB,CAAA,CAAmB7J,CAAAld,KAAnB,CACvF,EAD2H+mB,CAAA,CAAmB7J,CAAApd,MAAnB,CADnG,CAHyB,CA3hBrD,CAoiBIkd,GAAW,CACb7B,UAAW,UADE,CAEbkJ,KAAM,GAFO,CAGbgD,cAAe,GAHF,CAIb5iB,MAAO,KAJM,CAKbygB,IAAK,QALQ,CAMboC,KAAM,QANO,CAObC,eAAgB,MAPH,CAQbC,aAAc,OARD;AASbC,cAAe,OATF,CApiBf,CA+iBIxK,GAAa,CACf9B,UAAW,YADI,CAEfkJ,KAAM,GAFS,CAGfgD,cAAe,GAHA,CAIf5iB,MAAO,MAJQ,CAKfygB,IAAK,OALU,CAMfoC,KAAM,OANS,CAOfC,eAAgB,KAPD,CAQfC,aAAc,QARC,CASfC,cAAe,QATA,CA/iBjB,CA2jBIC,GAAsCA,QAAS,CAAC3K,CAAD,CAAO,CACxD,MAAO,SAAS,CAAC1a,CAAD,CAAQ,CACtB,IAAIykB,EAAmBH,EAAA,CAAStkB,CAAA1C,IAAT,CAAoB0C,CAAAtC,OAApB,CAAvB,CACIgnB,EAAqBJ,EAAA,CAAStkB,CAAArC,KAAT,CAAqBqC,CAAAvC,MAArB,CACzB,OAAO,SAAS,CAACod,CAAD,CAAU,CACxB,MAAIH,EAAJ,GAAaC,EAAb,CACS8J,CAAA,CAAiB5J,CAAAvd,IAAjB,CADT,EAC0CmnB,CAAA,CAAiB5J,CAAAnd,OAAjB,CAD1C,CAIOgnB,CAAA,CAAmB7J,CAAAld,KAAnB,CAJP,EAI2C+mB,CAAA,CAAmB7J,CAAApd,MAAnB,CALnB,CAHJ,CADgC,CA3jB1D,CA0lBIQ,GAAYA,QAAkB,CAAC3B,CAAD,CAAO,CAAA,IACnCgpB,EAAgBhpB,CAAA6B,OADmB,CAEnCjC,EAAcI,CAAAJ,YAFqB,CAGnCM,EAAWF,CAAAE,SAHwB,CAKnC6B,EAA0B/B,CAAA+B,wBAC1BknB,EAAAA,CAF4BjpB,CAAA8B,0BAEV,CArBfmkB,EAAA,CAqB2CpkB,CArB3C,CAqB2CjC,CAtB/B8D,MAAArB,CAsB+BzC,CAtBX8D,MAAA6D,OAAA4W,KAAA9b,aAApBA;AAAiE6E,EAC7E,CAqBe,CAAgF8hB,CAbtG,EAAA,CAc6CppB,CAlBxC2e,QAAAkI,OAAL,CAkB0D1kB,CAdnD,CAcsCnC,CAdd2e,QAAAkI,OAAxB,CAAA,CAcqBwC,CAdrB,CAJP,CACS,CAAA,CAiBF,EAAA,GAVP,CAUO,CAA+ElnB,CAV/E,CAU+E7B,CAV/E,CAAA,CAU+E2B,CAV/E,CAUA,CAAP,OAAO,EAPgC,CA1lBzC,CAymBIqnB,GAAmBA,QAAyB,CAACtnB,CAAD,CAAO,CACrD,MAAOD,GAAA,CAAUrD,CAAA,CAAS,EAAT,CAAasD,CAAb,CAAmB,CAClCG,wBAAyB0mB,EADS,CAAnB,CAAV,CAD8C,CAzmBvD,CAy4BIU,GAA+BA,QAAS,CAACnpB,CAAD,CAAO,CAAA,IAC7C2C,EAAY3C,CAAA2C,UADiC,CAG7Cwd,EAAcngB,CAAAmgB,YAH+B,CAI7ClgB,EAAcD,CAAAC,YACdmpB,EAAAA,CAAc,EAAQ,CAAAzmB,CAAAT,QAAA,CAAkBie,CAAlB,CAAR,EAA0C,CAAAxd,CAAAV,UAAA,CAAoBke,CAApB,CAA1C,CAElB,OALoBngB,EAAAiiB,cA3HLI,SAAA,CAgIWlC,CAhIX,CAgIf,CACSiJ,CAAA,CAAcliB,EAAd,CAAuBob,EAAA,CAAOriB,CAAAgB,MAAP,CADhC,CAIOmoB,CAAA,CAAcnpB,CAAAgB,MAAd,CAAkCiG,EAXQ,CAz4BnD,CAg7BImiB,GAA8BA,QAAoC,CAACjL,CAAD,CAAOvc,CAAP,CAAeynB,CAAf,CAAyB,CAC7F,MAAOznB,EAAA,CAAOuc,CAAAwK,eAAP,CAAP,CAAqCU,CAAA/L,OAAA,CAAgBa,CAAAwK,eAAhB,CAArC,CAA4EU,CAAApM,UAAA,CAAmBkB,CAAA0K,cAAnB,CAA5E,CAAqH,CADxB,CAh7B/F,CAo7BIS,GAAUA,QAAgB,CAACvpB,CAAD,CAAO,CAAA,IAC/Boe,EAAOpe,CAAAoe,KADwB,CAE/BoL,EAAiBxpB,CAAAwpB,eACjBF,EAAAA,CAAWtpB,CAAAspB,SACf,OAAO7D,EAAA,CAAMrH,CAAAsH,KAAN,CAAiB8D,CAAA1oB,UAAA,CAAyBsd,CAAAmI,IAAzB,CAAjB;CAA+F+C,CAf/F/L,OAAA,CAeyFa,CAf9EtY,MAAX,CAeA,CAA+FwjB,CAftEpM,UAAA,CAegEkB,CAflDuK,KAAd,CAezB,CAfoD,CAepD,EAA0GU,EAAA,CAA4BjL,CAA5B,CAAkCoL,CAAA1oB,UAAlC,CAA4DwoB,CAA5D,CAA1G,CAJ4B,CAp7BrC,CA07BIG,GAAWA,QAAiB,CAACzmB,CAAD,CAAQ,CAAA,IAClCob,EAAOpb,CAAAob,KAD2B,CAElCoL,EAAiBxmB,CAAAwmB,eACjBF,EAAAA,CAAWtmB,CAAAsmB,SACf,OAAO7D,EAAA,CAAMrH,CAAAsH,KAAN,CAAiB8D,CAAA1oB,UAAA,CAAyBsd,CAAAtY,MAAzB,CAAjB,EAA+FwjB,CAjB/F/L,OAAA,CAiByFa,CAjB9EmI,IAAX,CAiBA,CAA+F+C,CAjBxEpM,UAAA,CAiBkEkB,CAjBpDuK,KAAd,CAiBvB,CAjBkD,CAiBlD,EAA0GU,EAAA,CAA4BjL,CAA5B,CAAkCoL,CAAA1oB,UAAlC,CAA4DwoB,CAA5D,CAA1G,CAJ+B,CA17BxC,CAu8BII,GAAkBA,QAAS,CAAC1pB,CAAD,CAAO,CAAA,IAChCN,EAASM,CAAAN,OADuB,CAEhCe,EAAYT,CAAAS,UAFoB,CAGhCoD,EAAa7D,CAAA6D,WAHmB,CAIhC2D,EAAYxH,CAAAwH,UAJoB,CAKhCya,EAAgBjiB,CAAAiiB,cALgB,CAMhCzf,EAAoB0kB,EAAA,CAA6B1f,CAAAhG,WAAAD,GAA7B,CAAsDsC,CAAtD,CACpB8lB,EAAAA,CAAgBlpB,CAAAI,KACpB,KAAIud,EAAO5W,CAAA4W,KAEX,IAAI,CAAC5b,CAAAlD,OAAL,CACE,MAhBEsqB,EAEG,CAgBOpiB,CAAA3G,KAhBP,CAAA4kB,CAAA,CAeGrH,CAfGsH,KAAN,CAAiBkE,CAAAC,WAAA,CAedzL,CAfkCtY,MAApB,CAAjB,EAiBO6jB,CA5CPpM,OAAA,CA0CGa,CA1CQtY,MAAX,CA2BA,CAiBO6jB,CA5CkBzM,UAAA,CA0CtBkB,CA1CoCuK,KAAd,CA2BzB,CA3BoD,CA2BpD,EAAuGU,EAAA,CAepGjL,CAfoG,CAAkCwL,CAAAC,WAAlC,CAiBhGF,CAjBgG,CAAvG,CAsBH1pB,EAAAA,CAAcP,CAAAO,YAGlB,IAFI6pB,CAEJ;AAJgBpqB,CAAAiD,UAEGlB,IAAA,CAAc,CAAd,CAEnB,CAAkB,CACZyC,CAAAA,CAAUL,CAAA,CAAWimB,CAAX,CAEd,IAAwC7H,CAhN3BI,SAAA,CAgNayH,CAhNb,CAgNb,CACE,MAAOL,GAAA,CAAS,CACdrL,KAAMA,CADQ,CAEdoL,eAAgBtlB,CAAArD,KAFF,CAGdyoB,SAAUK,CAHI,CAAT,CAOLI,EAAAA,CAAmBrpB,EAAA8f,OAAA,CAAmBtc,CAAArD,KAAnB,CAAiCZ,CAAAgB,MAAjC,CACvB,OAAOwoB,GAAA,CAAS,CACdrL,KAAMA,CADQ,CAEdoL,eAAgBO,CAFF,CAGdT,SAAUK,CAHI,CAAT,CAZS,CAmBdvpB,CAAAA,CAAOoC,CAAA,CAAkBA,CAAAlD,OAAlB,CAA6C,CAA7C,CAEX,OAAIc,EAAAoB,WAAAD,GAAJ,GAA2Bd,CAAAe,WAAAD,GAA3B,CACSooB,CAAAzM,UAAArH,OADT,CAI8CoM,CAtO/BI,SAAA,CAsOWjiB,CAAAoB,WAAAD,GAtOX,CAsOf,EACMV,CACG,CADIH,EAAA8f,OAAA,CAAmBpgB,CAAAS,KAAnB,CAA8ByhB,EAAA,CAAOL,CAAAhiB,YAAAgB,MAAP,CAA9B,CACJ,CAAAsoB,EAAA,CAAQ,CACbnL,KAAMA,CADO,CAEboL,eAAgB3oB,CAFH,CAGbyoB,SAAUK,CAHG,CAAR,CAFT,EASOJ,EAAA,CAAQ,CACbnL,KAAMA,CADO,CAEboL,eAAgBppB,CAAAS,KAFH,CAGbyoB,SAAUK,CAHG,CAAR,CAxD6B,CAv8BtC,CAsgCI7nB,GAA6BA,QAAS,CAAC0F,CAAD,CAAYvG,CAAZ,CAAmB,CAG3D,MAAA,CAFIyC,CAEJ,CAFY8D,CAAA9D,MAEZ,EAIOmE,CAAA,CAAI5G,CAAJ,CAAWyC,CAAA6D,OAAA4W,KAAA9b,aAAX,CAJP,CACSpB,CAJkD,CAtgC7D,CAkjCI+oB,GAAoCA,QAAS,CAACpoB,CAAD,CAAO,CAjClDlC,IAAAA;AAkC4DkC,CAlCnDlC,OADkF,KAE3Fe,EAiC4DmB,CAjChDnB,UAF+E,CAG3F+G,EAgC4D5F,CAhChD4F,UAH+E,CAI3F3D,EA+B4DjC,CA/B/CiC,WAJ8E,CAK3Foe,EA8B4DrgB,CA9B5CqgB,cAL2E,CAM3FgI,EAAWxpB,CAAAI,KAAAqc,UAAArH,OANgF,CAO3FlW,EAAKD,CAAAC,GAEJ6H,EAIL,EAAK7H,CAAL,CAIgB,SAAhB,GAAIA,CAAAhC,KAAJ,CACE,CADF,CACS+rB,EAAA,CAAe,CACpBhqB,OAAQA,CADY,CAEpBe,UAAWA,CAFS,CAGpBoD,WAAYA,CAHQ,CAIpB2D,UAAWA,CAJS,CAKpBya,cAAeA,CALK,CAAf,CADT,EArIA,CADIniB,CACJ,CADcD,CAAA,CAiJJH,CAjJI,CACd,EAAyF,IAAK,EAA9F,CAAsEX,CAAA,CAAU,CAAA,CAAV,CA+ItE,CA9IIohB,CA8IJ,CA9IkBrgB,CAAAwC,YA8IlB,CA7IIuT,CA6IJ,CAEchS,CA/ID,CAAWsc,CAAX,CAAAtf,KAAAqc,UAAArH,OA6Ib,CA5II6J,CA4IJ,CA5IiByJ,EAAA,CAA4B,CAC3CxmB,UA4IQjD,CA5IGiD,UADgC,CAE3Csf,cA6IeA,CA/I4B,CAG3C9B,YAAaA,CAH8B,CAI3ClgB,YAyIQP,CAzIKO,YAJ8B,CAA5B,CA4IjB,CAAA,CAAA,CAtIO4H,CAAA,CAAIgO,CAAJ,CAAY6J,CAAZ,CA4HP,CAJA,CACE,CADF,CACSuK,CAwBT,OADuBF,CADnBviB,CACmBuiB,CADPnoB,CAAA4F,UACOuiB,EAAYjoB,EAAA,CAA0B0F,CAA1B,CAAqC0iB,CAArC,CAAZH,CAAwEG,CAHzC,CAljCxD,CAyjCIC,GAAkBA,QAAS,CAACjqB,CAAD,CAAWymB,CAAX,CAAsB,CACnD,IAAIxI,EAAOoH,EAAA,CAASoB,CAAT,CAAoBzmB,CAAAqH,OAAA0W,QAApB,CAAX,CACI5b,EAAeigB,EAAA,CAAOnE,CAAP,CAmBnB,OAZc7W,CACZ5D,MAPUhD,EAAAC,QAAA+C,CAAoB,CAC9B1C,IAAK2lB,CAAAzlB,EADyB,CAE9BE,OAAQulB,CAAAzlB,EAARE,CAAsBlB,CAAAwD,MAAAoa,OAFQ;AAG9Bzc,KAAMslB,CAAArlB,EAHwB,CAI9BH,MAAOwlB,CAAArlB,EAAPH,CAAqBjB,CAAAwD,MAAAqa,MAJS,CAApBra,CAME4D,CAEZC,OAAQ,CACN0W,QAAS/d,CAAAqH,OAAA0W,QADH,CAENC,IAAKhe,CAAAqH,OAAA2W,IAFC,CAGN7T,QAASsc,CAHH,CAINxI,KAAM,CACJzQ,MAAOyQ,CADH,CAEJ9b,aAAcA,CAFV,CAJA,CAFIiF,CATqC,CAzjCrD,CAmmCI8iB,GAAyBA,QAAS,CAACpqB,CAAD,CAAO,CAAA,IACvCN,EAASM,CAAAN,OAD8B,CAEvCQ,EAAWF,CAAAE,SAF4B,CAGvCN,EAAcI,CAAAJ,YAHyB,CAIvCiE,EAAa7D,CAAA6D,WACbwmB,EAAAA,CAAkBrqB,CAAAqqB,gBACtB,KAAIC,EAAmBH,EAAA,CAAejqB,CAAf,CAAyB2H,CAAA,CAAI3H,CAAAqH,OAAA8C,QAAJ,CAA6BggB,CAA7B,CAAzB,CAAvB,CACIE,EAAoB3qB,CAAA8D,MAAA,CAAoByV,EAAA,CAAgBvZ,CAAhB,CAA6BiI,CAAA,CAAIjI,CAAA8D,MAAA6D,OAAA8C,QAAJ,CAAsCggB,CAAtC,CAA7B,CAApB,CAA2GzqB,CAC/HQ,EAAAA,CAAOV,CAAAiD,UACP6nB,EAAAA,CAAqBzqB,CAAA,CAAsB,CAC7CM,cAAesD,CAAA,CAAcvD,CAAAqB,IAAd,CAAwBoC,CAAxB,CAD8B,CAE7CjE,YAAaA,CAFgC,CAG7CK,YAAaP,CAAAO,YAHgC,CAI7CC,SAAUoqB,CAAA5mB,MAJmC,CAK7CtD,KAAMA,CALuC,CAM7CD,mBAAoB,CAAA,CANyB,CAAtB,CAQrBsqB,EAAAA,CAAsB1qB,CAAA,CAAsB,CAC9CM,cAAesD,CAAA,CAAcvD,CAAAqB,IAAd,CAAwBoC,CAAxB,CAD+B,CAE9CjE,YAAa2qB,CAFiC,CAG9CtqB,YAAaP,CAAAO,YAHiC;AAI9CC,SAAUA,CAAAwD,MAJoC,CAK9CtD,KAAMA,CALwC,CAM9CD,mBAAoB,CAAA,CAN0B,CAAtB,CAQ1B,KAAI8B,EAAY,EAAhB,CACIC,EAAU,EADd,CAEI1B,EAAS,CAACJ,CAAD,CAAOoqB,CAAP,CAA2BC,CAA3B,CACbrqB,EAAAqB,IAAA5C,QAAA,CAAiB,QAAS,CAAC0C,CAAD,CAAK,CAC7B,IAAIc,CAzC2B,EAAA,CAAA,CACjC,IAAShD,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAwCuCmB,CAxCnBlB,OAApB,CAAmCD,CAAA,EAAnC,CAAwC,CACtC,IAAIgD,EAuCiC7B,CAvClB,CAAOnB,CAAP,CAAA6C,QAAA,CAuCcX,CAvCd,CAEnB,IAAIc,CAAJ,CAAkB,CAChB,CAAA,CAAOA,CAAP,OAAA,CADgB,CAHoB,CAQxC,CAAA,CAAO,IAT0B,CA2C3BA,CAAJ,CACEH,CAAA,CAAQX,CAAR,CADF,CACgBc,CADhB,CAKAJ,CAAA,CAAUV,CAAV,CALA,CAKgB,CAAA,CARa,CAA/B,CAmBA,OARgBjD,EAAAosB,CAAS,EAATA,CAAahrB,CAAbgrB,CAAqB,CACnC/nB,UAAW,CACTlB,IAAKrB,CAAAqB,IADI,CAETQ,UAAWA,CAFF,CAGTC,QAASA,CAHA,CADwB,CAArBwoB,CAvC2B,CAnmC7C,CAypCIC,GAAoCA,QAAS,CAAC3qB,CAAD,CAAO,CAAA,IAElDS,EAAYT,CAAAS,UAEZmqB,EAAAA,CAPG/iB,CAAA,CAMQ7H,CAAAE,SANJqH,OAAA4W,KAAA9b,aAAJ,CAImBrC,CAAA6qB,oBAJnB,CAQHrK,EAAAA,CAAS+E,EAAA,CAASqF,CAAT,CAAkCnqB,CAAAI,KAAAqc,UAAArH,OAAlC,CACb,OAAOhO,EAAA,CAAIpH,CAAAgV,OAAAyH,UAAArH,OAAJ,CAAuC2K,CAAvC,CAN+C,CAzpCxD,CAkqCIsK,GAAiCA,QAAS,CAAC9qB,CAAD,CAAO,CAAA,IAC/CS,EAAYT,CAAAS,UADmC,CAE/Cb,EAAcI,CAAAJ,YAFiC,CAI/CM,EAAWF,CAAAE,SAJoC,CAK/C4B,EAA4B9B,CAAA8B,0BALmB;AAM/CipB,EAAsB/qB,CAAAgrB,eACtBA,EAAAA,CAAyC,IAAK,EAA7B,GAAAD,CAAA,CAAiC,CAAA,CAAjC,CAAyCA,CAC1DE,EAAAA,CAAe1F,EAAA,CALUvlB,CAAAkrB,uBAKV,CAAiCzqB,CAAAI,KAAAqc,UAAArH,OAAjC,CAEfjU,EAAAA,CAAO,CACTC,OAFYokB,EAAAkF,CAAiB1qB,CAAAI,KAAAqc,UAAjBiO,CAA2CF,CAA3CE,CACH,CAETvrB,YAAaA,CAFJ,CAGTkC,0BAA2BA,CAHlB,CAIT5B,SAAUA,CAJD,CAMX,OAAO8qB,EAAA,CAnkBArpB,EAAA,CAAUrD,CAAA,CAAS,EAAT,CAmkB8BsD,CAnkB9B,CAAmB,CAClCG,wBAAyBgnB,EAAA,CAkkBoBnnB,CAlkBehC,YAAAwe,KAAnC,CADS,CAAnB,CAAV,CAmkBA,CAAgD8K,EAAA,CAAiBtnB,CAAjB,CAhBJ,CAlqCrD,CAqrCIwpB,GAAmBA,QAAS,CAACprB,CAAD,CAAO,CAAA,IACjCunB,EAAkBvnB,CAAAunB,gBADe,CAEjC9mB,EAAYT,CAAAS,UAFqB,CAGjCb,EAAcI,CAAAJ,YAHmB,CAIjCiE,EAAa7D,CAAA6D,WAJoB,CAKjCU,EAAiBvE,CAAAuE,eALgB,CAMjCrE,EAAWF,CAAAE,SANsB,CAOjCmrB,EAA8BrrB,CAAAqrB,4BAPG,CAQjCC,EAA0BtrB,CAAAsrB,wBAC1BrJ,EAAAA,CAAgBjiB,CAAAiiB,cAEpB,IAAI,CAACriB,CAAAqU,UAAL,CACE,MAAO,KAGT,KAAIzR,EAAoB0kB,EAAA,CAA6BtnB,CAAA4B,WAAAD,GAA7B;AAAwDsC,CAAxD,CAAxB,CACI0nB,EAAetoB,EAAA,CAASxC,CAAT,CAAoBb,CAApB,CADnB,CAEa,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,gBAAA,CAAA,CAAA,UAAA,CAAA,CAAA,YAAA,CAAA,CAAA,kBAAA,CAAA,CAAA,eAAA,CAAA,CAAA,CAAA,IA9Wb,CADI4rB,CACJ,CAoXMjnB,CArXM5E,GACZ,EAAoJ,IAAK,EAAzJ,CAAiIZ,CAAA,CAAU,CAAA,CAAV,CAEjI,CAAmB,SAAnB,GAAIysB,CAAA7tB,KAAJ,EAIciC,CAIZ,CAJY4rB,CAAA5rB,YAIZ,CA0WI4C,CApZDlD,OAAL,EAIImsB,CAUJ,CAhBerG,CAMI5lB,MAUnB,CATIooB,CASJ,CAsYML,CA/Yc,CAAkBkE,CAAlB,CAAiC,CAAjC,CAAqCA,CAArC,CAAoD,CASxE,CAPIC,CAOJ,CAsYMlpB,CA7YU,CA6YVA,CA7Y4BlD,OAAlB,CAA6C,CAA7C,CAAAkC,WAAAhC,MAOhB,CAAA,CAAA,CAJIooB,CAIJ,CAsYMplB,CA9YW,CAAkB,CAAlB,CAAAhB,WAAAhC,MAQjB,EAAIooB,CAAJ,EAsYM2D,CA5YWrD,CAAewD,CAAfxD,CAA2BwD,CAA3BxD,CAAuC,CAMxD,EACS,IADT,CAION,CAlBP,EACE,CADF,CACS,IAyCP,CAAA,CAAA,CAAiB,IAAjB,EAAI+D,CAAJ,CACS,IADT,CAIO5oB,CAAA,CAAuB,CAC5BtC,UAqWEA,CAtW0B,CAE5B+B,kBAoWEA,CAtW0B,CAG5B5C,YAmWEA,CAtW0B,CAI5BM,SAkWEA,CAtW0B,CAK5BE,KAiWEmE,CAjWI5B,UALsB,CAM5B1C,YAgWEsE,CAhWWtE,YANe,CAO5BT,MAAOmsB,CAPqB,CAAvB,CAZT,GA4BW7rB,CAIX,CAJW0rB,CAAA1rB,QAIX,CAkVMF,CAlbD8c,iBAAL,EAIIkP,CAKJ,CAZc9rB,CAOEwC,YAKhB,CAHIupB,CAGJ,CAyaMhoB,CA7aYsc,CAAWyL,CAAXzL,CACK3e,WAAAhC,MAGvB,CAAA,CAAA,CAyaMyiB,CA5bSI,SAAAyJ,CAiB8CF,CAjB9CE,CAmBf;AAyaMvE,CAxaJ,CACSsE,CADT,CAIOA,CAJP,CAI0B,CAL5B,CAyaMtE,CAjaN,CACSsE,CADT,CAC4B,CAD5B,CAIOA,CArBP,EACE,CADF,CACS,IA+FT,CAAA,CAAA,CAAgB,IAAhB,EAAI/oB,CAAJ,CACS,IADT,CAIOC,CAAA,CAAuB,CAC5BtC,UA6UIA,CA9UwB,CAE5B+B,kBA4UIA,CA9UwB,CAG5B5C,YA2UIA,CA9UwB,CAI5BM,SA0UIA,CA9UwB,CAK5BE,KAyUImE,CAzUE5B,UALsB,CAM5B1C,YAwUIsE,CAxUStE,YANe,CAO5BT,MAAOsD,CAPqB,CAAvB,CApCP,CA4Wa,CAATpD,EAAAA,CAAS,CAkBb,IAAI,CAACA,CAAL,CACE,MAAO,KAGLmrB,EAAAA,CAAsBb,EAAA,CAAiC,CACzDtqB,OAAQA,CADiD,CAEzDe,UAAWA,CAF8C,CAGzD+G,UAAW5H,CAH8C,CAIzDiE,WAAYA,CAJ6C,CAKzDoe,cAAeA,CAL0C,CAAjC,CAgB1B,IAT6B6I,EAAAiB,CAA8B,CACzDtrB,UAAWA,CAD8C,CAEzDb,YAAaA,CAF4C,CAGzDsrB,uBAAwBL,CAHiC,CAIzD3qB,SAAUA,CAAAwD,MAJ+C,CAKzD5B,0BAA2B,CAAA,CAL8B,CAMzDkpB,eAAgB,CAAA,CANyC,CAA9Be,CAS7B,CAME,MAAO,CACLxW,gBANoBoV,EAAApV,CAAiC,CACrDsV,oBAAqBA,CADgC,CAErDpqB,UAAWA,CAF0C,CAGrDP,SAAUA,CAH2C,CAAjCqV,CAKf,CAEL7V,OAAQA,CAFH,CAGLoF,kBAAmB,IAHd,CAOL8gB,EAAAA,CAAWL,EAAA,CAASsF,CAAT,CAA8BQ,CAA9B,CACXW,EAAAA,CAAW5B,EAAA,CAAsB,CACnC1qB,OAAQA,CAD2B;AAEnCQ,SAAUA,CAFyB,CAGnCN,YAAaA,CAHsB,CAInCiE,WAAYA,CAJuB,CAKnCwmB,gBAAiBzE,CALkB,CAAtB,CAOf,OAAO,CACLrQ,gBAAiB+V,CADZ,CAEL5rB,OAAQssB,CAFH,CAGLlnB,kBAAmB8gB,CAHd,CA5E8B,CArrCvC,CAwwCIqG,GAAiBA,QAAuB,CAACzkB,CAAD,CAAY,CAEtD,CADI0kB,CACJ,CADW1kB,CAAA+W,QAAAkI,OACX,EAAgI,IAAK,EAArI,CAA6G1nB,CAAA,CAAU,CAAA,CAAV,CAC7G,OAAOmtB,EAH+C,CAxwCxD,CA8wCIC,GAA6BA,QAAS,CAACnsB,CAAD,CAAO,CAAA,IAC3CunB,EAAkBvnB,CAAAunB,gBADyB,CAE3CsD,EAAsB7qB,CAAA6qB,oBAFqB,CAG3C9F,EAAS/kB,CAAA+kB,OAHkC,CAI3CvX,EAAaxN,CAAAwN,WAJ8B,CAK3CtN,EAAWF,CAAAE,SALgC,CAM3CumB,EAAS1B,CAAAxG,QAAAkI,OAEb,IAAI,CAACA,CAAL,CACE,MAAO,KAGT,KAAIrI,EAAO2G,CAAA3G,KAAX,CACIgO,EAAyBpE,EAAA,CAASvB,CAAA,CAAOrI,CAAAtY,MAAP,CAAT,CAA6B2gB,CAAA,CAAOrI,CAAAmI,IAAP,CAA7B,CACzB8F,EAAAA,CAAarF,EAAA,CAAgBxZ,CAAhB,CAAAS,OAAA,CAAmC,QAAS,CAACzG,CAAD,CAAY,CACvE,MAAOA,EAAP,GAAqBud,CADkD,CAAxD,CAAA9W,OAAA,CAEP,QAAS,CAACzG,CAAD,CAAY,CAC7B,MAAOA,EAAAyM,UADsB,CAFd,CAAAhG,OAAA,CAIP,QAAS,CAACzG,CAAD,CAAY,CAC7B,MAAO,CAAA,CAAQA,CAAA+W,QAAAkI,OADc,CAJd,CAAAxY,OAAA,CAMP,QAAS,CAACzG,CAAD,CAAY,CAC7B,MAAOxF,GAAA,CAA+B9B,CAAAwD,MAA/B,CAAA,CAA+CuoB,EAAA,CAAezkB,CAAf,CAA/C,CADsB,CANd,CAAAyG,OAAA,CAQP,QAAS,CAACzG,CAAD,CAAY,CACzB8kB,CAAAA;AAAiBL,EAAA,CAAezkB,CAAf,CAErB,OAAI+f,EAAJ,CACSd,CAAA,CAAOrI,CAAAyK,aAAP,CADT,CACqCyD,CAAA,CAAelO,CAAAyK,aAAf,CADrC,CAIOyD,CAAA,CAAelO,CAAAwK,eAAf,CAJP,CAI6CnC,CAAA,CAAOrI,CAAAwK,eAAP,CAPhB,CARd,CAAA3a,OAAA,CAgBP,QAAS,CAACzG,CAAD,CAAY,CACzB8kB,CAAAA,CAAiBL,EAAA,CAAezkB,CAAf,CACrB,KAAI+kB,EAA8BvE,EAAA,CAASsE,CAAA,CAAelO,CAAAtY,MAAf,CAAT,CAAqCwmB,CAAA,CAAelO,CAAAmI,IAAf,CAArC,CAClC,OAAO6F,EAAA,CAAuBE,CAAA,CAAelO,CAAAtY,MAAf,CAAvB,CAAP,EAA6DsmB,CAAA,CAAuBE,CAAA,CAAelO,CAAAmI,IAAf,CAAvB,CAA7D,EAAiHgG,CAAA,CAA4B9F,CAAA,CAAOrI,CAAAtY,MAAP,CAA5B,CAAjH,EAAoKymB,CAAA,CAA4B9F,CAAA,CAAOrI,CAAAmI,IAAP,CAA5B,CAHvI,CAhBd,CAAApf,KAAA,CAoBT,QAAS,CAACC,CAAD,CAAIC,CAAJ,CAAO,CAClBmlB,CAAAA,CAAQP,EAAA,CAAe7kB,CAAf,CAAA,CAAkBgX,CAAAwK,eAAlB,CACR6D,EAAAA,CAASR,EAAA,CAAe5kB,CAAf,CAAA,CAAkB+W,CAAAwK,eAAlB,CAEb,OAAIrB,EAAJ,CACSiF,CADT,CACiBC,CADjB,CAIOA,CAJP,CAIgBD,CARM,CApBP,CAAAve,OAAA,CA6BP,QAAS,CAACzG,CAAD,CAAYhI,CAAZ,CAAmBktB,CAAnB,CAA0B,CAC3C,MAAOT,GAAA,CAAezkB,CAAf,CAAA,CAA0B4W,CAAAwK,eAA1B,CAAP,GAA0DqD,EAAA,CAAeS,CAAA,CAAM,CAAN,CAAf,CAAA,CAAyBtO,CAAAwK,eAAzB,CADf,CA7B5B,CAiCjB,IAAI,CAACyD,CAAA/sB,OAAL,CACE,MAAO,KAGT,IAA0B,CAA1B,GAAI+sB,CAAA/sB,OAAJ,CACE,MAAO+sB,EAAA,CAAW,CAAX,CAGLM,EAAAA,CAAWN,CAAApe,OAAA,CAAkB,QAAS,CAACzG,CAAD,CAAY,CAEpD,MADwBwgB,GAAA4E,CAASX,EAAA,CAAezkB,CAAf,CAAA,CAA0B4W,CAAAtY,MAA1B,CAAT8mB,CAAgDX,EAAA,CAAezkB,CAAf,CAAA,CAA0B4W,CAAAmI,IAA1B,CAAhDqG,CACjB,CAAkB/B,CAAA,CAAoBzM,CAAAsH,KAApB,CAAlB,CAF6C,CAAvC,CAKf;MAAwB,EAAxB,GAAIiH,CAAArtB,OAAJ,CACSqtB,CAAA,CAAS,CAAT,CADT,CAIsB,CAAtB,CAAIA,CAAArtB,OAAJ,CACSqtB,CAAAxlB,KAAA,CAAc,QAAS,CAACC,CAAD,CAAIC,CAAJ,CAAO,CACnC,MAAO4kB,GAAA,CAAe7kB,CAAf,CAAA,CAAkBgX,CAAAtY,MAAlB,CAAP,CAAuCmmB,EAAA,CAAe5kB,CAAf,CAAA,CAAkB+W,CAAAtY,MAAlB,CADJ,CAA9B,CAAA,CAEJ,CAFI,CADT,CAMOumB,CAAAllB,KAAA,CAAgB,QAAS,CAACC,CAAD,CAAIC,CAAJ,CAAO,CACrC,IAAImlB,EAAQtoB,EAAA,CAAQ2mB,CAAR,CAA6B1E,EAAA,CAAW8F,EAAA,CAAe7kB,CAAf,CAAX,CAA7B,CAAZ,CACIqlB,EAASvoB,EAAA,CAAQ2mB,CAAR,CAA6B1E,EAAA,CAAW8F,EAAA,CAAe5kB,CAAf,CAAX,CAA7B,CAEb,OAAImlB,EAAJ,GAAcC,CAAd,CACSD,CADT,CACiBC,CADjB,CAIOR,EAAA,CAAe7kB,CAAf,CAAA,CAAkBgX,CAAAtY,MAAlB,CAJP,CAIuCmmB,EAAA,CAAe5kB,CAAf,CAAA,CAAkB+W,CAAAtY,MAAlB,CARF,CAAhC,CAAA,CASJ,CATI,CAtEwC,CA9wCjD,CAg2CI+mB,GAAgCA,QAAsC,CAACpsB,CAAD,CAAYwhB,CAAZ,CAA2B,CACnG,IAAIgI,EAAWxpB,CAAAI,KAAAqc,UAAArH,OACf,OAAsDoM,EAllBvCI,SAAA,CAklBc5hB,CAAAe,WAAAD,GAllBd,CAklBR,CAAgEgkB,EAAA,CAAS0E,CAAT,CAAmBhI,CAAAhiB,YAAAgB,MAAnB,CAAhE,CAAsHgpB,CAF1B,CAh2CrG,CAy2CI6C,GAAuBA,QAAS,CAAC9sB,CAAD,CAAO,CAAA,IACrC6qB,EAAsB7qB,CAAA6qB,oBADe,CAErC3qB,EAAWF,CAAAE,SAF0B,CAGrCN,EAAcI,CAAAJ,YAHuB,CAKrCqiB,EAAgBjiB,CAAAiiB,cAsBpB,OAvBwBjiB,EAAAwC,kBAEXyL,OAAA,CAAyB,QAAS,CAACxN,CAAD,CAAY,CAV3D,IAAIwpB,EAYgCxpB,CAZrBI,KAAAqc,UACf,EAAA,CAW+C+E,CAjmBhCI,SAAA,CAimBqB5hB,CAXPe,WAAAD,GAtlBd,CAslBR;AAAgE0kB,EAAA,CAAiBgE,CAAjB,CAA2B3H,EAAA,CAWnDL,CAX0DhiB,YAAAgB,MAAP,CAA3B,CAAhE,CAAsIgpB,CAU3I,OAAOf,GAAA,CAAiB,CACtBrnB,OAAQ,CADc,CAEtBjC,YAAaA,CAFS,CAGtBM,SAAUA,CAAAwD,MAHY,CAItB5B,0BAA2B,CAAA,CAJL,CAAjB,CADkD,CAA9C,CAAAqF,KAAA4lB,CAOL,QAAS,CAAC3lB,CAAD,CAAIC,CAAJ,CAAO,CACtB,IAAI2lB,EAAcpH,EAAA,CAASiF,CAAT,CAA8B/oB,EAAA,CAA0BlC,CAA1B,CAAuCitB,EAAA,CAA8BzlB,CAA9B,CAAiC6a,CAAjC,CAAvC,CAA9B,CAAlB,CACIgL,EAAcrH,EAAA,CAASiF,CAAT,CAA8B/oB,EAAA,CAA0BlC,CAA1B,CAAuCitB,EAAA,CAA8BxlB,CAA9B,CAAiC4a,CAAjC,CAAvC,CAA9B,CAElB,OAAI+K,EAAJ,CAAkBC,CAAlB,CACU,EADV,CAIIA,CAAJ,CAAkBD,CAAlB,CACS,CADT,CAIO5lB,CAAA5F,WAAAhC,MAJP,CAI4B6H,CAAA7F,WAAAhC,MAZN,CAPXutB,CAqBN,CAAO,CAAP,CAAP,EAAoB,IA3BqB,CAz2C3C,CAu4CIG,GAAiB/iB,EAAA,CAAW+iB,QAAuB,CAAC9O,CAAD,CAAOsB,CAAP,CAAmB,CACpErd,CAAAA,CAAeqd,CAAA,CAAWtB,CAAAsH,KAAX,CACnB,OAAO,CACLhY,MAAOrL,CADF,CAELpB,MAAOwkB,CAAA,CAAMrH,CAAAsH,KAAN,CAAiBrjB,CAAjB,CAFF,CAFiE,CAArD,CAv4CrB,CA+4CI8qB,GAAkCA,QAAwC,CAAC3lB,CAAD,CAAY4lB,CAAZ,CAA6BvpB,CAA7B,CAAyC,CACrH,IAAIua,EAAO5W,CAAA4W,KAEX,IAAkC,SAAlC,GAAI5W,CAAAhG,WAAA2G,KAAJ,CACE,MAAOsd,EAAA,CAAMrH,CAAAsH,KAAN,CAAiB0H,CAAA,CAAgBhP,CAAAsH,KAAhB,CAAjB,CAGT,KAAI2H,EAAiB7lB,CAAA+W,QAAA1d,KAAAgpB,WAAA,CAAkCzL,CAAAuK,KAAlC,CAMjB2E,EAAAA,CALkBpG,EAAAqG,CAA6B/lB,CAAAhG,WAAAD,GAA7BgsB,CAAsD1pB,CAAtD0pB,CACNjtB,OAAAktB,CAAuB,QAAS,CAACC,CAAD,CAAM/O,CAAN,CAAiB,CAC/D,MAAO+O,EAAP;AAAa/O,CAAAjJ,OAAA3U,UAAA,CAA2Bsd,CAAAuK,KAA3B,CADkD,CAAjD6E,CAEb,CAFaA,CAIZF,CAD4BF,CAAA,CAAgBhP,CAAAsH,KAAhB,CAC5B4H,CAAgCD,CAEpC,OAAqB,EAArB,EAAIC,CAAJ,CACS,IADT,CAIO7H,CAAA,CAAMrH,CAAAsH,KAAN,CAAiB4H,CAAjB,CAnB8G,CA/4CvH,CA66CII,GAAiBA,QAAuB,CAAClmB,CAAD,CAAY/G,CAAZ,CAAuBoD,CAAvB,CAAmC,CAC7E,IAAIH,EAAQ8D,CAAA9D,MACVT,GAAA,CAASxC,CAAT,CAAoB+G,CAApB,CAAF,CAA+IzI,CAAA,CAAU,CAAA,CAAV,CAA/I,CAAkK,IAAK,EACrKyI,EAAA+W,QAAAE,gBAAF,CAAqK1f,CAAA,CAAU,CAAA,CAAV,CAArK,CAAwL,IAAK,EACzLquB,EAAAA,CAAkBF,EAAA,CAAe1lB,CAAA4W,KAAf,CAA+B3d,CAAAif,WAA/B,CAAAze,MACtB,KAAI0sB,EAAiBR,EAAA,CAAgC3lB,CAAhC,CAA2C4lB,CAA3C,CAA4DvpB,CAA5D,CACjBgD,EAAAA,CAAQ,CACVumB,gBAAiBA,CADP,CAEVhH,YAAauH,CAFH,CAGVC,kBAAmBpmB,CAAA9D,MAAA,CAAkB8D,CAAA9D,MAAA6D,OAAA2W,IAAlB,CAA+C,IAHxD,CAMZ,IAAI,CAACxa,CAAL,CAQE,MAPImqB,EAOG,CAPQrP,EAAA,CAAW,CACxB3d,KAAM2G,CAAA+W,QAAA1d,KADkB,CAExB4d,gBAAiB5X,CAFO,CAGxBuX,KAAM5W,CAAA4W,KAHkB,CAIxB1a,MAAO8D,CAAA9D,MAJiB,CAAX,CAOR,CAAApF,CAAA,CAAS,EAAT,CAAakJ,CAAb,CAAwB,CAC7B+W,QAASsP,CADoB,CAAxB,CAKLjQ,EAAAA,CAAY+P,CAAA,CAAiB9lB,CAAA,CAAInE,CAAA6D,OAAA2W,IAAJ,CAAsByP,CAAtB,CAAjB,CAAyDjqB,CAAA6D,OAAA2W,IACrE4P,EAAAA,CAjCGxvB,CAAA,CAAS,EAAT,CAiCsBoF,CAjCtB,CAAoB,CACzB6D,OAAQjJ,CAAA,CAAS,EAAT,CAgCmBoF,CAhCN6D,OAAb,CAA2B,CACjC2W,IA+BgCN,CAhCC,CAA3B,CADiB,CAApB,CAkCHW,EAAAA,CAAUC,EAAA,CAAW,CACvB3d,KAAM2G,CAAA+W,QAAA1d,KADiB;AAEvB4d,gBAAiB5X,CAFM,CAGvBuX,KAAM5W,CAAA4W,KAHiB,CAIvB1a,MAAOoqB,CAJgB,CAAX,CAMd,OAAOxvB,EAAA,CAAS,EAAT,CAAakJ,CAAb,CAAwB,CAC7B+W,QAASA,CADoB,CAE7B7a,MAAOoqB,CAFsB,CAAxB,CAjCsE,CA76C/E,CA4nDIhN,GAAqBA,QAAS,CAACphB,CAAD,CAAS,CAGzC,MAAA,CAFIC,CAEJ,CAFSD,CAAAC,GAET,EAIgB,SAAhB,GAAIA,CAAAhC,KAAJ,CACSgC,CAAAC,YAAAiD,YADT,CAIOlD,CAAAG,QAAA+C,YARP,CACS,IAJgC,CA5nD3C,CA+oDIkrB,GAAmBA,QAAS,CAAC/tB,CAAD,CAAO,CAAA,IACjC+D,EAAQ/D,CAAA+D,MACRpG,EAAAA,CAAOqC,CAAArC,KACyC6P,KAAAA,EAAAzJ,CAAA8c,WAAArT,WAPpD,KAAIjM,EAAKuf,EAAA,CAO6B/c,CAAArE,OAP7B,CACT,EAAA,CAAO6B,CAAA,CAAKiM,CAAA,CAAWjM,CAAX,CAAL,CAAsB,IAQzB2G,EAAAA,CAAOnE,CAAA8c,WAAArT,WAAA,CAA4BzJ,CAAA6c,SAAApZ,UAAAjG,GAA5B,CACX,KAAIysB,EAASC,CAATD,EAA2B9lB,CAC3BsU,EAAAA,CAAYwR,CAAA5P,KAAA5B,UAGhB,KAFI0R,CAEJ,CAFuC,UAEvC,GAFyB1R,CAEzB,GAF+D,SAE/D,GAFsD7e,CAEtD,EAFqF,WAErF,GAF4EA,CAE5E,GAFmH,YAEnH,GAFqG6e,CAErG,GAF6I,WAE7I,GAFoI7e,CAEpI,EAFqK,YAErK,GAF4JA,CAE5J,IAA0B,CANcswB,CAMxC,CACE,MAAO,KAGT,KAAI1G,EAA2B,WAA3BA;AAAkB5pB,CAAlB4pB,EAAmD,YAAnDA,GAA0C5pB,CAC1C8C,EAAAA,CAAYsD,CAAA8c,WAAAhd,WAAA,CAA4BE,CAAA6c,SAAAngB,UAAAc,GAA5B,CAChB,KAAI8pB,EAA8BtnB,CAAAsG,QAAAxJ,KAAAstB,gBAAlC,CACIC,EAAoBrqB,CAAA8c,WACpBhd,EAAAA,CAAauqB,CAAAvqB,WACb2J,EAAAA,CAAa4gB,CAAA5gB,WACV,IAAA0gB,CAAA,CAAqB,CAAA,CAAA,EAAA,CAAA,CAAA,gBAAA,CAAA,CAAA,4BAAA,CAAA,CAAA,UAAA,CAAA,CAAA,YAAA,CAAA,CAAA,WAAA,CAAA,CAAA,SAAA,CAAA,SAAA,CAAA,wBAAA,CAAA,QAAA,OAAA,UAAA,CAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,cAAA,CAAA,CAArB,KArFP,IAVIhuB,CAEAN,CAuGC,CAAAM,SAvGDN,CADAqiB,CACAriB,CAuGC,CAAAqiB,cAvGDriB,CAAAA,CAAAA,CAAcusB,EAAA,CAA0B,CAC1C5E,gBAsGGA,CAvGuC,CAE1CsD,oBAqGGQ,CAvGuC,CAG1CtG,OAoGGiJ,CAvGuC,CAI1CxgB,WAmGGA,CAvGuC,CAK1CtN,SAAUA,CALgC,CAA1B,CAQlB,CAAA,CAIIsC,CAAAA;AAAoB0kB,EAAA,CAA6BtnB,CAAA4B,WAAAD,GAA7B,CA2FnBsC,CA3FmB,CApFxB,IAiGkB2lB,CAjGlB,CAqFqBsD,EAAAtD,CAAoB,CACvCqB,oBAyFGQ,CA1FoC,CAEvCnrB,SAAUA,CAF6B,CAGvCN,YAAaA,CAH0B,CAIvC4C,kBAAmBA,CAJoB,CAKvCyf,cAAeA,CALwB,CAApBuH,CArFrB,CAAA,CAmCI6E,CAAAA,CA4IChD,CA5I6B,CA2DnBzrB,CA3D+Cwe,KAAAsH,KAA5B,CAA9B2I,EA3CiB7E,CA2CmE3oB,KAAAqc,UAAArH,OAAA,CA2DzEjW,CA3D8Gwe,KAAAsH,KAArC,CAGtF,KAAI4I,EA9Ce9E,CA8CFhoB,WAAAhC,MAMjB,EAAA,CApDmBgqB,CAgDfhoB,WAAAD,GAIJ,GAmIGd,CAvIkCe,WAAAD,GAIrC,EAAI8sB,CAAJ,CACSC,CADT,CAIOA,CAJP,CAIoB,CAGlBruB,EAAAA,CAAcitB,EAAA,CA2CHttB,CA3CkBwe,KAAf,CA4Hb3d,CA5H8Cif,WAAjC,CAClB,EAAA,CAAO3c,CAAA,CAAuB,CAC5BtC,UA0HGA,CA3HyB,CAE5B+B,kBA4CmBA,CA9CS,CAG5B5C,YAuCaA,CA1Ce,CAI5BM,SA2CUA,CA/CkB,CAK5BD,YAAaA,CALe,CAM5BG,KAAMwC,EANsB,CAO5BpD,MAAOooB,CAPqB,CAAvB,CApDP,CAAA,IAkGqBplB,EAjGflD,OAAJ,CACE,CADF,CACS,IADT,EAII8K,CA2BJ,CA3Be,CACbzH,UAAWC,EADE,CAEb3C,YAAa6nB,EAFA,CAGbnoB,GAAI,CACFhC,KAAM,SADJ,CAEFiC,YAAa,CACXiD,YAmFOjD,CAnFM4B,WAAAD,GADF,CAEX/B,MAAO,CAFI,CAFX,CAHS,CA2Bf,CAhBI+uB,CAgBJ,CAhBkCvE,EAAA,CAAiC,CACjEtqB,OAAQ0K,CADyD;AAEjE3J,UA6JCA,CA/JgE,CAGjE+G,UA2EW5H,CA9EsD,CAIjEiE,WA2JCA,CA/JgE,CAKjEoe,cA+EaA,CApFoD,CAAjC,CAgBlC,CATIxD,CASJ,CATsBxb,EAAA,CAwJnBxC,CAxJmB,CAuETb,CAvES,CAAA,CAuETA,CAvES,CAAiD8tB,EAAA,CAuE1D9tB,CAvE0D,CAwJpEa,CAxJoE,CAwJpEoD,CAxJoE,CASvE,CAAA,CAAA,CAR6BinB,EAAAiB,CAA8B,CACzDtrB,UAsJCA,CAvJwD,CAEzDb,YAAa6e,CAF4C,CAGzDyM,uBAAwBqD,CAHiC,CAIzDruB,SAuEQA,CAvEEwD,MAJ+C,CAKzD5B,0BAA2B,CAAA,CAL8B,CAMzDkpB,eAAgB,CAAA,CANyC,CAA9Be,CAQtB,CAAyB3hB,CAAzB,CAAoC,IA/B3C,CAsGG1K,EAAL,EAIImrB,CAYJ,CAZ0Bb,EAAA,CAAiC,CACzDtqB,OAAQA,CADiD,CAEzDe,UAkEGA,CApEsD,CAGzD+G,UAAW5H,CAH8C,CAIzDiE,WAgEGA,CApEsD,CAKzDoe,cAAeA,CAL0C,CAAjC,CAY1B,CAAA,CAAA,CAAO,CACL1M,gBANoBoV,EAAApV,CAAiC,CACrDsV,oBAAqBA,CADgC,CAErDpqB,UA2DGA,CA7DkD,CAGrDP,SAAUA,CAH2C,CAAjCqV,CAKf,CAEL7V,OAAQA,CAFH,CAGLoF,kBAAmB,IAHd,CAhBP,EACE,CADF,CACS,IAxBT,CAAA,IACE,EAAA,CAAO,IAoFT,OAAO,EApB8B,CA/oDvC,CA6rDI0pB,GAAqBA,QAAS,CAAC9qB,CAAD,CAAQ,CACxC,IAAIykB,EAAmBH,EAAA,CAAStkB,CAAA1C,IAAT,CAAoB0C,CAAAtC,OAApB,CAAvB,CACIgnB,EAAqBJ,EAAA,CAAStkB,CAAArC,KAAT,CAAqBqC,CAAAvC,MAArB,CACzB,OAAO,SAAS,CAACF,CAAD,CAAQ,CACtB,MAAOknB,EAAA,CAAiBlnB,CAAAC,EAAjB,CAAP;AAAoCinB,CAAA,CAAiBlnB,CAAAC,EAAjB,CAApC,EAAiEknB,CAAA,CAAmBnnB,CAAAK,EAAnB,CAAjE,EAAgG8mB,CAAA,CAAmBnnB,CAAAK,EAAnB,CAD1E,CAHgB,CA7rD1C,CAqsDImtB,GAAsBA,QAAS,CAACzuB,CAAD,CAAO,CAAA,IACpC6B,EAAS7B,CAAA6B,OAeb,OAAO,CAbH6sB,CAaG,CAbKnvB,CAAA,CAAKynB,EAAA,CADAhnB,CAAAwN,WACA,CAAL,CAAkC,QAAS,CAAChG,CAAD,CAAY,CACjE,MAAKA,EAAAyM,UAAL,CAMA,CAFIwS,CAEJ,CAFajf,CAAA+W,QAAAkI,OAEb,EAIO+H,EAAA,CAAkB/H,CAAlB,CAAA,CAA0B5kB,CAA1B,CAJP,CACS,CAAA,CAPT,CACS,CAAA,CAFwD,CAAvD,CAaL,EAAQ6sB,CAAAltB,WAAAD,GAAR,CAA8B,IAhBG,CArsD1C,CAkuDIotB,GAAuBA,QAAS,CAACvQ,CAAD,CAAO5B,CAAP,CAAkB,CACpD,MAAO4B,EAAA,GAASC,EAAT,CAA2C,MAA3C,GAAoB7B,CAAA6B,SAApB,CAA6E,OAA7E,GAAoD7B,CAAA8B,WADP,CAluDtD,CA0vDIsQ,GAAoBA,QAAS,CAAC5rB,CAAD,CAAQ,CAAA,IACnC6rB,EAAgB7rB,CAAA8rB,6CADmB,CAEnCruB,EAAYuC,CAAAvC,UAFuB,CAGnCb,EAAcoD,CAAApD,YAHqB,CAInC4C,EAAoBQ,CAAAR,kBAJe,CAKnCpC,EAAO4C,CAAA5C,KAL4B,CAMnCF,EAAW8C,CAAA9C,SANwB,CAQnC+hB,EAAgBjf,CAAAif,cARmB,CASnC7D,EAAOxe,CAAAwe,KAT4B,CAUnCmJ,EAAkBoH,EAAA,CAAoB/uB,CAAAwe,KAApB,CAHFpb,CAAAsB,cAGE,CAClBrE,EAAAA,CAAcitB,EAAA,CAAettB,CAAAwe,KAAf,CAAiC3d,CAAAif,WAAjC,CAClB,KAAIqP,EAAeF,CAAA,CAAczQ,CAAAsH,KAAd,CAAnB,CACIrjB,EAAepC,CAAAyN,MACftK,EAAAA;AAAkBC,EAAA,CAAwB5C,CAAxB,CAAmC+B,CAAnC,CAClB0B,EAAAA,CAAU3E,CAAA,CAAK6D,CAAL,CAAsB,QAAS,CAAC4rB,CAAD,CAAQ,CAEnD,IAAI9R,EAAY8R,CAAAnuB,KAAAqc,UAAhB,CACIpX,EAAQoX,CAAA,CAAUkB,CAAAtY,MAAV,CACRygB,EAAAA,CAAMrJ,CAAA,CAAUkB,CAAAmI,IAAV,CACN0I,EAAAA,CA9/BC,CAAA,CA8/BmDhN,CA9/B3CI,SAAA,CA0/BJ2M,CAAAxtB,WAAAD,GA1/BI,CAggCb,OAAIgmB,EAAJ,CACM0H,CAAJ,CACSF,CADT,CACwBjpB,CADxB,CAIOipB,CAJP,CAIsBjpB,CAJtB,CAI8BzD,CALhC,CAQI4sB,CAAJ,CACSF,CADT,EACyBxI,CADzB,CAC+BlkB,CAD/B,CAIO0sB,CAJP,EAIuBxI,CAnB4B,CAAvC,CAqBVzjB,EAAAA,CAAWmB,CAAA,CAAQ,CACrBxD,UAAWA,CADU,CAErByD,QAASA,CAFY,CAGrBzB,WAAYQ,EAAA,CAASxC,CAAT,CAAoBb,CAApB,CAHS,CAAR,CAKf,OAAOmD,EAAA,CAAuB,CAC5BtC,UAAWA,CADiB,CAE5B+B,kBAAmBA,CAFS,CAG5B5C,YAAaA,CAHe,CAI5BM,SAAUA,CAJkB,CAK5BE,KAAMA,CALsB,CAM5BH,YAAaA,CANe,CAO5BT,MAAOsD,CAPqB,CAAvB,CAzCgC,CA1vDzC,CAm4DIosB,GAAoBA,QAAS,CAAClsB,CAAD,CAAQ,CAAA,IACnCvC,EAAYuC,CAAAvC,UADuB,CAEnCouB,EAAgB7rB,CAAA8rB,6CAFmB,CAGnCvqB,EAAiBvB,CAAAuB,eAHkB,CAInC3E,EAAcoD,CAAApD,YAJqB,CAKnC4C,EAAoBQ,CAAAR,kBALe,CAMnC8B,EAAgBtB,CAAAsB,cANmB,CAOnC2d,EAAgBjf,CAAAif,cAEpB,IAAI,CAACriB,CAAA8c,iBAAL,CACE,MAAO,KAGT,KAAI0B;AAAOxe,CAAAwe,KAAX,CACIzb,EAAY4B,CAAA5B,UADhB,CAEIwsB,EAAmBjC,EAAA,CAAettB,CAAAwe,KAAf,CAAiC3d,CAAAif,WAAjC,CArBrB,KAAA,EAsB4Cnb,CAvB1C5E,GAAJ,EAAoC,SAApC,GAuB8C4E,CAvB7B5E,GAAAhC,KAAjB,CAuB8C4G,CAtBrC5E,GADT,CAIO,IAuCP,OAAA,CAnBIwgB,CAmBJ,CAnBkB5gB,CAAA,CAAK8D,EAAA,CAAwB5C,CAAxB,CAAmC+B,CAAnC,CAAL,CAA4D,QAAS,CAACwsB,CAAD,CAAQ,CAC7F,IAAIztB,EAAKytB,CAAAxtB,WAAAD,GAAT,CACIme,EAAayJ,EAAA,CAA4B,CAC3CxmB,UAAWA,CADgC,CAE3Csf,cAAeA,CAF4B,CAG3C9B,YAAa5e,CAH8B,CAI3CtB,YAAakvB,CAJ8B,CAA5B,CAlDgC,KAI/CjS,EAwDW8R,CAAAnuB,KAAAqc,UApDXpX,EAAAA,CAAQoX,CAAA,CAmDFkB,CAnDYtY,MAAV,CAARA,CAqDY4Z,CArDoB,CAmD1BtB,CAnDqCsH,KAAX,CAChCa,EAAAA,CAAMrJ,CAAA,CAkDAkB,CAlDUmI,IAAV,CAANA,CAoDY7G,CApDgB,CAkDtBtB,CAlDiCsH,KAAX,CAE5B0J,EAAAA,CAAyB,IAAzBA,CADOlS,CAAAyL,CAiDDvK,CAjDWuK,KAAVA,CAGPpB,EAAAA,CAAkBoH,EAAA,CA8CZvQ,CA9CY,CAkDC5Z,CAtEvBC,EAgEQlD,CAhERkD,GAsEuBD,CAtEZ1E,QAAAwC,YAAXmC,CAsEuBD,CAlEhBC,YAJPA,CAqE0BH,CAjDJ,CACtB,KAAIyqB,EA4CeF,CA5CA,CA6CTzQ,CA7CuBsH,KAAd,CAGjB,EAAA,CADE6B,CAAJ,CACSS,EAAA,CAASliB,CAAT,CAAgBA,CAAhB,CAAwBspB,CAAxB,CAAA,CAAyCL,CAAzC,CADT,CAIO/G,EAAA,CAASzB,CAAT,CAAe6I,CAAf,CAAgC7I,CAAhC,CAAA,CAAqCwI,CAArC,CAoCL,OAAO,EARsF,CAA7E,CAmBlB,EAIO5qB,CAAA,CAAuB,CAC5BC,cAAe+b,CAAA3e,WAAAD,GADa,CAE5B8C,cAAezE,CAAA4B,WAAAD,GAFa,CAG5BgD,eAAgBA,CAHY,CAI5BD,cAAeA,CAJa,CAAvB,CAJP;AACS,IArC8B,CAn4DzC,CAm7DI+qB,GAAiBA,QAAS,CAACrvB,CAAD,CAAO,CAAA,IAC/B6qB,EAAsB7qB,CAAA6qB,oBADS,CAE/BpqB,EAAYT,CAAAS,UAFmB,CAG/BoD,EAAa7D,CAAA6D,WAHkB,CAI/B2J,EAAaxN,CAAAwN,WAJkB,CAK/BjJ,EAAiBvE,CAAAuE,eALc,CAM/BrE,EAAWF,CAAAE,SANoB,CAO/BoE,EAAgBtE,CAAAsE,cAChB2d,EAAAA,CAAgBjiB,CAAAiiB,cACpB,KAAI5d,EAAgBoqB,EAAA,CAAmB,CACrC5sB,OAAQgpB,CAD6B,CAErCrd,WAAYA,CAFyB,CAAnB,CAKpB,IAAI,CAACnJ,CAAL,CACE,MAAO0jB,GAGLnoB,EAAAA,CAAc4N,CAAA,CAAWnJ,CAAX,CACd7B,EAAAA,CAAoB0kB,EAAA,CAA6BtnB,CAAA4B,WAAAD,GAA7B,CAAwDsC,CAAxD,CAvOxB,EAAA,CAJA,CAFIH,CAEJ,CA4OuE9D,CA9O3D8D,MAEZ,EAIOmE,CAAA,CAwO6EgjB,CAxO7E,CAAWnnB,CAAA6D,OAAA4W,KAAAzQ,MAAX,CAJP,CA4OoFmd,CACpF,OAAOqE,GAAA,CAAiB,CACtBJ,6CAA8CA,CADxB,CAEtBruB,UAAWA,CAFW,CAGtB8D,eAAgBA,CAHM,CAItB3E,YAAaA,CAJS,CAKtB4C,kBAAmBA,CALG,CAMtB8B,cAAeA,CANO,CAOtB2d,cAAeA,CAPO,CAAjB,CAAP,EAQM2M,EAAA,CAAiB,CACrBE,6CAA8CA,CADzB,CAErBruB,UAAWA,CAFU;AAGrBb,YAAaA,CAHQ,CAIrB4C,kBAAmBA,CAJE,CAKrBpC,KAAMmE,CAAA5B,UALe,CAMrBzC,SAAUA,CANW,CAOrBoE,cAAeA,CAPM,CAQrB2d,cAAeA,CARM,CAAjB,CA7B6B,CAn7DrC,CAo/DIqN,GAAqBA,QAAS,CAAC9hB,CAAD,CAAalG,CAAb,CAAsB,CACtD,IAAI+e,CAEJ,OAAO/nB,EAAA,CAAS,EAAT,CAAakP,CAAb,EAA0B6Y,CAAA,CAAY,EAAZ,CAAgBA,CAAA,CAAU/e,CAAA9F,WAAAD,GAAV,CAAhB,CAAmD+F,CAAnD,CAA4D+e,CAAtF,EAH+C,CAp/DxD,CAkjEIrhB,GAAUA,QAAS,CAAChF,CAAD,CAAO,CAAA,IACxB+D,EAAQ/D,CAAA+D,MADgB,CAKxBwrB,EAAevvB,CAAAN,OALS,CAMxBoF,EAAoB9E,CAAA8E,kBANI,CAOxB5E,EAHiBF,CAAAE,SAGjBA,EAA6B6D,CAAA7D,SAPL,CAQxBsvB,EAAsBtvB,CAAAqH,OAAA8C,QARE,CASxBwW,EANmB7gB,CAAA6gB,WAMnBA,EAAiC9c,CAAA8c,WACjCtL,EAAAA,CARwBvV,CAAAuV,gBAQxBA,EAA2CxR,CAAAsG,QAAAoL,OAAAga,UAC/C,KAAIjP,EAAS+E,EAAA,CAAShQ,CAAT,CAA0BxR,CAAAka,QAAAxI,OAAAga,UAA1B,CACTha,EAAAA,CAAS,CACX+K,OAAQA,CADG,CAEXiP,UAAWla,CAFA,CAGX4Y,gBAAiBtmB,CAAA,CAAI9D,CAAAka,QAAAxI,OAAA0Y,gBAAJ,CAA0C3N,CAA1C,CAHN,CAKb,KAAI3f,EAAO,CACT4uB,UAAW5nB,CAAA,CAAI4N,CAAAga,UAAJ,CAAsBD,CAAtB,CADF;AAETrB,gBAAiBtmB,CAAA,CAAI4N,CAAA0Y,gBAAJ,CAA4BqB,CAA5B,CAFR,CAIPnlB,EAAAA,CAAU,CACZoL,OAAQA,CADI,CAEZ5U,KAAMA,CAFM,CAIuByD,EAAAA,CAAAP,CAAAO,cA9FrC,KAAI6Z,EAAOoH,EAAA,CA8FmFlb,CAAAxJ,KAAAstB,gBA9FnF,CA8F+CpqB,CAAAsG,QAAAxJ,KAAAstB,gBA9F/C,CAEsC7sB,EAAAA,CAAA6c,CAAA7c,EACNJ,EAAAA,CAAAid,CAAAjd,EAF3C,EAAA,CAAO,CACLod,WAVW,CAAb,GAAIH,CAAJ,CAU4Bhc,CAAAmc,WAV5B,CAIc,CAAP,CAAAH,CAAA,CAAW,OAAX,CAAqB,MAKrB,CAELE,SAnBW,CAAb,GAAIF,CAAJ,CAmBwBhc,CAAAkc,SAnBxB,CAIc,CAAP,CAAAF,CAAA,CAAW,MAAX,CAAoB,IAapB,CA+FP,IAAoB,YAApB,GAAIpa,CAAAC,MAAJ,CACE,MAAO1F,EAAA,CAAS,CACd0F,MAAO,YADO,CAAT,CAEJD,CAFI,CAEG,CACR8c,WAAYA,CADJ,CAER3gB,SAAUA,CAFF,CAGRmK,QAASA,CAHD,CAIR/F,cAAeA,CAJP,CAFH,CAUL7D,EAAAA,CAAYogB,CAAAhd,WAAA,CAAsBE,CAAA6c,SAAAngB,UAAAc,GAAtB,CACZmpB,EAAAA,CAAY6E,CAAZ7E,EAA4B2E,EAAA,CAAc,CAC5CxE,oBAAqBhqB,CAAAstB,gBADuB,CAE5C1tB,UAAWA,CAFiC,CAG5CoD,WAAYgd,CAAAhd,WAHgC,CAI5C2J,WAAYqT,CAAArT,WAJgC;AAK5CjJ,eAAgBR,CAAArE,OAL4B,CAM5CQ,SAAUA,CANkC,CAO5CoE,cAAeA,CAP6B,CAQ5C2d,cAAele,CAAAke,cAR6B,CAAd,CApE5Bpe,EAAAA,CAkFUgd,CAAAhd,WAjFV2J,EAAAA,CAkFUqT,CAAArT,WA1GVpN,KAAAA,EAAO0gB,EAAA,CAwGO/c,CAAArE,OAxGP,CACX,KAAIgwB,EAAM5O,EAAA,CAsGA4J,CAtGA,CAMV,IAJKtqB,CAIL,EAAIA,CAAJ,GAAasvB,CAAb,CAMA,GAFIC,CAEClR,CAiBSjR,CAnBM,CAAWpN,CAAX,CAEfqe,CAAAkR,CAAApR,QAAAE,gBAAL,CAAA,CAvjBA,IAAI5X,EA2jB4B8oB,CA3jBpBpR,QAAAE,gBACX5X,EAAD,CAAqJ,IAAK,EAA1J,CAAkI9H,CAAA,CAAU,CAAA,CAAV,CAGlI,EAFI2E,CAEJ,CAujBgCisB,CAzjBpBjsB,MAEZ,GAcA,CADIksB,CACJ,CADmB/oB,CAAA+mB,kBACnB,EAAsL,IAAK,EAA3L,CAAmK7uB,CAAA,CAAU,CAAA,CAAV,CAQnK,CAPI+uB,CAOJ,CAxEOxvB,CAAA,CAAS,EAAT,CAiEsBoF,CAjEtB,CAAoB,CACzB6D,OAAQjJ,CAAA,CAAS,EAAT,CAgEmBoF,CAhEN6D,OAAb,CAA2B,CACjC2W,IA+DgC0R,CAhEC,CAA3B,CADiB,CAApB,CAwEP,CANIrR,CAMJ,CANcC,EAAA,CAAW,CACvB3d,KAsiB8B8uB,CAtiBxBpR,QAAA1d,KADiB,CAEvBud,KAqiB8BuR,CAriBxBvR,KAFiB,CAGvB1a,MAAOoqB,CAHgB,CAIvBrP,gBAAiB,IAJM,CAAX,CAMd,CAAA,CAAA,CAAOngB,CAAA,CAAS,EAAT,CAiiByBqxB,CAjiBzB,CAAwB,CAC7BpR,QAASA,CADoB,CAE7B7a,MAAOoqB,CAFsB,CAAxB,CAtBP,GACM+B,CAOJ,CAPgBrR,EAAA,CAAW,CACzB3d,KAqjB4B8uB,CArjBtBpR,QAAA1d,KADmB,CAEzBud,KAojB4BuR,CApjBtBvR,KAFmB,CAGzB1a,MAAO,IAHkB,CAIzB+a,gBAAiB,IAJQ,CAAX,CAOhB;AAAA,CAAA,CAAOngB,CAAA,CAAS,EAAT,CA+iBuBqxB,CA/iBvB,CAAwB,CAC7BpR,QAASsR,CADoB,CAAxB,CART,CAwjBA,EAAA,CAAOP,EAAA,CAYO9hB,CAZP,CAA8BlG,CAA9B,CALP,CAAA,IACE,EAAA,CAgBYkG,CAvBd,KACE,EAAA,CAsBYA,CAId,EAFIwgB,CAEJ,CAFalN,EAAA,CAuEH4J,CAvEG,CAEb,GAIIljB,CAMJ,CANgBgG,CAAA,CAAWwgB,CAAX,CAMhB,CAJI/qB,EAAA,CA8DSxC,CA9DT,CAAoB+G,CAApB,CAIJ,EAAIA,CAAA+W,QAAAE,gBAAJ,CACE,CADF,CACSqR,CADT,EAIIC,CACJ,CADcrC,EAAA,CAAelmB,CAAf,CAsDD/G,CAtDC,CAAqCoD,CAArC,CACd,CAAA,CAAA,CAAOyrB,EAAA,CAAkBQ,CAAlB,CAA2BC,CAA3B,CALP,CAVA,EACE,CADF,CACSD,CAuFT,OAbaxxB,EAAAqJ,CAAS,EAATA,CAAa5D,CAAb4D,CAAoB,CAC/B0C,QAASA,CADsB,CAE/B/F,cAAeA,CAFgB,CAG/Buc,WAAY,CACVhd,WAAYgd,CAAAhd,WADF,CAEV2J,WAAYwiB,CAFF,CAHmB,CAO/BtwB,OAAQgrB,CAPuB,CAQ/BxqB,SAAUA,CARqB,CAS/B4E,kBAAmBA,CAAnBA,EAAwC,IATT,CAU/B3E,mBAAoB2E,CAAA,CAAoB,CAAA,CAApB,CAA4B,IAVjB,CAApB6C,CAzDe,CAljE9B,CAioEIsoB,GAAaA,QAAS,CAACjwB,CAAD,CAAO,CAAA,IAC3BN,EAASM,CAAAN,OADkB,CAE3BQ,EAAWF,CAAAE,SAFgB,CAI3BN,EAAcI,CAAAJ,YAJa,CAK3BO,EAAqBH,CAAAG,mBALM,CAM3BC,EAAOV,CAAAiD,UACPtC,EAAAA,CAAgBqE,CAAA,CAAgBtE,CAAAqB,IAAhB,CAJHzB,CAAA6D,WAIG,CAChBlB,EAAAA,CAAY5C,CAAA,CAAsB,CACpCM,cAAeA,CADqB,CAEpCT,YAAaA,CAFuB,CAGpCK,YAAaP,CAAAO,YAHuB,CAIpCC,SAAUA,CAAAwD,MAJ0B;AAKpCvD,mBAAoBA,CALgB,CAMpCC,KAAMA,CAN8B,CAAtB,CAQhB,OAAO9B,EAAA,CAAS,EAAT,CAAaoB,CAAb,CAAqB,CAC1BiD,UAAWA,CADe,CAArB,CAhBwB,CAjoEjC,CAspEIutB,GAA4BA,QAAS,CAAClwB,CAAD,CAAO,CAAA,IAE1CS,EAAYT,CAAAS,UAF8B,CAK1CP,EAAWF,CAAAE,SAEX2qB,EAAAA,CAAsBb,EAAA,CAAiC,CACzDtqB,OAPWM,CAAAN,OAM8C,CAEzDe,UAAWA,CAF8C,CAGzDoD,WANe7D,CAAA6D,WAG0C,CAIzD2D,UARcxH,CAAAwH,UAI2C,CAKzDya,cANkBjiB,CAAAiiB,cACuC,CAAjC,CAO1B,OAAO0I,GAAA,CAAiC,CACtCE,oBAAqBA,CADiB,CAEtCpqB,UAAWA,CAF2B,CAGtCP,SAAUA,CAH4B,CAAjC,CAduC,CAtpEhD,CA2qEIiwB,GAAeA,QAAS,CAACnwB,CAAD,CAAO,CAAA,IAC7B+D,EAAQ/D,CAAA+D,MADqB,CAE7BqsB,EAAmBpwB,CAAA6gB,WACnBwP,EAAAA,CAAiBrwB,CAAAE,SACI,OAAzB,GAAE6D,CAAAc,aAAF,CAA8F9F,CAAA,CAAU,CAAA,CAAV,CAA9F,CAAiH,IAAK,EACtH,KAAIuxB,EAAuBvsB,CAAArE,OACvBQ,EAAAA,CAAWmwB,CAAXnwB,EAA6B6D,CAAA7D,SAC7B2gB,EAAAA,CAAauP,CAAbvP,EAAiC9c,CAAA8c,WAPJ,KAQ7Bhd,EAAagd,CAAAhd,WARgB,CAS7B2J,EAAaqT,CAAArT,WATgB,CAU7B/M,EAAYoD,CAAA,CAAWE,CAAA6c,SAAAngB,UAAAc,GAAX,CAViB,CAW7BysB,EAASlN,EAAA,CAAkBwP,CAAlB,CACZtC,EAAD,CAA4I,IAAK,EAAjJ,CAAyHjvB,CAAA,CAAU,CAAA,CAAV,CACrHa;CAAAA,CAAc4N,CAAA,CAAWwgB,CAAX,CACdtuB,EAAAA,CAASuwB,EAAA,CAAU,CACrBvwB,OAAQ4wB,CADa,CAErBpwB,SAAUA,CAFW,CAGrBN,YAAaA,CAHQ,CAIrBiE,WAAYA,CAJS,CAAV,CAMT0R,EAAAA,CAAkB2a,EAAA,CAAyB,CAC7CxwB,OAAQA,CADqC,CAE7Ce,UAAWA,CAFkC,CAG7C+G,UAAW5H,CAHkC,CAI7CiE,WAAYA,CAJiC,CAK7C3D,SAAUA,CALmC,CAM7C+hB,cAAele,CAAAke,cAN8B,CAAzB,CAQtB,OAAOjd,GAAA,CAAO,CACZtF,OAAQA,CADI,CAEZ6V,gBAAiBA,CAFL,CAGZxR,MAAOA,CAHK,CAIZ8c,WAAYA,CAJA,CAKZ3gB,SAAUA,CALE,CAAP,CA5B0B,CA3qEnC,CAgtEIqwB,GAAmBA,QAAS,CAAC/uB,CAAD,CAAa,CAC3C,MAAO,CACLhC,MAAOgC,CAAAhC,MADF,CAELqD,YAAarB,CAAAqB,YAFR,CADoC,CAhtE7C,CAutEI2tB,GAAiBA,QAAS,CAACxwB,CAAD,CAAO,CAAA,IAC/BS,EAAYT,CAAAS,UADmB,CAE/ByH,EAAOlI,CAAAkI,KAFwB,CAG/BrE,EAAa7D,CAAA6D,WACb3D,EAAAA,CAAWF,CAAAE,SACf,KAAID,EAAcitB,EAAA,CAAehlB,CAAAkW,KAAf,CAA0B3d,CAAAif,WAA1B,CACd+Q,EAAAA,CAAavJ,EAAA,CAA6Bhf,CAAA1G,WAAAD,GAA7B,CAAiDsC,CAAjD,CACjB,KAAI6sB,EAAWD,CAAAltB,QAAA,CAAmB9C,CAAnB,CACC,GAAhB,GAAEiwB,CAAF,CAA6H3xB,CAAA,CAAU,CAAA,CAAV,CAA7H,CAAgJ,IAAK,EACjJsB,EAAAA,CAAgBowB,CAAAhtB,MAAA,CAAiBitB,CAAjB,CAA4B,CAA5B,CAChBrO,EAAAA,CAAWhiB,CAAAC,OAAA,CAAqB,QAAS,CAAC6B,CAAD,CAAWgB,CAAX,CAAiB,CAC5DhB,CAAA,CAASgB,CAAA3B,WAAAD,GAAT,CAAA;AAA+B,CAAA,CAC/B,OAAOY,EAFqD,CAA/C,CAGZ,EAHY,CAIX8f,EAAAA,CAAgB,CAClBG,cAAwC,SAAxCA,GAAela,CAAA1G,WAAA2G,KADG,CAElBlI,YAAaA,CAFK,CAGlBoiB,SAAUA,CAHQ,CAqBpB,OAAO,CACL3iB,OATWA,CACXiD,UATc5C,CAAA4C,CAAsB,CACpCtC,cAAeA,CADqB,CAEpCT,YAAasI,CAFuB,CAGpCjI,YAAaA,CAHuB,CAIpCG,KAAM,IAJ8B,CAKpCF,SAAUA,CAAAwD,MAL0B,CAMpCvD,mBAAoB,CAAA,CANgB,CAAtBwC,CAQHjD,CAEXO,YAAaA,CAFFP,CAGXC,GAAI,CACFhC,KAAM,SADJ,CAEFiC,YAAa2wB,EAAA,CAAgB9vB,CAAAe,WAAhB,CAFX,CAHO9B,CAQN,CAELuiB,cAAeA,CAFV,CAnC4B,CAvtErC,CAy1EI0O,GAAmCA,QAAS,CAAC3wB,CAAD,CAAO,CAAA,IAEjD4wB,EAAoB5wB,CAAA4wB,kBAF6B,CAGjD1wB,EAAWF,CAAAE,SAHsC,CAIjD2wB,EAAqB3wB,CAAAqH,OAAA4W,KAAAzQ,MACzB,OAJgB1N,EAAA+G,UAIT5I,IAAA,CAAc,QAAS,CAACsC,CAAD,CAAY,CAV1C,IAAIiD,EAYaktB,CAAAhqB,CADGnG,CAAAe,WAAAqB,YACH+D,CAZLlD,MACXA,EAAD,CAA6H,IAAK,EAAlI,CAA0G3E,CAAA,CAAU,CAAA,CAAV,CAcxG,KAAI+xB,EAAcjpB,CAAA,CAAIgpB,CAAJ,CAbbntB,CAYuB6D,OAAA4W,KAAAzQ,MACV,CA/BhBqjB,EAAAA,CAmCqB7wB,CAAAqH,OAAA0W,QAlCrBxI;CAAAA,CAAS/U,EAAA8f,OAAA,CAgCE/f,CAhCiBgV,OAAnB,CAiCDqb,CAjCC,CACTjwB,EAAAA,CAAOH,EAAA+c,WAAA,CAAuBhI,CAAvB,CAA+Bsb,CAA/B,CAmCT,OAjCUzyB,EAAA0yB,CAAS,EAATA,CA6BGvwB,CA7BHuwB,CAAwB,CAClCxR,YAAalhB,CAAA,CAAS,EAAT,CA4BAmC,CA5Ba+e,YAAb,CAAoC,CAC/C/J,OAAQA,CADuC,CAApC,CADqB,CAIlCA,OAAQA,CAJ0B,CAKlC5U,KAAMA,CAL4B,CAAxBmwB,CAsB8B,CAAnC,CAL8C,CAz1EvD,CA82EIC,GAAiCA,QAAS,CAACjxB,CAAD,CAAO,CAAA,IAC/CqmB,CAD+C,CACpC6K,CADoC,CAG/CntB,EAAQ/D,CAAA+D,MACRotB,EAAAA,CAAYnxB,CAAAmxB,UAEhB,KAAIC,EAAmBD,CAAAvqB,SAAAzI,IAAA,CAAuB,QAAS,CAAC6G,CAAD,CAAS,CAG9D,MADemU,GAAAmN,CADAviB,CAAA8c,WAAArT,WAAA6jB,CAA4BrsB,CAAAnC,YAA5BwuB,CACA/K,CAA0BthB,CAAAuC,OAA1B+e,CAF+C,CAAzC,CAMnB9Y,EAAAA,CAAalP,CAAA,CAAS,EAAT,CAAayF,CAAA8c,WAAArT,WAAb,CAA0C,EAA1C,CAA8CsZ,EAAA,CAAesK,CAAf,CAA9C,CAEjB,KAAIE,EAAmBvK,EAAA,CAAe4J,EAAA,CAAgC,CACpE5pB,UAAWoqB,CAAApqB,UADyD,CAEpE6pB,kBAAmBpjB,CAFiD,CAGpEtN,SAAU6D,CAAA7D,SAH0D,CAAhC,CAAf,CAAvB,CAMI2D,EAAavF,CAAA,CAAS,EAAT,CAAayF,CAAA8c,WAAAhd,WAAb,CAA0C,EAA1C,CAA8CytB,CAA9C,CAEjBH,EAAAxqB,SAAA9H,QAAA,CAA2B,QAAS,CAAC0C,CAAD,CAAK,CACvC,OAAOsC,CAAA,CAAWtC,CAAX,CADgC,CAAzC,CAGIsf,EAAAA,CAAa,CACfrT,WAAYA,CADG,CAEf3J,WAAYA,CAFG,CAKb0tB,EAAAA,CAAU,CADVC,CACU;AADE1Q,EAAA,CAAkB/c,CAAArE,OAAlB,CACF,EAAYmhB,CAAArT,WAAA,CAAsBgkB,CAAtB,CAAZ,CAA+C,IA9BV,KAkC/CC,EAAiBjB,EAAA,CAAc,CACjC/vB,UAJcogB,CAAAhd,WAAApD,CAAsBsD,CAAA6c,SAAAngB,UAAAc,GAAtBd,CAGmB,CAEjCyH,KAJS2Y,CAAArT,WAAAtF,CAAsBnE,CAAA6c,SAAApZ,UAAAjG,GAAtB2G,CAEwB,CAGjCrE,WAAYA,CAHqB,CAIjC3D,SAAU6D,CAAA7D,SAJuB,CAAd,CAMjBwxB,EAAAA,CAAeD,CAAA/xB,OACfuiB,EAAAA,CAAgBwP,CAAAxP,cAGhBviB,EAAAA,CAAS2vB,EAAA,CAAc,CACzBxE,oBAAqB9mB,CAAAsG,QAAAxJ,KAAAstB,gBADI,CAEzB1tB,UAAWogB,CAAAhd,WAAA,CAAsBE,CAAA6c,SAAAngB,UAAAc,GAAtB,CAFc,CAGzBsC,WAAYgd,CAAAhd,WAHa,CAIzB2J,WAAYqT,CAAArT,WAJa,CAKzBjJ,eANmBgtB,CAAAhtB,EAAWgtB,CAAA7U,iBAAXnY,CAAsCR,CAAArE,OAAtC6E,CAAqDmtB,CAC/C,CAMzBxxB,SAAU6D,CAAA7D,SANe,CAOzBoE,cAAeP,CAAAO,cAPU,CAQzB2d,cAAeA,CARU,CAAd,CAYT0P,EAAAA,CAAgBrzB,CAAA,CAAS,CAC3B0F,MAAO,UADoB,CAAT,CAEjBD,CAFiB,EAETsiB,CAAA,CAAY,EAAZ,CAAgBA,CAAA,MAAhB;AAAqC,UAArC,CAAiDA,CAAA3mB,OAAjD,CAAoEA,CAApE,CAA4E2mB,CAAAqL,aAA5E,CAAqGA,CAArG,CAAmHrL,CAAAxF,WAAnH,CAA0IA,CAA1I,CAAsJwF,CAAApE,cAAtJ,CAAgLA,CAAhL,CAA+LoE,CAAAlmB,mBAA/L,CAA8N,CAAA,CAA9N,CAAqOkmB,CAF5N,EAIpB,OAAoB,YAApB,GAAItiB,CAAAC,MAAJ,CACS2tB,CADT,CAIkBrzB,CAAAszB,CAAS,CACzB5tB,MAAO,cADkB,CAAT4tB,CAEfD,CAFeC,EAECV,CAAA,CAAY,EAAZ,CAAgBA,CAAA,MAAhB,CAAqC,cAArC,CAAqDA,CAAAjmB,OAArD,CAAwElH,CAAAkH,OAAxE,CAAsFimB,CAAAW,UAAtF,CAA4G,CAAA,CAA5G,CAAmHX,CAFpHU,EAhEiC,CA92ErD,CAy7EIE,GAAsBA,QAA4B,CAAC/tB,CAAD,CAAQuD,CAAR,CAAiByqB,CAAjB,CAAoC,CACrDlR,IAAAA,EAAA9c,CAAA8c,WAzLnC,EAAA,CAAO,CACLhd,WAAYgd,CAAAhd,WADP,CAEL2J,WAAY8hB,EAAA,CAAkBzO,CAAArT,WAAlB,CAuLuClG,CAvLvC,CAFP,CA2LP,OAN8B,MAM9B,GAAgBvD,CANTc,aAMP,EAA0BktB,CAA1B,CACS/sB,EAAA,CAAO,CACZjB,MAAOA,CADK,CAEZ8c,WAAYA,CAFA,CAAP,CADT,CAOOsP,EAAA,CAAY,CACjBpsB,MAAOA,CADU,CAEjB8c,WAAYA,CAFK,CAAZ,CAViF,CAz7E1F,CAq9EImR,GAAO,CACThuB,MAAO,MADE,CAETiM,UAAW,IAFF,CAGTgiB,YAAa,CAAA,CAHJ,CAr9EX,CA09EI3Y,GAAWA,QAAS,CAACvV,CAAD,CAAQuU,CAAR,CAAgB,CACxB,IAAK,EAAnB,GAAIvU,CAAJ,GACEA,CADF,CACUiuB,EADV,CAIA,IAAoB,OAApB;AAAI1Z,CAAA3a,KAAJ,CACE,MAAOW,EAAA,CAAS,EAAT,CAAa0zB,EAAb,CAAmB,CACxBC,YAAa,CAAA,CADW,CAAnB,CAKT,IAAoB,iBAApB,GAAI3Z,CAAA3a,KAAJ,CAAuC,CACnB,MAAlB,GAAEoG,CAAAC,MAAF,CAAuIjF,CAAA,CAAU,CAAA,CAAV,CAAvI,CAA0J,IAAK,EAD1H,KAEjCmzB,EAAkB5Z,CAAA1D,QAClBgM,EAAAA,CAAWsR,CAAAtR,SAHsB,KAKjC1gB,EAAWgyB,CAAAhyB,SACX2gB,EAAAA,CAAaqR,CAAArR,WAJjB,KAKIhc,EAAeqtB,CAAArtB,aALnB,CAMIpE,EAAYogB,CAAAhd,WAAA,CAAsB+c,CAAAngB,UAAAc,GAAtB,CANhB,CAOI2G,EAAO2Y,CAAArT,WAAA,CAAsBoT,CAAApZ,UAAAjG,GAAtB,CACPkU,EAAAA,CAAS,CACXga,UAPoByC,CAAA3c,gBAMT,CAEX4Y,gBAAiB1tB,CAAAgV,OAAAyH,UAAArH,OAFN,CAGX2K,OAAQtZ,EAHG,CAKT+W,EAAAA,CAAU,CACZxI,OAAQA,CADI,CAEZ5U,KAAM,CACJ4uB,UAAW5nB,CAAA,CAAI4N,CAAAga,UAAJ,CAAsBvvB,CAAAqH,OAAA0W,QAAtB,CADP,CAEJkQ,gBAAiBtmB,CAAA,CAAI4N,CAAAga,UAAJ,CAAsBvvB,CAAAqH,OAAA0W,QAAtB,CAFb,CAFM,CAOd,KAAIkU,EAAwBnL,EAAA,CAAgBnG,CAAArT,WAAhB,CAAA4kB,MAAA,CAA6C,QAAS,CAACjvB,CAAD,CAAO,CACvF,MAAO,CAACA,CAAAmZ,cAD+E,CAA7D,CAIxBmV;CAAAA,CAAiBjB,EAAA,CAAc,CACjC/vB,UAAWA,CADsB,CAEjCyH,KAAMA,CAF2B,CAGjCrE,WAAYgd,CAAAhd,WAHqB,CAIjC3D,SAAUA,CAJuB,CAAd,CAMjBR,EAAAA,CAAS+xB,CAAA/xB,OAoBb,OAjBaiI,CACX3D,MAAO,UADI2D,CAEX/C,WAAY,CAAA,CAFD+C,CAGXiZ,SAAUA,CAHCjZ,CAIX9C,aAAcA,CAJH8C,CAKXkZ,WAAYA,CALDlZ,CAMXsW,QAASA,CANEtW,CAOX0C,QAAS4T,CAPEtW,CAQXwqB,sBAAuBA,CARZxqB,CASXjI,OAAQA,CATGiI,CAUXsa,cAZkBwP,CAAAxP,cAEPta,CAWX+pB,aAAchyB,CAXHiI,CAYXzH,SAAUA,CAZCyH,CAaXrD,cAAe6iB,EAbJxf,CAcX7C,kBAAmB,IAdR6C,CAeXxH,mBAAoB,IAfTwH,CAnCwB,CAuDvC,GAAoB,qBAApB,GAAI2Q,CAAA3a,KAAJ,CAA2C,CAGzC,GAAoB,YAApB,GAAIoG,CAAAC,MAAJ,EAAoD,cAApD,GAAoCD,CAAAC,MAApC,CACE,MAAOD,EAGS,WAAlB,GAAEA,CAAAC,MAAF,CAAgJjF,CAAA,CAAU,CAAA,CAAV,CAAhJ,CAAmK,IAAK,EAMxK,OAJcT,EAAA+zB,CAAS,CACrBruB,MAAO,YADc,CAATquB,CAEXtuB,CAFWsuB,EAEHhM,CAAA,CAAY,EAAZ,CAAgBA,CAAA,MAAhB,CAAqC,YAArC;AAAmDA,CAFhDgM,EAT2B,CAgB3C,GAAoB,wBAApB,GAAI/Z,CAAA3a,KAAJ,CAEE,MADkB,YAAlB,GAAEoG,CAAAC,MAAF,EAAkD,cAAlD,GAAkCD,CAAAC,MAAlC,CAAkMjF,CAAA,CAAU,CAAA,CAAV,CAAlM,CAAqN,IAAK,EACnN,CAAAkyB,EAAA,CAA8B,CACnCltB,MAAOA,CAD4B,CAEnCotB,UAAW7Y,CAAA1D,QAFwB,CAA9B,CAMT,IAAoB,MAApB,GAAI0D,CAAA3a,KAAJ,CAA4B,CAC1B,GAAoB,cAApB,GAAIoG,CAAAC,MAAJ,CACE,MAAOD,EAGRD,EAAA,CAAkBC,CAAlB,CAAD,CAAkK,IAAK,EAAvK,CAA+IhF,CAAA,CAAU,CAAA,CAAV,CAC3IuzB,EAAAA,CAAmBha,CAAA1D,QAAAa,OAEvB,OAAI+P,EAAA,CAAQ8M,CAAR,CAA0BvuB,CAAAsG,QAAAoL,OAAAga,UAA1B,CAAJ,CACS1rB,CADT,CAIOiB,EAAA,CAAO,CACZjB,MAAOA,CADK,CAEZwR,gBAAiB+c,CAFL,CAGZ5yB,OA7I0B,MA6IlB,GAAWqE,CA7IhBc,aA6IK,CAAoBd,CAAArE,OAApB,CAAmC,IAH/B,CAAP,CAZmB,CAmB5B,GAAoB,yBAApB,GAAI4Y,CAAA3a,KAAJ,CAA+C,CAK7C,GAJoB,cAIpB,GAJIoG,CAAAC,MAIJ,EAAoB,YAApB,GAAID,CAAAC,MAAJ,CACE,MAAOW,EAAA,CAAwBZ,CAAxB,CAGRD,EAAA,CAAkBC,CAAlB,CAAD,CAAkK,IAAK,EAAvK,CAA+IhF,CAAA,CAAU,CAAA,CAAV,CAC3IwzB,EAAAA,CAAmBja,CAAA1D,QAGnB/S,EAAAA,CAASkC,CAAA8c,WAAArT,WAAA,CAFJ+kB,CAAAhxB,GAEI,CAEb;GAAI,CAACM,CAAL,CACE,MAAOkC,EAGLuiB,EAAAA,CAAWnN,EAAA,CAAgBtX,CAAhB,CAPC0wB,CAAA5L,UAOD,CACf,OAAOmL,GAAA,CAAoB/tB,CAApB,CAA2BuiB,CAA3B,CAAqC,CAAA,CAArC,CApBsC,CAuB/C,GAAoB,6BAApB,GAAIhO,CAAA3a,KAAJ,CAAmD,CACjD,GAAoB,cAApB,GAAIoG,CAAAC,MAAJ,CACE,MAAOD,EAGRD,EAAA,CAAkBC,CAAlB,CAAD,CAAuK,IAAK,EAA5K,CAAoJhF,CAAA,CAAU,CAAA,CAAV,CAChJyzB,EAAAA,CAAmBla,CAAA1D,QAEnBX,EAAAA,CAAYue,CAAAve,UAEhB,EADIwe,CACJ,CADc1uB,CAAA8c,WAAArT,WAAA,CAFJglB,CAAAjxB,GAEI,CACd,EAA+J,IAAK,EAApK,CAA4IxC,CAAA,CAAU,CAAA,CAAV,CAC1I0zB,EAAAxe,UAAF,GAAwBA,CAAxB,CAAwNlV,CAAA,CAAU,CAAA,CAAV,CAAxN,CAA2O,IAAK,EAE5OuI,EAAAA,CAAUhJ,CAAA,CAAS,EAAT,CAAam0B,CAAb,CAAsB,CAClCxe,UAAWA,CADuB,CAAtB,CAId,OAAO6d,GAAA,CAAoB/tB,CAApB,CAA2BuD,CAA3B,CAAoC,CAAA,CAApC,CAjB0C,CAoBnD,GAAoB,qCAApB,GAAIgR,CAAA3a,KAAJ,CAA2D,CACzD,GAAoB,cAApB,GAAIoG,CAAAC,MAAJ,CACE,MAAOD,EAGRD,EAAA,CAAkBC,CAAlB,CAAD,CAAuK,IAAK,EAA5K,CAAoJhF,CAAA,CAAU,CAAA,CAAV,CAChJ2zB,EAAAA,CAAmBpa,CAAA1D,QAEnB8H,EAAAA,CAAmBgW,CAAAhW,iBAEvB,EADIiW,CACJ,CADe5uB,CAAA8c,WAAArT,WAAA,CAFJklB,CAAAnxB,GAEI,CACf,EAA0K,IAAK,EAA/K,CAAuJxC,CAAA,CAAU,CAAA,CAAV,CACrJ4zB,EAAAjW,iBAAF;AAAgCA,CAAhC,CAA6P3d,CAAA,CAAU,CAAA,CAAV,CAA7P,CAAgR,IAAK,EAEjR6zB,EAAAA,CAAWt0B,CAAA,CAAS,EAAT,CAAaq0B,CAAb,CAAuB,CACpCjW,iBAAkBA,CADkB,CAAvB,CAIf,OAAOoV,GAAA,CAAoB/tB,CAApB,CAA2B6uB,CAA3B,CAAqC,CAAA,CAArC,CAjBkD,CAoB3D,GAAoB,uBAApB,GAAIta,CAAA3a,KAAJ,CAA6C,CAC3C,GAAoB,cAApB,GAAIoG,CAAAC,MAAJ,EAAsD,gBAAtD,GAAsCD,CAAAC,MAAtC,CACE,MAAOD,EAGRD,EAAA,CAAkBC,CAAlB,CAAD,CAA2J,IAAK,EAAhK,CAAwIhF,CAAA,CAAU,CAAA,CAAV,CACvIgF,EAAAouB,sBAAD,CAA4K,IAAK,EAAjL,CAAyJpzB,CAAA,CAAU,CAAA,CAAV,CACrJ8zB,EAAAA,CAAava,CAAA1D,QAAA+R,UAEjB,IAAInB,CAAA,CAAQzhB,CAAA7D,SAAAqH,OAAA8C,QAAR,CAAuCwoB,CAAvC,CAAJ,CACE,MAAOluB,EAAA,CAAwBZ,CAAxB,CAGL+uB,EAAAA,CAAY3I,EAAA,CAAepmB,CAAA7D,SAAf,CAA+B2yB,CAA/B,CAEhB,OA/N4B,MA+N5B,GAAe9uB,CA/NVc,aA+NL,CACSsrB,EAAA,CAAY,CACjBpsB,MAAOA,CADU,CAEjB7D,SAAU4yB,CAFO,CAAZ,CADT,CAOO9tB,EAAA,CAAO,CACZjB,MAAOA,CADK,CAEZ7D,SAAU4yB,CAFE,CAAP,CAtBoC,CA4B7C,GAAoB,4BAApB,GAAIxa,CAAA3a,KAAJ,CAAkD,CAChD,GAAI,CAACmG,CAAA,CAAkBC,CAAlB,CAAL,CACE,MAAOA,EAGL6Z,EAAAA,CAAYtF,CAAA1D,QAAAgJ,UAEhB,IAAI4H,CAAA,CAAQ5H,CAAR,CAAmB7Z,CAAA7D,SAAAqH,OAAA2W,IAAnB,CAAJ,CACE,MAAOna,EAGLgvB;CAAAA,CAAgBz0B,CAAA,CAAS,EAAT,CAAayF,CAAA7D,SAAb,CAA6B,CAC/CqH,OAAQjJ,CAAA,CAAS,EAAT,CAAayF,CAAA7D,SAAAqH,OAAb,CAAoC,CAC1C2W,IAAKN,CADqC,CAApC,CADuC,CAA7B,CAMpB,OAAOtf,EAAA,CAAS,CACd0F,MAAO,UADO,CAAT,CAEJD,CAFI,CAEG,CACR7D,SAAU6yB,CADF,CAFH,CAjByC,CAwBlD,GAAoB,SAApB,GAAIza,CAAA3a,KAAJ,EAAiD,WAAjD,GAAiC2a,CAAA3a,KAAjC,EAAgF,WAAhF,GAAgE2a,CAAA3a,KAAhE,EAA+G,YAA/G,GAA+F2a,CAAA3a,KAA/F,CAA6H,CAC3H,GAAoB,YAApB,GAAIoG,CAAAC,MAAJ,EAAoD,cAApD,GAAoCD,CAAAC,MAApC,CACE,MAAOD,EAGS,WAAlB,GAAEA,CAAAC,MAAF,CAAkJjF,CAAA,CAAU,CAAA,CAAV,CAAlJ,CAAqK,IAAK,EAO1K,OAAA,CALIi0B,CAKJ,CALejF,EAAA,CAAgB,CAC7BhqB,MAAOA,CADsB,CAE7BpG,KAAM2a,CAAA3a,KAFuB,CAAhB,CAKf,EAIOqH,EAAA,CAAO,CACZjB,MAAOA,CADK,CAEZrE,OAAQszB,CAAAtzB,OAFI,CAGZ6V,gBAAiByd,CAAAzd,gBAHL,CAIZzQ,kBAAmBkuB,CAAAluB,kBAJP,CAAP,CAJP,CACSf,CAbkH,CAwB7H,MAAoB,cAApB,GAAIuU,CAAA3a,KAAJ,EAGMsN,CAGWgoB,CAHF3a,CAAA1D,QAAA3J,OAGEgoB,CAFG,YAAlB,GAAElvB,CAAAC,MAAF;AAAoKjF,CAAA,CAAU,CAAA,CAAV,CAApK,CAAuL,IAAK,EAE7Kk0B,CAAA30B,CAAA20B,CAAS,CACtBjvB,MAAO,cADe,CAATivB,CAEZlvB,CAFYkvB,EAEJ/B,CAAA,CAAY,EAAZ,CAAgBA,CAAA,MAAhB,CAAqC,cAArC,CAAqDA,CAAAW,UAArD,CAA2E,CAAA,CAA3E,CAAiFX,CAAAjmB,OAAjF,CAAoGA,CAApG,CAA4GimB,CAFxG+B,EANjB,EAaoB,cAApB,GAAI3a,CAAA3a,KAAJ,EACMu1B,CAKWC,CALQ7a,CAAA1D,QAKRue,CAJXljB,CAIWkjB,CAJCD,CAAAjjB,UAIDkjB,CAHX/R,CAGW+R,CAHID,CAAA9R,aAGJ+R,CAFX3R,CAEW2R,CAFWD,CAAA1R,oBAEX2R,CADG,UAAlB,GAAEpvB,CAAAC,MAAF,EAAgD,cAAhD,GAAgCD,CAAAC,MAAhC,CAA8KjF,CAAA,CAAU,CAAA,CAAV,CAA9K,CAAiM,IAAK,EACvLo0B,CAAAA,CACbnvB,MAAO,gBADMmvB,CAEbljB,UAAWA,CAFEkjB,CAGb/R,aAAcA,CAHD+R,CAIb3R,oBAAqBA,CAJR2R,CAKbtS,WAAY9c,CAAA8c,WALCsS,CANjB,EAgBoB,eAApB,GAAI7a,CAAA3a,KAAJ,CAES,CACLqG,MAAO,MADF,CAELiM,UAHeqI,CAAA1D,QAAA3E,UACV,CAGLgiB,YAAa,CAAA,CAHR,CAFT,CASOluB,CA9R+B,CA19ExC,CAuwFI2U,GAAuBA,QAA6B,CAAC9W,CAAD,CAAO,CAC7D,MAAO,CACLjE,KAAM,wBADD,CAELiX,QAAShT,CAFJ,CADsD,CAvwF/D;AA6wFI4E,GAAqBA,QAA2B,EAAG,CACrD,MAAO,CACL7I,KAAM,qBADD,CAELiX,QAAS,IAFJ,CAD8C,CA7wFvD,CAmxFI+D,GAAwBA,QAA8B,CAAC/W,CAAD,CAAO,CAC/D,MAAO,CACLjE,KAAM,yBADD,CAELiX,QAAShT,CAFJ,CADwD,CAnxFjE,CAyxFIgX,GAA2BA,QAAiC,CAAChX,CAAD,CAAO,CACrE,MAAO,CACLjE,KAAM,6BADD,CAELiX,QAAShT,CAFJ,CAD8D,CAzxFvE,CA+xFIiX,GAAkCA,QAAwC,CAACjX,CAAD,CAAO,CACnF,MAAO,CACLjE,KAAM,qCADD,CAELiX,QAAShT,CAFJ,CAD4E,CA/xFrF,CAqyFI8O,GAAOA,QAAa,CAAC9O,CAAD,CAAO,CAC7B,MAAO,CACLjE,KAAM,MADD,CAELiX,QAAShT,CAFJ,CADsB,CAryF/B,CAuzFIiQ,GAASA,QAAe,EAAG,CAC7B,MAAO,CACLlU,KAAM,SADD,CAELiX,QAAS,IAFJ,CADsB,CAvzF/B,CA6zFIjD,GAAWA,QAAiB,EAAG,CACjC,MAAO,CACLhU,KAAM,WADD,CAELiX,QAAS,IAFJ,CAD0B,CA7zFnC,CAm0FI7C,GAAYA,QAAkB,EAAG,CACnC,MAAO,CACLpU,KAAM,YADD,CAELiX,QAAS,IAFJ,CAD4B,CAn0FrC,CAy0FI3C,GAAWA,QAAiB,EAAG,CACjC,MAAO,CACLtU,KAAM,WADD;AAELiX,QAAS,IAFJ,CAD0B,CAz0FnC,CA21FIwe,GAAeA,QAAqB,CAACxxB,CAAD,CAAO,CAC7C,MAAO,CACLjE,KAAM,eADD,CAELiX,QAAShT,CAFJ,CADsC,CA31F/C,CA62FIyxB,GAAwBA,QAA8B,EAAG,CAC3D,MAAO,CACL11B,KAAM,yBADD,CAELiX,QAAS,IAFJ,CADoD,CA72F7D,CAy5FIL,GAAUA,QAAS,CAACrJ,CAAD,CAAU,CAC/B,MAAO,SAAS,CAAClL,CAAD,CAAO,CAAA,IACjBmU,EAAWnU,CAAAmU,SADM,CAEjBQ,EAAW3U,CAAA2U,SACf,OAAO,SAAS,CAAC2e,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CACvB,GAAoB,MAApB,GAAIA,CAAA3a,KAAJ,CACE21B,CAAA,CAAKhb,CAAL,CADF,KAAA,CADuB,IAMnB4Z,EAAkB5Z,CAAA1D,QANC,CAOnBrT,EAAK2wB,CAAA3wB,GACLgU,EAAAA,CAAkB2c,CAAA3c,gBAClB1Q,EAAAA,CAAeqtB,CAAArtB,aACnB,KAAIoZ,EAAU9J,CAAA,EAEQ,iBAAtB,GAAI8J,CAAAja,MAAJ,EACE2Q,CAAA,CAASye,EAAA,CAAa,CACpBnjB,UAAWgO,CAAAhO,UADS,CAAb,CAAT,CAKqB,OAAvB,GAAEkE,CAAA,EAAAnQ,MAAF,CAAgIjF,CAAA,CAAU,CAAA,CAAV,CAAhI,CAAmJ,IAAK,EACxJ4V,EAAA,CAjGC,CACLhX,KAAM,OADD,CAELiX,QAAS,IAFJ,CAiGD,CASI2e,EAAAA,CAAwBroB,CAAAsoB,gBAAA,CALdC,CACZnxB,YAAaf,CADDkyB,CAEZzX,cALkBA,CAClBC,yBAA2C,MAA3CA;AAA0BpX,CADRmX,CAGNyX,CAKc,CAM5B9e,EAAA,CA9LC,CACLhX,KAAM,iBADD,CAELiX,QA4L4BhT,CACtBgf,SANa2S,CAAA3S,SAKShf,CAEtBif,WANe0S,CAAA1S,WAIOjf,CAGtB2T,gBAAiBA,CAHK3T,CAItBiD,aAAcA,CAJQjD,CAKtB1B,SARaqzB,CAAArzB,SAGS0B,CA9LvB,CA8LD,CAjCA,CADuB,CADJ,CAHF,CADQ,CAz5FjC,CA48FIkN,GAASA,QAAS,CAAC5D,CAAD,CAAU,CAC9B,MAAO,SAAS,EAAG,CACjB,MAAO,SAAS,CAACooB,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CACH,iBAApB,GAAIA,CAAA3a,KAAJ,EACEuN,CAAAjD,SAAA,EAGkB,eAApB,GAAIqQ,CAAA3a,KAAJ,EACEuN,CAAAF,SAAA,CAAiBsN,CAAA1D,QAAA3E,UAAAtI,OAAAsD,OAAjB,CAGkB,QAApB,GAAIqN,CAAA3a,KAAJ,EAA+C,eAA/C,GAA+B2a,CAAA3a,KAA/B,EACEuN,CAAAlC,QAAA,EAGFsqB,EAAA,CAAKhb,CAAL,CAbuB,CADJ,CADN,CADW,CA58FhC,CAk+FIgJ,GAAS,CACXhY,YAAa,4BADF,CAEX0H,KAAM,yBAFK,CAl+Fb,CAs+FIlR,GAAU,CACZ2hB,QAAS,CACPzQ,KAAM,CADC,CAEP0iB,UAAW,EAFJ,CADG;AAKZhS,MAAO,CACL1Q,KAAM,GADD,CALK,CAt+Fd,CAo/FI2iB,GAAoB,OAApBA,CAAiDrS,EAAAhY,YAp/FrD,CAq/FID,GAAc,CAChBuqB,MAAO,UAAPA,CAAoBD,EADJ,CAEhBE,KAAM,YAANA,CAAqBF,EAArBE,CAAyC,YAAzCA,CAAwDF,EAFxC,CAGhB3iB,KAAMA,QAAa,CAACmQ,CAAD,CAAW,CACxB2S,CAAAA,CAAS3S,CAAT2S,CAAoB,IAApBA,CAA2BxS,EAAAtQ,KAC/B,OAAO,YAAP,CAAsB8iB,CAAtB,CAA+B,YAA/B,CAA8CA,CAFlB,CAHd,CAOhBxqB,YAAa,YAAbA,CAA4BqqB,EAPZ,CAQhBnU,YAAa,SAAbA,CAAyBmU,EAAzBnU,CAA6C,UAA7CA,CAA0DmU,EAA1DnU,CAA8E,WAA9EA,CAA4FmU,EAR5E,CAr/FlB,CAggGIpS,GAASA,QAAe,CAACf,CAAD,CAAS,CACnC,MAAOgF,EAAA,CAAQhF,CAAR,CAAgBtZ,EAAhB,CAAA,CAA0B,IAA1B,CAAiC,YAAjC,CAAgDsZ,CAAAlf,EAAhD,CAA2D,MAA3D,CAAoEkf,CAAAtf,EAApE,CAA+E,KADnD,CAhgGrC,CAogGI6yB,GAAa,CACfxS,OAAQA,EADO,CAEfvQ,KAAMA,QAAa,CAACwP,CAAD,CAASwT,CAAT,CAAsB,CAGvC,MAAA,CAFIC,CAEJ,CAFgB1S,EAAA,CAAOf,CAAP,CAEhB,EAIKwT,CAAL,CAIOC,CAJP,CAImB,SAJnB,CAI+Bn0B,EAAA4hB,MAAA1Q,KAJ/B,CAIoD,GAJpD,CACSijB,CALT,CACS,IAJ8B,CAF1B,CApgGjB,CAuhGIC,GArCWC,GAqCXD,CAtCWE,GAj/Ff,CA4mGI1a,GAAUA,QAAS,CAAC1Z,CAAD,CAAO,CAAA,IACxBmU,EAAWnU,CAAAmU,SADa,CAExBQ,EAAW3U,CAAA2U,SACf,OAAO,SAAS,CAAC2e,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CACvB,GAAoB,MAApB;AAAIA,CAAA3a,KAAJ,CACE21B,CAAA,CAAKhb,CAAL,CADF,KAAA,CAKA,IAAIvU,EAAQoQ,CAAA,EACRlJ,EAAAA,CAASqN,CAAA1D,QAAA3J,OAEb,IAAoB,YAApB,GAAIlH,CAAAC,MAAJ,CACE2Q,CAAA,CAlRC,CACLhX,KAAM,cADD,CAELiX,QAgRyBhT,CACnBqJ,OAAQA,CADWrJ,CAlRpB,CAkRD,CADF,KAOA,IAAoB,MAApB,GAAImC,CAAAC,MAAJ,CAAA,CAIuC,cACvC,GADuBD,CAAAC,MACvB,EADyDD,CAAA8tB,UACzD,CAA+I9yB,CAAA,CAAU,CAAA,CAAV,CAA/I,CAAkK,IAAK,EACrJ,WAAlB,GAAEgF,CAAAC,MAAF,EAAgD,cAAhD,GAAgCD,CAAAC,MAAhC,CAAqKjF,CAAA,CAAU,CAAA,CAAV,CAArK,CAAwL,IAAK,EAC7L,KAAI6hB,EAAW7c,CAAA6c,SAAf,CACIC,EAAa9c,CAAA8c,WADjB,CAEIpgB,EAAYogB,CAAAhd,WAAA,CAAsBE,CAAA6c,SAAAngB,UAAAc,GAAtB,CAnEhBsC,KAAAA,EA4EcE,CAAA8c,WAAAhd,WA1EdwwB,KAAAA,EAqEctwB,CAAArE,OAxEiB,KAI/BwI,EAuEQnE,CAAA8c,WAAArT,WAAAtF,CAA4BnE,CAAA6c,SAAApZ,UAAAjG,GAA5B2G,CA3EuB,CAK/BhI,EAuEY6D,CAAA7D,SA5EmB,CAM/BwxB,EAoEgB3tB,CAAA2tB,aAlEf2C,EAAA10B,GAAL,EAAiC,MAAjC,GA+DcsL,CA/Dd,EAeE,CAAA,CADyB,SAA3B,GAAIopB,CAAA10B,GAAAhC,KAAJ,CAEY02B,CAFZ,CAOsB/1B,CAAAg2B,CAAS,EAATA;AAAaD,CAAbC,CAAyB,CAC7C3xB,UAAWC,EADkC,CAAzB0xB,CANpB,CAAA,CAAA,CAE0B,CAAA,CAjB5B,GAQE,CAAA,CAP2BrE,EAAAsE,CAAU,CACnC1wB,WAAYA,CADuB,CAEnCnE,OAAQgyB,CAF2B,CAGnC9xB,YAAasI,CAHsB,CAInChI,SAAUA,CAJyB,CAKnCC,mBAAoB,CAAA,CALe,CAAVo0B,CAO3B,CAAA,CAAA,CAE0B,CAAA,CAV5B,CA0EQ30B,EAAAA,CAAc,CAFd40B,CAEc,CAFWA,CAEX,EAAyB/0B,CAAA,CAAkBC,CAAlB,CAAzB,CAAqD,IACnEI,EAAAA,CAAU00B,CAAA,CAAyB30B,CAAA,CAAcH,CAAd,CAAzB,CAAiD,IAK3DiI,EAAAA,CAAS,CACXrF,YAAa7B,CAAAe,WAAAD,GADF,CAEX5D,KAAM8C,CAAAe,WAAA7D,KAFK,CAGXonB,OAPWA,CACXvlB,MAAOohB,CAAAngB,UAAAjB,MADIulB,CAEXliB,YAAa+d,CAAApZ,UAAAjG,GAFFwjB,CAIA,CAIX9Z,OAAQA,CAJG,CAKX9C,KAAMpE,CAAAc,aALK,CAMXjF,YAAaA,CANF,CAOXE,QAASA,CAPE,CA3GbI,EAAAA,CAwHY6D,CAAA7D,SAvHZ+hB,EAAAA,CAwHiBle,CAAAke,cAvHjBpe,EAAAA,CAqHcgd,CArHDhd,WACb2J,EAAAA,CAoHcqT,CApHDrT,WACb3K,EAAAA,CAAcie,EAAA,CAiHJphB,CAjHI,CAElB,KAAIwI,EAAOsF,CAAA,CAgHM/M,CAhHKe,WAAAqB,YAAX,CACP4xB,EAAAA,CAAkBvE,EAAA,CAAyB,CAC7CxwB,OA6GYA,CA9GiC,CAE7Ce,UA6GeA,CA/G8B,CAG7CoD,WAAYA,CAHiC,CAI7Coe,cAAeA,CAJ8B,CAK7Cza,WAPgB3E,CAAAjD,CAAc4N,CAAA,CAAW3K,CAAX,CAAdjD,CAAwC,IAOxD4H,GAA0BU,CALmB,CAM7ChI,SAAUA,CANmC,CAAzB,CAStB;CAAA,CADaqlB,EAAA/E,CAASiU,CAATjU,CAuGI/f,CAvGsBgV,OAAAyH,UAAArH,OAA1B2K,CA4GLvQ,EAAAA,CAAY,CACd2Q,SAAU7c,CAAA6c,SADI,CAEdqB,cAAele,CAAAke,cAFD,CAGdta,OAAQA,CAHM,CAIdjI,OAAQA,CAJM,CAMW8lB,EAAA,CAAQzhB,CAAAsG,QAAAoL,OAAA+K,OAAR,CAAqCgB,CAArC,CAE3B,EAFgG1hB,CAAA6H,CAAA7H,QAEhG,CACE6U,CAAA,CAASye,EAAA,CAAa,CACpBnjB,UAAWA,CADS,CAAb,CAAT,CADF,EAvJAykB,CAwKA,CAxKa9O,EAAA,CA+JF7hB,CAAAsG,QAAAoL,OAAA+K,OA/JE,CAgKEgB,CAhKF,CAwKb,CAtKc,CAAlB,EAAIkT,CAAJ,CACE,CADF,CA/CaN,GA+Cb,CAR0BO,IAY1B,EAAID,CAAJ,CACE,CADF,CAlDaP,GAkDb,EAKIhT,CAEJ,CA1DaiT,GA0Db,CAHiBM,CAGjB,CAnB0BC,IAmB1B,CAF6BT,EAE7B,CAAA,CAAA,CAAOU,MAAA,CAAOC,CADgB,QAAXC,GAqJL7pB,CArJK6pB,CAjBIC,EAiBJD,CAAsB3T,CAAtB2T,CAAsD3T,CAC3D0T,SAAA,CAAqB,CAArB,CAAP,CAPP,CAkKI,CAAAlgB,CAAA,CAhXG,CACLhX,KAAM,cADD,CAELiX,QAyWahT,CACT4f,oBAAqBA,CADZ5f,CAETwf,aAAcA,CAFLxf,CAGTqO,UAAWA,CAHFrO,CA3WR,CAgXH,CAjBA,CArDA,CAfA,CADuB,CADJ,CAHK,CA5mG9B,CAywGImY,GAAkBA,QAAS,CAAChG,CAAD,CAAQ,CACrC,IAAIihB,EAAW1vB,EAAA,CAAkB,CAC/BE,eAAgBA,QAAuB,CAACmhB,CAAD,CAAY,CACjD5S,CAAAY,SAAA,CAheG,CACLhX,KAAM,uBADD,CAELiX,QA8doChT,CAChC+kB,UAAWA,CADqB/kB,CAhe/B,CAgeH,CADiD,CADpB,CAAlB,CAOf,OAAO,SAAS,CAAC0xB,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CAClB0c,CAAAzvB,SAAA,EAAL;AAA4C,iBAA5C,GAA4B+S,CAAA3a,KAA5B,EACEq3B,CAAAlvB,MAAA,EAGE,EAAAkvB,CAAAzvB,SAAA,EAAJ,EAjBmB,eAiBnB,GAAqC+S,CAjBlC3a,KAiBH,EAjBsD,cAiBtD,GAAqC2a,CAjBC3a,KAiBtC,EAjBwF,OAiBxF,GAAqC2a,CAjBmC3a,KAiBxE,EACEq3B,CAAAjvB,KAAA,EAGFutB,EAAA,CAAKhb,CAAL,CATuB,CADJ,CARc,CAzwGvC,CAgyGI2c,GAAuBA,QAAS,CAAC9lB,CAAD,CAAW,CAC7C,IAAI+lB,EAAY,CAAA,CAAhB,CACIC,EAAY,CAAA,CADhB,CAEIC,EAAYnmB,UAAA,CAAW,QAAS,EAAG,CACrCkmB,CAAA,CAAY,CAAA,CADyB,CAAvB,CAFhB,CAMIxtB,EAASA,QAAe,CAAC/J,CAAD,CAAU,CAChCs3B,CAAJ,CACmH,IAAK,EADxH,CAKIC,CAAJ,CAC2K,IAAK,EADhL,EAKAD,CAEA,CAFY,CAAA,CAEZ,CADA/lB,CAAA,CAASvR,CAAT,CACA,CAAAy3B,YAAA,CAAaD,CAAb,CAPA,CANoC,CAgBtCztB,EAAAutB,UAAA,CAAmBI,QAAS,EAAG,CAC7B,MAAOJ,EADsB,CAI/B,OAAOvtB,EA3BsC,CAhyG/C,CA8zGI4tB,GAAmBA,QAAS,EAAG,CACjC,IAAIhpB,EAAU,EAAd,CAEIipB,EAAUA,QAAgB,CAACC,CAAD,CAAU,CACtC,IAAIj2B,EAAQN,CAAA,CAAUqN,CAAV,CAAmB,QAAS,CAACpJ,CAAD,CAAO,CAC7C,MAAOA,EAAAsyB,QAAP,GAAwBA,CADqB,CAAnC,CAGC,GAAb,GAAEj2B,CAAF,CAAqGT,CAAA,CAAU,CAAA,CAAV,CAArG,CAAwH,IAAK,EAEvGwN,EAAA+B,OAAAonB,CAAel2B,CAAfk2B,CAAsB,CAAtBA,CACVjuB,CAAgB,CAAhBA,CAEZkuB,SAAA,EATsC,CAoCxC,OAAO,CACL9tB,IAzBQA,QAAY,CAACpJ,CAAD,CAAK,CACzB,IAAIg3B,EAAUxmB,UAAA,CAAW,QAAS,EAAG,CACnC,MAAOumB,EAAA,CAAQC,CAAR,CAD4B,CAAvB,CAOdlpB,EAAA7K,KAAA,CAJY+F,CACVguB,QAASA,CADChuB;AAEVkuB,SAAUl3B,CAFAgJ,CAIZ,CARyB,CAwBpB,CAELmuB,MAfUA,QAAc,EAAG,CAC3B,GAAKrpB,CAAAjN,OAAL,CAAA,CAIA,IAAIu2B,EAAU,EAAArf,OAAA,CAAUjK,CAAV,CACdA,EAAAjN,OAAA,CAAiB,CACjBu2B,EAAAh3B,QAAA,CAAgB,QAAS,CAAC4I,CAAD,CAAQ,CAC/B4tB,YAAA,CAAa5tB,CAAAguB,QAAb,CACAhuB,EAAAkuB,SAAA,EAF+B,CAAjC,CANA,CAD2B,CAatB,CAvC0B,CA9zGnC,CA22GIG,GAAoBA,QAA0B,CAACtJ,CAAD,CAAQC,CAAR,CAAgB,CAChE,MAAa,KAAb,EAAID,CAAJ,EAA+B,IAA/B,EAAqBC,CAArB,CACS,CAAA,CADT,CAIa,IAAb,EAAID,CAAJ,EAA+B,IAA/B,EAAqBC,CAArB,CACS,CAAA,CADT,CAIOD,CAAA3pB,YAJP,GAI6B4pB,CAAA5pB,YAJ7B,EAImD2pB,CAAAhtB,MAJnD,GAImEitB,CAAAjtB,MATH,CA32GlE,CAs3GIu2B,GAAiBA,QAAuB,CAACvJ,CAAD,CAAQC,CAAR,CAAgB,CAC1D,MAAa,KAAb,EAAID,CAAJ,EAA+B,IAA/B,EAAqBC,CAArB,CACS,CAAA,CADT,CAIa,IAAb,EAAID,CAAJ,EAA+B,IAA/B,EAAqBC,CAArB,CACS,CAAA,CADT,CAIOD,CAAAlqB,YAJP,GAI6BmqB,CAAAnqB,YAJ7B,EAImDkqB,CAAA3pB,YAJnD,GAIyE4pB,CAAA5pB,YATf,CAt3G5D,CAi4GImzB,GAAkBA,QAAwB,CAACxJ,CAAD,CAAQC,CAAR,CAAgB,CAC5D,GAAID,CAAJ,GAAcC,CAAd,CACE,MAAO,CAAA,CAIT,KAAIwJ,EAAmBzJ,CAAAhlB,UAAAjG,GAAnB00B,GAA0CxJ,CAAAjlB,UAAAjG,GAA1C00B,EAAiEzJ,CAAAhlB,UAAA7J,KAAjEs4B,GAA0FxJ,CAAAjlB,UAAA7J,KAC9F,OAFuB6uB,EAAA/rB,UAAAc,GAEvB;AAF8CkrB,CAAAhsB,UAAAc,GAE9C,EAFqEirB,CAAA/rB,UAAAoC,YAErE,GAFqG4pB,CAAAhsB,UAAAoC,YAErG,EAFqI2pB,CAAA/rB,UAAA9C,KAErI,GAF8J8uB,CAAAhsB,UAAA9C,KAE9J,EAFuL6uB,CAAA/rB,UAAAjB,MAEvL,GAFiNitB,CAAAhsB,UAAAjB,MAEjN,EAA2By2B,CAPiC,CAj4G9D,CA24GIC,GAAcA,QAAoB,CAACC,CAAD,CAAM13B,CAAN,CAAU,CAE9CA,CAAA,EAF8C,CA34GhD,CAi5GI23B,GAAeA,QAAqB,CAACxV,CAAD,CAAWzY,CAAX,CAAiB,CACvD,MAAO,CACL7F,YAAase,CAAAngB,UAAAc,GADR,CAEL5D,KAAMijB,CAAApZ,UAAA7J,KAFD,CAGLonB,OAAQ,CACNliB,YAAa+d,CAAApZ,UAAAjG,GADP,CAEN/B,MAAOohB,CAAAngB,UAAAjB,MAFD,CAHH,CAOL2I,KAAMA,CAPD,CADgD,CAj5GzD,CA65GIqtB,GAAUA,QAAgB,CAACa,CAAD,CAAYC,CAAZ,CAAkBnnB,CAAlB,CAA4BonB,CAA5B,CAA+C,CAC3E,GAAKF,CAAL,CAAA,CAKA,IAAIG,EAAavB,EAAA,CAAoB9lB,CAApB,CAIjBknB,EAAA,CAAUC,CAAV,CAHeG,CACbtnB,SAAUqnB,CADGC,CAGf,CAEKD,EAAAtB,UAAA,EAAL,EACE/lB,CAAA,CAASonB,CAAA,CAAkBD,CAAlB,CAAT,CAZF,CAAA,IACEnnB,EAAA,CAASonB,CAAA,CAAkBD,CAAlB,CAAT,CAFyE,CA75G7E,CA86GII,GAAgBA,QAAS,CAAC5e,CAAD,CAAgB3I,CAAhB,CAA0B,CACrD,IAAIwnB,EAAepB,EAAA,EAAnB,CACIttB,EAAW,IADf,CAyEI+I,EAAOA,QAAa,CAACrJ,CAAD,CAAS,CAC9BM,CAAD,CAAyJ,IAAK,EAA9J,CAAsIlJ,CAAA,CAAU,CAAA,CAAV,CACtIkJ,EAAA,CAAW,IACXiuB,GAAA,CAAY,WAAZ,CAAyB,QAAS,EAAG,CACnC,MAAOV,GAAA,CAAQ1d,CAAA,EAAAG,UAAR;AAAmCtQ,CAAnC,CAA2CwH,CAA3C,CAAqD8I,EAArD,CAD4B,CAArC,CAH+B,CAsBjC,OAAO,CACL2e,YA7FgBA,QAAoB,CAAChW,CAAD,CAAWzY,CAAX,CAAiB,CACnDF,CAAF,CAAoJlJ,CAAA,CAAU,CAAA,CAAV,CAApJ,CAAuK,IAAK,EAC5Km3B,GAAA,CAAY,mBAAZ,CAAiC,QAAS,EAAG,CAC3C,IAAIz3B,EAAKqZ,CAAA,EAAAC,kBAELtZ,EAAJ,EACEA,CAAA,CAAG23B,EAAA,CAAaxV,CAAb,CAAuBzY,CAAvB,CAAH,CAJyC,CAA7C,CAFqD,CA4FhD,CAELrC,MAnFUA,QAAc,CAAC8a,CAAD,CAAWzY,CAAX,CAAiB,CACvCF,CAAF,CAAoJlJ,CAAA,CAAU,CAAA,CAAV,CAApJ,CAAuK,IAAK,EAC5K,KAAIu3B,EAAOF,EAAA,CAAaxV,CAAb,CAAuBzY,CAAvB,CACXF,EAAA,CAAW,CACTE,KAAMA,CADG,CAET0uB,aAAcjW,CAFL,CAGTkW,aAAcR,CAAAvR,OAHL,CAITgS,YAAa,IAJJ,CAMXJ,EAAA9uB,IAAA,CAAiB,QAAS,EAAG,CAC3BquB,EAAA,CAAY,aAAZ,CAA2B,QAAS,EAAG,CACrC,MAAOV,GAAA,CAAQ1d,CAAA,EAAAE,YAAR,CAAqCse,CAArC,CAA2CnnB,CAA3C,CAAqD6I,EAArD,CAD8B,CAAvC,CAD2B,CAA7B,CATyC,CAiFpC,CAGLhT,OApEWA,QAAe,CAAC4b,CAAD,CAAWlhB,CAAX,CAAmB,CAC7C,IAAI0lB,EAAW3lB,CAAA,CAAkBC,CAAlB,CACXI,EAAAA,CAAUD,CAAA,CAAcH,CAAd,CACbuI,EAAD,CAAyJ,IAAK,EAA9J,CAAsIlJ,CAAA,CAAU,CAAA,CAAV,CACtI,KAAIi4B,EAAqB,CAAChB,EAAA,CAAgBpV,CAAhB,CAA0B3Y,CAAA4uB,aAA1B,CAEtBG,EAAJ,GACE/uB,CAAA4uB,aADF,CAC0BjW,CAD1B,CAIA,KAAIqW,EAAqB,CAACnB,EAAA,CAAkB7tB,CAAA6uB,aAAlB,CAAyC1R,CAAzC,CAEtB6R,EAAJ,GACEhvB,CAAA6uB,aADF,CAC0B1R,CAD1B,CAIA,KAAI8R,EAAqB,CAACnB,EAAA,CAAe9tB,CAAA8uB,YAAf;AAAqCj3B,CAArC,CAEtBo3B,EAAJ,GACEjvB,CAAA8uB,YADF,CACyBj3B,CADzB,CAIA,IAAKk3B,CAAL,EAA4BC,CAA5B,EAAmDC,CAAnD,CAAA,CAIA,IAAIZ,EAAOh4B,CAAA,CAAS,EAAT,CAAa83B,EAAA,CAAaxV,CAAb,CAAuB3Y,CAAAE,KAAvB,CAAb,CAAoD,CAC7DrI,QAASA,CADoD,CAE7DF,YAAawlB,CAFgD,CAApD,CAKXuR,EAAA9uB,IAAA,CAAiB,QAAS,EAAG,CAC3BquB,EAAA,CAAY,cAAZ,CAA4B,QAAS,EAAG,CACtC,MAAOV,GAAA,CAAQ1d,CAAA,EAAAI,aAAR,CAAsCoe,CAAtC,CAA4CnnB,CAA5C,CAAsD+I,EAAtD,CAD+B,CAAxC,CAD2B,CAA7B,CATA,CAtB6C,CAiExC,CAIL0d,MA/BUA,QAAc,EAAG,CAC1B3tB,CAAD,CAAsI,IAAK,EAA3I,CAAmHlJ,CAAA,CAAU,CAAA,CAAV,CACnH43B,EAAAf,MAAA,EAF2B,CA2BtB,CAKL5kB,KAAMA,CALD,CAMLkF,MApBUA,QAAc,EAAG,CAC3B,GAAKjO,CAAL,CAAA,CAIA,IAAIN,EAASrJ,CAAA,CAAS,EAAT,CAAa83B,EAAA,CAAanuB,CAAA4uB,aAAb,CAAoC5uB,CAAAE,KAApC,CAAb,CAAiE,CAC5ErI,QAAS,IADmE,CAE5EF,YAAa,IAF+D,CAG5EqL,OAAQ,QAHoE,CAAjE,CAMb+F,EAAA,CAAKrJ,CAAL,CAVA,CAD2B,CActB,CAhG8C,CA96GvD,CAwhHIqS,GAAcA,QAAS,CAAClC,CAAD,CAAgB3I,CAAhB,CAA0B,CACnD,IAAIgoB,EAAYT,EAAA,CAAa5e,CAAb,CAA4B3I,CAA5B,CAChB,OAAO,SAAS,CAAC4E,CAAD,CAAQ,CACtB,MAAO,SAAS,CAACuf,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CACvB,GAAoB,iBAApB,GAAIA,CAAA3a,KAAJ,CAAuC,CACrC,IAAIijB,EAAWtI,CAAA1D,QAAAgM,SACfuW,EAAAP,YAAA,CAAsBhW,CAAtB;AAAgCtI,CAAA1D,QAAA/P,aAAhC,CACAyuB,EAAA,CAAKhb,CAAL,CACA6e,EAAArxB,MAAA,CAAgB8a,CAAhB,CAA0BtI,CAAA1D,QAAA/P,aAA1B,CAJqC,CAAvC,IAQoB,eAApB,GAAIyT,CAAA3a,KAAJ,EACMgK,CAGJ,CAHa2Q,CAAA1D,QAAA3E,UAAAtI,OAGb,CAFAwvB,CAAAvB,MAAA,EAEA,CADAtC,CAAA,CAAKhb,CAAL,CACA,CAAA6e,CAAAnmB,KAAA,CAAerJ,CAAf,CAJF,GAQA2rB,CAAA,CAAKhb,CAAL,CAEA,CAAoB,OAApB,GAAIA,CAAA3a,KAAJ,CACEw5B,CAAAjhB,MAAA,EADF,EAKInS,CAEJ,CAFYgQ,CAAAI,SAAA,EAEZ,CAAoB,UAApB,GAAIpQ,CAAAC,MAAJ,EACEmzB,CAAAnyB,OAAA,CAAiBjB,CAAA6c,SAAjB,CAAiC7c,CAAArE,OAAjC,CARF,CAVA,CATuB,CADJ,CADD,CAF2B,CAxhHrD,CA8jHIia,GAAuBA,QAAS,CAAC5F,CAAD,CAAQ,CAC1C,MAAO,SAAS,CAACuf,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CACH,yBAApB,GAAIA,CAAA3a,KAAJ,CACE21B,CAAA,CAAKhb,CAAL,CADF,EAKIvU,CAEJ,CAFYgQ,CAAAI,SAAA,EAEZ,CADkB,gBAAlB,GAAEpQ,CAAAC,MAAF,CAA6JjF,CAAA,CAAU,CAAA,CAAV,CAA7J,CAAgL,IAAK,EACrL,CAAAgV,CAAAY,SAAA,CAAeye,EAAA,CAAa,CAC1BnjB,UAAWlM,CAAAkM,UADe,CAAb,CAAf,CAPA,CADuB,CADJ,CADmB,CA9jH5C,CA+kHI2J,GAA8BA,QAAS,CAAC7F,CAAD,CAAQ,CACjD,IAAIrV,EAAS,IAAb,CACI4H,EAAU,IAcd,OAAO,SAAS,CAACgtB,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CACvB,GAAoB,OAApB;AAAIA,CAAA3a,KAAJ,EAA+C,eAA/C,GAA+B2a,CAAA3a,KAA/B,EAAkF,yBAAlF,GAAkE2a,CAAA3a,KAAlE,CAbE2I,CAKJ,GAJEyB,oBAAA,CAAqBzB,CAArB,CACA,CAAAA,CAAA,CAAU,IAGZ,EAAI5H,CAAJ,GACEA,CAAA,EACA,CAAAA,CAAA,CAAS,IAFX,CAYE40B,EAAA,CAAKhb,CAAL,CAEA,IAAoB,cAApB,GAAIA,CAAA3a,KAAJ,CAAA,CAIA,IAAIS,EAAU,CACZI,UAAW,QADC,CAEZH,QAAS,CACP6G,QAAS,CAAA,CADF,CAEPD,QAAS,CAAA,CAFF,CAGPyP,KAAM,CAAA,CAHC,CAFG,CAOZjW,GAAI24B,QAA2B,EAAG,CAGZ,gBAApB,GAFYrjB,CAAAI,SAAApQ,EAERC,MAAJ,EACE+P,CAAAY,SAAA,CAAe0e,EAAA,EAAf,CAJ8B,CAPtB,CAed/sB,EAAA,CAAUG,qBAAA,CAAsB,QAAS,EAAG,CAC1CH,CAAA,CAAU,IACV5H,EAAA,CAASZ,CAAA,CAAWsH,MAAX,CAAmB,CAAChH,CAAD,CAAnB,CAFiC,CAAlC,CAnBV,CAPuB,CADJ,CAhB0B,CA/kHnD,CAkoHIqb,GAA2BA,QAAS,CAACvO,CAAD,CAAU,CAChD,MAAO,SAAS,EAAG,CACjB,MAAO,SAAS,CAACooB,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CACH,eAApB,GAAIA,CAAA3a,KAAJ,EAAuD,OAAvD,GAAuC2a,CAAA3a,KAAvC,EAAkF,cAAlF,GAAkE2a,CAAA3a,KAAlE,EACEuN,CAAAmsB,eAAA,EAGF/D;CAAA,CAAKhb,CAAL,CALuB,CADJ,CADN,CAD6B,CAloHlD,CAgpHIjM,GAASA,QAAS,CAACnB,CAAD,CAAU,CAC9B,IAAIosB,EAAa,CAAA,CACjB,OAAO,SAAS,EAAG,CACjB,MAAO,SAAS,CAAChE,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CACH,iBAApB,GAAIA,CAAA3a,KAAJ,EACE25B,CAGA,CAHa,CAAA,CAGb,CAFApsB,CAAA6B,eAAA,CAAuBuL,CAAA1D,QAAAgM,SAAAngB,UAAAc,GAAvB,CAEA,CADA+xB,CAAA,CAAKhb,CAAL,CACA,CAAApN,CAAA2B,wBAAA,EAJF,GAQAymB,CAAA,CAAKhb,CAAL,CAEA,CAAKgf,CAAL,GAIoB,OAApB,GAAIhf,CAAA3a,KAAJ,EACE25B,CACA,CADa,CAAA,CACb,CAAApsB,CAAA2B,wBAAA,EAFF,EAMoB,eANpB,GAMIyL,CAAA3a,KANJ,GAOE25B,CAOA,CAPa,CAAA,CAOb,CANI3vB,CAMJ,CANa2Q,CAAA1D,QAAA3E,UAAAtI,OAMb,CAJIA,CAAA7H,QAIJ,EAHEoL,CAAAyB,eAAA,CAAuBhF,CAAArF,YAAvB,CAA2CqF,CAAA7H,QAAAwC,YAA3C,CAGF,CAAA4I,CAAA2B,wBAAA,EAdF,CAJA,CAVA,CADuB,CADJ,CADN,CAFW,CAhpHhC,CA4rHIiN,GAAcA,QAAS,CAACd,CAAD,CAAe,CACxC,MAAO,SAAS,CAACjF,CAAD,CAAQ,CACtB,MAAO,SAAS,CAACuf,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CANN,eAOjB;AAAeA,CAPd3a,KAOD,EAPoD,cAOpD,GAAe2a,CAPqB3a,KAOpC,EAPsF,OAOtF,GAAe2a,CAPuD3a,KAOtE,EACEqb,CAAAjT,KAAA,EACA,CAAAutB,CAAA,CAAKhb,CAAL,CAFF,EAMoB,iBAApB,GAAIA,CAAA3a,KAAJ,EACE21B,CAAA,CAAKhb,CAAL,CAGA,CAFIvU,CAEJ,CAFYgQ,CAAAI,SAAA,EAEZ,CADkB,UAAlB,GAAEpQ,CAAAC,MAAF,CAAkJjF,CAAA,CAAU,CAAA,CAAV,CAAlJ,CAAqK,IAAK,EAC1K,CAAAia,CAAAlT,MAAA,CAAmB/B,CAAnB,CAJF,GAQAuvB,CAAA,CAAKhb,CAAL,CACA,CAAAU,CAAAzR,OAAA,CAAoBwM,CAAAI,SAAA,EAApB,CATA,CAPuB,CADJ,CADD,CADgB,CA5rH1C,CAqtHI0F,GAAeA,QAAS,CAAC9F,CAAD,CAAQ,CAClC,MAAO,SAAS,CAACuf,CAAD,CAAO,CACrB,MAAO,SAAS,CAAChb,CAAD,CAAS,CACvBgb,CAAA,CAAKhb,CAAL,CAEoB,yBAApB,GAAIA,CAAA3a,KAAJ,GAII45B,CAEJ,CAFsBxjB,CAAAI,SAAA,EAEtB,CAA8B,cAA9B,GAAIojB,CAAAvzB,MAAJ,GAIIuzB,CAAA1F,UAJJ,EAQA9d,CAAAY,SAAA,CAt4BG,CACLhX,KAAM,MADD,CAELiX,QAo4BsBhT,CAClBqJ,OAAQssB,CAAAtsB,OADUrJ,CAt4BjB,CAs4BH,CARA,CANA,CAHuB,CADJ,CADW,CArtHpC,CA+uHI2X,GAAyLf,EAAAgf,QA/uH7L,CA0vHInxB,GAAUA,QAAc,EAAG,CAC7B,MAAO,CACLU,UAAW,EADN,CAELJ,SAAU,EAFL,CAGLC,SAAU,EAHL,CADsB,CA1vH/B,CA01HIiX,GAAgBA,QAAS,CAAC7d,CAAD,CAAO,CAK9B4d,CAAAA,CAAY2H,EAAA,CAAS,CACvBjkB,EAJgBtB,CAAAmd,YAGO;AAEvBjc,EANiBlB,CAAAod,aAIM,CAAT,CAGb,CACD9b,EALUtB,CAAA+d,MAIT,CAED7c,EAPWlB,CAAA8d,OAKV,CAHa,CAWhB,OAJwB2Z,CACtBn2B,EAAGuP,IAAAqN,IAAA,CAAS,CAAT,CAAYN,CAAAtc,EAAZ,CADmBm2B,CAEtBv2B,EAAG2P,IAAAqN,IAAA,CAAS,CAAT,CAAYN,CAAA1c,EAAZ,CAFmBu2B,CAZU,CA11HpC,CA62HIC,GAAsBA,QAAS,EAAG,CACpC,IAAIC,EAAMtyB,QAAAuyB,gBACTD,EAAD,CAA6H,IAAK,EAAlI,CAA0G54B,CAAA,CAAU,CAAA,CAAV,CAC1G,OAAO44B,EAH6B,CA72HtC,CAm3HIE,GAAsBA,QAAS,EAAG,CACpC,IAAIF,EAAMD,EAAA,EAOV,OANgB7Z,GAAAD,CAAa,CAC3BR,aAAcua,CAAAva,aADa,CAE3BD,YAAawa,CAAAxa,YAFc,CAG3BY,MAAO4Z,CAAAG,YAHoB,CAI3Bha,OAAQ6Z,CAAAI,aAJmB,CAAbna,CAFoB,CAn3HtC,CA83HIoa,GAAeA,QAAS,EAAG,CAC7B,IAAIzwB,EAnrBG,CACLjG,EAAG8D,MAAAQ,YADE,CAEL1E,EAAGkE,MAAAS,YAFE,CAmrBP,CACI+X,EAAYia,EAAA,EADhB,CAEI72B,EAAMuG,CAAArG,EAFV,CAGIG,EAAOkG,CAAAjG,EAHX,CAIIq2B,EAAMD,EAAA,EAuBV,OAZex3B,CACbwD,MAPUhD,EAAAC,QAAA+C,CAAoB,CAC9B1C,IAAKA,CADyB,CAE9BK,KAAMA,CAFwB,CAG9BF,MALUE,CAKVF,CAPUw2B,CAAAG,YAIoB,CAI9B12B,OALWJ,CAKXI,CAPWu2B,CAAAI,aAGmB,CAApBr0B,CAMGxD,CAEbqH,OAAQ,CACN0W,QAAS1W,CADH,CAEN8C,QAAS9C,CAFH,CAGN2W,IAAKN,CAHC;AAINO,KAAM,CACJzQ,MAAOxG,EADH,CAEJ7E,aAAc6E,EAFV,CAJA,CAFKhH,CAhBc,CA93H/B,CA65HI+3B,GAAqBA,QAAS,CAACj4B,CAAD,CAAO,CAAA,IACnC4gB,EAAW5gB,CAAA4gB,SADwB,CAEnC5E,EAAgBhc,CAAAgc,cAFmB,CAGnC9V,EAAWlG,CAAAkG,SAGXhG,EAAAA,CAAW83B,EAAA,EACf,KAAI7b,EAAejc,CAAAqH,OAAA8C,QAAnB,CAEImD,EAAatH,CAAAsB,UAAAuG,aAAA,CADN6S,CAAApZ,UACsC7J,KAAhC,CAAAQ,IAAA,CAA+C,QAAS,CAACsJ,CAAD,CAAQ,CAC/E,MAAOA,EAAAtB,UAAA+V,2BAAA,CAA2CC,CAA3C,CAAyDH,CAAzD,CADwE,CAAhE,CAGbnY,EAAAA,CAAaqC,CAAAzF,UAAAsN,aAAA,CAAgC6S,CAAAngB,UAAA9C,KAAhC,CAAAQ,IAAA,CAA6D,QAAS,CAACsJ,CAAD,CAAQ,CAC7F,MAAOA,EAAAR,aAAA,CAAmBkV,CAAnB,CADsF,CAA9E,CAajB,OALaxU,CACXkZ,WANeA,CACfhd,WAAYkjB,EAAA,CAAeljB,CAAf,CADGgd,CAEfrT,WAAYsZ,EAAA,CAAetZ,CAAf,CAFGqT,CAKJlZ,CAEXiZ,SAAUA,CAFCjZ,CAGXzH,SAAUA,CAHCyH,CApB0B,CA75HzC,CA48HIoR,GAA0BA,QAAS,CAAC7S,CAAD,CAAWC,CAAX,CAAsB,CAC3D,IAAI+xB,EAAa,IAAjB,CACIf,EAAYlxB,CAAA,CAAgB,CAC9BE,UAAW,CACTyB,QAASzB,CAAAuS,qBADA,CAETlS,mBAAoBL,CAAAK,mBAFX,CADmB;AAK9BN,SAAUA,CALoB,CAAhB,CADhB,CAoEIiyB,EAAaA,QAAmB,CAAChzB,CAAD,CAAQ,CACzC+yB,CAAD,CAAwJ,IAAK,EAA7J,CAAqIn5B,CAAA,CAAU,CAAA,CAAV,CACrI,KAAIkJ,EAAWiwB,CAAAtX,SAAAngB,UAEI,WAAnB,GAAI0E,CAAAxH,KAAJ,EACMqK,EAAA,CAAoB9B,CAApB,CAA8B+B,CAA9B,CAAwC9C,CAAAuI,MAAxC,CADN,EAEIypB,CAAAtvB,IAAA,CAAc1C,CAAAuI,MAAd,CAIe,UAAnB,GAAIvI,CAAAxH,KAAJ,EACMqK,EAAA,CAAoB9B,CAApB,CAA8B+B,CAA9B,CAAwC9C,CAAAuI,MAAxC,CADN,EAEIypB,CAAArvB,OAAA,CAAiB3C,CAAAuI,MAAjB,CAZsC,CA6C5C,OARcxC,CACZ0N,yBAjG6BA,QAAiC,CAACrX,CAAD,CAAK0S,CAAL,CAAgB,CAC7E/N,CAAAsB,UAAAsG,OAAA,CAA0BvM,CAA1B,CAAD,CAAgM,IAAK,EAArM,CAA6KxC,CAAA,CAAU,CAAA,CAAV,CAExKm5B,EAAL,EAIA/xB,CAAAyS,yBAAA,CAAmC,CACjCrX,GAAIA,CAD6B,CAEjC0S,UAAWA,CAFsB,CAAnC,CAP8E,CAgGlE/I,CAEZ2N,gCArFoCA,QAAwC,CAACtX,CAAD,CAAKmb,CAAL,CAAuB,CAC9Fwb,CAAL,GAIChyB,CAAAsB,UAAAsG,OAAA,CAA0BvM,CAA1B,CAAD,CAAsM,IAAK,EAA3M,CAAmLxC,CAAA,CAAU,CAAA,CAAV,CACnL,CAAAoH,CAAA0S,gCAAA,CAA0C,CACxCtX,GAAIA,CADoC,CAExCmb,iBAAkBA,CAFsB,CAA1C,CALA,CADmG,CAmFvFxR,CAGZiO,gBA9DoBA,QAAwB,CAAC5X,CAAD,CAAK0d,CAAL,CAAa,CACpDiZ,CAAL,EAIAhyB,CAAAsB,UAAAR,QAAA,CAA2BzF,CAA3B,CAAA4E,UAAAoB,OAAA,CAAgD0X,CAAhD,CALyD,CA2D7C/T;AAIZyN,sBA3E0BA,QAA8B,CAACpX,CAAD,CAAKolB,CAAL,CAAgB,CACnEuR,CAAL,GAIChyB,CAAAsB,UAAAsG,OAAA,CAA0BvM,CAA1B,CAAD,CAA2L,IAAK,EAAhM,CAAwKxC,CAAA,CAAU,CAAA,CAAV,CACxK,CAAAoH,CAAAwS,sBAAA,CAAgC,CAC9BpX,GAAIA,CAD0B,CAE9BolB,UAAWA,CAFmB,CAAhC,CALA,CADwE,CAuE5Dzb,CAKZsoB,gBAzBoBA,QAAwB,CAACC,CAAD,CAAU,CACpDyE,CAAF,CAAyJn5B,CAAA,CAAU,CAAA,CAAV,CAAzJ,CAA4K,IAAK,EACjL,KAAI0I,EAAQvB,CAAAzF,UAAAuG,QAAA,CAA2BysB,CAAAnxB,YAA3B,CAAZ,CACI4F,EAAOhC,CAAAsB,UAAAR,QAAA,CAA2BS,CAAAjG,WAAAqB,YAA3B,CACP+d,EAAAA,CAAW,CACbngB,UAAWgH,CAAAjG,WADE,CAEbgG,UAAWU,CAAA1G,WAFE,CAIX6M,EAAAA,CAAcnI,CAAAkI,UAAA,CAAmB+pB,CAAnB,CAClBD,EAAA,CAAa,CACXtX,SAAUA,CADC,CAEXvS,YAAaA,CAFF,CAIb,OAAO4pB,GAAA,CAAkB,CACvBrX,SAAUA,CADa,CAEvB1a,SAAUA,CAFa,CAGvB8V,cAAeyX,CAAAzX,cAHQ,CAAlB,CAb+C,CAoB1C9Q,CAMZmsB,eAzDmBA,QAAuB,EAAG,CACxCa,CAAL,GAIAf,CAAApxB,KAAA,EAMA,CAJAG,CAAAsB,UAAAuG,aAAA,CADWmqB,CAAAtX,SAAApZ,UACqB7J,KAAhC,CAAAkB,QAAA,CAAmD,QAAS,CAAC4I,CAAD,CAAQ,CAClE,MAAOA,EAAAtB,UAAA4Y,YAAA,EAD2D,CAApE,CAIA;AADAmZ,CAAA7pB,YAAA,EACA,CAAA6pB,CAAA,CAAa,IAVb,CAD6C,CAmDjChtB,CA1G6C,CA58H7D,CAikIIgJ,GAAgBA,QAAS,CAACnQ,CAAD,CAAQxC,CAAR,CAAY,CACvC,MAAoB,MAApB,GAAIwC,CAAAC,MAAJ,CACS,CAAA,CADT,CAIoB,gBAIpB,GAJID,CAAAC,MAIJ,EAAID,CAAAkM,UAAAtI,OAAArF,YAAJ,GAA2Cf,CAA3C,CACS,CAAA,CADT,CAIyC,MAJzC,GAIOwC,CAAAkM,UAAAtI,OAAAsD,OAbgC,CAjkIzC,CAilIIiO,GAAgBA,QAAS,CAAC+F,CAAD,CAAS,CACpC7Z,MAAAgzB,SAAA,CAAgBnZ,CAAA3d,EAAhB,CAA0B2d,CAAA/d,EAA1B,CADoC,CAjlItC,CAqlIIm3B,GAA0BluB,EAAA,CAAW,QAAS,CAACqD,CAAD,CAAa,CAC7D,MAAOwZ,GAAA,CAAgBxZ,CAAhB,CAAAS,OAAA,CAAmC,QAAS,CAACzG,CAAD,CAAY,CAK7D,MAJKA,EAAAyM,UAIL,EAAKzM,CAAA9D,MAAL,CAIO,CAAA,CAJP,CACS,CAAA,CANoD,CAAxD,CADsD,CAAjC,CArlI9B,CAmmII40B,GAA6BA,QAAmC,CAACz2B,CAAD,CAAS2L,CAAT,CAAqB,CAKvF,MAJYjO,EAAAmvB,CAAK2J,EAAA,CAAwB7qB,CAAxB,CAALkhB,CAA0C,QAAS,CAAClnB,CAAD,CAAY,CACxEA,CAAA9D,MAAD,CAAmH,IAAK,EAAxH,CAAgG3E,CAAA,CAAU,CAAA,CAAV,CAChG,OAAOyvB,GAAA,CAAkBhnB,CAAA9D,MAAAsa,cAAlB,CAAA,CAAiDnc,CAAjD,CAFkE,CAA/D6sB,CAD2E,CAnmIzF,CA8nII6J,GAAS,CACXC,oBAAqB,GADV,CAEXC,sBAAuB,GAFZ,CAGXC,eAAgB,EAHL,CAIXC,KAAMA,QAAa,CAACC,CAAD,CAAa,CAC9B,MAAO/nB,KAAAiV,IAAA,CAAS8S,CAAT;AAAqB,CAArB,CADuB,CAJrB,CAOXC,kBAAmB,CACjBC,gBAAiB,IADA,CAEjBC,aAAc,GAFG,CAPR,CA9nIb,CAqpIIC,GAAiBA,QAAS,CAACh5B,CAAD,CAAO,CAAA,IAC/Bi5B,EAAej5B,CAAAi5B,aADgB,CAG/B5uB,EAAUrK,CAAAqK,QACV6uB,EAAAA,CAFal5B,CAAAm5B,WAEbD,CAAqBD,CAEzB,OAAc,EAAd,GAAIC,CAAJ,EAC+N,IAAK,EAC3N,CAAA,CAFT,GAKqB7uB,CALrB,CAK+B4uB,CAL/B,EAMkCC,CAZC,CArpIrC,CAuqIIE,GAAwBA,QAAS,CAACC,CAAD,CAAiBC,CAAjB,CAA6B,CAChE,GAAID,CAAJ,CAAqBC,CAAAC,mBAArB,CACE,MAAO,EAGT,IAAIF,CAAJ,EAAsBC,CAAAE,iBAAtB,CACE,MAAOjB,GAAAG,eAGT,IAAIW,CAAJ,GAAuBC,CAAAC,mBAAvB,CACE,MAZYE,EAeVC,EAAAA,CAAiCV,EAAA,CAAc,CACjDC,aAAcK,CAAAE,iBADmC,CAEjDL,WAAYG,CAAAC,mBAFqC,CAGjDlvB,QAASgvB,CAHwC,CAAd,CAMjC9xB,EAAAA,CAASgxB,EAAAG,eAATnxB,CAAiCgxB,EAAAI,KAAA,CADE,CACF,CADMe,CACN,CACrC,OAAO7oB,KAAA8oB,KAAA,CAAUpyB,CAAV,CApByD,CAvqIlE,CA8rIIwxB,GAAeR,EAAAM,kBAAAE,aA9rInB,CA+rIIa,GAASrB,EAAAM,kBAAAC,gBA/rIb;AAgsIIe,GAAqBA,QAAS,CAACC,CAAD,CAAiBC,CAAjB,CAAgC,CAM5DC,CAAAA,CAFMhX,EAAA0M,EAENsK,CALeD,CAOnB,IAAIC,CAAJ,EAAeJ,EAAf,CACE,MAAOE,EAGT,IAAIE,CAAJ,CAAcjB,EAAd,CACE,MAxCYU,EA2CVQ,EAAAA,CAAyCjB,EAAA,CAAc,CACzDC,aAAcF,EAD2C,CAEzDI,WAhBeS,EAc0C,CAGzDvvB,QAAS2vB,CAHgD,CAAd,CAKhCF,EAATvyB,EAA0BgxB,EAAAI,KAAA,CAAYsB,CAAZ,CAC9B,OAAOppB,KAAA8oB,KAAA,CAAUpyB,CAAV,CAtByD,CAhsIlE,CAytII2yB,GAAYA,QAAS,CAACl6B,CAAD,CAAO,CAAA,IAG1B+5B,EAAgB/5B,CAAA+5B,cAHU,CAI1BI,EAAyBn6B,CAAAm6B,uBACzB5yB,EAAAA,CAAS6xB,EAAA,CAJQp5B,CAAAq5B,eAIR,CAHIr5B,CAAAs5B,WAGJ,CAEb,OAAe,EAAf,GAAI/xB,CAAJ,CACS,CADT,CAIK4yB,CAAL,CAIOtpB,IAAAqN,IAAA,CAAS2b,EAAA,CAAkBtyB,CAAlB,CAA0BwyB,CAA1B,CAAT,CAnEON,CAmEP,CAJP,CACSlyB,CAZqB,CAztIhC,CA2uII6yB,GAAmBA,QAAS,CAACp6B,CAAD,CAAO,CAAA,IACjCq6B,EAAYr6B,CAAAq6B,UADqB,CAEjCC,EAAkBt6B,CAAAs6B,gBAFe,CAGjCP,EAAgB/5B,CAAA+5B,cAHiB,CAIjC3b,EAAOpe,CAAAoe,KACP+b,EAAAA,CAAyBn6B,CAAAm6B,uBA9F7B,EAAA,CAJiBb,CACfC,mBAkGqCc,CArGd,CAqGyBjc,CArGfuK,KAAV,CAGvB4Q,CAH8ChB,EAAAC,oBAE/Bc,CAEfE,iBAiGqCa,CApGhB,CAoG2Bjc,CApGjBuK,KAAV,CAGrB6Q,CAH4CjB,EAAAE,sBAC7Ba,CAsGjB,OAFoBgB,EAAA,CAAgBlc,CAAAmI,IAAhB,CAEpB;AAFgD+T,CAAA,CAAgBlc,CAAAtY,MAAhB,CAEhD,CACSo0B,EAAA,CAAS,CACdb,eAAgBiB,CAAA,CAAgBlc,CAAAmI,IAAhB,CADF,CAEd+S,WAAYA,CAFE,CAGdS,cAAeA,CAHD,CAIdI,uBAAwBA,CAJV,CAAT,CADT,CASQ,EATR,CASYD,EAAA,CAAS,CACnBb,eAAgBiB,CAAA,CAAgBlc,CAAAtY,MAAhB,CADG,CAEnBwzB,WAAYA,CAFO,CAGnBS,cAAeA,CAHI,CAInBI,uBAAwBA,CAJL,CAAT,CAlByB,CA3uIvC,CA0xIII,GAAU7W,EAAA,CAAM,QAAS,CAAChW,CAAD,CAAQ,CACnC,MAAiB,EAAV,GAAAA,CAAA,CAAc,CAAd,CAAkBA,CADU,CAAvB,CA1xId,CA6xII8sB,GAAaA,QAAS,CAACx6B,CAAD,CAAO,CAAA,IAC3B+5B,EAAgB/5B,CAAA+5B,cADW,CAE3BM,EAAYr6B,CAAAq6B,UAFe,CAG3B9b,EAAUve,CAAAue,QAHiB,CAI3B1I,EAAS7V,CAAA6V,OACTskB,EAAAA,CAAyBn6B,CAAAm6B,uBAC7B,KAAIG,EAAkB,CACpBt5B,IAAK6U,CAAA3U,EAALF,CAAgBq5B,CAAAr5B,IADI,CAEpBG,MAAOk5B,CAAAl5B,MAAPA,CAAyB0U,CAAAvU,EAFL,CAGpBF,OAAQi5B,CAAAj5B,OAARA,CAA2ByU,CAAA3U,EAHP,CAIpBG,KAAMwU,CAAAvU,EAAND,CAAiBg5B,CAAAh5B,KAJG,CAMlBH,EAAAA,CAAIk5B,EAAA,CAAgB,CACtBC,UAAWA,CADW,CAEtBC,gBAAiBA,CAFK,CAGtBP,cAAeA,CAHO,CAItB3b,KAAMC,EAJgB,CAKtB8b,uBAAwBA,CALF,CAAhB,CAOJ74B,EAAAA,CAAI84B,EAAA,CAAgB,CACtBC,UAAWA,CADW;AAEtBC,gBAAiBA,CAFK,CAGtBP,cAAeA,CAHO,CAItB3b,KAAME,EAJgB,CAKtB6b,uBAAwBA,CALF,CAAhB,CAOJM,EAAAA,CAAWF,EAAA,CAAQ,CACrBj5B,EAAGA,CADkB,CAErBJ,EAAGA,CAFkB,CAAR,CAKf,IAAIskB,CAAA,CAAQiV,CAAR,CAAkBvzB,EAAlB,CAAJ,CACE,MAAO,KApDLwzB,EAAAA,CAyDOnc,CAzDcT,OAArB4c,CAwDSL,CAxD6Bvc,OAQxC,EAAA,CALF,CAFI6c,CAEJ,CAsDWpc,CAxDgBR,MAE3B,CAqDasc,CAvD8Btc,MAE3C,GAA8B2c,CAA9B,CAIIC,CAAJ,EAA4BD,CAA5B,CACS,IADT,CAIO,CACLp5B,EAAGq5B,CAAA,CAAuB,CAAvB,CA8CaF,CA9Ccn5B,EADzB,CAELJ,EAAGw5B,CAAA,CAAqB,CAArB,CA6CaD,CA7CYv5B,EAFvB,CARP,CAuDkBu5B,CAGlB,OAAKG,EAAL,CAIOpV,CAAA,CAAQoV,CAAR,CAAiB1zB,EAAjB,CAAA,CAA2B,IAA3B,CAAkC0zB,CAJzC,CACS,IA1CsB,CA7xIjC,CA60IIC,GAAiBnX,EAAA,CAAM,QAAS,CAAChW,CAAD,CAAQ,CAC1C,MAAc,EAAd,GAAIA,CAAJ,CACS,CADT,CAIe,CAAR,CAAAA,CAAA,CAAY,CAAZ,CAAiB,EALkB,CAAvB,CA70IrB,CAo1IIotB,GAAa,QAAS,EAAG,CAC3B,IAAIC,EAAeA,QAAqB,CAACl5B,CAAD,CAASqc,CAAT,CAAc,CACpD,MAAa,EAAb,CAAIrc,CAAJ,CACSA,CADT,CAIIA,CAAJ,CAAaqc,CAAb,CACSrc,CADT,CACkBqc,CADlB,CAIO,CAT6C,CAYtD,OAAO,SAAS,CAACle,CAAD,CAAO,CAAA,IAEjBke,EAAMle,CAAAke,IAEN8c,EAAAA,CAAenzB,CAAA,CAHL7H,CAAAqK,QAGK,CADNrK,CAAAif,OACM,CACfgc,EAAAA,CAAU,CACZ35B,EAAGy5B,CAAA,CAAaC,CAAA15B,EAAb,CAA6B4c,CAAA5c,EAA7B,CADS,CAEZJ,EAAG65B,CAAA,CAAaC,CAAA95B,EAAb,CAA6Bgd,CAAAhd,EAA7B,CAFS,CAKd,OAAIskB,EAAA,CAAQyV,CAAR,CAAiB/zB,EAAjB,CAAJ,CACS,IADT,CAIO+zB,CAdc,CAbI,CAAZ,EAp1IjB,CAk3IIC,GAAqBA,QAA2B,CAACl4B,CAAD,CAAQ,CAAA,IACtDm4B,EAASn4B,CAAAkb,IAD6C,CAEtD7T,EAAUrH,CAAAqH,QAEV6T,EAAAA,CAAM,CACR5c,EAAGuP,IAAAqN,IAAA,CAAS7T,CAAA/I,EAAT,CAAoB65B,CAAA75B,EAApB,CADK,CAERJ,EAAG2P,IAAAqN,IAAA,CAAS7T,CAAAnJ,EAAT;AAAoBi6B,CAAAj6B,EAApB,CAFK,CAINk6B,EAAAA,CAAiBP,EAAA,CALR73B,CAAAic,OAKQ,CACjBgc,EAAAA,CAAUH,EAAA,CAAW,CACvB5c,IAAKA,CADkB,CAEvB7T,QAASA,CAFc,CAGvB4U,OAAQmc,CAHe,CAAX,CAcd,OARI,CAACH,CAQL,EAJyB,CAIzB,GAJIG,CAAA95B,EAIJ,EAJ4C,CAI5C,GAJ8B25B,CAAA35B,EAI9B,EAAyB,CAAzB,GAAI85B,CAAAl6B,EAAJ,EAA4C,CAA5C,GAA8B+5B,CAAA/5B,EAA9B,CACS,CAAA,CADT,CAIO,CAAA,CA3BmD,CAl3I5D,CA+4IIm6B,GAAkBA,QAAwB,CAACn7B,CAAD,CAAW+e,CAAX,CAAmB,CAC/D,MAAOic,GAAA,CAAmB,CACxB7wB,QAASnK,CAAAqH,OAAA8C,QADe,CAExB6T,IAAKhe,CAAAqH,OAAA2W,IAFmB,CAGxBe,OAAQA,CAHgB,CAAnB,CADwD,CA/4IjE,CAm6IIqc,GAAqBA,QAA2B,CAAC9zB,CAAD,CAAYyX,CAAZ,CAAoB,CAGtE,MAAA,CAFIvb,CAEJ,CAFY8D,CAAA9D,MAEZ,EAIOw3B,EAAA,CAAmB,CACxB7wB,QAAS3G,CAAA6D,OAAA8C,QADe,CAExB6T,IAAKxa,CAAA6D,OAAA2W,IAFmB,CAGxBe,OAAQA,CAHgB,CAAnB,CAJP,CACS,CAAA,CAJ6D,CAn6IxE,CAw+IIsc,GAAYA,QAAS,CAACv7B,CAAD,CAAO,CAAA,IAC1B+D,EAAQ/D,CAAA+D,MADkB,CAE1Bg2B,EAAgB/5B,CAAA+5B,cAFU,CAG1BI,EAAyBn6B,CAAAm6B,uBAHC,CAI1BjhB,EAAelZ,CAAAkZ,aACfC,EAAAA,CAAkBnZ,CAAAmZ,gBACtB,KAAItD,EAAS9R,CAAAsG,QAAAxJ,KAAAstB,gBAAb,CAEI5P,EADYxa,CAAA8c,WAAAhd,WAAApD,CAA4BsD,CAAA6c,SAAAngB,UAAAc,GAA5Bd,CACFI,KAAAC,UAEd,IAAIiD,CAAAouB,sBAAJ,CAAiC,CA/C7BjyB,IAAAA;AAgDa6D,CAAA7D,SA3CjB,KAAIqH,EAASizB,EAAA,CAAU,CACrBT,cA6CiBA,CA9CI,CAErBM,UAAWn6B,CAAAwD,MAFU,CAGrB6a,QA6CWA,CAhDU,CAIrB1I,OA6CUA,CAjDW,CAKrBskB,uBA6C0BA,CAlDL,CAAV,CAqDX,IA9CF,CA8CE,CA9CK5yB,CAAA,EAAU8zB,EAAA,CAAgBn7B,CAAhB,CAA0BqH,CAA1B,CAAV,CAA8CA,CAA9C,CAAuD,IA8C5D,CAAa,CACX2R,CAAA,CAAasiB,CAAb,CACA,OAFW,CAXkB,CAmBlB,CAAA,CAAA1a,EAAA,CAAkB/c,CAAArE,OAAlB,CAvZX8N,EAAAA,CAwZUzJ,CAAA8c,WAAArT,WAzZI5N,EAGlB,EACMmhB,CAMJ,CANiBvT,CAAA,CAJD5N,CAIC,CAMjB,CAAA,CAAA,CAJKmhB,CAAArd,MAAL,CAIOqd,CAJP,CACS,IAJX,EAWA,CAXA,CAUgBuX,EAAA5Z,CA0YN7I,CA1YM6I,CAAmClR,CAAnCkR,CA+YXlX,EAAL,GAtDIA,CAkEJ,CANaA,CAMb,CAhDA,CAgDA,CA3DA,CAFI9D,CAEJ,CAFY8D,CAAA9D,MAEZ,EAWO,CAPH6D,CAOG,CAPMizB,EAAA,CAAU,CACrBT,cA+CeA,CAhDM,CAErBM,UAAW32B,CAAAsa,cAFU,CAGrBO,QA+CSA,CAlDY,CAIrB1I,OA+CQA,CAnDa,CAKrBskB,uBA+CwBA,CApDH,CAAV,CAON,GAAUmB,EAAA,CAAmB9zB,CAAnB,CAA8BD,CAA9B,CAAV,CAAkDA,CAAlD,CAA2D,IAXlE,CACS,IA0DT,CAAI0X,CAAJ,EACE9F,CAAA,CAAgB3R,CAAAhG,WAAAD,GAAhB,CAAyC0d,CAAzC,CAbF,CAjC8B,CAx+IhC,CA0hJIwc,GAAuBA,QAAS,CAACz7B,CAAD,CAAO,CACzC,IACImZ,EAAkBnZ,CAAAmZ,gBADtB,CAEIuiB,EAAuBh2B,EAAA,CAFR1F,CAAAkZ,aAEQ,CAF3B,CAGIyiB,EAA0Bj2B,EAAA,CAAQyT,CAAR,CAH9B,CAIIlR,EAAW,IAJf,CAMI2zB,EAAYA,QAAkB,CAAC73B,CAAD,CAAQ,CACvCkE,CAAD,CAAiI,IAAK,EAAtI,CAA8GlJ,CAAA,CAAU,CAAA,CAAV,CADtE,KAEpC88B,EAAY5zB,CAGhBszB,GAAA,CAAS,CACPx3B,MAAOA,CADA;AAEPmV,aAAcwiB,CAFP,CAGPviB,gBAAiBwiB,CAHV,CAIP5B,cALkB8B,CAAA9B,cACX,CAKPI,uBAP2B0B,CAAA1B,uBAEpB,CAAT,CALwC,CAsD1C,OAAO,CACLr0B,MAzCYg2B,QAAgB,CAAC/3B,CAAD,CAAQ,CAElCkE,CAAF,CAA4HlJ,CAAA,CAAU,CAAA,CAAV,CAA5H,CAA+I,IAAK,EAEpJ,KAAIg7B,EAAgB/W,EAAA,EAApB,CAEI+Y,EAAkB,CAAA,CAFtB,CAIIC,EAAqBA,QAA2B,EAAG,CACrDD,CAAA,CAAkB,CAAA,CADmC,CAIvDR,GAAA,CAAS,CACPx3B,MAAOA,CADA,CAEPg2B,cAAe,CAFR,CAGPI,uBAAwB,CAAA,CAHjB,CAIPjhB,aAAc8iB,CAJP,CAKP7iB,gBAAiB6iB,CALV,CAAT,CAOA/zB,EAAA,CAAW,CACT8xB,cAAeA,CADN,CAETI,uBAAwB4B,CAFf,CAMPA,EAAJ,EACEH,CAAA,CAAU73B,CAAV,CA1BkC,CAwC/B,CAELgC,KAZSA,QAAa,EAAG,CACpBkC,CAAL,GAIAyzB,CAAA11B,OAAA,EAEA,CADA21B,CAAA31B,OAAA,EACA,CAAAiC,CAAA,CAAW,IANX,CADyB,CAUpB,CAGLV,OAAQq0B,CAHH,CA7DkC,CA1hJ3C,CA8lJIK,GAAsBA,QAAS,CAACj8B,CAAD,CAAO,CAAA,IACpC0Q,EAAO1Q,CAAA0Q,KAD6B,CAEpCyI,EAAkBnZ,CAAAmZ,gBAFkB,CAGpCD,EAAelZ,CAAAkZ,aA0EnB,OAzBmBgjB,SAAqB,CAACn4B,CAAD,CAAQ,CAC9C,IAAI0vB,EAAU1vB,CAAAe,kBAEd;GAAK2uB,CAAL,CAAA,CAIA,IAAI7zB,EAAckhB,EAAA,CAAkB/c,CAAArE,OAAlB,CACjBE,EAAD,CAA0J,IAAK,EAA/J,CAAuIb,CAAA,CAAU,CAAA,CAAV,CACjF,EAAA,CAAAgF,CAAA8c,WAAArT,WAAA,CAA4B5N,CAA5B,CAhDtD,IAAK07B,EAAA,CAAmB9zB,CAAnB,CAgD2FisB,CAhD3F,CAAL,CAAA,CAIA,IAAIwH,CAEJ,EA1LF,CA0LE,CA1LF,CANIv3B,CAMJ,CAwLoC8D,CA9LxB9D,MAMZ,GAAK43B,EAAA,CAwL+B9zB,CAxL/B,CAoO6FisB,CApO7F,CAAL,CAIOqH,EAAA,CAAW,CAChBzwB,QAAS3G,CAAA6D,OAAA8C,QADO,CAEhB6T,IAAKxa,CAAA6D,OAAA2W,IAFW,CAGhBe,OA6NgGwU,CAhOhF,CAAX,CAJP,CACS,IAyLP,GAKI0I,CAGJ,CAHgC5W,EAAA,CAqCgEkO,CArChE,CAAiBwH,CAAjB,CAGhC,CAFA9hB,CAAA,CAAgB3R,CAAAhG,WAAAD,GAAhB,CAAyC46B,CAAzC,CAEA,CAAA,CAAA,CADgB5W,EAAA6W,CAmCgF3I,CAnChF2I,CAAiBD,CAAjBC,CAPhB,GACEjjB,CAAA,CAAgB3R,CAAAhG,WAAAD,GAAhB,CAyC8FkyB,CAzC9F,CACA,CAAA,CAAA,CAAO,IAFT,CANA,CAkDK4I,CAAL,GAK6En8B,CAE7E,CAHe6D,CAAA7D,SAGf,CAFgD6D,CAAAouB,sBAEhD,EAnCKkJ,EAAA,CAAgBn7B,CAAhB,CAA0B+e,CAA1B,CAmCL,GA7BA,CAhPF,CAgPE,CAhPGoc,EAAA,CA8O4Bn7B,CA9O5B,CA8OsC+e,CA9OtC,CAAL,CAMO6b,EAAA,CAAW,CAChBzwB,QAuO+BnK,CAzOnBqH,OAAA8C,QACI,CAEhB6T,IAsO+Bhe,CA1OvBqH,OAAA2W,IAEQ,CAGhBe,OAqOyCA,CAxOzB,CAAX,CANP,CACS,IA+OP,GAKIqd,CAGJ,CAH6B/W,EAAA,CAAStG,CAAT,CAAiBgc,CAAjB,CAG7B,CAFA/hB,CAAA,CAAaojB,CAAb,CAEA,CAAA,CAAA,CADgB/W,EAAA6W,CAASnd,CAATmd,CAAiBE,CAAjBF,CAPhB,GACEljB,CAAA,CAAa+F,CAAb,CACA,CAAA,CAAA,CAAO,IAFT,CA6BA,EAAKsd,CAAL,GAhEI9mB,CACJ,CADa5N,CAAA,CAoEA9D,CApEIsG,QAAAoL,OAAAga,UAAJ,CAoEO8M,CApEP,CACb,CAAA7rB,CAAA,CAAK,CACH+E,OAAQA,CADL,CAAL,CA+DA,CAPA,CARA,CAH8C,CApDR,CA9lJ1C,CA8qJIwD,GAAsBA,QAAS,CAACjZ,CAAD,CAAO,CAAA,IACpCmZ,EAAkBnZ,CAAAmZ,gBADkB;AAEpCD,EAAelZ,CAAAkZ,aACfxI,EAAAA,CAAO1Q,CAAA0Q,KACX,KAAI8rB,EAAgBf,EAAA,CAAoB,CACtCviB,aAAcA,CADwB,CAEtCC,gBAAiBA,CAFqB,CAApB,CAApB,CAIIsjB,EAAaR,EAAA,CAAmB,CAClCvrB,KAAMA,CAD4B,CAElCwI,aAAcA,CAFoB,CAGlCC,gBAAiBA,CAHiB,CAAnB,CA4BjB,OALeujB,CACbn1B,OAlBWA,QAAe,CAACxD,CAAD,CAAQ,CACd,UAApB,GAAIA,CAAAC,MAAJ,GAI2B,OAA3B,GAAID,CAAAc,aAAJ,CACE23B,CAAAj1B,OAAA,CAAqBxD,CAArB,CADF,CAKKA,CAAAe,kBALL,EASA23B,CAAA,CAAW14B,CAAX,CAbA,CADkC,CAiBrB24B,CAEb52B,MAAO02B,CAAA12B,MAFM42B,CAGb32B,KAAMy2B,CAAAz2B,KAHO22B,CA/ByB,CA9qJ1C,CAstJI5zB,GAEK,CACL+T,KAFSA,sBACJ,CAELva,YAAa,mCAFR,CAGL+F,UAAW,iCAHN,CAxtJT,CA8tJI5H,GAEK,CACLoc,KAFSA,oBACJ,CAELxU,UAAW,+BAFN,CAGL9G,GAAI,uBAHC,CAhuJT,CA0uJe,GAAA,+BA1uJf;AA8uJIqd,GAAkB,CACpBvW,UAAW,sCADS,CA9uJtB,CAkvJIM,GAAkBA,QAAwB,CAACiS,CAAD,CAAU,CACtD,MAAO,SAAS,CAAC1H,CAAD,CAAY,CAC1B,MAAO,GAAP,CAAaA,CAAb,CAAyB,OAAzB,CAAiC0H,CAAjC,CAA2C,IADjB,CAD0B,CAlvJxD,CAwvJIhR,GAAYA,QAAkB,CAACH,CAAD,CAAQkzB,CAAR,CAAkB,CAClD,MAAOlzB,EAAAtL,IAAA,CAAU,QAAS,CAACy+B,CAAD,CAAO,CAC/B,IAAIlvB,EAAQkvB,CAAAr0B,OAAA,CAAYo0B,CAAZ,CAEZ,OAAKjvB,EAAL,CAIOkvB,CAAA/zB,SAJP,CAIuB,KAJvB,CAI+B6E,CAJ/B,CAIuC,IAJvC,CACS,EAJsB,CAA1B,CAAAmvB,KAAA,CAQC,GARD,CAD2C,CAxvJpD,CAuzJIryB,GAA8C,WAAlB,GAAA,MAAOpF,OAAP,CAAgC0E,CAAAgzB,gBAAhC,CAAwDhzB,CAAA2E,UAvzJxF,CAyzJI7D,GAAUA,QAAgB,EAAG,CAC/B,IAAImyB,EAAO13B,QAAA23B,cAAA,CAAuB,MAAvB,CACVD,EAAD,CAAmI,IAAK,EAAxI,CAAgHh+B,CAAA,CAAU,CAAA,CAAV,CAChH,OAAOg+B,EAHwB,CAzzJjC,CA+zJItyB,GAAgBA,QAAsB,CAACnC,CAAD,CAAQ,CAChD,IAAIvK,EAAKsH,QAAAuJ,cAAA,CAAuB,OAAvB,CAELtG,EAAJ,EACEvK,CAAA4M,aAAA,CAAgB,OAAhB,CAAyBrC,CAAzB,CAGFvK,EAAAJ,KAAA,CAAU,UACV,OAAOI,EARyC,CA/zJlD,CA+pKI8c,GAAeL,EAAAyiB,cAAA,CAA6B,IAA7B,CA/pKnB,CAiqKIjuB;AAAkBA,QAAS,EAAG,CAChC,IAAIrF,EAAOtE,QAAAsE,KACVA,EAAD,CAAmH,IAAK,EAAxH,CAAgG5K,CAAA,CAAU,CAAA,CAAV,CAChG,OAAO4K,EAHyB,CAjqKlC,CAuqKIoF,GAAiB,CACnBmuB,SAAU,UADS,CAEnBnf,MAAO,KAFY,CAGnBD,OAAQ,KAHW,CAInBP,OAAQ,MAJW,CAKnBF,OAAQ,GALW,CAMnBG,QAAS,GANU,CAOnB2f,SAAU,QAPS,CAQnBC,KAAM,eARa,CASnB,YAAa,aATM,CAvqKrB,CAmvKI3iB,GAAaD,EAAAyiB,cAAA,CAA6B,IAA7B,CAnvKjB,CAk5KII,EAl5KJ,CAm5KIjsB,IAAiBisB,EAAA,CAAiB,EAAjB,CAAqBA,EAAA,CAb9BC,EAa8B,CAArB,CAA6C,CAAA,CAA7C,CAAmDD,EAAA,CAd9DE,CAc8D,CAAnD,CAAyE,CAAA,CAAzE,CAA+EF,EAAhGjsB,CAn5KJ,CA05KIE,GAAqB,QAAS,EAAG,CAGnC,MAAwB,WAAxB,GAAI,MAAOjM,SAAX,CAFWwX,kBAEX,CAKgBtd,CAAAi+B,CADCnR,CANNxP,kBAMMwP,CAAO,oBAAPA,CAAoB,wBAApBA,CAAqC,qBAArCA,CAAmD,mBAAnDA,CACDmR,CAAiB,QAAS,CAACh/B,CAAD,CAAY,CACpD,MAAO,IAAP,CAAcA,CAAd,GAA2B6G,SADyB,CAAtCm4B,CALhB,EAFW3gB,kBADwB,CAAZ,EA15KzB;AA+6KI4gB,GAAS,CACX9/B,KAAM,MADK,CA/6Kb,CAsrLI+/B,EAtrLJ,CA0rLIxrB,IAAkBwrB,EAAA,CAAkB,EAAlB,CAAsBA,EAAA,CAhT7BC,EAgT6B,CAAtB,CAAkD,CAAA,CAAlD,CAAwDD,EAAA,CAjTjEE,EAiTiE,CAAxD,CAAkF,CAAA,CAAlF,CAAwFF,EAAA,CA9SnGx1B,EA8SmG,CAAxF,CAAgH,CAAA,CAAhH,CAAsHw1B,EAAA,CA/SlInX,EA+SkI,CAAtH,CAA6I,CAAA,CAA7I,CAAmJmX,EAArKxrB,CA1rLJ,CA80LI2rB,GAAS,CACXlgC,KAAM,MADK,CA90Lb,CAknMImV,GAAsB,CACxBgrB,MAAO,CAAA,CADiB,CAExBztB,OAAQ,CAAA,CAFgB,CAGxB0tB,SAAU,CAAA,CAHc,CAIxBC,OAAQ,CAAA,CAJgB,CAKxBC,OAAQ,CAAA,CALgB,CAMxBC,SAAU,CAAA,CANc,CAOxBC,MAAO,CAAA,CAPiB,CAQxBC,MAAO,CAAA,CARiB,CAlnM1B,CAuqMI9qB,GAAuB,QAAS,EAAG,CAGrC,MAAwB,WAAxB,GAAI,MAAOjO,SAAX,CAFWwX,SAEX,CAKYtd,CAAAmO,CADK2e,CANNxP,SAMMwP,CAAO,mBAAPA,CAA4B,uBAA5BA,CACL3e,CAAiB,QAAS,CAAC2wB,CAAD,CAAO,CAC3C,MAAOA,EAAP,GAAe7qB,QAAA9H,UAD4B,CAAjCgC,CALZ,EAFWmP,SAD0B,CAAZ,EAvqM3B,CAggNInG,GAAiB,CAv9BrB4nB,QAAuB,CAAC5oB,CAAD,CAAM,CAC3B,IAAI6oB,EAAWz0B,CAAAC,OAAA,CAAa0zB,EAAb,CAAf,CACIe,EAAkB10B,CAAAC,OAAA,CAAalM,CAAb,CADtB,CAEI4gC,EAAsBj2B,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACvD,MAAO,CACLjK,UAAW,WADN,CAELC,GAAIigC,QAAoB,CAACv5B,CAAD,CAAQ,CAC9B,GAAIw5B,EAAAx5B,CAAAw5B,iBAAAA,EAxIQvuB,CAwIRuuB,GAIAx5B,CAAAkL,OAJAsuB;AAQAx5B,CAAAy5B,QARAD,EAQiBx5B,CAAA05B,QARjBF,EAQkCx5B,CAAA25B,SARlCH,EAQoDx5B,CAAA45B,OARpDJ,CAAJ,CAQA,CAIA,IAAIr8B,EAAcoT,CAAAwB,uBAAA,CAA2B/R,CAA3B,CAEb7C,EAAL,GAIImO,CAJJ,CAIciF,CAAAsB,WAAA,CAAe1U,CAAf,CAA4ByD,CAA5B,CAAkC,CAC9CgP,YAAa5P,CADiC,CAAlC,CAJd,IAYAA,CAAAqL,eAAA,EAMA,CALIvP,CAKJ,CALY,CACVK,EAAG6D,CAAAmL,QADO,CAEVpP,EAAGiE,CAAAoL,QAFO,CAKZ,CADAiuB,CAAAn0B,QAAA,EACA,CAAA20B,CAAA,CAAiBvuB,CAAjB,CAA0BxP,CAA1B,CAlBA,CANA,CAT8B,CAF3B,CADgD,CAA/B,CAuCvB,CAACyU,CAAD,CAvCuB,CAF1B,CA0CIupB,EAA2Bz2B,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAC5D,MAAO,CACLjK,UAAW,2BADN,CAELC,GAAIA,QAAW,CAAC0G,CAAD,CAAQ,CACrB,GAAIw5B,CAAAx5B,CAAAw5B,iBAAJ,CAAA,CAIA,IAAIp9B,EAAKmU,CAAAwB,uBAAA,CAA2B/R,CAA3B,CAET,IAAK5D,CAAL,CAAA,CAIA,IAAIlD,EAAUqX,CAAAyB,wBAAA,CAA4B5V,CAA5B,CAETlD,EAAL,GAIIA,CAAAgT,wBAJJ,EAQKqE,CAAAqB,WAAA,CAAexV,CAAf,CARL,EAYA4D,CAAAqL,eAAA,EAZA,CANA,CANA,CADqB,CAFlB,CADqD,CAA/B,CA+B5B,CAACkF,CAAD,CA/B4B,CA1C/B,CA0EIwpB,EAAmB12B,CAAA0B,YAAA,CAAuBg1B,QAAyB,EAAG,CAKxEV,CAAAn0B,QAAA,CAA0BvM,CAAA,CAAWsH,MAAX;AAAmB,CAAC65B,CAAD,CAA2BR,CAA3B,CAAnB,CAJZpgC,CACZ4G,QAAS,CAAA,CADG5G,CAEZ6G,QAAS,CAAA,CAFG7G,CAIY,CAL8C,CAAnD,CAMpB,CAAC4gC,CAAD,CAA2BR,CAA3B,CANoB,CA1EvB,CAiFI14B,EAAOyC,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAGvB,MAArB,GAFcq0B,CAAAl0B,QAEV1M,KAAJ,GAIA4gC,CAAAl0B,QAEA,CAFmBozB,EAEnB,CADAe,CAAAn0B,QAAA,EACA,CAAA60B,CAAA,EANA,CAH4C,CAAnC,CAUR,CAACA,CAAD,CAVQ,CAjFX,CA4FIl5B,EAASwC,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAC9C,IAAIlG,EAAQu6B,CAAAl0B,QACZtE,EAAA,EAEmB,WAAnB,GAAI/B,CAAArG,KAAJ,EACEqG,CAAAyM,QAAAzK,OAAA,CAAqB,CACnBiL,qBAAsB,CAAA,CADH,CAArB,CAKiB,UAAnB,GAAIjN,CAAArG,KAAJ,EACEqG,CAAAyM,QAAAyF,MAAA,EAX4C,CAAnC,CAaV,CAACnQ,CAAD,CAbU,CA5Fb,CA0GIo5B,EAAsB32B,CAAA0B,YAAA,CAAuBi1B,QAA4B,EAAG,CAK9E,IAAInhC,EAAWgS,EAAA,CAAmB,CAChChK,OAAQA,CADwB,CAEhCiK,UAAWlK,CAFqB,CAGhCmK,SAAUA,QAAiB,EAAG,CAC5B,MAAOquB,EAAAl0B,QADqB,CAHE,CAMhC8F,SAAUA,QAAiB,CAACnM,CAAD,CAAQ,CACjCu6B,CAAAl0B,QAAA,CAAmBrG,CADc,CANH,CAAnB,CAUfw6B,EAAAn0B,QAAA,CAA0BvM,CAAA,CAAWsH,MAAX,CAAmBpH,CAAnB,CAdZK,CACZ6G,QAAS,CAAA,CADG7G,CAEZ4G,QAAS,CAAA,CAFG5G,CAcY,CAfoD,CAAtD,CAgBvB,CAAC2H,CAAD,CAASD,CAAT,CAhBuB,CA1G1B,CA2HIi5B,EAAmBx2B,CAAA0B,YAAA,CAAuB80B,QAAyB,CAACvuB,CAAD,CAAUxP,CAAV,CAAiB,CAC1D,MAA5B;AAAEs9B,CAAAl0B,QAAA1M,KAAF,CAA+IoB,CAAA,CAAU,CAAA,CAAV,CAA/I,CAAkK,IAAK,EACvKw/B,EAAAl0B,QAAA,CAAmB,CACjB1M,KAAM,SADW,CAEjBsD,MAAOA,CAFU,CAGjBwP,QAASA,CAHQ,CAKnB0uB,EAAA,EAPsF,CAAjE,CAQpB,CAACA,CAAD,CARoB,CASvB30B,GAAA,CAA0B8E,QAAc,EAAG,CACzC4vB,CAAA,EACA,OAAOxwB,SAAgB,EAAG,CACxB8vB,CAAAn0B,QAAA,EADwB,CAFe,CAA3C,CAKG,CAAC60B,CAAD,CALH,CArI2B,CAu9BR,CAhvBrBE,QAA0B,CAAC1pB,CAAD,CAAM,CAC9B,IAAI8oB,EAAkB10B,CAAAC,OAAA,CAAawH,EAAb,CAAtB,CACIktB,EAAsBj2B,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACvD,MAAO,CACLjK,UAAW,SADN,CAELC,GAAI4gC,QAAkB,CAACl6B,CAAD,CAAQ,CA4B5BY,QAASA,EAAI,EAAG,CACbu5B,CAAD,CAAyJ,IAAK,EAA9J,CAAsIvgC,CAAA,CAAU,CAAA,CAAV,CACtIugC,EAAA,CAAc,CAAA,CACdd,EAAAn0B,QAAA,EACA60B,EAAA,EAJc,CA3BhB,GAAIP,CAAAx5B,CAAAw5B,iBAAJ,EA9YIltB,EA8YJ,GAIItM,CAAAgM,QAJJ,CAIA,CAIA,IAAI7O,EAAcoT,CAAAwB,uBAAA,CAA2B/R,CAA3B,CAElB,IAAK7C,CAAL,GAIIgT,CAJJ,CAIcI,CAAAsB,WAAA,CAAe1U,CAAf,CAA4ByD,CAA5B,CAAkC,CAC9CgP,YAAa5P,CADiC,CAAlC,CAJd,EAQA,CAIAA,CAAAqL,eAAA,EACA,KAAI8uB,EAAc,CAAA,CACd7uB,EAAAA,CAAU6E,CAAAK,SAAA,EACd6oB,EAAAn0B,QAAA,EASAm0B,EAAAn0B,QAAA,CAA0BvM,CAAA,CAAWsH,MAAX,CAAmBoM,EAAA,CAAoBf,CAApB,CAA6B1K,CAA7B,CAAnB,CAAuD,CAC/Eb,QAAS,CAAA,CADsE,CAE/ED,QAAS,CAAA,CAFsE,CAAvD,CAhB1B,CAdA,CAL4B,CAFzB,CADgD,CAA/B;AA4CvB,CAACyQ,CAAD,CA5CuB,CAD1B,CA8CIwpB,EAAmB12B,CAAA0B,YAAA,CAAuBq1B,QAAwB,EAAG,CAKvEf,CAAAn0B,QAAA,CAA0BvM,CAAA,CAAWsH,MAAX,CAAmB,CAACq5B,CAAD,CAAnB,CAJZpgC,CACZ4G,QAAS,CAAA,CADG5G,CAEZ6G,QAAS,CAAA,CAFG7G,CAIY,CAL6C,CAAlD,CAMpB,CAACogC,CAAD,CANoB,CAOvBj0B,GAAA,CAA0B8E,QAAc,EAAG,CACzC4vB,CAAA,EACA,OAAOxwB,SAAgB,EAAG,CACxB8vB,CAAAn0B,QAAA,EADwB,CAFe,CAA3C,CAKG,CAAC60B,CAAD,CALH,CAtD8B,CAgvBX,CAtiBrBM,QAAyB,CAAC9pB,CAAD,CAAM,CAC7B,IAAI6oB,EAAWz0B,CAAAC,OAAA,CAAa8zB,EAAb,CAAf,CACIW,EAAkB10B,CAAAC,OAAA,CAAalM,CAAb,CADtB,CAEIqS,EAAW1H,CAAA0B,YAAA,CAAuBgG,QAAiB,EAAG,CACxD,MAAOquB,EAAAl0B,QADiD,CAA3C,CAEZ,EAFY,CAFf,CAKI8F,EAAW3H,CAAA0B,YAAA,CAAuBiG,QAAiB,CAACnM,CAAD,CAAQ,CAC7Du6B,CAAAl0B,QAAA,CAAmBrG,CAD0C,CAAhD,CAEZ,EAFY,CALf,CAQIy6B,EAAsBj2B,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACvD,MAAO,CACLjK,UAAW,YADN,CAELC,GAAIghC,QAAqB,CAACt6B,CAAD,CAAQ,CAC/B,GAAIw5B,CAAAx5B,CAAAw5B,iBAAJ,CAAA,CAIA,IAAIr8B,EAAcoT,CAAAwB,uBAAA,CAA2B/R,CAA3B,CAEb7C,EAAL,GAIImO,CAJJ,CAIciF,CAAAsB,WAAA,CAAe1U,CAAf,CAA4ByD,CAA5B,CAAkC,CAC9CgP,YAAa5P,CADiC,CAAlC,CAJd,IAYIqN,CAQJ,CARYrN,CAAAoN,QAAA,CAAc,CAAd,CAQZ,CALItR,CAKJ,CALY,CACVK,EAHYkR,CAAAlC,QAEF,CAEVpP,EAHYsR,CAAAjC,QACF,CAKZ,CADAiuB,CAAAn0B,QAAA,EACA;AAAA20B,CAAA,CAAiBvuB,CAAjB,CAA0BxP,CAA1B,CApBA,CANA,CAD+B,CAF5B,CADgD,CAA/B,CAiCvB,CAACyU,CAAD,CAjCuB,CAR1B,CA0CIwpB,EAAmB12B,CAAA0B,YAAA,CAAuBg1B,QAAyB,EAAG,CAKxEV,CAAAn0B,QAAA,CAA0BvM,CAAA,CAAWsH,MAAX,CAAmB,CAACq5B,CAAD,CAAnB,CAJZpgC,CACZ6G,QAAS,CAAA,CADG7G,CAEZ4G,QAAS,CAAA,CAFG5G,CAIY,CAL8C,CAAnD,CAMpB,CAACogC,CAAD,CANoB,CA1CvB,CAiDI14B,EAAOyC,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAC5C,IAAIG,EAAUk0B,CAAAl0B,QAEO,OAArB,GAAIA,CAAA1M,KAAJ,GAIqB,SAMrB,GANI0M,CAAA1M,KAMJ,EALE03B,YAAA,CAAahrB,CAAAq1B,iBAAb,CAKF,CAFAvvB,CAAA,CAAS0tB,EAAT,CAEA,CADAW,CAAAn0B,QAAA,EACA,CAAA60B,CAAA,EAVA,CAH4C,CAAnC,CAcR,CAACA,CAAD,CAAmB/uB,CAAnB,CAdQ,CAjDX,CAgEInK,EAASwC,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAC9C,IAAIlG,EAAQu6B,CAAAl0B,QACZtE,EAAA,EAEmB,WAAnB,GAAI/B,CAAArG,KAAJ,EACEqG,CAAAyM,QAAAzK,OAAA,CAAqB,CACnBiL,qBAAsB,CAAA,CADH,CAArB,CAKiB,UAAnB,GAAIjN,CAAArG,KAAJ,EACEqG,CAAAyM,QAAAyF,MAAA,EAX4C,CAAnC,CAaV,CAACnQ,CAAD,CAbU,CAhEb,CA8EIo5B,EAAsB32B,CAAA0B,YAAA,CAAuBi1B,QAA4B,EAAG,CAC9E,IAAI9gC,EAAU,CACZ6G,QAAS,CAAA,CADG,CAEZD,QAAS,CAAA,CAFG,CAAd,CAIIrD,EAAO,CACToE,OAAQA,CADC,CAETiK,UAAWlK,CAFF,CAGTmK,SAAUA,CAHD,CAJX,CASIyvB,EAAe7hC,CAAA,CAAWsH,MAAX;AAAmBgN,EAAA,CAAkBxQ,CAAlB,CAAnB,CAA4CvD,CAA5C,CATnB,CAUIuhC,EAAe9hC,CAAA,CAAWsH,MAAX,CAAmB+M,EAAA,CAAkBvQ,CAAlB,CAAnB,CAA4CvD,CAA5C,CAEnBmgC,EAAAn0B,QAAA,CAA0Bw1B,QAAkB,EAAG,CAC7CF,CAAA,EACAC,EAAA,EAF6C,CAb+B,CAAtD,CAiBvB,CAAC55B,CAAD,CAASkK,CAAT,CAAmBnK,CAAnB,CAjBuB,CA9E1B,CAgGI+5B,EAAgBt3B,CAAA0B,YAAA,CAAuB41B,QAAsB,EAAG,CAClE,IAAI97B,EAAQkM,CAAA,EACK,UAAjB,GAAElM,CAAArG,KAAF,CAA2IoB,CAAA,CAAU,CAAA,CAAV,CAA3I,CAA8J,IAAK,EAC/J0R,EAAAA,CAAUzM,CAAAyM,QAAAM,UAAA,CAAwB/M,CAAA/C,MAAxB,CACdkP,EAAA,CAAS,CACPxS,KAAM,UADC,CAEP8S,QAASA,CAFF,CAGP4B,SAAU,CAAA,CAHH,CAAT,CAJkE,CAAhD,CASjB,CAACnC,CAAD,CAAWC,CAAX,CATiB,CAhGpB,CA0GI6uB,EAAmBx2B,CAAA0B,YAAA,CAAuB80B,QAAyB,CAACvuB,CAAD,CAAUxP,CAAV,CAAiB,CAChE,MAAtB,GAAEiP,CAAA,EAAAvS,KAAF,CAAyIoB,CAAA,CAAU,CAAA,CAAV,CAAzI,CAA4J,IAAK,EACjK,KAAI2gC,EAAmBzwB,UAAA,CAAW6wB,CAAX,CAtPJC,GAsPI,CACvB5vB,EAAA,CAAS,CACPxS,KAAM,SADC,CAEPsD,MAAOA,CAFA,CAGPwP,QAASA,CAHF,CAIPivB,iBAAkBA,CAJX,CAAT,CAMAP,EAAA,EATsF,CAAjE,CAUpB,CAACA,CAAD,CAAsBjvB,CAAtB,CAAgCC,CAAhC,CAA0C2vB,CAA1C,CAVoB,CAWvBt1B,GAAA,CAA0B8E,QAAc,EAAG,CACzC4vB,CAAA,EACA,OAAOxwB,SAAgB,EAAG,CACxB8vB,CAAAn0B,QAAA,EACA,KAAIrG,EAAQkM,CAAA,EAEO,UAAnB,GAAIlM,CAAArG,KAAJ,GACE03B,YAAA,CAAarxB,CAAA07B,iBAAb,CACA,CAAAvvB,CAAA,CAAS0tB,EAAT,CAFF,CAJwB,CAFe,CAA3C,CAWG,CAAC3tB,CAAD;AAAWgvB,CAAX,CAA6B/uB,CAA7B,CAXH,CAYA3F,GAAA,CAA0Bw1B,QAAmB,EAAG,CAS9C,MARaliC,EAAAY,CAAW0G,MAAX1G,CAAmB,CAAC,CAC/BF,UAAW,WADoB,CAE/BC,GAAIA,QAAW,EAAG,EAFa,CAG/BJ,QAAS,CACP6G,QAAS,CAAA,CADF,CAEPD,QAAS,CAAA,CAFF,CAHsB,CAAD,CAAnBvG,CADiC,CAAhD,CAUG,EAVH,CAlI6B,CAsiBV,CAhgNrB,CAusNIuhC,GAAgB,CAvsNpB,CAguNIC,GAAYA,QAAgB,CAACrjB,CAAD,CAAO,CACrC,MAAO,SAAS,CAACnP,CAAD,CAAQ,CACtB,MAAOmP,EAAP,GAAgBnP,CADM,CADa,CAhuNvC,CAsuNIyyB,GAAWD,EAAA,CAAU,QAAV,CAtuNf,CAuuNIE,GAASF,EAAA,CAAU,MAAV,CACKA,GAAA,CAAU,SAAV,CAElB,KAAIG,GAAWA,QAAiB,CAAClD,CAAD,CAAW1+B,CAAX,CAAe,CAC7C,MAAOA,EAAA,CAAG0+B,CAAAmD,UAAH,CAAP,EAAiC7hC,CAAA,CAAG0+B,CAAAoD,UAAH,CADY,CAA/C,CA4CIlkB,GAAuBA,QAASA,EAAoB,CAACte,CAAD,CAAK,CAC3D,GAAU,IAAV,EAAIA,CAAJ,CACS,CAAA,CAAA,IADT,KAIA,IAAA,CAAA,GAAA,QAAA,KAAA,CAAA,CAAA,CAAA,IAAA,KAAA,IAAA,CAAA,GAAA,QAAA,gBAAA,CAAA,CAAA,CAAA,IAAA,KAAA,CAxCA,IAAI+Q,EAAQ1J,MAAAka,iBAAA,CAwCZvhB,CAxCY,CACRo/B,EAAAA,CAAW,CACbmD,UAAWxxB,CAAAwxB,UADE,CAEbC,UAAWzxB,CAAAyxB,UAFE,CAuCf,EAAA,CAnCOF,EAAA,CAASlD,CAAT,CAAmBgD,EAAnB,CAmCP,EAnCuCE,EAAA,CAASlD,CAAT,CAAmBiD,EAAnB,CAmCvC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,cAAA,CAAA,CAJA,MAAA,EAD2D,CA5C7D;AA8EIvkB,GAAeA,QAAS,CAAC9d,CAAD,CAAK,CAC/B,MAAO,CACLuD,EAAGvD,CAAAkf,WADE,CAEL/b,EAAGnD,CAAAif,UAFE,CADwB,CA9EjC,CAqFIT,GAAaA,QAASA,EAAU,CAACxe,CAAD,CAAK,CACvC,MAAKA,EAAL,CAMuB,OAAvB,GAFYqH,MAAAka,iBAAAxQ,CAAwB/Q,CAAxB+Q,CAERouB,SAAJ,CACS,CAAA,CADT,CAIO3gB,CAAA,CAAWxe,CAAAoV,cAAX,CAVP,CACS,CAAA,CAF8B,CArFzC,CAqPI0L,GAAY,CACd5Z,QAAS,CAAA,CADK,CArPhB,CAwPI6Z,GAAU,CACZ7Z,QAAS,CAAA,CADG,CAxPd,CAqQImW,GAAQ,CArQZ,CAkbIolB,GAAQ,CACVziB,MAAO,CADG,CAEVD,OAAQ,CAFE,CAGVP,OAv6NckjB,CACdz/B,IAAK,CADSy/B,CAEdt/B,MAAO,CAFOs/B,CAGdr/B,OAAQ,CAHMq/B,CAIdp/B,KAAM,CAJQo/B,CAo6NJ,CAlbZ,CA4cIC,GAAWA,QAAiB,CAAC19B,CAAD,CAAQ,CAAA,IAElCwc,EAAcxc,CAAAwc,YAFoB,CAGlCmhB,EAAU39B,CAAA29B,QAjBZ,EAAA,CAe2B39B,CAAA49B,uBAhB7B,CACSJ,EADT,CAIgB,OAAhB,GAkBWG,CAlBX,CACSH,EADT,CAIO,CACL1iB,OAYa0B,CAZL/J,OAAAyH,UAAAY,OADH,CAELC,MAWayB,CAXN/J,OAAAyH,UAAAa,MAFF,CAGLR,OAUaiC,CAVL/J,OAAA8H,OAHH,CAgBP,OAAO,CACLkC,QAASD,CAAAC,QADJ,CAELohB,UAAW,YAFN,CAGL9iB,MAAO4K,CAAA5K,MAHF,CAILD,OAAQ6K,CAAA7K,OAJH;AAKLgjB,UAAWnY,CAAApL,OAAAvc,IALN,CAML+/B,YAAapY,CAAApL,OAAApc,MANR,CAOL6/B,aAAcrY,CAAApL,OAAAnc,OAPT,CAQL6/B,WAAYtY,CAAApL,OAAAlc,KARP,CASL6/B,WAAY,GATP,CAULC,SAAU,GAVL,CAWLC,cAAe,MAXV,CAYLh4B,WAAwB,MAAZ,GAAAu3B,CAAA,CAAqBt3B,EAAAmW,YAArB,CAA+C,IAZtD,CAT+B,CA5cxC,CAqiBI6hB,GAAgB7mB,EAAA8mB,KAAA,CAhEpBC,QAAoB,CAAC9pB,CAAD,CAAQ,CAC1B,IAAI+pB,EAAsB13B,CAAAC,OAAA,CAAa,IAAb,CAA1B,CACI03B,EAA2Bj5B,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAC3Ds3B,CAAAn3B,QAAL,GAIAgrB,YAAA,CAAamM,CAAAn3B,QAAb,CACA,CAAAm3B,CAAAn3B,QAAA,CAA8B,IAL9B,CADgE,CAAnC,CAO5B,EAP4B,CAD/B,CASIs2B,EAAUlpB,CAAAkpB,QATd,CAUIe,EAAkBjqB,CAAAiqB,gBAVtB,CAWIC,EAAUlqB,CAAAkqB,QAXd,CAYIt5B,EAAYoP,CAAApP,UAZhB,CAcIu5B,EAAY93B,CAAA8M,SAAA,CAAiC,MAAjC,GAAea,CAAAkpB,QAAf,CAdhB,CAeIC,EAAyBgB,CAAA,CAAU,CAAV,CAf7B,CAgBIC,EAA4BD,CAAA,CAAU,CAAV,CAEhC93B,EAAA2E,UAAA,CAAgB,QAAS,EAAG,CAC1B,GAAI,CAACmyB,CAAL,CACE,MAAO1hB,GAGT,IAAgB,MAAhB,GAAIyhB,CAAJ,CAGE,MAFAc,EAAA,EAEOviB,CADP2iB,CAAA,CAA0B,CAAA,CAA1B,CACO3iB,CAAAA,EAGT;GAAIsiB,CAAAn3B,QAAJ,CACE,MAAO6U,GAGTsiB,EAAAn3B,QAAA,CAA8B4E,UAAA,CAAW,QAAS,EAAG,CACnDuyB,CAAAn3B,QAAA,CAA8B,IAC9Bw3B,EAAA,CAA0B,CAAA,CAA1B,CAFmD,CAAvB,CAI9B,OAAOJ,EAnBmB,CAA5B,CAoBG,CAACd,CAAD,CAAUC,CAAV,CAAkCa,CAAlC,CApBH,CAqBIK,EAAAA,CAAkBt5B,CAAA0B,YAAA,CAAuB,QAAS,CAAC/E,CAAD,CAAQ,CACjC,QAA3B,GAAIA,CAAA48B,aAAJ,GAIAL,CAAA,EAEA,CAAgB,OAAhB,GAAIf,CAAJ,EACEgB,CAAA,EAPF,CAD4D,CAAxC,CAUnB,CAAChB,CAAD,CAAUgB,CAAV,CAAmBD,CAAnB,CAVmB,CAWtB,KAAI5yB,EAAQ4xB,EAAA,CAAS,CACnBE,uBAAwBA,CADL,CAEnBD,QAASlpB,CAAAkpB,QAFU,CAGnBnhB,YAAa/H,CAAA+H,YAHM,CAAT,CAKZ,OAAOhF,GAAA5L,cAAA,CAA6B6I,CAAA+H,YAAAxM,QAA7B,CAAwD,CAC7DlE,MAAOA,CADsD,CAE7D,kCAAmCzG,CAF0B,CAG7Dq5B,gBAAiBI,CAH4C,CAI7Dh3B,IAAK2M,CAAAuqB,SAJwD,CAAxD,CAxDmB,CAgER,CAriBpB,CAuiBItf,GAAmBlI,EAAAyiB,cAAA,CAA6B,IAA7B,CAviBvB,CAymBIgF,GAAe,QAAS,CAACC,CAAD,CAAuB,CAGjDD,QAASA,EAAY,EAAG,CAGtB,IAFA,IAAI3e,CAAJ,CAESC,EAAOC,SAAAlkB,OAFhB,CAEkCsC,EAAW6J,KAAJ,CAAU8X,CAAV,CAFzC,CAE0DE,EAAO,CAAjE,CAAoEA,CAApE,CAA2EF,CAA3E,CAAiFE,CAAA,EAAjF,CACE7hB,CAAA,CAAK6hB,CAAL,CAAA;AAAaD,SAAA,CAAUC,CAAV,CAGfH,EAAA,CAAQ4e,CAAAv2B,KAAA+X,MAAA,CAAgCwe,CAAhC,CAAsD,CAAC,IAAD,CAAA1rB,OAAA,CAAc5U,CAAd,CAAtD,CAAR,EAAsF,IACtF0hB,EAAAvf,MAAA,CAAc,CACZpC,UAAW,CAAA,CAAQ2hB,CAAA7L,MAAA0qB,GADP,CAEZ7L,KAAMhT,CAAA7L,MAAA0qB,GAFM,CAGZxB,QAASrd,CAAA7L,MAAArV,cAAA,EAA6BkhB,CAAA7L,MAAA0qB,GAA7B,CAA8C,MAA9C,CAAuD,MAHpD,CAMd7e,EAAAqe,QAAA,CAAgBS,QAAS,EAAG,CACE,OAA5B,GAAI9e,CAAAvf,MAAA48B,QAAJ,EAIArd,CAAAoB,SAAA,CAAe,CACb/iB,UAAW,CAAA,CADE,CAAf,CAL0B,CAU5B,OAAO2hB,EAxBe,CAFxBP,EAAA,CAAekf,CAAf,CAA6BC,CAA7B,CA6BAD,EAAAI,yBAAA,CAAwCC,QAAiC,CAAC7qB,CAAD,CAAQ1T,CAAR,CAAe,CACtF,MAAK0T,EAAArV,cAAL,CAQIqV,CAAA0qB,GAAJ,CACS,CACLxgC,UAAW,CAAA,CADN,CAEL20B,KAAM7e,CAAA0qB,GAFD,CAGLxB,QAAS,MAHJ,CADT,CAQI58B,CAAApC,UAAJ,CACS,CACLA,UAAW,CAAA,CADN,CAEL20B,KAAMvyB,CAAAuyB,KAFD,CAGLqK,QAAS,OAHJ,CADT,CAQO,CACLh/B,UAAW,CAAA,CADN,CAELg/B,QAAS,OAFJ,CAGLrK,KAAM,IAHD,CAxBP,CACS,CACL30B,UAAW,CAAA,CAAQ8V,CAAA0qB,GADd,CAEL7L,KAAM7e,CAAA0qB,GAFD,CAGLxB,QAAS,MAHJ,CAF6E,CAgC3EsB;CAAAv2B,UAEbiZ,OAAA,CAAgBC,QAAe,EAAG,CAChC,MAAK,KAAA7gB,MAAApC,UAAL,CASO,IAAA8V,MAAAqD,SAAA,CALQ2b,CACbkL,QAAS,IAAAA,QADIlL,CAEbH,KAAM,IAAAvyB,MAAAuyB,KAFOG,CAGbkK,QAAS,IAAA58B,MAAA48B,QAHIlK,CAKR,CATP,CACS,IAFuB,CAalC,OAAOwL,EA7E0C,CAAhC,CA8EjBznB,EAAA+nB,cA9EiB,CAzmBnB,CAs9BIC,GAAiBA,QAAS,CAACp7B,CAAD,CAAIC,CAAJ,CAAO,CACnC,MAAOD,EAAP,GAAaC,CADsB,CAt9BrC,CA09BI4Z,GAA+BA,QAAS,CAACtZ,CAAD,CAAS,CAAA,IAC/C7H,EAAU6H,CAAA7H,QAGd,OAAA,CAFIF,CAEJ,CAFkB+H,CAAA/H,YAElB,EACSA,CAAAiD,YADT,CAII/C,CAAJ,CACSA,CAAA+C,YADT,CAIO,IAZ4C,CA19BrD,CA4lCI4/B,GAAS,CACXhiB,OAAQ,CACN9iB,KAAM,WADA,CAEN6iB,OAAQtZ,EAFF,CAGNoZ,iBAAkB,IAHZ,CAINuB,0BAA2B,CAAA,CAJrB,CAKNnB,SAAUiB,EAAA,CAAqB,IAArB,CALJ,CADG,CA5lCb,CAusCIiB,GAAqBjI,EAAA+nB,QAAA,CAbCC,QAA4B,EAAG,CACvD,IAAIC,EAAmB9iB,EAAA,EAAvB,CACI+iB,EAAoBjhB,EAAA,EAMxB,OAJe/Y,SAAiB,CAAC9E,CAAD,CAAQ4c,CAAR,CAAkB,CAChD,MAAOiiB,EAAA,CAAiB7+B,CAAjB,CAAwB4c,CAAxB,CAAP,EAA4CkiB,CAAA,CAAkB9+B,CAAlB,CAAyB4c,CAAzB,CAA5C;AAAkF8hB,EADlC,CAJK,CAahC,CAHAK,CACvBzP,sBAAuBA,EADAyP,CAGA,CAA4D,IAA5D,CAAkE,CACzFloB,QAASC,EADgF,CAEzFkoB,KAAM,CAAA,CAFmF,CAGzFC,mBAAoBR,EAHqE,CAAlE,CAAA,CAzVzBS,QAAkB,CAACxrB,CAAD,CAAQ,CACxB,IAAI3M,EAAMhB,CAAAC,OAAA,CAAa,IAAb,CAAV,CACIm5B,EAAS16B,CAAA0B,YAAA,CAAuB,QAAS,CAACnM,CAAD,CAAK,CAChD+M,CAAAT,QAAA,CAActM,CADkC,CAArC,CAEV,EAFU,CADb,CAIIolC,EAAS36B,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAC9C,MAAOY,EAAAT,QADuC,CAAnC,CAEV,EAFU,CAJb,CAQI+4B,EAAsBroB,EAAA,CAAmBN,EAAnB,CAR1B,CASIpS,EAAY+6B,CAAA/6B,UAThB,CAUI8P,EAAoBirB,CAAAjrB,kBAVxB,CAWIjS,EAAWk9B,CAAAl9B,SAEXm9B,EAAAA,CAAuBtoB,EAAA,CAAmB2H,EAAnB,CAdH,KAepB/kB,EAAO0lC,CAAA1lC,KAfa,CAgBpBkF,EAAcwgC,CAAAxgC,YAhBM,CAkBpBrB,EAAagH,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAC9C,MAAO,CACLlH,GAAIkW,CAAAnV,YADC,CAEL9C,MAAOiY,CAAAjY,MAFF,CAGL7B,KAAMA,CAHD,CAILkF,YAAaA,CAJR,CADuC,CAA/B,CAOd,CAAC4U,CAAAnV,YAAD,CAAoBmV,CAAAjY,MAApB,CAAiC7B,CAAjC,CAAuCkF,CAAvC,CAPc,CAQbiY,EAAAA,CAAWrD,CAAAqD,SA1BS,KA2BpBxY,EAAcmV,CAAAnV,YA3BM,CA4BpB2R,EAAYwD,CAAAxD,UA5BQ,CA6BpB5C,EAA0BoG,CAAApG,wBA7BN,CA8BpB4D,EAA6BwC,CAAAxC,2BA9BT;AAgCpBwL,EAAShJ,CAAAgJ,OAhCW,CAiCpB6iB,EAA8B7rB,CAAA4b,sBAIlC,IAAI,CANU5b,CAAAwI,QAMd,CAAc,CACZ,IAAIsjB,EAAe/6B,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAChD,MAAO,CACLjH,WAAYA,CADP,CAEL0E,SAAUA,CAFL,CAGLkZ,gBAAiB+jB,CAHZ,CAILluB,2BAA4BA,CAJvB,CAKL5D,wBAAyBA,CALpB,CAML4C,UAAWA,CANN,CADyC,CAA/B,CAShB,CAACzS,CAAD,CAAa0E,CAAb,CAAuBi9B,CAAvB,CAA+BluB,CAA/B,CAA2D5D,CAA3D,CAAoF4C,CAApF,CATgB,CAUnBkL,GAAA,CAAsBokB,CAAtB,CAXY,CAcd,IAAIC,EAAkBh7B,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACnD,MAAOwL,EAAA,CAAY,CACjBwvB,SAAU,CADO,CAEjB,oCAAqCnhC,CAFpB,CAGjB,kCAAmC+F,CAHlB,CAIjB,kBAAmB8P,CAJF,CAKjB1X,UAAW,CAAA,CALM,CAMjBuX,YAAa6H,EANI,CAAZ,CAOH,IAR+C,CAA/B,CASnB,CAACxX,CAAD,CAAY/F,CAAZ,CAAyB2R,CAAzB,CAAoCkE,CAApC,CATmB,CAAtB,CAUIurB,EAAYl7B,CAAA0B,YAAA,CAAuB,QAAS,CAAC/E,CAAD,CAAQ,CAClC,UAApB,GAAIsb,CAAA9iB,KAAJ,EAIK8iB,CAAAzV,SAJL,EAQ2B,WAR3B,GAQI7F,CAAA48B,aARJ,EAYAuB,CAAA,EAbsD,CAAxC;AAcb,CAACA,CAAD,CAA8B7iB,CAA9B,CAda,CAeZgW,EAAAA,CAAWjuB,CAAAC,QAAA,CAAmB,QAAS,EAAG,CA9LvC,GAAgB,UAAhB,GA+LkBgY,CA/LlB9iB,KAAA,CAAA,CAhCP,IAAIgmC,EA+NqBljB,CAhOT/B,UACNjJ,OAAV,CACI+K,EA8NqBC,CA9NZD,OADb,CAGIxV,EA4NqByV,CA5NVzV,SACXgpB,KAAAA,EAAc,CAAA,CA2NOvT,CA7NPN,YAGlB,KAAI/d,EAd+B,IAAnC,EAwOyBqe,CAxOrBtgB,mBAAJ,CAwOyBsgB,CAvOhBtgB,mBADT,CAIyB,MAJzB,GAwOyBsgB,CApOlBtY,KAUP,CACIiY,EAAkB,CAAA,CAAQpV,CAC1B44B,EAAAA,CAAYxjB,CAAA,CAAkB2T,EAAA/iB,KAAA,CAAgBwP,CAAhB,CAAwBwT,CAAxB,CAAlB,CAAyDD,EAAAxS,OAAA,CAAkBf,CAAlB,CAGlExf,KAAAA,EAAA2iC,CAAA7iC,UAAAE,IAAAA,CACCK,EAAAsiC,CAAA7iC,UAAAO,KADDL,CAGE+c,EAAA4lB,CAAAzmB,UAAAa,MACCD,EAAAA,CAAA6lB,CAAAzmB,UAAAY,OA3CV,EAAA,CA4CmD9S,CA5CnD,CACS3B,EAAA2H,KAAA,CA2C0ChG,CA3CzBmW,SAAjB,CADT,CA4CoC/e,CAxCpC,CACSiH,EAAAwqB,KADT,CAIOxqB,EAAAuqB,MA0CP,EAAA,CAbY9kB,CACVouB,SAAU,OADApuB,CAEV9N,IAAKA,CAFK8N,CAGVzN,KAAMA,CAHIyN,CAIV+xB,UAAW,YAJD/xB,CAKViP,MAAOA,CALGjP,CAMVgP,OAAQA,CANEhP,CAOV1F,WAAY,CAPF0F,CAQV80B,UAAWA,CARD90B,CASV2S,QAA4BuS,CAlC9B,CAkC2C5T,CA9BpC,CAAkBtgB,EAAA2hB,QAAAzQ,KAAlB,CAAyClR,EAAA2hB,QAAAiS,UAJhD;AACS,IAwBG5kB,CAUV+0B,OAAQzjB,CAAA,CAnDKjX,IAmDL,CApDAlB,GA0CE6G,CAWVsyB,cAAe,MAXLtyB,CAwBL,CAAA,IAPP,EAAA,CAAO,CACL80B,UAAW7P,EAAAxS,OAAA,CAqMYd,CArMMD,OAAlB,CADN,CAELpX,WAoMuBqX,CApMXoB,0BAAA,CAAsC,IAAtC,CAA6C,MAFpD,CAkNL,OAVala,CACXq6B,SAAUkB,CADCv7B,CAEXm8B,eAAgB,CACd,gCAAiCz7B,CADnB,CAEd,wBAAyB/F,CAFX,CAGdwM,MAtMCA,CAmMa,CAId4yB,gBAPkC,UAAhBA,GAAAjhB,CAAA9iB,KAAA+jC,EAA8BjhB,CAAAzV,SAA9B02B,CAAgDgC,CAAhDhC,CAA4D,IAGhE,CAFL/5B,CAQX67B,gBAAiBA,CARN77B,CAH+B,CAA/B,CAcZ,CAACU,CAAD,CAAYm7B,CAAZ,CAA6BlhC,CAA7B,CAA0Cme,CAA1C,CAAkDijB,CAAlD,CAA6DR,CAA7D,CAdY,CAef,KAAIa,EAASv7B,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAC1C,MAAO,CACLnG,YAAad,CAAAD,GADR,CAEL5D,KAAM6D,CAAA7D,KAFD,CAGLonB,OAAQ,CACNvlB,MAAOgC,CAAAhC,MADD,CAENqD,YAAarB,CAAAqB,YAFP,CAHH,CADmC,CAA/B,CASV,CAACrB,CAAAqB,YAAD,CAAyBrB,CAAAD,GAAzB,CAAwCC,CAAAhC,MAAxC,CAA0DgC,CAAA7D,KAA1D,CATU,CAUb,OAAOmd,EAAA,CAAS2b,CAAT,CAAmBhW,CAAAC,SAAnB;AAAoCqjB,CAApC,CArGiB,CAyVD,CAvsCzB,CAg/CIC,GAAqBrpB,EAAA+nB,QAAA,CApJGuB,QAA4B,EAAG,CACzD,IAAIC,EAAoB,CACtB1kB,YAAa,IADS,CAEtB2kB,yBAA0B,CAAA,CAFJ,CAGtBzjB,SAAU,CACR0jB,eAAgB,CAAA,CADR,CAERC,iBAAkB,IAFV,CAGRC,qBAAsB,IAHd,CAIRC,mBAAoB,CAAA,CAJZ,CAHY,CAStBC,SAAU,IATY,CAAxB,CAYIC,EAAuBnmC,CAAA,CAAS,EAAT,CAAa4lC,CAAb,CAAgC,CACzDC,yBAA0B,CAAA,CAD+B,CAAhC,CAZ3B,CAgBIO,EAAqBv6B,EAAA,CAAW,QAAS,CAAC3I,CAAD,CAAa,CACxD,MAAO,CACLc,YAAad,CAAAD,GADR,CAEL5D,KAAM6D,CAAA7D,KAFD,CAGLonB,OAAQ,CACNvlB,MAAOgC,CAAAhC,MADD,CAENqD,YAAarB,CAAAqB,YAFP,CAHH,CADiD,CAAjC,CAhBzB,CA0BI8hC,EAAcx6B,EAAA,CAAW,QAAS,CAAC5I,CAAD,CAAK0S,CAAL,CAAgB2wB,CAAhB,CAA2CC,CAA3C,CAAoE58B,CAApE,CAA8E68B,CAA9E,CAA2F,CAC/H,IAAIxiC,EAAc2F,CAAAzG,WAAAD,GAGlB,OAFa0G,EAAAzG,WAAAqB,YAEb,GAFiDtB,CAEjD,EACMijC,CAUG,CAVQM,CAAA,CAAc,CAC3BngB,OAAQmgB,CADmB,CAE3B78B,SAAUy8B,CAAA,CAAmBz8B,CAAAzG,WAAnB,CAFiB,CAAd,CAGX,IAOG,CAAA,CACLge,YAAavX,CAAAuX,YADR,CAEL2kB,yBAA0B,CAAA,CAFrB;AAGLzjB,SATcqkB,CACdX,eAAgBQ,CADFG,CAEdV,iBAAkBO,CAAA,CAA4BtiC,CAA5B,CAA0C,IAF9CyiC,CAGdT,qBAAsBhiC,CAHRyiC,CAIdR,mBAAoB,CAAA,CAJNQ,CAMT,CAILP,SAAUA,CAJL,CAXT,EAmBKvwB,CAAL,CAIK4wB,CAAL,CAUO,CACLrlB,YAAavX,CAAAuX,YADR,CAEL2kB,yBAA0B,CAAA,CAFrB,CAGLzjB,SATaA,CACb0jB,eAAgBQ,CADHlkB,CAEb2jB,iBAAkB/hC,CAFLoe,CAGb4jB,qBAAsB,IAHT5jB,CAIb6jB,mBAAoB,CAAA,CAJP7jB,CAMR,CAIL8jB,SAAU,IAJL,CAVP,CACSN,CALT,CACSO,CAxBsH,CAA/G,CAoGlB,OAvDe57B,SAAiB,CAAC9E,CAAD,CAAQ4c,CAAR,CAAkB,CAChD,IAAIpf,EAAKof,CAAA9d,YAAT,CACIlF,EAAOgjB,CAAAhjB,KADX,CAEIsW,EAAY,CAAC0M,CAAAlE,eACbqoB,EAAAA,CAAcnkB,CAAAmkB,YAElB,IAAI/gC,CAAAa,WAAJ,CAAsB,CACpB,IAAIgc,EAAW7c,CAAA6c,SAEf,IAAoBjjB,CAApB,GAA0BijB,CAxFdpZ,UAAA7J,KAwFZ,CACE,MAAO8mC,EAGLx8B,EAAAA,CAAkClE,CAAA8c,WAxFnChd,WAAA,CAwFyB+c,CAxFHngB,UAAAc,GAAtB,CAyFC6iC,EAAAA,CAAiBtjB,EAAA,CAAkB/c,CAAArE,OAAlB,CAAjB0kC,GAAqD7iC,CACzD;MAAOojC,EAAA,CAAYpjC,CAAZ,CAAgB0S,CAAhB,CAA2BmwB,CAA3B,CAA2CA,CAA3C,CAA2Dn8B,CAA3D,CAAqE68B,CAArE,CATa,CAYtB,GAAoB,gBAApB,GAAI/gC,CAAAC,MAAJ,CAAsC,CAChCiM,CAAAA,CAAYlM,CAAAkM,UAEhB,IAAoBtS,CAApB,GAA0BsS,CAAA2Q,SApGdpZ,UAAA7J,KAoGZ,CACE,MAAO8mC,EAGL5I,EAAAA,CAA6C93B,CAAA8c,WApG9Chd,WAAA,CAoG0BoM,CAAA2Q,SApGJngB,UAAAc,GAAtB,CAsGH,OAAOojC,EAAA,CAAYpjC,CAAZ,CAAgB0S,CAAhB,CAA2BgN,EAAA,CAA4BhR,CAAAtI,OAA5B,CAA3B,GAA6EpG,CAA7E,CAAiFuf,EAAA,CAAkB7Q,CAAAvQ,OAAlB,CAAjF,GAAyH6B,CAAzH,CAA6Hs6B,CAA7H,CAAwIiJ,CAAxI,CAT6B,CAYtC,GAAoB,MAApB,GAAI/gC,CAAAC,MAAJ,EAA8BD,CAAAkM,UAA9B,EAAiD,CAAClM,CAAAkuB,YAAlD,CAAqE,CAC/D+S,CAAAA,CAAajhC,CAAAkM,UAEjB,IAAoBtS,CAApB,GAA0BqnC,CAAApkB,SAhHdpZ,UAAA7J,KAgHZ,CACE,MAAO8mC,EAGLlT,EAAAA,CAAUzQ,EAAA,CAAkBkkB,CAAAtlC,OAAlB,CAAV6xB,GAAmDhwB,CACnD0jC,EAAAA,CAAe,EAAQtlC,CAAAqlC,CAAAtlC,OAAAC,GAAR,EAA8D,SAA9D,GAAgCqlC,CAAAtlC,OAAAC,GAAAhC,KAAhC,CAGnB,IAAI4zB,CAAJ,CACE,MAAO0T,EAAA,CAAef,CAAf,CAAmCO,CAG5C,IANaO,CAAApkB,SAAApZ,UAAAjG,GAMb,GANkDA,CAMlD,CACE,MAAO2iC,EAhB0D,CAsBrE,MAAOO,EApDyC,CAxEO,CAoJlC,CAnBES,CACzBC,wBAv5K4BA,QAAgC,CAACvjC,CAAD,CAAO,CACnE,MAAO,CACLjE,KAAM,4BADD;AAELiX,QAAShT,CAFJ,CAD4D,CAs5K1CsjC,CAmBF,CAAgE,IAAhE,CAAsE,CAC7FtqB,QAASC,EADoF,CAE7FkoB,KAAM,CAAA,CAFuF,CAG7FC,mBAAoBR,EAHyE,CAAtE,CAAA,CA7QzB4C,QAAkB,CAAC3tB,CAAD,CAAQ,CACxB,IAAI6C,EAAaxQ,CAAAmR,WAAA,CAAiBR,EAAjB,CAChBH,EAAD,CAA0H,IAAK,EAA/H,CAAuGvb,CAAA,CAAU,CAAA,CAAV,CAF/E,KAGpBsJ,EAAYiS,CAAAjS,UAHQ,CAIpBvE,EAAoBwW,CAAAxW,kBAJA,CAKpBuhC,EAAev7B,CAAAC,OAAA,CAAa,IAAb,CALK,CAMpBu7B,EAAiBx7B,CAAAC,OAAA,CAAa,IAAb,CACjB+Q,EAAAA,CAAWrD,CAAAqD,SAPS,KAQpBjY,EAAc4U,CAAA5U,YARM,CASpBlF,EAAO8Z,CAAA9Z,KATa,CAUpBwK,EAAOsP,CAAAtP,KAVa,CAWpBqU,EAAY/E,CAAA+E,UAXQ,CAYpBI,EAA0BnF,CAAAmF,wBAZN,CAapBH,EAAiBhF,CAAAgF,eAbG,CAcpBC,EAAmBjF,CAAAiF,iBAdC,CAepBgE,EAAWjJ,CAAAiJ,SAfS,CAgBpB8jB,EAAW/sB,CAAA+sB,SAhBS,CAiBpBW,EAA0B1tB,CAAA0tB,wBAjBN,CAkBpBI,EAAuB9tB,CAAA8tB,qBAlBH,CAmBpBnpB,EAAkB5T,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CACvD,MAAOm7B,EAAAh7B,QADgD,CAAnC,CAEnB,EAFmB,CAnBE,CAsBpBm7B,EAAkBh9B,CAAA0B,YAAA,CAAuB,QAAS,CAACwD,CAAD,CAAQ,CAC5D23B,CAAAh7B,QAAA,CAAuBqD,CADqC,CAAxC,CAEnB,EAFmB,CAGElF,EAAA0B,YAAA,CAAuB,QAAS,EAAG,CACzD,MAAOo7B,EAAAj7B,QADkD,CAAnC;AAErB,EAFqB,CAGxB,KAAIo7B,EAAoBj9B,CAAA0B,YAAA,CAAuB,QAAS,CAACwD,CAAD,CAAQ,CAC9D43B,CAAAj7B,QAAA,CAAyBqD,CADqC,CAAxC,CAErB,EAFqB,CAAxB,CAQIg4B,EAA6Bl9B,CAAA0B,YAAA,CAAuB,QAAS,EAAG,CAC9DpG,CAAA,EAAJ,EACEqhC,CAAA,CAAwB,CACtBvnB,UAAWia,EAAA,EADW,CAAxB,CAFgE,CAAnC,CAM9B,CAAC/zB,CAAD,CAAoBqhC,CAApB,CAN8B,CAOjC9pB,GAAA,CAAsB,CACpBxY,YAAaA,CADO,CAEpBlF,KAAMA,CAFc,CAGpBwK,KAAMA,CAHc,CAIpBqU,UAAWA,CAJS,CAKpBC,eAAgBA,CALI,CAMpBC,iBAAkBA,CANE,CAOpBE,wBAAyBA,CAPL,CAQpBR,gBAAiBA,CARG,CAAtB,CAUA,KAAIoD,EAAchF,EAAA5L,cAAA,CAA6BqzB,EAA7B,CAA2C,CAC3DE,GAAI1qB,CAAA+H,YADuD,CAE3Dpd,cAAeqV,CAAA0sB,yBAF4C,CAA3C,CAGf,QAAS,CAACnkC,CAAD,CAAO,CAIjB,MAAOwa,GAAA5L,cAAA,CAA6ByyB,EAA7B,CAA4C,CACjD7hB,YAHSxf,CAAAs2B,KAEwC,CAEjDqL,QALY3hC,CAAA2hC,QAGqC,CAGjDK,SAAUyD,CAHuC,CAIjD9E,QALY3gC,CAAA2gC,QACqC,CAKjDt4B,UAAWA,CALsC,CAMjDq5B,gBAAiBgE,CANgC,CAA5C,CAJU,CAHD,CAgBdjP,EAAAA,CAAWjuB,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAC5C,MAAO,CACLu5B,SAAUwD,CADL;AAELhmB,YAAaA,CAFR,CAGLmmB,eAAgB,CACd,wBAAyB9iC,CADX,CAEd,gCAAiCwF,CAFnB,CAHX,CADqC,CAA/B,CASZ,CAACA,CAAD,CAAYxF,CAAZ,CAAyB2c,CAAzB,CAAsCgmB,CAAtC,CATY,CAUf,KAAI7iB,EAAkB6hB,CAAA,CAAWA,CAAAv8B,SAAA3F,YAAX,CAA2C,IAC7DmgB,EAAAA,CAAmBja,CAAAC,QAAA,CAAmB,QAAS,EAAG,CACpD,MAAO,CACL5F,YAAaA,CADR,CAELlF,KAAMA,CAFD,CAGLglB,gBAAiBA,CAHZ,CAD6C,CAA/B,CAMpB,CAAC9f,CAAD,CAAc8f,CAAd,CAA+BhlB,CAA/B,CANoB,CA4BvB,OAAO6c,GAAA5L,cAAA,CAA6B8T,EAAAhI,SAA7B,CAAwD,CAC7DhN,MAAO+U,CADsD,CAAxD,CAEJ3H,CAAA,CAAS2b,CAAT,CAAmB/V,CAAnB,CAFI,CApBPklB,QAAiB,EAAG,CAClB,GAAI,CAACpB,CAAL,CACE,MAAO,KAFS,KAKdv8B,EAAWu8B,CAAAv8B,SALG,CAMd0c,EAAS6f,CAAA7f,OANK,CAOdkhB,EAAOrrB,EAAA5L,cAAA,CAA6B4T,EAA7B,CAA+C,CACxDlgB,YAAa2F,CAAA3F,YAD2C,CAExD9C,MAAOyI,CAAA8c,OAAAvlB,MAFiD,CAGxDygB,QAAS,CAAA,CAH+C,CAIxDhM,UAAW,CAAA,CAJ6C,CAKxD5C,wBAAyB,CAAA,CAL+B,CAMxD4D,2BAA4B,CAAA,CAN4B,CAA/C,CAOR,QAAS,CAAC6wB,CAAD,CAAoBC,CAApB,CAAuC,CACjD,MAAOphB,EAAA,CAAOmhB,CAAP;AAA0BC,CAA1B,CAA6C99B,CAA7C,CAD0C,CAPxC,CAUX,OAAOgb,GAAA+iB,aAAA,CAAsBH,CAAtB,CAA4BN,CAAA,EAA5B,CAjBW,CAsBa,EAF1B,CA5GiB,CA6QD,CAKzBvB,GAAAiC,aAAA,CAfmBA,CACjB99B,KAAM,UADW89B,CAEjBtoC,KAAM,SAFWsoC,CAGjBzpB,UAAW,UAHMypB,CAIjBxpB,eAAgB,CAAA,CAJCwpB,CAKjBvpB,iBAAkB,CAAA,CALDupB,CAMjBrpB,wBAAyB,CAAA,CANRqpB,CAOjBnB,YAAa,IAPImB,CAQjBV,qBAbFW,QAAgB,EAAG,CAChB7gC,QAAAsE,KAAD,CAA6H,IAAK,EAAlI,CAA0G5K,CAAA,CAAU,CAAA,CAAV,CAC1G,OAAOsG,SAAAsE,KAFU,CAKAs8B,CAiBnB1oC,EAAA4oC,gBAAA,CAthDAA,QAAwB,CAAC1uB,CAAD,CAAQ,CAC9B,IAAIpP,EAAYG,CAAAC,QAAA,CAAmB,QAAS,EAAG,CAC7C,MAAO,EAAP,CAAYw3B,EAAA,EADiC,CAA/B,CAEb,EAFa,CAAhB,CAGI5wB,EAAkBoI,CAAApI,gBAAlBA,EA9nNgBA,mGA+nNpB,OAAOmL,GAAA5L,cAAA,CAA6BwU,EAA7B,CAA4C,IAA5C;AAAkD,QAAS,CAAC1L,CAAD,CAAe,CAC/E,MAAO8C,GAAA5L,cAAA,CAA6B4I,EAA7B,CAAkC,CACvClP,MAAOmP,CAAAnP,MADgC,CAEvCD,UAAWA,CAF4B,CAGvCqP,aAAcA,CAHyB,CAIvCrI,gBAAiBA,CAJsB,CAKvCoH,qBAAsBgB,CAAAhB,qBALiB,CAMvCkB,QAASF,CAAAE,QAN8B,CAOvCI,kBAAmBN,CAAAM,kBAPoB,CAQvCC,YAAaP,CAAAO,YAR0B,CASvCE,aAAcT,CAAAS,aATyB,CAUvCD,UAAWR,CAAAQ,UAV4B,CAAlC,CAWJR,CAAAqD,SAXI,CADwE,CAA1E,CALuB,CAuhDhCvd,EAAA0lC,UAAA,CAjSAmD,QAAwB,CAAC3uB,CAAD,CAAQ,CAI9B,MAAO+C,GAAA5L,cAAA,CAA6B4T,EAA7B,CAA+ClkB,CAAA,CAAS,EAAT,CAAamZ,CAAb,CAAoB,CACxEwI,QAAS,CAAA,CAD+D,CAExEhM,UAL8C,SAAhCA,GAAA,MAAOwD,EAAA4uB,eAAPpyB,CAA4C,CAACwD,CAAA4uB,eAA7CpyB,CAAoE,CAAA,CAGV,CAGxEgB,2BAL+BA,CAAAA,CAAQwC,CAAA6uB,kCAEiC,CAIxEj1B,wBAL4BA,CAAAA,CAAQoG,CAAApG,wBACoC,CAApB,CAA/C,CAJuB,CAkShC9T;CAAA6nC,UAAA,CAAoBpB,EACpBzmC,EAAAgpC,mBAAA,CA5hDAA,QAA2B,EAAG,CAC5BtG,EAAA,CAAgB,CADY,CA3yNgC;\",\n\"sources\":[\"node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.cjs.js\"],\n\"sourcesContent\":[\"shadow$provide[121] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\\n\\nvar React = require('react');\\nvar React__default = _interopDefault(React);\\nvar useMemoOne = require('use-memo-one');\\nvar _inheritsLoose = _interopDefault(require('@babel/runtime-corejs2/helpers/inheritsLoose'));\\nvar _extends = _interopDefault(require('@babel/runtime-corejs2/helpers/extends'));\\nvar redux = require('redux');\\nvar reactRedux = require('react-redux');\\nvar cssBoxModel = require('css-box-model');\\nvar memoizeOne = _interopDefault(require('memoize-one'));\\nvar _Object$values = _interopDefault(require('@babel/runtime-corejs2/core-js/object/values'));\\nvar _Object$keys = _interopDefault(require('@babel/runtime-corejs2/core-js/object/keys'));\\nvar rafSchd = _interopDefault(require('raf-schd'));\\nvar _Date$now = _interopDefault(require('@babel/runtime-corejs2/core-js/date/now'));\\nvar _Object$assign = _interopDefault(require('@babel/runtime-corejs2/core-js/object/assign'));\\nvar ReactDOM = _interopDefault(require('react-dom'));\\nvar _Number$isInteger = _interopDefault(require('@babel/runtime-corejs2/core-js/number/is-integer'));\\n\\nvar isProduction = process.env.NODE_ENV === 'production';\\nvar spacesAndTabs = /[ \\\\t]{2,}/g;\\nvar lineStartWithSpaces = /^[ \\\\t]*/gm;\\n\\nvar clean = function clean(value) {\\n  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\\n};\\n\\nvar getDevMessage = function getDevMessage(message) {\\n  return clean(\\\"\\\\n  %creact-beautiful-dnd\\\\n\\\\n  %c\\\" + clean(message) + \\\"\\\\n\\\\n  %c\\\\uD83D\\\\uDC77\\\\u200D This is a development only message. It will be removed in production builds.\\\\n\\\");\\n};\\n\\nvar getFormattedMessage = function getFormattedMessage(message) {\\n  return [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];\\n};\\nvar isDisabledFlag = '__react-beautiful-dnd-disable-dev-warnings';\\nfunction log(type, message) {\\n  var _console;\\n\\n  if (isProduction) {\\n    return;\\n  }\\n\\n  if (typeof window !== 'undefined' && window[isDisabledFlag]) {\\n    return;\\n  }\\n\\n  (_console = console)[type].apply(_console, getFormattedMessage(message));\\n}\\nvar warning = log.bind(null, 'warn');\\nvar error = log.bind(null, 'error');\\n\\nfunction noop() {}\\n\\nfunction getOptions(shared, fromBinding) {\\n  return _extends({}, shared, {}, fromBinding);\\n}\\n\\nfunction bindEvents(el, bindings, sharedOptions) {\\n  var unbindings = bindings.map(function (binding) {\\n    var options = getOptions(sharedOptions, binding.options);\\n    el.addEventListener(binding.eventName, binding.fn, options);\\n    return function unbind() {\\n      el.removeEventListener(binding.eventName, binding.fn, options);\\n    };\\n  });\\n  return function unbindAll() {\\n    unbindings.forEach(function (unbind) {\\n      unbind();\\n    });\\n  };\\n}\\n\\nvar isProduction$1 = process.env.NODE_ENV === 'production';\\nvar prefix = 'Invariant failed';\\nfunction RbdInvariant(message) {\\n  this.message = message;\\n}\\n\\nRbdInvariant.prototype.toString = function toString() {\\n  return this.message;\\n};\\n\\nfunction invariant(condition, message) {\\n  if (condition) {\\n    return;\\n  }\\n\\n  if (isProduction$1) {\\n    throw new RbdInvariant(prefix);\\n  } else {\\n    throw new RbdInvariant(prefix + \\\": \\\" + (message || ''));\\n  }\\n}\\n\\nvar ErrorBoundary = function (_React$Component) {\\n  _inheritsLoose(ErrorBoundary, _React$Component);\\n\\n  function ErrorBoundary() {\\n    var _this;\\n\\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\\n    _this.callbacks = null;\\n    _this.unbind = noop;\\n\\n    _this.onWindowError = function (event) {\\n      var callbacks = _this.getCallbacks();\\n\\n      if (callbacks.isDragging()) {\\n        callbacks.tryAbort();\\n        process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n        An error was caught by our window 'error' event listener while a drag was occurring.\\\\n        The active drag has been aborted.\\\\n      \\\") : void 0;\\n      }\\n\\n      var err = event.error;\\n\\n      if (err instanceof RbdInvariant) {\\n        event.preventDefault();\\n\\n        if (process.env.NODE_ENV !== 'production') {\\n          error(err.message);\\n        }\\n      }\\n    };\\n\\n    _this.getCallbacks = function () {\\n      if (!_this.callbacks) {\\n        throw new Error('Unable to find AppCallbacks in <ErrorBoundary/>');\\n      }\\n\\n      return _this.callbacks;\\n    };\\n\\n    _this.setCallbacks = function (callbacks) {\\n      _this.callbacks = callbacks;\\n    };\\n\\n    return _this;\\n  }\\n\\n  var _proto = ErrorBoundary.prototype;\\n\\n  _proto.componentDidMount = function componentDidMount() {\\n    this.unbind = bindEvents(window, [{\\n      eventName: 'error',\\n      fn: this.onWindowError\\n    }]);\\n  };\\n\\n  _proto.componentWillUnmount = function componentWillUnmount() {\\n    this.unbind();\\n  };\\n\\n  _proto.componentDidCatch = function componentDidCatch(err) {\\n    if (err instanceof RbdInvariant) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        error(err.message);\\n      }\\n\\n      this.setState({});\\n      return;\\n    }\\n\\n    throw err;\\n  };\\n\\n  _proto.render = function render() {\\n    return this.props.children(this.setCallbacks);\\n  };\\n\\n  return ErrorBoundary;\\n}(React__default.Component);\\n\\nvar liftInstruction = \\\"Draggable item. Ensure your screen reader is not in browse mode and then press space bar to lift.\\\";\\n\\nvar position = function position(index) {\\n  return index + 1;\\n};\\n\\nvar onDragStart = function onDragStart(start) {\\n  return \\\"\\\\n  You have lifted an item in position \\\" + position(start.source.index) + \\\".\\\\n  Use the arrow keys to move, space bar to drop, and escape to cancel.\\\\n\\\";\\n};\\n\\nvar withLocation = function withLocation(source, destination) {\\n  var isInHomeList = source.droppableId === destination.droppableId;\\n  var startPosition = position(source.index);\\n  var endPosition = position(destination.index);\\n\\n  if (isInHomeList) {\\n    return \\\"\\\\n      You have moved the item from position \\\" + startPosition + \\\"\\\\n      to position \\\" + endPosition + \\\"\\\\n    \\\";\\n  }\\n\\n  return \\\"\\\\n    You have moved the item from position \\\" + startPosition + \\\"\\\\n    in list \\\" + source.droppableId + \\\"\\\\n    to list \\\" + destination.droppableId + \\\"\\\\n    in position \\\" + endPosition + \\\"\\\\n  \\\";\\n};\\n\\nvar withCombine = function withCombine(id, source, combine) {\\n  var inHomeList = source.droppableId === combine.droppableId;\\n\\n  if (inHomeList) {\\n    return \\\"\\\\n      The item \\\" + id + \\\"\\\\n      has been combined with \\\" + combine.draggableId;\\n  }\\n\\n  return \\\"\\\\n      The item \\\" + id + \\\"\\\\n      in list \\\" + source.droppableId + \\\"\\\\n      has been combined with \\\" + combine.draggableId + \\\"\\\\n      in list \\\" + combine.droppableId + \\\"\\\\n    \\\";\\n};\\n\\nvar onDragUpdate = function onDragUpdate(update) {\\n  var location = update.destination;\\n\\n  if (location) {\\n    return withLocation(update.source, location);\\n  }\\n\\n  var combine = update.combine;\\n\\n  if (combine) {\\n    return withCombine(update.draggableId, update.source, combine);\\n  }\\n\\n  return 'You are over an area that cannot be dropped on';\\n};\\n\\nvar returnedToStart = function returnedToStart(source) {\\n  return \\\"\\\\n  The item has returned to its starting position\\\\n  of \\\" + position(source.index) + \\\"\\\\n\\\";\\n};\\n\\nvar onDragEnd = function onDragEnd(result) {\\n  if (result.reason === 'CANCEL') {\\n    return \\\"\\\\n      Movement cancelled.\\\\n      \\\" + returnedToStart(result.source) + \\\"\\\\n    \\\";\\n  }\\n\\n  var location = result.destination;\\n  var combine = result.combine;\\n\\n  if (location) {\\n    return \\\"\\\\n      You have dropped the item.\\\\n      \\\" + withLocation(result.source, location) + \\\"\\\\n    \\\";\\n  }\\n\\n  if (combine) {\\n    return \\\"\\\\n      You have dropped the item.\\\\n      \\\" + withCombine(result.draggableId, result.source, combine) + \\\"\\\\n    \\\";\\n  }\\n\\n  return \\\"\\\\n    The item has been dropped while not over a drop area.\\\\n    \\\" + returnedToStart(result.source) + \\\"\\\\n  \\\";\\n};\\n\\nvar preset = {\\n  liftInstruction: liftInstruction,\\n  onDragStart: onDragStart,\\n  onDragUpdate: onDragUpdate,\\n  onDragEnd: onDragEnd\\n};\\n\\nvar origin = {\\n  x: 0,\\n  y: 0\\n};\\nvar add = function add(point1, point2) {\\n  return {\\n    x: point1.x + point2.x,\\n    y: point1.y + point2.y\\n  };\\n};\\nvar subtract = function subtract(point1, point2) {\\n  return {\\n    x: point1.x - point2.x,\\n    y: point1.y - point2.y\\n  };\\n};\\nvar isEqual = function isEqual(point1, point2) {\\n  return point1.x === point2.x && point1.y === point2.y;\\n};\\nvar negate = function negate(point) {\\n  return {\\n    x: point.x !== 0 ? -point.x : 0,\\n    y: point.y !== 0 ? -point.y : 0\\n  };\\n};\\nvar patch = function patch(line, value, otherValue) {\\n  var _ref;\\n\\n  if (otherValue === void 0) {\\n    otherValue = 0;\\n  }\\n\\n  return _ref = {}, _ref[line] = value, _ref[line === 'x' ? 'y' : 'x'] = otherValue, _ref;\\n};\\nvar distance = function distance(point1, point2) {\\n  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\\n};\\nvar closest = function closest(target, points) {\\n  return Math.min.apply(Math, points.map(function (point) {\\n    return distance(target, point);\\n  }));\\n};\\nvar apply = function apply(fn) {\\n  return function (point) {\\n    return {\\n      x: fn(point.x),\\n      y: fn(point.y)\\n    };\\n  };\\n};\\n\\nvar executeClip = (function (frame, subject) {\\n  var result = cssBoxModel.getRect({\\n    top: Math.max(subject.top, frame.top),\\n    right: Math.min(subject.right, frame.right),\\n    bottom: Math.min(subject.bottom, frame.bottom),\\n    left: Math.max(subject.left, frame.left)\\n  });\\n\\n  if (result.width <= 0 || result.height <= 0) {\\n    return null;\\n  }\\n\\n  return result;\\n});\\n\\nvar offsetByPosition = function offsetByPosition(spacing, point) {\\n  return {\\n    top: spacing.top + point.y,\\n    left: spacing.left + point.x,\\n    bottom: spacing.bottom + point.y,\\n    right: spacing.right + point.x\\n  };\\n};\\nvar getCorners = function getCorners(spacing) {\\n  return [{\\n    x: spacing.left,\\n    y: spacing.top\\n  }, {\\n    x: spacing.right,\\n    y: spacing.top\\n  }, {\\n    x: spacing.left,\\n    y: spacing.bottom\\n  }, {\\n    x: spacing.right,\\n    y: spacing.bottom\\n  }];\\n};\\nvar noSpacing = {\\n  top: 0,\\n  right: 0,\\n  bottom: 0,\\n  left: 0\\n};\\n\\nvar scroll = function scroll(target, frame) {\\n  if (!frame) {\\n    return target;\\n  }\\n\\n  return offsetByPosition(target, frame.scroll.diff.displacement);\\n};\\n\\nvar increase = function increase(target, axis, withPlaceholder) {\\n  if (withPlaceholder && withPlaceholder.increasedBy) {\\n    var _extends2;\\n\\n    return _extends({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));\\n  }\\n\\n  return target;\\n};\\n\\nvar clip = function clip(target, frame) {\\n  if (frame && frame.shouldClipSubject) {\\n    return executeClip(frame.pageMarginBox, target);\\n  }\\n\\n  return cssBoxModel.getRect(target);\\n};\\n\\nvar getSubject = (function (_ref) {\\n  var page = _ref.page,\\n      withPlaceholder = _ref.withPlaceholder,\\n      axis = _ref.axis,\\n      frame = _ref.frame;\\n  var scrolled = scroll(page.marginBox, frame);\\n  var increased = increase(scrolled, axis, withPlaceholder);\\n  var clipped = clip(increased, frame);\\n  return {\\n    page: page,\\n    withPlaceholder: withPlaceholder,\\n    active: clipped\\n  };\\n});\\n\\nvar scrollDroppable = (function (droppable, newScroll) {\\n  !droppable.frame ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false) : invariant(false) : void 0;\\n  var scrollable = droppable.frame;\\n  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);\\n  var scrollDisplacement = negate(scrollDiff);\\n\\n  var frame = _extends({}, scrollable, {\\n    scroll: {\\n      initial: scrollable.scroll.initial,\\n      current: newScroll,\\n      diff: {\\n        value: scrollDiff,\\n        displacement: scrollDisplacement\\n      },\\n      max: scrollable.scroll.max\\n    }\\n  });\\n\\n  var subject = getSubject({\\n    page: droppable.subject.page,\\n    withPlaceholder: droppable.subject.withPlaceholder,\\n    axis: droppable.axis,\\n    frame: frame\\n  });\\n\\n  var result = _extends({}, droppable, {\\n    frame: frame,\\n    subject: subject\\n  });\\n\\n  return result;\\n});\\n\\nfunction values(map) {\\n  return _Object$values(map);\\n}\\nfunction findIndex(list, predicate) {\\n  if (list.findIndex) {\\n    return list.findIndex(predicate);\\n  }\\n\\n  for (var i = 0; i < list.length; i++) {\\n    if (predicate(list[i])) {\\n      return i;\\n    }\\n  }\\n\\n  return -1;\\n}\\nfunction find(list, predicate) {\\n  if (list.find) {\\n    return list.find(predicate);\\n  }\\n\\n  var index = findIndex(list, predicate);\\n\\n  if (index !== -1) {\\n    return list[index];\\n  }\\n\\n  return undefined;\\n}\\nfunction toArray(list) {\\n  return Array.prototype.slice.call(list);\\n}\\n\\nvar toDroppableMap = memoizeOne(function (droppables) {\\n  return droppables.reduce(function (previous, current) {\\n    previous[current.descriptor.id] = current;\\n    return previous;\\n  }, {});\\n});\\nvar toDraggableMap = memoizeOne(function (draggables) {\\n  return draggables.reduce(function (previous, current) {\\n    previous[current.descriptor.id] = current;\\n    return previous;\\n  }, {});\\n});\\nvar toDroppableList = memoizeOne(function (droppables) {\\n  return values(droppables);\\n});\\nvar toDraggableList = memoizeOne(function (draggables) {\\n  return values(draggables);\\n});\\n\\nvar getDraggablesInsideDroppable = memoizeOne(function (droppableId, draggables) {\\n  var result = toDraggableList(draggables).filter(function (draggable) {\\n    return droppableId === draggable.descriptor.droppableId;\\n  }).sort(function (a, b) {\\n    return a.descriptor.index - b.descriptor.index;\\n  });\\n  return result;\\n});\\n\\nvar forward = {\\n  vertical: 'down',\\n  horizontal: 'right'\\n};\\nvar backward = {\\n  vertical: 'up',\\n  horizontal: 'left'\\n};\\n\\nfunction tryGetDestination(impact) {\\n  if (impact.at && impact.at.type === 'REORDER') {\\n    return impact.at.destination;\\n  }\\n\\n  return null;\\n}\\nfunction tryGetCombine(impact) {\\n  if (impact.at && impact.at.type === 'COMBINE') {\\n    return impact.at.combine;\\n  }\\n\\n  return null;\\n}\\n\\nvar removeDraggableFromList = memoizeOne(function (remove, list) {\\n  return list.filter(function (item) {\\n    return item.descriptor.id !== remove.descriptor.id;\\n  });\\n});\\n\\nvar moveToNextCombine = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      draggable = _ref.draggable,\\n      destination = _ref.destination,\\n      insideDestination = _ref.insideDestination,\\n      previousImpact = _ref.previousImpact;\\n\\n  if (!destination.isCombineEnabled) {\\n    return null;\\n  }\\n\\n  var location = tryGetDestination(previousImpact);\\n\\n  if (!location) {\\n    return null;\\n  }\\n\\n  function getImpact(target) {\\n    var at = {\\n      type: 'COMBINE',\\n      whenEntered: isMovingForward ? forward : backward,\\n      combine: {\\n        draggableId: target,\\n        droppableId: destination.descriptor.id\\n      }\\n    };\\n    return _extends({}, previousImpact, {\\n      at: at\\n    });\\n  }\\n\\n  var all = previousImpact.displaced.all;\\n  var closestId = all.length ? all[0] : null;\\n\\n  if (isMovingForward) {\\n    return closestId ? getImpact(closestId) : null;\\n  }\\n\\n  var withoutDraggable = removeDraggableFromList(draggable, insideDestination);\\n\\n  if (!closestId) {\\n    if (!withoutDraggable.length) {\\n      return null;\\n    }\\n\\n    var last = withoutDraggable[withoutDraggable.length - 1];\\n    return getImpact(last.descriptor.id);\\n  }\\n\\n  var indexOfClosest = findIndex(withoutDraggable, function (d) {\\n    return d.descriptor.id === closestId;\\n  });\\n  !(indexOfClosest !== -1) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find displaced item in set') : invariant(false) : void 0;\\n  var proposedIndex = indexOfClosest - 1;\\n\\n  if (proposedIndex < 0) {\\n    return null;\\n  }\\n\\n  var before = withoutDraggable[proposedIndex];\\n  return getImpact(before.descriptor.id);\\n});\\n\\nvar isHomeOf = (function (draggable, destination) {\\n  return draggable.descriptor.droppableId === destination.descriptor.id;\\n});\\n\\nvar noDisplacedBy = {\\n  point: origin,\\n  value: 0\\n};\\nvar emptyGroups = {\\n  invisible: {},\\n  visible: {},\\n  all: []\\n};\\nvar noImpact = {\\n  displaced: emptyGroups,\\n  displacedBy: noDisplacedBy,\\n  at: null\\n};\\n\\nvar isWithin = (function (lowerBound, upperBound) {\\n  return function (value) {\\n    return lowerBound <= value && value <= upperBound;\\n  };\\n});\\n\\nvar isPartiallyVisibleThroughFrame = (function (frame) {\\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\\n  return function (subject) {\\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\\n\\n    if (isContained) {\\n      return true;\\n    }\\n\\n    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\\n    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\\n    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\\n\\n    if (isPartiallyContained) {\\n      return true;\\n    }\\n\\n    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\\n    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\\n    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\\n\\n    if (isTargetBiggerThanFrame) {\\n      return true;\\n    }\\n\\n    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\\n    return isTargetBiggerOnOneAxis;\\n  };\\n});\\n\\nvar isTotallyVisibleThroughFrame = (function (frame) {\\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\\n  return function (subject) {\\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\\n    return isContained;\\n  };\\n});\\n\\nvar vertical = {\\n  direction: 'vertical',\\n  line: 'y',\\n  crossAxisLine: 'x',\\n  start: 'top',\\n  end: 'bottom',\\n  size: 'height',\\n  crossAxisStart: 'left',\\n  crossAxisEnd: 'right',\\n  crossAxisSize: 'width'\\n};\\nvar horizontal = {\\n  direction: 'horizontal',\\n  line: 'x',\\n  crossAxisLine: 'y',\\n  start: 'left',\\n  end: 'right',\\n  size: 'width',\\n  crossAxisStart: 'top',\\n  crossAxisEnd: 'bottom',\\n  crossAxisSize: 'height'\\n};\\n\\nvar isTotallyVisibleThroughFrameOnAxis = (function (axis) {\\n  return function (frame) {\\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\\n    return function (subject) {\\n      if (axis === vertical) {\\n        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\\n      }\\n\\n      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\\n    };\\n  };\\n});\\n\\nvar getDroppableDisplaced = function getDroppableDisplaced(target, destination) {\\n  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\\n  return offsetByPosition(target, displacement);\\n};\\n\\nvar isVisibleInDroppable = function isVisibleInDroppable(target, destination, isVisibleThroughFrameFn) {\\n  if (!destination.subject.active) {\\n    return false;\\n  }\\n\\n  return isVisibleThroughFrameFn(destination.subject.active)(target);\\n};\\n\\nvar isVisibleInViewport = function isVisibleInViewport(target, viewport, isVisibleThroughFrameFn) {\\n  return isVisibleThroughFrameFn(viewport)(target);\\n};\\n\\nvar isVisible = function isVisible(_ref) {\\n  var toBeDisplaced = _ref.target,\\n      destination = _ref.destination,\\n      viewport = _ref.viewport,\\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\\n      isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;\\n  var displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\\n  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\\n};\\n\\nvar isPartiallyVisible = function isPartiallyVisible(args) {\\n  return isVisible(_extends({}, args, {\\n    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\\n  }));\\n};\\nvar isTotallyVisible = function isTotallyVisible(args) {\\n  return isVisible(_extends({}, args, {\\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\\n  }));\\n};\\nvar isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis(args) {\\n  return isVisible(_extends({}, args, {\\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\\n  }));\\n};\\n\\nvar getShouldAnimate = function getShouldAnimate(id, last, forceShouldAnimate) {\\n  if (typeof forceShouldAnimate === 'boolean') {\\n    return forceShouldAnimate;\\n  }\\n\\n  if (!last) {\\n    return true;\\n  }\\n\\n  var invisible = last.invisible,\\n      visible = last.visible;\\n\\n  if (invisible[id]) {\\n    return false;\\n  }\\n\\n  var previous = visible[id];\\n  return previous ? previous.shouldAnimate : true;\\n};\\n\\nfunction getTarget(draggable, displacedBy) {\\n  var marginBox = draggable.page.marginBox;\\n  var expandBy = {\\n    top: displacedBy.point.y,\\n    right: 0,\\n    bottom: 0,\\n    left: displacedBy.point.x\\n  };\\n  return cssBoxModel.getRect(cssBoxModel.expand(marginBox, expandBy));\\n}\\n\\nfunction getDisplacementGroups(_ref) {\\n  var afterDragging = _ref.afterDragging,\\n      destination = _ref.destination,\\n      displacedBy = _ref.displacedBy,\\n      viewport = _ref.viewport,\\n      forceShouldAnimate = _ref.forceShouldAnimate,\\n      last = _ref.last;\\n  return afterDragging.reduce(function process(groups, draggable) {\\n    var target = getTarget(draggable, displacedBy);\\n    var id = draggable.descriptor.id;\\n    groups.all.push(id);\\n    var isVisible = isPartiallyVisible({\\n      target: target,\\n      destination: destination,\\n      viewport: viewport,\\n      withDroppableDisplacement: true\\n    });\\n\\n    if (!isVisible) {\\n      groups.invisible[draggable.descriptor.id] = true;\\n      return groups;\\n    }\\n\\n    var shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\\n    var displacement = {\\n      draggableId: id,\\n      shouldAnimate: shouldAnimate\\n    };\\n    groups.visible[id] = displacement;\\n    return groups;\\n  }, {\\n    all: [],\\n    visible: {},\\n    invisible: {}\\n  });\\n}\\n\\nfunction getIndexOfLastItem(draggables, options) {\\n  if (!draggables.length) {\\n    return 0;\\n  }\\n\\n  var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\\n  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\\n}\\n\\nfunction goAtEnd(_ref) {\\n  var insideDestination = _ref.insideDestination,\\n      inHomeList = _ref.inHomeList,\\n      displacedBy = _ref.displacedBy,\\n      destination = _ref.destination;\\n  var newIndex = getIndexOfLastItem(insideDestination, {\\n    inHomeList: inHomeList\\n  });\\n  return {\\n    displaced: emptyGroups,\\n    displacedBy: displacedBy,\\n    at: {\\n      type: 'REORDER',\\n      destination: {\\n        droppableId: destination.descriptor.id,\\n        index: newIndex\\n      }\\n    }\\n  };\\n}\\n\\nfunction calculateReorderImpact(_ref2) {\\n  var draggable = _ref2.draggable,\\n      insideDestination = _ref2.insideDestination,\\n      destination = _ref2.destination,\\n      viewport = _ref2.viewport,\\n      displacedBy = _ref2.displacedBy,\\n      last = _ref2.last,\\n      index = _ref2.index,\\n      forceShouldAnimate = _ref2.forceShouldAnimate;\\n  var inHomeList = isHomeOf(draggable, destination);\\n\\n  if (index == null) {\\n    return goAtEnd({\\n      insideDestination: insideDestination,\\n      inHomeList: inHomeList,\\n      displacedBy: displacedBy,\\n      destination: destination\\n    });\\n  }\\n\\n  var match = find(insideDestination, function (item) {\\n    return item.descriptor.index === index;\\n  });\\n\\n  if (!match) {\\n    return goAtEnd({\\n      insideDestination: insideDestination,\\n      inHomeList: inHomeList,\\n      displacedBy: displacedBy,\\n      destination: destination\\n    });\\n  }\\n\\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\\n  var sliceFrom = insideDestination.indexOf(match);\\n  var impacted = withoutDragging.slice(sliceFrom);\\n  var displaced = getDisplacementGroups({\\n    afterDragging: impacted,\\n    destination: destination,\\n    displacedBy: displacedBy,\\n    last: last,\\n    viewport: viewport.frame,\\n    forceShouldAnimate: forceShouldAnimate\\n  });\\n  return {\\n    displaced: displaced,\\n    displacedBy: displacedBy,\\n    at: {\\n      type: 'REORDER',\\n      destination: {\\n        droppableId: destination.descriptor.id,\\n        index: index\\n      }\\n    }\\n  };\\n}\\n\\nfunction didStartAfterCritical(draggableId, afterCritical) {\\n  return Boolean(afterCritical.effected[draggableId]);\\n}\\n\\nvar fromCombine = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      destination = _ref.destination,\\n      draggables = _ref.draggables,\\n      combine = _ref.combine,\\n      afterCritical = _ref.afterCritical;\\n\\n  if (!destination.isCombineEnabled) {\\n    return null;\\n  }\\n\\n  var combineId = combine.draggableId;\\n  var combineWith = draggables[combineId];\\n  var combineWithIndex = combineWith.descriptor.index;\\n  var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\\n\\n  if (didCombineWithStartAfterCritical) {\\n    if (isMovingForward) {\\n      return combineWithIndex;\\n    }\\n\\n    return combineWithIndex - 1;\\n  }\\n\\n  if (isMovingForward) {\\n    return combineWithIndex + 1;\\n  }\\n\\n  return combineWithIndex;\\n});\\n\\nvar fromReorder = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      isInHomeList = _ref.isInHomeList,\\n      insideDestination = _ref.insideDestination,\\n      location = _ref.location;\\n\\n  if (!insideDestination.length) {\\n    return null;\\n  }\\n\\n  var currentIndex = location.index;\\n  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\\n  var firstIndex = insideDestination[0].descriptor.index;\\n  var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\\n  var upperBound = isInHomeList ? lastIndex : lastIndex + 1;\\n\\n  if (proposedIndex < firstIndex) {\\n    return null;\\n  }\\n\\n  if (proposedIndex > upperBound) {\\n    return null;\\n  }\\n\\n  return proposedIndex;\\n});\\n\\nvar moveToNextIndex = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      isInHomeList = _ref.isInHomeList,\\n      draggable = _ref.draggable,\\n      draggables = _ref.draggables,\\n      destination = _ref.destination,\\n      insideDestination = _ref.insideDestination,\\n      previousImpact = _ref.previousImpact,\\n      viewport = _ref.viewport,\\n      afterCritical = _ref.afterCritical;\\n  var wasAt = previousImpact.at;\\n  !wasAt ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot move in direction without previous impact location') : invariant(false) : void 0;\\n\\n  if (wasAt.type === 'REORDER') {\\n    var _newIndex = fromReorder({\\n      isMovingForward: isMovingForward,\\n      isInHomeList: isInHomeList,\\n      location: wasAt.destination,\\n      insideDestination: insideDestination\\n    });\\n\\n    if (_newIndex == null) {\\n      return null;\\n    }\\n\\n    return calculateReorderImpact({\\n      draggable: draggable,\\n      insideDestination: insideDestination,\\n      destination: destination,\\n      viewport: viewport,\\n      last: previousImpact.displaced,\\n      displacedBy: previousImpact.displacedBy,\\n      index: _newIndex\\n    });\\n  }\\n\\n  var newIndex = fromCombine({\\n    isMovingForward: isMovingForward,\\n    destination: destination,\\n    displaced: previousImpact.displaced,\\n    draggables: draggables,\\n    combine: wasAt.combine,\\n    afterCritical: afterCritical\\n  });\\n\\n  if (newIndex == null) {\\n    return null;\\n  }\\n\\n  return calculateReorderImpact({\\n    draggable: draggable,\\n    insideDestination: insideDestination,\\n    destination: destination,\\n    viewport: viewport,\\n    last: previousImpact.displaced,\\n    displacedBy: previousImpact.displacedBy,\\n    index: newIndex\\n  });\\n});\\n\\nvar getCombinedItemDisplacement = (function (_ref) {\\n  var displaced = _ref.displaced,\\n      afterCritical = _ref.afterCritical,\\n      combineWith = _ref.combineWith,\\n      displacedBy = _ref.displacedBy;\\n  var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\\n\\n  if (didStartAfterCritical(combineWith, afterCritical)) {\\n    return isDisplaced ? origin : negate(displacedBy.point);\\n  }\\n\\n  return isDisplaced ? displacedBy.point : origin;\\n});\\n\\nvar whenCombining = (function (_ref) {\\n  var afterCritical = _ref.afterCritical,\\n      impact = _ref.impact,\\n      draggables = _ref.draggables;\\n  var combine = tryGetCombine(impact);\\n  !combine ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false) : invariant(false) : void 0;\\n  var combineWith = combine.draggableId;\\n  var center = draggables[combineWith].page.borderBox.center;\\n  var displaceBy = getCombinedItemDisplacement({\\n    displaced: impact.displaced,\\n    afterCritical: afterCritical,\\n    combineWith: combineWith,\\n    displacedBy: impact.displacedBy\\n  });\\n  return add(center, displaceBy);\\n});\\n\\nvar distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter(axis, box) {\\n  return box.margin[axis.start] + box.borderBox[axis.size] / 2;\\n};\\n\\nvar distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter(axis, box) {\\n  return box.margin[axis.end] + box.borderBox[axis.size] / 2;\\n};\\n\\nvar getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter(axis, target, isMoving) {\\n  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\\n};\\n\\nvar goAfter = function goAfter(_ref) {\\n  var axis = _ref.axis,\\n      moveRelativeTo = _ref.moveRelativeTo,\\n      isMoving = _ref.isMoving;\\n  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\\n};\\nvar goBefore = function goBefore(_ref2) {\\n  var axis = _ref2.axis,\\n      moveRelativeTo = _ref2.moveRelativeTo,\\n      isMoving = _ref2.isMoving;\\n  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\\n};\\nvar goIntoStart = function goIntoStart(_ref3) {\\n  var axis = _ref3.axis,\\n      moveInto = _ref3.moveInto,\\n      isMoving = _ref3.isMoving;\\n  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\\n};\\n\\nvar whenReordering = (function (_ref) {\\n  var impact = _ref.impact,\\n      draggable = _ref.draggable,\\n      draggables = _ref.draggables,\\n      droppable = _ref.droppable,\\n      afterCritical = _ref.afterCritical;\\n  var insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\\n  var draggablePage = draggable.page;\\n  var axis = droppable.axis;\\n\\n  if (!insideDestination.length) {\\n    return goIntoStart({\\n      axis: axis,\\n      moveInto: droppable.page,\\n      isMoving: draggablePage\\n    });\\n  }\\n\\n  var displaced = impact.displaced,\\n      displacedBy = impact.displacedBy;\\n  var closestAfter = displaced.all[0];\\n\\n  if (closestAfter) {\\n    var closest = draggables[closestAfter];\\n\\n    if (didStartAfterCritical(closestAfter, afterCritical)) {\\n      return goBefore({\\n        axis: axis,\\n        moveRelativeTo: closest.page,\\n        isMoving: draggablePage\\n      });\\n    }\\n\\n    var withDisplacement = cssBoxModel.offset(closest.page, displacedBy.point);\\n    return goBefore({\\n      axis: axis,\\n      moveRelativeTo: withDisplacement,\\n      isMoving: draggablePage\\n    });\\n  }\\n\\n  var last = insideDestination[insideDestination.length - 1];\\n\\n  if (last.descriptor.id === draggable.descriptor.id) {\\n    return draggablePage.borderBox.center;\\n  }\\n\\n  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\\n    var page = cssBoxModel.offset(last.page, negate(afterCritical.displacedBy.point));\\n    return goAfter({\\n      axis: axis,\\n      moveRelativeTo: page,\\n      isMoving: draggablePage\\n    });\\n  }\\n\\n  return goAfter({\\n    axis: axis,\\n    moveRelativeTo: last.page,\\n    isMoving: draggablePage\\n  });\\n});\\n\\nvar withDroppableDisplacement = (function (droppable, point) {\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    return point;\\n  }\\n\\n  return add(point, frame.scroll.diff.displacement);\\n});\\n\\nvar getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement(_ref) {\\n  var impact = _ref.impact,\\n      draggable = _ref.draggable,\\n      droppable = _ref.droppable,\\n      draggables = _ref.draggables,\\n      afterCritical = _ref.afterCritical;\\n  var original = draggable.page.borderBox.center;\\n  var at = impact.at;\\n\\n  if (!droppable) {\\n    return original;\\n  }\\n\\n  if (!at) {\\n    return original;\\n  }\\n\\n  if (at.type === 'REORDER') {\\n    return whenReordering({\\n      impact: impact,\\n      draggable: draggable,\\n      draggables: draggables,\\n      droppable: droppable,\\n      afterCritical: afterCritical\\n    });\\n  }\\n\\n  return whenCombining({\\n    impact: impact,\\n    draggables: draggables,\\n    afterCritical: afterCritical\\n  });\\n};\\n\\nvar getPageBorderBoxCenterFromImpact = (function (args) {\\n  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);\\n  var droppable = args.droppable;\\n  var withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\\n  return withDisplacement;\\n});\\n\\nvar scrollViewport = (function (viewport, newScroll) {\\n  var diff = subtract(newScroll, viewport.scroll.initial);\\n  var displacement = negate(diff);\\n  var frame = cssBoxModel.getRect({\\n    top: newScroll.y,\\n    bottom: newScroll.y + viewport.frame.height,\\n    left: newScroll.x,\\n    right: newScroll.x + viewport.frame.width\\n  });\\n  var updated = {\\n    frame: frame,\\n    scroll: {\\n      initial: viewport.scroll.initial,\\n      max: viewport.scroll.max,\\n      current: newScroll,\\n      diff: {\\n        value: diff,\\n        displacement: displacement\\n      }\\n    }\\n  };\\n  return updated;\\n});\\n\\nfunction getDraggables(ids, draggables) {\\n  return ids.map(function (id) {\\n    return draggables[id];\\n  });\\n}\\n\\nfunction tryGetVisible(id, groups) {\\n  for (var i = 0; i < groups.length; i++) {\\n    var displacement = groups[i].visible[id];\\n\\n    if (displacement) {\\n      return displacement;\\n    }\\n  }\\n\\n  return null;\\n}\\n\\nvar speculativelyIncrease = (function (_ref) {\\n  var impact = _ref.impact,\\n      viewport = _ref.viewport,\\n      destination = _ref.destination,\\n      draggables = _ref.draggables,\\n      maxScrollChange = _ref.maxScrollChange;\\n  var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\\n  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\\n  var last = impact.displaced;\\n  var withViewportScroll = getDisplacementGroups({\\n    afterDragging: getDraggables(last.all, draggables),\\n    destination: destination,\\n    displacedBy: impact.displacedBy,\\n    viewport: scrolledViewport.frame,\\n    last: last,\\n    forceShouldAnimate: false\\n  });\\n  var withDroppableScroll = getDisplacementGroups({\\n    afterDragging: getDraggables(last.all, draggables),\\n    destination: scrolledDroppable,\\n    displacedBy: impact.displacedBy,\\n    viewport: viewport.frame,\\n    last: last,\\n    forceShouldAnimate: false\\n  });\\n  var invisible = {};\\n  var visible = {};\\n  var groups = [last, withViewportScroll, withDroppableScroll];\\n  last.all.forEach(function (id) {\\n    var displacement = tryGetVisible(id, groups);\\n\\n    if (displacement) {\\n      visible[id] = displacement;\\n      return;\\n    }\\n\\n    invisible[id] = true;\\n  });\\n\\n  var newImpact = _extends({}, impact, {\\n    displaced: {\\n      all: last.all,\\n      invisible: invisible,\\n      visible: visible\\n    }\\n  });\\n\\n  return newImpact;\\n});\\n\\nvar withViewportDisplacement = (function (viewport, point) {\\n  return add(viewport.scroll.diff.displacement, point);\\n});\\n\\nvar getClientFromPageBorderBoxCenter = (function (_ref) {\\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\\n      draggable = _ref.draggable,\\n      viewport = _ref.viewport;\\n  var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\\n  var offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\\n  return add(draggable.client.borderBox.center, offset);\\n});\\n\\nvar isTotallyVisibleInNewLocation = (function (_ref) {\\n  var draggable = _ref.draggable,\\n      destination = _ref.destination,\\n      newPageBorderBoxCenter = _ref.newPageBorderBoxCenter,\\n      viewport = _ref.viewport,\\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\\n      _ref$onlyOnMainAxis = _ref.onlyOnMainAxis,\\n      onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;\\n  var changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\\n  var shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\\n  var args = {\\n    target: shifted,\\n    destination: destination,\\n    withDroppableDisplacement: withDroppableDisplacement,\\n    viewport: viewport\\n  };\\n  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\\n});\\n\\nvar moveToNextPlace = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      draggable = _ref.draggable,\\n      destination = _ref.destination,\\n      draggables = _ref.draggables,\\n      previousImpact = _ref.previousImpact,\\n      viewport = _ref.viewport,\\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\\n      previousClientSelection = _ref.previousClientSelection,\\n      afterCritical = _ref.afterCritical;\\n\\n  if (!destination.isEnabled) {\\n    return null;\\n  }\\n\\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\\n  var isInHomeList = isHomeOf(draggable, destination);\\n  var impact = moveToNextCombine({\\n    isMovingForward: isMovingForward,\\n    draggable: draggable,\\n    destination: destination,\\n    insideDestination: insideDestination,\\n    previousImpact: previousImpact\\n  }) || moveToNextIndex({\\n    isMovingForward: isMovingForward,\\n    isInHomeList: isInHomeList,\\n    draggable: draggable,\\n    draggables: draggables,\\n    destination: destination,\\n    insideDestination: insideDestination,\\n    previousImpact: previousImpact,\\n    viewport: viewport,\\n    afterCritical: afterCritical\\n  });\\n\\n  if (!impact) {\\n    return null;\\n  }\\n\\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\\n    impact: impact,\\n    draggable: draggable,\\n    droppable: destination,\\n    draggables: draggables,\\n    afterCritical: afterCritical\\n  });\\n  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\\n    draggable: draggable,\\n    destination: destination,\\n    newPageBorderBoxCenter: pageBorderBoxCenter,\\n    viewport: viewport.frame,\\n    withDroppableDisplacement: false,\\n    onlyOnMainAxis: true\\n  });\\n\\n  if (isVisibleInNewLocation) {\\n    var clientSelection = getClientFromPageBorderBoxCenter({\\n      pageBorderBoxCenter: pageBorderBoxCenter,\\n      draggable: draggable,\\n      viewport: viewport\\n    });\\n    return {\\n      clientSelection: clientSelection,\\n      impact: impact,\\n      scrollJumpRequest: null\\n    };\\n  }\\n\\n  var distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\\n  var cautious = speculativelyIncrease({\\n    impact: impact,\\n    viewport: viewport,\\n    destination: destination,\\n    draggables: draggables,\\n    maxScrollChange: distance\\n  });\\n  return {\\n    clientSelection: previousClientSelection,\\n    impact: cautious,\\n    scrollJumpRequest: distance\\n  };\\n});\\n\\nvar getKnownActive = function getKnownActive(droppable) {\\n  var rect = droppable.subject.active;\\n  !rect ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot get clipped area from droppable') : invariant(false) : void 0;\\n  return rect;\\n};\\n\\nvar getBestCrossAxisDroppable = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      pageBorderBoxCenter = _ref.pageBorderBoxCenter,\\n      source = _ref.source,\\n      droppables = _ref.droppables,\\n      viewport = _ref.viewport;\\n  var active = source.subject.active;\\n\\n  if (!active) {\\n    return null;\\n  }\\n\\n  var axis = source.axis;\\n  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\\n  var candidates = toDroppableList(droppables).filter(function (droppable) {\\n    return droppable !== source;\\n  }).filter(function (droppable) {\\n    return droppable.isEnabled;\\n  }).filter(function (droppable) {\\n    return Boolean(droppable.subject.active);\\n  }).filter(function (droppable) {\\n    return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable));\\n  }).filter(function (droppable) {\\n    var activeOfTarget = getKnownActive(droppable);\\n\\n    if (isMovingForward) {\\n      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\\n    }\\n\\n    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\\n  }).filter(function (droppable) {\\n    var activeOfTarget = getKnownActive(droppable);\\n    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\\n    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\\n  }).sort(function (a, b) {\\n    var first = getKnownActive(a)[axis.crossAxisStart];\\n    var second = getKnownActive(b)[axis.crossAxisStart];\\n\\n    if (isMovingForward) {\\n      return first - second;\\n    }\\n\\n    return second - first;\\n  }).filter(function (droppable, index, array) {\\n    return getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];\\n  });\\n\\n  if (!candidates.length) {\\n    return null;\\n  }\\n\\n  if (candidates.length === 1) {\\n    return candidates[0];\\n  }\\n\\n  var contains = candidates.filter(function (droppable) {\\n    var isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\\n    return isWithinDroppable(pageBorderBoxCenter[axis.line]);\\n  });\\n\\n  if (contains.length === 1) {\\n    return contains[0];\\n  }\\n\\n  if (contains.length > 1) {\\n    return contains.sort(function (a, b) {\\n      return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\\n    })[0];\\n  }\\n\\n  return candidates.sort(function (a, b) {\\n    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));\\n    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));\\n\\n    if (first !== second) {\\n      return first - second;\\n    }\\n\\n    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\\n  })[0];\\n});\\n\\nvar getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter(draggable, afterCritical) {\\n  var original = draggable.page.borderBox.center;\\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\\n};\\nvar getCurrentPageBorderBox = function getCurrentPageBorderBox(draggable, afterCritical) {\\n  var original = draggable.page.borderBox;\\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\\n};\\n\\nvar getClosestDraggable = (function (_ref) {\\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\\n      viewport = _ref.viewport,\\n      destination = _ref.destination,\\n      insideDestination = _ref.insideDestination,\\n      afterCritical = _ref.afterCritical;\\n  var sorted = insideDestination.filter(function (draggable) {\\n    return isTotallyVisible({\\n      target: getCurrentPageBorderBox(draggable, afterCritical),\\n      destination: destination,\\n      viewport: viewport.frame,\\n      withDroppableDisplacement: true\\n    });\\n  }).sort(function (a, b) {\\n    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\\n    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\\n\\n    if (distanceToA < distanceToB) {\\n      return -1;\\n    }\\n\\n    if (distanceToB < distanceToA) {\\n      return 1;\\n    }\\n\\n    return a.descriptor.index - b.descriptor.index;\\n  });\\n  return sorted[0] || null;\\n});\\n\\nvar getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {\\n  var displacement = displaceBy[axis.line];\\n  return {\\n    value: displacement,\\n    point: patch(axis.line, displacement)\\n  };\\n});\\n\\nvar getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables) {\\n  var axis = droppable.axis;\\n\\n  if (droppable.descriptor.mode === 'virtual') {\\n    return patch(axis.line, placeholderSize[axis.line]);\\n  }\\n\\n  var availableSpace = droppable.subject.page.contentBox[axis.size];\\n  var insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\\n  var spaceUsed = insideDroppable.reduce(function (sum, dimension) {\\n    return sum + dimension.client.marginBox[axis.size];\\n  }, 0);\\n  var requiredSpace = spaceUsed + placeholderSize[axis.line];\\n  var needsToGrowBy = requiredSpace - availableSpace;\\n\\n  if (needsToGrowBy <= 0) {\\n    return null;\\n  }\\n\\n  return patch(axis.line, needsToGrowBy);\\n};\\n\\nvar withMaxScroll = function withMaxScroll(frame, max) {\\n  return _extends({}, frame, {\\n    scroll: _extends({}, frame.scroll, {\\n      max: max\\n    })\\n  });\\n};\\n\\nvar addPlaceholder = function addPlaceholder(droppable, draggable, draggables) {\\n  var frame = droppable.frame;\\n  !!isHomeOf(draggable, droppable) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Should not add placeholder space to home list') : invariant(false) : void 0;\\n  !!droppable.subject.withPlaceholder ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot add placeholder size to a subject when it already has one') : invariant(false) : void 0;\\n  var placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\\n  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\\n  var added = {\\n    placeholderSize: placeholderSize,\\n    increasedBy: requiredGrowth,\\n    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\\n  };\\n\\n  if (!frame) {\\n    var _subject = getSubject({\\n      page: droppable.subject.page,\\n      withPlaceholder: added,\\n      axis: droppable.axis,\\n      frame: droppable.frame\\n    });\\n\\n    return _extends({}, droppable, {\\n      subject: _subject\\n    });\\n  }\\n\\n  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\\n  var newFrame = withMaxScroll(frame, maxScroll);\\n  var subject = getSubject({\\n    page: droppable.subject.page,\\n    withPlaceholder: added,\\n    axis: droppable.axis,\\n    frame: newFrame\\n  });\\n  return _extends({}, droppable, {\\n    subject: subject,\\n    frame: newFrame\\n  });\\n};\\nvar removePlaceholder = function removePlaceholder(droppable) {\\n  var added = droppable.subject.withPlaceholder;\\n  !added ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot remove placeholder form subject when there was none') : invariant(false) : void 0;\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    var _subject2 = getSubject({\\n      page: droppable.subject.page,\\n      axis: droppable.axis,\\n      frame: null,\\n      withPlaceholder: null\\n    });\\n\\n    return _extends({}, droppable, {\\n      subject: _subject2\\n    });\\n  }\\n\\n  var oldMaxScroll = added.oldFrameMaxScroll;\\n  !oldMaxScroll ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected droppable with frame to have old max frame scroll when removing placeholder') : invariant(false) : void 0;\\n  var newFrame = withMaxScroll(frame, oldMaxScroll);\\n  var subject = getSubject({\\n    page: droppable.subject.page,\\n    axis: droppable.axis,\\n    frame: newFrame,\\n    withPlaceholder: null\\n  });\\n  return _extends({}, droppable, {\\n    subject: subject,\\n    frame: newFrame\\n  });\\n};\\n\\nvar moveToNewDroppable = (function (_ref) {\\n  var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\\n      moveRelativeTo = _ref.moveRelativeTo,\\n      insideDestination = _ref.insideDestination,\\n      draggable = _ref.draggable,\\n      draggables = _ref.draggables,\\n      destination = _ref.destination,\\n      viewport = _ref.viewport,\\n      afterCritical = _ref.afterCritical;\\n\\n  if (!moveRelativeTo) {\\n    if (insideDestination.length) {\\n      return null;\\n    }\\n\\n    var proposed = {\\n      displaced: emptyGroups,\\n      displacedBy: noDisplacedBy,\\n      at: {\\n        type: 'REORDER',\\n        destination: {\\n          droppableId: destination.descriptor.id,\\n          index: 0\\n        }\\n      }\\n    };\\n    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\\n      impact: proposed,\\n      draggable: draggable,\\n      droppable: destination,\\n      draggables: draggables,\\n      afterCritical: afterCritical\\n    });\\n    var withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\\n    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\\n      draggable: draggable,\\n      destination: withPlaceholder,\\n      newPageBorderBoxCenter: proposedPageBorderBoxCenter,\\n      viewport: viewport.frame,\\n      withDroppableDisplacement: false,\\n      onlyOnMainAxis: true\\n    });\\n    return isVisibleInNewLocation ? proposed : null;\\n  }\\n\\n  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\\n\\n  var proposedIndex = function () {\\n    var relativeTo = moveRelativeTo.descriptor.index;\\n\\n    if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\\n      return relativeTo;\\n    }\\n\\n    if (isGoingBeforeTarget) {\\n      return relativeTo;\\n    }\\n\\n    return relativeTo + 1;\\n  }();\\n\\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\\n  return calculateReorderImpact({\\n    draggable: draggable,\\n    insideDestination: insideDestination,\\n    destination: destination,\\n    viewport: viewport,\\n    displacedBy: displacedBy,\\n    last: emptyGroups,\\n    index: proposedIndex\\n  });\\n});\\n\\nvar moveCrossAxis = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\\n      draggable = _ref.draggable,\\n      isOver = _ref.isOver,\\n      draggables = _ref.draggables,\\n      droppables = _ref.droppables,\\n      viewport = _ref.viewport,\\n      afterCritical = _ref.afterCritical;\\n  var destination = getBestCrossAxisDroppable({\\n    isMovingForward: isMovingForward,\\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\\n    source: isOver,\\n    droppables: droppables,\\n    viewport: viewport\\n  });\\n\\n  if (!destination) {\\n    return null;\\n  }\\n\\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\\n  var moveRelativeTo = getClosestDraggable({\\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\\n    viewport: viewport,\\n    destination: destination,\\n    insideDestination: insideDestination,\\n    afterCritical: afterCritical\\n  });\\n  var impact = moveToNewDroppable({\\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\\n    destination: destination,\\n    draggable: draggable,\\n    draggables: draggables,\\n    moveRelativeTo: moveRelativeTo,\\n    insideDestination: insideDestination,\\n    viewport: viewport,\\n    afterCritical: afterCritical\\n  });\\n\\n  if (!impact) {\\n    return null;\\n  }\\n\\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\\n    impact: impact,\\n    draggable: draggable,\\n    droppable: destination,\\n    draggables: draggables,\\n    afterCritical: afterCritical\\n  });\\n  var clientSelection = getClientFromPageBorderBoxCenter({\\n    pageBorderBoxCenter: pageBorderBoxCenter,\\n    draggable: draggable,\\n    viewport: viewport\\n  });\\n  return {\\n    clientSelection: clientSelection,\\n    impact: impact,\\n    scrollJumpRequest: null\\n  };\\n});\\n\\nvar whatIsDraggedOver = (function (impact) {\\n  var at = impact.at;\\n\\n  if (!at) {\\n    return null;\\n  }\\n\\n  if (at.type === 'REORDER') {\\n    return at.destination.droppableId;\\n  }\\n\\n  return at.combine.droppableId;\\n});\\n\\nvar getDroppableOver = function getDroppableOver(impact, droppables) {\\n  var id = whatIsDraggedOver(impact);\\n  return id ? droppables[id] : null;\\n};\\n\\nvar moveInDirection = (function (_ref) {\\n  var state = _ref.state,\\n      type = _ref.type;\\n  var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);\\n  var isMainAxisMovementAllowed = Boolean(isActuallyOver);\\n  var home = state.dimensions.droppables[state.critical.droppable.id];\\n  var isOver = isActuallyOver || home;\\n  var direction = isOver.axis.direction;\\n  var isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');\\n\\n  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\\n    return null;\\n  }\\n\\n  var isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';\\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\\n  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\\n  var _state$dimensions = state.dimensions,\\n      draggables = _state$dimensions.draggables,\\n      droppables = _state$dimensions.droppables;\\n  return isMovingOnMainAxis ? moveToNextPlace({\\n    isMovingForward: isMovingForward,\\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\\n    draggable: draggable,\\n    destination: isOver,\\n    draggables: draggables,\\n    viewport: state.viewport,\\n    previousClientSelection: state.current.client.selection,\\n    previousImpact: state.impact,\\n    afterCritical: state.afterCritical\\n  }) : moveCrossAxis({\\n    isMovingForward: isMovingForward,\\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\\n    draggable: draggable,\\n    isOver: isOver,\\n    draggables: draggables,\\n    droppables: droppables,\\n    viewport: state.viewport,\\n    afterCritical: state.afterCritical\\n  });\\n});\\n\\nfunction isMovementAllowed(state) {\\n  return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';\\n}\\n\\nvar isPositionInFrame = (function (frame) {\\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\\n  return function (point) {\\n    return isWithinVertical(point.y) && isWithinVertical(point.y) && isWithinHorizontal(point.x) && isWithinHorizontal(point.x);\\n  };\\n});\\n\\nvar getDroppableOver$1 = (function (_ref) {\\n  var target = _ref.target,\\n      droppables = _ref.droppables;\\n  var maybe = find(toDroppableList(droppables), function (droppable) {\\n    if (!droppable.isEnabled) {\\n      return false;\\n    }\\n\\n    var active = droppable.subject.active;\\n\\n    if (!active) {\\n      return false;\\n    }\\n\\n    return isPositionInFrame(active)(target);\\n  });\\n  return maybe ? maybe.descriptor.id : null;\\n});\\n\\nvar withDroppableScroll = (function (droppable, point) {\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    return point;\\n  }\\n\\n  return add(point, frame.scroll.diff.value);\\n});\\n\\nvar isUserMovingForward = (function (axis, direction) {\\n  return axis === vertical ? direction.vertical === 'down' : direction.horizontal === 'right';\\n});\\n\\nfunction atIndex(_ref) {\\n  var draggable = _ref.draggable,\\n      closest = _ref.closest,\\n      inHomeList = _ref.inHomeList;\\n\\n  if (!closest) {\\n    return null;\\n  }\\n\\n  if (!inHomeList) {\\n    return closest.descriptor.index;\\n  }\\n\\n  if (closest.descriptor.index > draggable.descriptor.index) {\\n    return closest.descriptor.index - 1;\\n  }\\n\\n  return closest.descriptor.index;\\n}\\n\\nvar getReorderImpact = (function (_ref2) {\\n  var currentCenter = _ref2.pageBorderBoxCenterWithDroppableScrollChange,\\n      draggable = _ref2.draggable,\\n      destination = _ref2.destination,\\n      insideDestination = _ref2.insideDestination,\\n      last = _ref2.last,\\n      viewport = _ref2.viewport,\\n      userDirection = _ref2.userDirection,\\n      afterCritical = _ref2.afterCritical;\\n  var axis = destination.axis;\\n  var isMovingForward = isUserMovingForward(destination.axis, userDirection);\\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\\n  var targetCenter = currentCenter[axis.line];\\n  var displacement = displacedBy.value;\\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\\n  var closest = find(withoutDragging, function (child) {\\n    var id = child.descriptor.id;\\n    var borderBox = child.page.borderBox;\\n    var start = borderBox[axis.start];\\n    var end = borderBox[axis.end];\\n    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\\n\\n    if (isMovingForward) {\\n      if (didStartAfterCritical$1) {\\n        return targetCenter < start;\\n      }\\n\\n      return targetCenter < start + displacement;\\n    }\\n\\n    if (didStartAfterCritical$1) {\\n      return targetCenter <= end - displacement;\\n    }\\n\\n    return targetCenter <= end;\\n  });\\n  var newIndex = atIndex({\\n    draggable: draggable,\\n    closest: closest,\\n    inHomeList: isHomeOf(draggable, destination)\\n  });\\n  return calculateReorderImpact({\\n    draggable: draggable,\\n    insideDestination: insideDestination,\\n    destination: destination,\\n    viewport: viewport,\\n    last: last,\\n    displacedBy: displacedBy,\\n    index: newIndex\\n  });\\n});\\n\\nfunction getWhenEntered(id, current, lastCombineImpact) {\\n  if (!lastCombineImpact) {\\n    return current;\\n  }\\n\\n  if (id !== lastCombineImpact.combine.draggableId) {\\n    return current;\\n  }\\n\\n  return lastCombineImpact.whenEntered;\\n}\\n\\nfunction tryGetCombineImpact(impact) {\\n  if (impact.at && impact.at.type === 'COMBINE') {\\n    return impact.at;\\n  }\\n\\n  return null;\\n}\\n\\nfunction calculateCombineImpact(_ref) {\\n  var combineWithId = _ref.combineWithId,\\n      destinationId = _ref.destinationId,\\n      userDirection = _ref.userDirection,\\n      previousImpact = _ref.previousImpact;\\n  var lastCombineImpact = tryGetCombineImpact(previousImpact);\\n  var whenEntered = getWhenEntered(combineWithId, userDirection, lastCombineImpact);\\n  var impact = {\\n    displacedBy: previousImpact.displacedBy,\\n    displaced: previousImpact.displaced,\\n    at: {\\n      type: 'COMBINE',\\n      whenEntered: whenEntered,\\n      combine: {\\n        draggableId: combineWithId,\\n        droppableId: destinationId\\n      }\\n    }\\n  };\\n  return impact;\\n}\\n\\nfunction getWhenEntered$1(id, current, lastCombineImpact) {\\n  if (!lastCombineImpact) {\\n    return current;\\n  }\\n\\n  if (id !== lastCombineImpact.combine.draggableId) {\\n    return current;\\n  }\\n\\n  return lastCombineImpact.whenEntered;\\n}\\n\\nvar isCombiningWith = function isCombiningWith(_ref) {\\n  var id = _ref.id,\\n      currentCenter = _ref.currentCenter,\\n      axis = _ref.axis,\\n      borderBox = _ref.borderBox,\\n      displaceBy = _ref.displaceBy,\\n      currentUserDirection = _ref.currentUserDirection,\\n      lastCombineImpact = _ref.lastCombineImpact;\\n  var start = borderBox[axis.start] + displaceBy[axis.line];\\n  var end = borderBox[axis.end] + displaceBy[axis.line];\\n  var size = borderBox[axis.size];\\n  var twoThirdsOfSize = size * 0.666;\\n  var whenEntered = getWhenEntered$1(id, currentUserDirection, lastCombineImpact);\\n  var isMovingForward = isUserMovingForward(axis, whenEntered);\\n  var targetCenter = currentCenter[axis.line];\\n\\n  if (isMovingForward) {\\n    return isWithin(start, start + twoThirdsOfSize)(targetCenter);\\n  }\\n\\n  return isWithin(end - twoThirdsOfSize, end)(targetCenter);\\n};\\n\\nfunction tryGetCombineImpact$1(impact) {\\n  if (impact.at && impact.at.type === 'COMBINE') {\\n    return impact.at;\\n  }\\n\\n  return null;\\n}\\n\\nvar getCombineImpact = (function (_ref2) {\\n  var draggable = _ref2.draggable,\\n      currentCenter = _ref2.pageBorderBoxCenterWithDroppableScrollChange,\\n      previousImpact = _ref2.previousImpact,\\n      destination = _ref2.destination,\\n      insideDestination = _ref2.insideDestination,\\n      userDirection = _ref2.userDirection,\\n      afterCritical = _ref2.afterCritical;\\n\\n  if (!destination.isCombineEnabled) {\\n    return null;\\n  }\\n\\n  var axis = destination.axis;\\n  var displaced = previousImpact.displaced;\\n  var canBeDisplacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\\n  var lastCombineImpact = tryGetCombineImpact$1(previousImpact);\\n  var combineWith = find(removeDraggableFromList(draggable, insideDestination), function (child) {\\n    var id = child.descriptor.id;\\n    var displaceBy = getCombinedItemDisplacement({\\n      displaced: displaced,\\n      afterCritical: afterCritical,\\n      combineWith: id,\\n      displacedBy: canBeDisplacedBy\\n    });\\n    return isCombiningWith({\\n      id: id,\\n      currentCenter: currentCenter,\\n      axis: axis,\\n      borderBox: child.page.borderBox,\\n      displaceBy: displaceBy,\\n      currentUserDirection: userDirection,\\n      lastCombineImpact: lastCombineImpact\\n    });\\n  });\\n\\n  if (!combineWith) {\\n    return null;\\n  }\\n\\n  return calculateCombineImpact({\\n    combineWithId: combineWith.descriptor.id,\\n    destinationId: destination.descriptor.id,\\n    previousImpact: previousImpact,\\n    userDirection: userDirection\\n  });\\n});\\n\\nvar getDragImpact = (function (_ref) {\\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\\n      draggable = _ref.draggable,\\n      draggables = _ref.draggables,\\n      droppables = _ref.droppables,\\n      previousImpact = _ref.previousImpact,\\n      viewport = _ref.viewport,\\n      userDirection = _ref.userDirection,\\n      afterCritical = _ref.afterCritical;\\n  var destinationId = getDroppableOver$1({\\n    target: pageBorderBoxCenter,\\n    droppables: droppables\\n  });\\n\\n  if (!destinationId) {\\n    return noImpact;\\n  }\\n\\n  var destination = droppables[destinationId];\\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\\n  var pageBorderBoxCenterWithDroppableScrollChange = withDroppableScroll(destination, pageBorderBoxCenter);\\n  return getCombineImpact({\\n    pageBorderBoxCenterWithDroppableScrollChange: pageBorderBoxCenterWithDroppableScrollChange,\\n    draggable: draggable,\\n    previousImpact: previousImpact,\\n    destination: destination,\\n    insideDestination: insideDestination,\\n    userDirection: userDirection,\\n    afterCritical: afterCritical\\n  }) || getReorderImpact({\\n    pageBorderBoxCenterWithDroppableScrollChange: pageBorderBoxCenterWithDroppableScrollChange,\\n    draggable: draggable,\\n    destination: destination,\\n    insideDestination: insideDestination,\\n    last: previousImpact.displaced,\\n    viewport: viewport,\\n    userDirection: userDirection,\\n    afterCritical: afterCritical\\n  });\\n});\\n\\nvar getVertical = function getVertical(previous, diff) {\\n  if (diff === 0) {\\n    return previous;\\n  }\\n\\n  return diff > 0 ? 'down' : 'up';\\n};\\n\\nvar getHorizontal = function getHorizontal(previous, diff) {\\n  if (diff === 0) {\\n    return previous;\\n  }\\n\\n  return diff > 0 ? 'right' : 'left';\\n};\\n\\nvar getUserDirection = (function (previous, oldPageBorderBoxCenter, newPageBorderBoxCenter) {\\n  var diff = subtract(newPageBorderBoxCenter, oldPageBorderBoxCenter);\\n  return {\\n    horizontal: getHorizontal(previous.horizontal, diff.x),\\n    vertical: getVertical(previous.vertical, diff.y)\\n  };\\n});\\n\\nvar patchDroppableMap = (function (droppables, updated) {\\n  var _extends2;\\n\\n  return _extends({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));\\n});\\n\\nvar clearUnusedPlaceholder = function clearUnusedPlaceholder(_ref) {\\n  var previousImpact = _ref.previousImpact,\\n      impact = _ref.impact,\\n      droppables = _ref.droppables;\\n  var last = whatIsDraggedOver(previousImpact);\\n  var now = whatIsDraggedOver(impact);\\n\\n  if (!last) {\\n    return droppables;\\n  }\\n\\n  if (last === now) {\\n    return droppables;\\n  }\\n\\n  var lastDroppable = droppables[last];\\n\\n  if (!lastDroppable.subject.withPlaceholder) {\\n    return droppables;\\n  }\\n\\n  var updated = removePlaceholder(lastDroppable);\\n  return patchDroppableMap(droppables, updated);\\n};\\n\\nvar recomputePlaceholders = (function (_ref2) {\\n  var draggable = _ref2.draggable,\\n      draggables = _ref2.draggables,\\n      droppables = _ref2.droppables,\\n      previousImpact = _ref2.previousImpact,\\n      impact = _ref2.impact;\\n  var cleaned = clearUnusedPlaceholder({\\n    previousImpact: previousImpact,\\n    impact: impact,\\n    droppables: droppables\\n  });\\n  var isOver = whatIsDraggedOver(impact);\\n\\n  if (!isOver) {\\n    return cleaned;\\n  }\\n\\n  var droppable = droppables[isOver];\\n\\n  if (isHomeOf(draggable, droppable)) {\\n    return cleaned;\\n  }\\n\\n  if (droppable.subject.withPlaceholder) {\\n    return cleaned;\\n  }\\n\\n  var patched = addPlaceholder(droppable, draggable, draggables);\\n  return patchDroppableMap(cleaned, patched);\\n});\\n\\nvar update = (function (_ref) {\\n  var state = _ref.state,\\n      forcedClientSelection = _ref.clientSelection,\\n      forcedDimensions = _ref.dimensions,\\n      forcedViewport = _ref.viewport,\\n      forcedImpact = _ref.impact,\\n      scrollJumpRequest = _ref.scrollJumpRequest;\\n  var viewport = forcedViewport || state.viewport;\\n  var currentWindowScroll = viewport.scroll.current;\\n  var dimensions = forcedDimensions || state.dimensions;\\n  var clientSelection = forcedClientSelection || state.current.client.selection;\\n  var offset = subtract(clientSelection, state.initial.client.selection);\\n  var client = {\\n    offset: offset,\\n    selection: clientSelection,\\n    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\\n  };\\n  var page = {\\n    selection: add(client.selection, currentWindowScroll),\\n    borderBoxCenter: add(client.borderBoxCenter, currentWindowScroll)\\n  };\\n  var current = {\\n    client: client,\\n    page: page\\n  };\\n  var userDirection = getUserDirection(state.userDirection, state.current.page.borderBoxCenter, current.page.borderBoxCenter);\\n\\n  if (state.phase === 'COLLECTING') {\\n    return _extends({\\n      phase: 'COLLECTING'\\n    }, state, {\\n      dimensions: dimensions,\\n      viewport: viewport,\\n      current: current,\\n      userDirection: userDirection\\n    });\\n  }\\n\\n  var draggable = dimensions.draggables[state.critical.draggable.id];\\n  var newImpact = forcedImpact || getDragImpact({\\n    pageBorderBoxCenter: page.borderBoxCenter,\\n    draggable: draggable,\\n    draggables: dimensions.draggables,\\n    droppables: dimensions.droppables,\\n    previousImpact: state.impact,\\n    viewport: viewport,\\n    userDirection: userDirection,\\n    afterCritical: state.afterCritical\\n  });\\n  var withUpdatedPlaceholders = recomputePlaceholders({\\n    draggable: draggable,\\n    impact: newImpact,\\n    previousImpact: state.impact,\\n    draggables: dimensions.draggables,\\n    droppables: dimensions.droppables\\n  });\\n\\n  var result = _extends({}, state, {\\n    current: current,\\n    userDirection: userDirection,\\n    dimensions: {\\n      draggables: dimensions.draggables,\\n      droppables: withUpdatedPlaceholders\\n    },\\n    impact: newImpact,\\n    viewport: viewport,\\n    scrollJumpRequest: scrollJumpRequest || null,\\n    forceShouldAnimate: scrollJumpRequest ? false : null\\n  });\\n\\n  return result;\\n});\\n\\nfunction getDraggables$1(ids, draggables) {\\n  return ids.map(function (id) {\\n    return draggables[id];\\n  });\\n}\\n\\nvar recompute = (function (_ref) {\\n  var impact = _ref.impact,\\n      viewport = _ref.viewport,\\n      draggables = _ref.draggables,\\n      destination = _ref.destination,\\n      forceShouldAnimate = _ref.forceShouldAnimate;\\n  var last = impact.displaced;\\n  var afterDragging = getDraggables$1(last.all, draggables);\\n  var displaced = getDisplacementGroups({\\n    afterDragging: afterDragging,\\n    destination: destination,\\n    displacedBy: impact.displacedBy,\\n    viewport: viewport.frame,\\n    forceShouldAnimate: forceShouldAnimate,\\n    last: last\\n  });\\n  return _extends({}, impact, {\\n    displaced: displaced\\n  });\\n});\\n\\nvar getClientBorderBoxCenter = (function (_ref) {\\n  var impact = _ref.impact,\\n      draggable = _ref.draggable,\\n      droppable = _ref.droppable,\\n      draggables = _ref.draggables,\\n      viewport = _ref.viewport,\\n      afterCritical = _ref.afterCritical;\\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\\n    impact: impact,\\n    draggable: draggable,\\n    draggables: draggables,\\n    droppable: droppable,\\n    afterCritical: afterCritical\\n  });\\n  return getClientFromPageBorderBoxCenter({\\n    pageBorderBoxCenter: pageBorderBoxCenter,\\n    draggable: draggable,\\n    viewport: viewport\\n  });\\n});\\n\\nvar refreshSnap = (function (_ref) {\\n  var state = _ref.state,\\n      forcedDimensions = _ref.dimensions,\\n      forcedViewport = _ref.viewport;\\n  !(state.movementMode === 'SNAP') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false) : invariant(false) : void 0;\\n  var needsVisibilityCheck = state.impact;\\n  var viewport = forcedViewport || state.viewport;\\n  var dimensions = forcedDimensions || state.dimensions;\\n  var draggables = dimensions.draggables,\\n      droppables = dimensions.droppables;\\n  var draggable = draggables[state.critical.draggable.id];\\n  var isOver = whatIsDraggedOver(needsVisibilityCheck);\\n  !isOver ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Must be over a destination in SNAP movement mode') : invariant(false) : void 0;\\n  var destination = droppables[isOver];\\n  var impact = recompute({\\n    impact: needsVisibilityCheck,\\n    viewport: viewport,\\n    destination: destination,\\n    draggables: draggables\\n  });\\n  var clientSelection = getClientBorderBoxCenter({\\n    impact: impact,\\n    draggable: draggable,\\n    droppable: destination,\\n    draggables: draggables,\\n    viewport: viewport,\\n    afterCritical: state.afterCritical\\n  });\\n  return update({\\n    impact: impact,\\n    clientSelection: clientSelection,\\n    state: state,\\n    dimensions: dimensions,\\n    viewport: viewport\\n  });\\n});\\n\\nvar getHomeLocation = (function (descriptor) {\\n  return {\\n    index: descriptor.index,\\n    droppableId: descriptor.droppableId\\n  };\\n});\\n\\nvar getLiftEffect = (function (_ref) {\\n  var draggable = _ref.draggable,\\n      home = _ref.home,\\n      draggables = _ref.draggables,\\n      viewport = _ref.viewport;\\n  var displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\\n  var insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\\n  var rawIndex = insideHome.indexOf(draggable);\\n  !(rawIndex !== -1) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected draggable to be inside home list') : invariant(false) : void 0;\\n  var afterDragging = insideHome.slice(rawIndex + 1);\\n  var effected = afterDragging.reduce(function (previous, item) {\\n    previous[item.descriptor.id] = true;\\n    return previous;\\n  }, {});\\n  var afterCritical = {\\n    inVirtualList: home.descriptor.mode === 'virtual',\\n    displacedBy: displacedBy,\\n    effected: effected\\n  };\\n  var displaced = getDisplacementGroups({\\n    afterDragging: afterDragging,\\n    destination: home,\\n    displacedBy: displacedBy,\\n    last: null,\\n    viewport: viewport.frame,\\n    forceShouldAnimate: false\\n  });\\n  var impact = {\\n    displaced: displaced,\\n    displacedBy: displacedBy,\\n    at: {\\n      type: 'REORDER',\\n      destination: getHomeLocation(draggable.descriptor)\\n    }\\n  };\\n  return {\\n    impact: impact,\\n    afterCritical: afterCritical\\n  };\\n});\\n\\nvar patchDimensionMap = (function (dimensions, updated) {\\n  return {\\n    draggables: dimensions.draggables,\\n    droppables: patchDroppableMap(dimensions.droppables, updated)\\n  };\\n});\\n\\nvar records = {};\\nvar isEnabled = false;\\n\\nvar isTimingsEnabled = function isTimingsEnabled() {\\n  return isEnabled;\\n};\\nvar start = function start(key) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (!isTimingsEnabled()) {\\n      return;\\n    }\\n\\n    var now = performance.now();\\n    records[key] = now;\\n  }\\n};\\nvar finish = function finish(key) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (!isTimingsEnabled()) {\\n      return;\\n    }\\n\\n    var now = performance.now();\\n    var previous = records[key];\\n\\n    if (!previous) {\\n      console.warn('cannot finish timing as no previous time found', key);\\n      return;\\n    }\\n\\n    var result = now - previous;\\n    var rounded = result.toFixed(2);\\n\\n    var style = function () {\\n      if (result < 12) {\\n        return {\\n          textColor: 'green',\\n          symbol: '\\u2705'\\n        };\\n      }\\n\\n      if (result < 40) {\\n        return {\\n          textColor: 'orange',\\n          symbol: '\\u26a0\\ufe0f'\\n        };\\n      }\\n\\n      return {\\n        textColor: 'red',\\n        symbol: '\\u274c'\\n      };\\n    }();\\n\\n    console.log(style.symbol + \\\" %cTiming %c\\\" + rounded + \\\" %cms %c\\\" + key, 'color: blue; font-weight: bold;', \\\"color: \\\" + style.textColor + \\\"; font-size: 1.1em;\\\", 'color: grey;', 'color: purple; font-weight: bold;');\\n  }\\n};\\n\\nvar offsetDraggable = (function (_ref) {\\n  var draggable = _ref.draggable,\\n      offset = _ref.offset,\\n      initialWindowScroll = _ref.initialWindowScroll;\\n  var client = cssBoxModel.offset(draggable.client, offset);\\n  var page = cssBoxModel.withScroll(client, initialWindowScroll);\\n\\n  var moved = _extends({}, draggable, {\\n    placeholder: _extends({}, draggable.placeholder, {\\n      client: client\\n    }),\\n    client: client,\\n    page: page\\n  });\\n\\n  return moved;\\n});\\n\\nvar getFrame = (function (droppable) {\\n  var frame = droppable.frame;\\n  !frame ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected Droppable to have a frame') : invariant(false) : void 0;\\n  return frame;\\n});\\n\\nvar adjustAdditionsForScrollChanges = (function (_ref) {\\n  var additions = _ref.additions,\\n      updatedDroppables = _ref.updatedDroppables,\\n      viewport = _ref.viewport;\\n  var windowScrollChange = viewport.scroll.diff.value;\\n  return additions.map(function (draggable) {\\n    var droppableId = draggable.descriptor.droppableId;\\n    var modified = updatedDroppables[droppableId];\\n    var frame = getFrame(modified);\\n    var droppableScrollChange = frame.scroll.diff.value;\\n    var totalChange = add(windowScrollChange, droppableScrollChange);\\n    var moved = offsetDraggable({\\n      draggable: draggable,\\n      offset: totalChange,\\n      initialWindowScroll: viewport.scroll.initial\\n    });\\n    return moved;\\n  });\\n});\\n\\nvar timingsKey = 'Processing dynamic changes';\\nvar publishWhileDraggingInVirtual = (function (_ref) {\\n  var _extends2, _extends3;\\n\\n  var state = _ref.state,\\n      published = _ref.published;\\n  start(timingsKey);\\n  var withScrollChange = published.modified.map(function (update) {\\n    var existing = state.dimensions.droppables[update.droppableId];\\n    var scrolled = scrollDroppable(existing, update.scroll);\\n    return scrolled;\\n  });\\n\\n  var droppables = _extends({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));\\n\\n  var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\\n    additions: published.additions,\\n    updatedDroppables: droppables,\\n    viewport: state.viewport\\n  }));\\n\\n  var draggables = _extends({}, state.dimensions.draggables, {}, updatedAdditions);\\n\\n  published.removals.forEach(function (id) {\\n    delete draggables[id];\\n  });\\n  var dimensions = {\\n    droppables: droppables,\\n    draggables: draggables\\n  };\\n  var wasOverId = whatIsDraggedOver(state.impact);\\n  var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\\n  var draggable = dimensions.draggables[state.critical.draggable.id];\\n  var home = dimensions.droppables[state.critical.droppable.id];\\n\\n  var _getLiftEffect = getLiftEffect({\\n    draggable: draggable,\\n    home: home,\\n    draggables: draggables,\\n    viewport: state.viewport\\n  }),\\n      onLiftImpact = _getLiftEffect.impact,\\n      afterCritical = _getLiftEffect.afterCritical;\\n\\n  var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\\n  var impact = getDragImpact({\\n    pageBorderBoxCenter: state.current.page.borderBoxCenter,\\n    draggable: dimensions.draggables[state.critical.draggable.id],\\n    draggables: dimensions.draggables,\\n    droppables: dimensions.droppables,\\n    previousImpact: previousImpact,\\n    viewport: state.viewport,\\n    userDirection: state.userDirection,\\n    afterCritical: afterCritical\\n  });\\n  finish(timingsKey);\\n\\n  var draggingState = _extends({\\n    phase: 'DRAGGING'\\n  }, state, (_extends2 = {}, _extends2[\\\"phase\\\"] = 'DRAGGING', _extends2.impact = impact, _extends2.onLiftImpact = onLiftImpact, _extends2.dimensions = dimensions, _extends2.afterCritical = afterCritical, _extends2.forceShouldAnimate = false, _extends2));\\n\\n  if (state.phase === 'COLLECTING') {\\n    return draggingState;\\n  }\\n\\n  var dropPending = _extends({\\n    phase: 'DROP_PENDING'\\n  }, draggingState, (_extends3 = {}, _extends3[\\\"phase\\\"] = 'DROP_PENDING', _extends3.reason = state.reason, _extends3.isWaiting = false, _extends3));\\n\\n  return dropPending;\\n});\\n\\nvar isSnapping = function isSnapping(state) {\\n  return state.movementMode === 'SNAP';\\n};\\n\\nvar postDroppableChange = function postDroppableChange(state, updated, isEnabledChanging) {\\n  var dimensions = patchDimensionMap(state.dimensions, updated);\\n\\n  if (!isSnapping(state) || isEnabledChanging) {\\n    return update({\\n      state: state,\\n      dimensions: dimensions\\n    });\\n  }\\n\\n  return refreshSnap({\\n    state: state,\\n    dimensions: dimensions\\n  });\\n};\\n\\nfunction removeScrollJumpRequest(state) {\\n  if (state.isDragging && state.movementMode === 'SNAP') {\\n    return _extends({\\n      phase: 'DRAGGING'\\n    }, state, {\\n      scrollJumpRequest: null\\n    });\\n  }\\n\\n  return state;\\n}\\n\\nvar idle = {\\n  phase: 'IDLE',\\n  completed: null,\\n  shouldFlush: false\\n};\\nvar reducer = (function (state, action) {\\n  if (state === void 0) {\\n    state = idle;\\n  }\\n\\n  if (action.type === 'FLUSH') {\\n    return _extends({}, idle, {\\n      shouldFlush: true\\n    });\\n  }\\n\\n  if (action.type === 'INITIAL_PUBLISH') {\\n    !(state.phase === 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'INITIAL_PUBLISH must come after a IDLE phase') : invariant(false) : void 0;\\n    var _action$payload = action.payload,\\n        critical = _action$payload.critical,\\n        clientSelection = _action$payload.clientSelection,\\n        viewport = _action$payload.viewport,\\n        dimensions = _action$payload.dimensions,\\n        movementMode = _action$payload.movementMode;\\n    var draggable = dimensions.draggables[critical.draggable.id];\\n    var home = dimensions.droppables[critical.droppable.id];\\n    var client = {\\n      selection: clientSelection,\\n      borderBoxCenter: draggable.client.borderBox.center,\\n      offset: origin\\n    };\\n    var initial = {\\n      client: client,\\n      page: {\\n        selection: add(client.selection, viewport.scroll.initial),\\n        borderBoxCenter: add(client.selection, viewport.scroll.initial)\\n      }\\n    };\\n    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function (item) {\\n      return !item.isFixedOnPage;\\n    });\\n\\n    var _getLiftEffect = getLiftEffect({\\n      draggable: draggable,\\n      home: home,\\n      draggables: dimensions.draggables,\\n      viewport: viewport\\n    }),\\n        impact = _getLiftEffect.impact,\\n        afterCritical = _getLiftEffect.afterCritical;\\n\\n    var result = {\\n      phase: 'DRAGGING',\\n      isDragging: true,\\n      critical: critical,\\n      movementMode: movementMode,\\n      dimensions: dimensions,\\n      initial: initial,\\n      current: initial,\\n      isWindowScrollAllowed: isWindowScrollAllowed,\\n      impact: impact,\\n      afterCritical: afterCritical,\\n      onLiftImpact: impact,\\n      viewport: viewport,\\n      userDirection: forward,\\n      scrollJumpRequest: null,\\n      forceShouldAnimate: null\\n    };\\n    return result;\\n  }\\n\\n  if (action.type === 'COLLECTION_STARTING') {\\n    var _extends2;\\n\\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\\n      return state;\\n    }\\n\\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Collection cannot start from phase \\\" + state.phase) : invariant(false) : void 0;\\n\\n    var _result = _extends({\\n      phase: 'COLLECTING'\\n    }, state, (_extends2 = {}, _extends2[\\\"phase\\\"] = 'COLLECTING', _extends2));\\n\\n    return _result;\\n  }\\n\\n  if (action.type === 'PUBLISH_WHILE_DRAGGING') {\\n    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Unexpected \\\" + action.type + \\\" received in phase \\\" + state.phase) : invariant(false) : void 0;\\n    return publishWhileDraggingInVirtual({\\n      state: state,\\n      published: action.payload\\n    });\\n  }\\n\\n  if (action.type === 'MOVE') {\\n    if (state.phase === 'DROP_PENDING') {\\n      return state;\\n    }\\n\\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, action.type + \\\" not permitted in phase \\\" + state.phase) : invariant(false) : void 0;\\n    var _clientSelection = action.payload.client;\\n\\n    if (isEqual(_clientSelection, state.current.client.selection)) {\\n      return state;\\n    }\\n\\n    return update({\\n      state: state,\\n      clientSelection: _clientSelection,\\n      impact: isSnapping(state) ? state.impact : null\\n    });\\n  }\\n\\n  if (action.type === 'UPDATE_DROPPABLE_SCROLL') {\\n    if (state.phase === 'DROP_PENDING') {\\n      return removeScrollJumpRequest(state);\\n    }\\n\\n    if (state.phase === 'COLLECTING') {\\n      return removeScrollJumpRequest(state);\\n    }\\n\\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, action.type + \\\" not permitted in phase \\\" + state.phase) : invariant(false) : void 0;\\n    var _action$payload2 = action.payload,\\n        id = _action$payload2.id,\\n        newScroll = _action$payload2.newScroll;\\n    var target = state.dimensions.droppables[id];\\n\\n    if (!target) {\\n      return state;\\n    }\\n\\n    var scrolled = scrollDroppable(target, newScroll);\\n    return postDroppableChange(state, scrolled, false);\\n  }\\n\\n  if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {\\n    if (state.phase === 'DROP_PENDING') {\\n      return state;\\n    }\\n\\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Attempting to move in an unsupported phase \\\" + state.phase) : invariant(false) : void 0;\\n    var _action$payload3 = action.payload,\\n        _id = _action$payload3.id,\\n        isEnabled = _action$payload3.isEnabled;\\n    var _target = state.dimensions.droppables[_id];\\n    !_target ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot find Droppable[id: \\\" + _id + \\\"] to toggle its enabled state\\\") : invariant(false) : void 0;\\n    !(_target.isEnabled !== isEnabled) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Trying to set droppable isEnabled to \\\" + String(isEnabled) + \\\"\\\\n      but it is already \\\" + String(_target.isEnabled)) : invariant(false) : void 0;\\n\\n    var updated = _extends({}, _target, {\\n      isEnabled: isEnabled\\n    });\\n\\n    return postDroppableChange(state, updated, true);\\n  }\\n\\n  if (action.type === 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED') {\\n    if (state.phase === 'DROP_PENDING') {\\n      return state;\\n    }\\n\\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Attempting to move in an unsupported phase \\\" + state.phase) : invariant(false) : void 0;\\n    var _action$payload4 = action.payload,\\n        _id2 = _action$payload4.id,\\n        isCombineEnabled = _action$payload4.isCombineEnabled;\\n    var _target2 = state.dimensions.droppables[_id2];\\n    !_target2 ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot find Droppable[id: \\\" + _id2 + \\\"] to toggle its isCombineEnabled state\\\") : invariant(false) : void 0;\\n    !(_target2.isCombineEnabled !== isCombineEnabled) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Trying to set droppable isCombineEnabled to \\\" + String(isCombineEnabled) + \\\"\\\\n      but it is already \\\" + String(_target2.isCombineEnabled)) : invariant(false) : void 0;\\n\\n    var _updated = _extends({}, _target2, {\\n      isCombineEnabled: isCombineEnabled\\n    });\\n\\n    return postDroppableChange(state, _updated, true);\\n  }\\n\\n  if (action.type === 'MOVE_BY_WINDOW_SCROLL') {\\n    if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {\\n      return state;\\n    }\\n\\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot move by window in phase \\\" + state.phase) : invariant(false) : void 0;\\n    !state.isWindowScrollAllowed ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Window scrolling is currently not supported for fixed lists') : invariant(false) : void 0;\\n    var _newScroll = action.payload.newScroll;\\n\\n    if (isEqual(state.viewport.scroll.current, _newScroll)) {\\n      return removeScrollJumpRequest(state);\\n    }\\n\\n    var _viewport = scrollViewport(state.viewport, _newScroll);\\n\\n    if (isSnapping(state)) {\\n      return refreshSnap({\\n        state: state,\\n        viewport: _viewport\\n      });\\n    }\\n\\n    return update({\\n      state: state,\\n      viewport: _viewport\\n    });\\n  }\\n\\n  if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {\\n    if (!isMovementAllowed(state)) {\\n      return state;\\n    }\\n\\n    var maxScroll = action.payload.maxScroll;\\n\\n    if (isEqual(maxScroll, state.viewport.scroll.max)) {\\n      return state;\\n    }\\n\\n    var withMaxScroll = _extends({}, state.viewport, {\\n      scroll: _extends({}, state.viewport.scroll, {\\n        max: maxScroll\\n      })\\n    });\\n\\n    return _extends({\\n      phase: 'DRAGGING'\\n    }, state, {\\n      viewport: withMaxScroll\\n    });\\n  }\\n\\n  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {\\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\\n      return state;\\n    }\\n\\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, action.type + \\\" received while not in DRAGGING phase\\\") : invariant(false) : void 0;\\n\\n    var _result2 = moveInDirection({\\n      state: state,\\n      type: action.type\\n    });\\n\\n    if (!_result2) {\\n      return state;\\n    }\\n\\n    return update({\\n      state: state,\\n      impact: _result2.impact,\\n      clientSelection: _result2.clientSelection,\\n      scrollJumpRequest: _result2.scrollJumpRequest\\n    });\\n  }\\n\\n  if (action.type === 'DROP_PENDING') {\\n    var _extends3;\\n\\n    var reason = action.payload.reason;\\n    !(state.phase === 'COLLECTING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Can only move into the DROP_PENDING phase from the COLLECTING phase') : invariant(false) : void 0;\\n\\n    var newState = _extends({\\n      phase: 'DROP_PENDING'\\n    }, state, (_extends3 = {}, _extends3[\\\"phase\\\"] = 'DROP_PENDING', _extends3.isWaiting = true, _extends3.reason = reason, _extends3));\\n\\n    return newState;\\n  }\\n\\n  if (action.type === 'DROP_ANIMATE') {\\n    var _action$payload5 = action.payload,\\n        completed = _action$payload5.completed,\\n        dropDuration = _action$payload5.dropDuration,\\n        newHomeClientOffset = _action$payload5.newHomeClientOffset;\\n    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot animate drop from phase \\\" + state.phase) : invariant(false) : void 0;\\n    var _result3 = {\\n      phase: 'DROP_ANIMATING',\\n      completed: completed,\\n      dropDuration: dropDuration,\\n      newHomeClientOffset: newHomeClientOffset,\\n      dimensions: state.dimensions\\n    };\\n    return _result3;\\n  }\\n\\n  if (action.type === 'DROP_COMPLETE') {\\n    var _completed = action.payload.completed;\\n    return {\\n      phase: 'IDLE',\\n      completed: _completed,\\n      shouldFlush: false\\n    };\\n  }\\n\\n  return state;\\n});\\n\\nvar lift = function lift(args) {\\n  return {\\n    type: 'LIFT',\\n    payload: args\\n  };\\n};\\nvar initialPublish = function initialPublish(args) {\\n  return {\\n    type: 'INITIAL_PUBLISH',\\n    payload: args\\n  };\\n};\\nvar publishWhileDragging = function publishWhileDragging(args) {\\n  return {\\n    type: 'PUBLISH_WHILE_DRAGGING',\\n    payload: args\\n  };\\n};\\nvar collectionStarting = function collectionStarting() {\\n  return {\\n    type: 'COLLECTION_STARTING',\\n    payload: null\\n  };\\n};\\nvar updateDroppableScroll = function updateDroppableScroll(args) {\\n  return {\\n    type: 'UPDATE_DROPPABLE_SCROLL',\\n    payload: args\\n  };\\n};\\nvar updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {\\n  return {\\n    type: 'UPDATE_DROPPABLE_IS_ENABLED',\\n    payload: args\\n  };\\n};\\nvar updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(args) {\\n  return {\\n    type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',\\n    payload: args\\n  };\\n};\\nvar move = function move(args) {\\n  return {\\n    type: 'MOVE',\\n    payload: args\\n  };\\n};\\nvar moveByWindowScroll = function moveByWindowScroll(args) {\\n  return {\\n    type: 'MOVE_BY_WINDOW_SCROLL',\\n    payload: args\\n  };\\n};\\nvar updateViewportMaxScroll = function updateViewportMaxScroll(args) {\\n  return {\\n    type: 'UPDATE_VIEWPORT_MAX_SCROLL',\\n    payload: args\\n  };\\n};\\nvar moveUp = function moveUp() {\\n  return {\\n    type: 'MOVE_UP',\\n    payload: null\\n  };\\n};\\nvar moveDown = function moveDown() {\\n  return {\\n    type: 'MOVE_DOWN',\\n    payload: null\\n  };\\n};\\nvar moveRight = function moveRight() {\\n  return {\\n    type: 'MOVE_RIGHT',\\n    payload: null\\n  };\\n};\\nvar moveLeft = function moveLeft() {\\n  return {\\n    type: 'MOVE_LEFT',\\n    payload: null\\n  };\\n};\\nvar flush = function flush() {\\n  return {\\n    type: 'FLUSH',\\n    payload: null\\n  };\\n};\\nvar animateDrop = function animateDrop(args) {\\n  return {\\n    type: 'DROP_ANIMATE',\\n    payload: args\\n  };\\n};\\nvar completeDrop = function completeDrop(args) {\\n  return {\\n    type: 'DROP_COMPLETE',\\n    payload: args\\n  };\\n};\\nvar drop = function drop(args) {\\n  return {\\n    type: 'DROP',\\n    payload: args\\n  };\\n};\\nvar dropPending = function dropPending(args) {\\n  return {\\n    type: 'DROP_PENDING',\\n    payload: args\\n  };\\n};\\nvar dropAnimationFinished = function dropAnimationFinished() {\\n  return {\\n    type: 'DROP_ANIMATION_FINISHED',\\n    payload: null\\n  };\\n};\\n\\nfunction checkIndexes(insideDestination) {\\n  if (insideDestination.length <= 1) {\\n    return;\\n  }\\n\\n  var indexes = insideDestination.map(function (d) {\\n    return d.descriptor.index;\\n  });\\n  var errors = {};\\n\\n  for (var i = 1; i < indexes.length; i++) {\\n    var current = indexes[i];\\n    var previous = indexes[i - 1];\\n\\n    if (current !== previous + 1) {\\n      errors[current] = true;\\n    }\\n  }\\n\\n  if (!_Object$keys(errors).length) {\\n    return;\\n  }\\n\\n  var formatted = indexes.map(function (index) {\\n    var hasError = Boolean(errors[index]);\\n    return hasError ? \\\"[\\\\uD83D\\\\uDD25\\\" + index + \\\"]\\\" : \\\"\\\" + index;\\n  }).join(', ');\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n    Detected non-consecutive <Draggable /> indexes.\\\\n\\\\n    (This can cause unexpected bugs)\\\\n\\\\n    \\\" + formatted + \\\"\\\\n  \\\") : void 0;\\n}\\n\\nfunction validateDimensions(critical, dimensions) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    var insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\\n    checkIndexes(insideDestination);\\n  }\\n}\\n\\nvar lift$1 = (function (marshal) {\\n  return function (_ref) {\\n    var getState = _ref.getState,\\n        dispatch = _ref.dispatch;\\n    return function (next) {\\n      return function (action) {\\n        if (action.type !== 'LIFT') {\\n          next(action);\\n          return;\\n        }\\n\\n        var _action$payload = action.payload,\\n            id = _action$payload.id,\\n            clientSelection = _action$payload.clientSelection,\\n            movementMode = _action$payload.movementMode;\\n        var initial = getState();\\n\\n        if (initial.phase === 'DROP_ANIMATING') {\\n          dispatch(completeDrop({\\n            completed: initial.completed\\n          }));\\n        }\\n\\n        !(getState().phase === 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Unexpected phase to start a drag') : invariant(false) : void 0;\\n        dispatch(flush());\\n        var scrollOptions = {\\n          shouldPublishImmediately: movementMode === 'SNAP'\\n        };\\n        var request = {\\n          draggableId: id,\\n          scrollOptions: scrollOptions\\n        };\\n\\n        var _marshal$startPublish = marshal.startPublishing(request),\\n            critical = _marshal$startPublish.critical,\\n            dimensions = _marshal$startPublish.dimensions,\\n            viewport = _marshal$startPublish.viewport;\\n\\n        validateDimensions(critical, dimensions);\\n        dispatch(initialPublish({\\n          critical: critical,\\n          dimensions: dimensions,\\n          clientSelection: clientSelection,\\n          movementMode: movementMode,\\n          viewport: viewport\\n        }));\\n      };\\n    };\\n  };\\n});\\n\\nvar style = (function (marshal) {\\n  return function () {\\n    return function (next) {\\n      return function (action) {\\n        if (action.type === 'INITIAL_PUBLISH') {\\n          marshal.dragging();\\n        }\\n\\n        if (action.type === 'DROP_ANIMATE') {\\n          marshal.dropping(action.payload.completed.result.reason);\\n        }\\n\\n        if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE') {\\n          marshal.resting();\\n        }\\n\\n        next(action);\\n      };\\n    };\\n  };\\n});\\n\\nvar curves = {\\n  outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',\\n  drop: 'cubic-bezier(.2,1,.1,1)'\\n};\\nvar combine = {\\n  opacity: {\\n    drop: 0,\\n    combining: 0.7\\n  },\\n  scale: {\\n    drop: 0.75\\n  }\\n};\\nvar timings = {\\n  outOfTheWay: 0.2,\\n  minDropTime: 0.33,\\n  maxDropTime: 0.55\\n};\\nvar outOfTheWayTiming = timings.outOfTheWay + \\\"s \\\" + curves.outOfTheWay;\\nvar transitions = {\\n  fluid: \\\"opacity \\\" + outOfTheWayTiming,\\n  snap: \\\"transform \\\" + outOfTheWayTiming + \\\", opacity \\\" + outOfTheWayTiming,\\n  drop: function drop(duration) {\\n    var timing = duration + \\\"s \\\" + curves.drop;\\n    return \\\"transform \\\" + timing + \\\", opacity \\\" + timing;\\n  },\\n  outOfTheWay: \\\"transform \\\" + outOfTheWayTiming,\\n  placeholder: \\\"height \\\" + outOfTheWayTiming + \\\", width \\\" + outOfTheWayTiming + \\\", margin \\\" + outOfTheWayTiming\\n};\\n\\nvar moveTo = function moveTo(offset) {\\n  return isEqual(offset, origin) ? null : \\\"translate(\\\" + offset.x + \\\"px, \\\" + offset.y + \\\"px)\\\";\\n};\\n\\nvar transforms = {\\n  moveTo: moveTo,\\n  drop: function drop(offset, isCombining) {\\n    var translate = moveTo(offset);\\n\\n    if (!translate) {\\n      return null;\\n    }\\n\\n    if (!isCombining) {\\n      return translate;\\n    }\\n\\n    return translate + \\\" scale(\\\" + combine.scale.drop + \\\")\\\";\\n  }\\n};\\n\\nvar minDropTime = timings.minDropTime,\\n    maxDropTime = timings.maxDropTime;\\nvar dropTimeRange = maxDropTime - minDropTime;\\nvar maxDropTimeAtDistance = 1500;\\nvar cancelDropModifier = 0.6;\\nvar getDropDuration = (function (_ref) {\\n  var current = _ref.current,\\n      destination = _ref.destination,\\n      reason = _ref.reason;\\n  var distance$1 = distance(current, destination);\\n\\n  if (distance$1 <= 0) {\\n    return minDropTime;\\n  }\\n\\n  if (distance$1 >= maxDropTimeAtDistance) {\\n    return maxDropTime;\\n  }\\n\\n  var percentage = distance$1 / maxDropTimeAtDistance;\\n  var duration = minDropTime + dropTimeRange * percentage;\\n  var withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;\\n  return Number(withDuration.toFixed(2));\\n});\\n\\nvar getNewHomeClientOffset = (function (_ref) {\\n  var impact = _ref.impact,\\n      draggable = _ref.draggable,\\n      dimensions = _ref.dimensions,\\n      viewport = _ref.viewport,\\n      afterCritical = _ref.afterCritical;\\n  var draggables = dimensions.draggables,\\n      droppables = dimensions.droppables;\\n  var droppableId = whatIsDraggedOver(impact);\\n  var destination = droppableId ? droppables[droppableId] : null;\\n  var home = droppables[draggable.descriptor.droppableId];\\n  var newClientCenter = getClientBorderBoxCenter({\\n    impact: impact,\\n    draggable: draggable,\\n    draggables: draggables,\\n    afterCritical: afterCritical,\\n    droppable: destination || home,\\n    viewport: viewport\\n  });\\n  var offset = subtract(newClientCenter, draggable.client.borderBox.center);\\n  return offset;\\n});\\n\\nvar getDropImpact = (function (_ref) {\\n  var draggables = _ref.draggables,\\n      reason = _ref.reason,\\n      lastImpact = _ref.lastImpact,\\n      home = _ref.home,\\n      viewport = _ref.viewport,\\n      onLiftImpact = _ref.onLiftImpact;\\n\\n  if (!lastImpact.at || reason !== 'DROP') {\\n    var recomputedHomeImpact = recompute({\\n      draggables: draggables,\\n      impact: onLiftImpact,\\n      destination: home,\\n      viewport: viewport,\\n      forceShouldAnimate: true\\n    });\\n    return {\\n      impact: recomputedHomeImpact,\\n      didDropInsideDroppable: false\\n    };\\n  }\\n\\n  if (lastImpact.at.type === 'REORDER') {\\n    return {\\n      impact: lastImpact,\\n      didDropInsideDroppable: true\\n    };\\n  }\\n\\n  var withoutMovement = _extends({}, lastImpact, {\\n    displaced: emptyGroups\\n  });\\n\\n  return {\\n    impact: withoutMovement,\\n    didDropInsideDroppable: true\\n  };\\n});\\n\\nvar drop$1 = (function (_ref) {\\n  var getState = _ref.getState,\\n      dispatch = _ref.dispatch;\\n  return function (next) {\\n    return function (action) {\\n      if (action.type !== 'DROP') {\\n        next(action);\\n        return;\\n      }\\n\\n      var state = getState();\\n      var reason = action.payload.reason;\\n\\n      if (state.phase === 'COLLECTING') {\\n        dispatch(dropPending({\\n          reason: reason\\n        }));\\n        return;\\n      }\\n\\n      if (state.phase === 'IDLE') {\\n        return;\\n      }\\n\\n      var isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;\\n      !!isWaitingForDrop ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : invariant(false) : void 0;\\n      !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot drop in phase: \\\" + state.phase) : invariant(false) : void 0;\\n      var critical = state.critical;\\n      var dimensions = state.dimensions;\\n      var draggable = dimensions.draggables[state.critical.draggable.id];\\n\\n      var _getDropImpact = getDropImpact({\\n        reason: reason,\\n        lastImpact: state.impact,\\n        afterCritical: state.afterCritical,\\n        onLiftImpact: state.onLiftImpact,\\n        home: state.dimensions.droppables[state.critical.droppable.id],\\n        viewport: state.viewport,\\n        draggables: state.dimensions.draggables\\n      }),\\n          impact = _getDropImpact.impact,\\n          didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;\\n\\n      var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\\n      var combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\\n      var source = {\\n        index: critical.draggable.index,\\n        droppableId: critical.droppable.id\\n      };\\n      var result = {\\n        draggableId: draggable.descriptor.id,\\n        type: draggable.descriptor.type,\\n        source: source,\\n        reason: reason,\\n        mode: state.movementMode,\\n        destination: destination,\\n        combine: combine\\n      };\\n      var newHomeClientOffset = getNewHomeClientOffset({\\n        impact: impact,\\n        draggable: draggable,\\n        dimensions: dimensions,\\n        viewport: state.viewport,\\n        afterCritical: state.afterCritical\\n      });\\n      var completed = {\\n        critical: state.critical,\\n        afterCritical: state.afterCritical,\\n        result: result,\\n        impact: impact\\n      };\\n      var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\\n\\n      if (!isAnimationRequired) {\\n        dispatch(completeDrop({\\n          completed: completed\\n        }));\\n        return;\\n      }\\n\\n      var dropDuration = getDropDuration({\\n        current: state.current.client.offset,\\n        destination: newHomeClientOffset,\\n        reason: reason\\n      });\\n      var args = {\\n        newHomeClientOffset: newHomeClientOffset,\\n        dropDuration: dropDuration,\\n        completed: completed\\n      };\\n      dispatch(animateDrop(args));\\n    };\\n  };\\n});\\n\\nvar getWindowScroll = (function () {\\n  return {\\n    x: window.pageXOffset,\\n    y: window.pageYOffset\\n  };\\n});\\n\\nfunction getWindowScrollBinding(update) {\\n  return {\\n    eventName: 'scroll',\\n    options: {\\n      passive: true,\\n      capture: false\\n    },\\n    fn: function fn(event) {\\n      if (event.target !== window && event.target !== window.document) {\\n        return;\\n      }\\n\\n      update();\\n    }\\n  };\\n}\\n\\nfunction getScrollListener(_ref) {\\n  var onWindowScroll = _ref.onWindowScroll;\\n\\n  function updateScroll() {\\n    onWindowScroll(getWindowScroll());\\n  }\\n\\n  var scheduled = rafSchd(updateScroll);\\n  var binding = getWindowScrollBinding(scheduled);\\n  var unbind = noop;\\n\\n  function isActive() {\\n    return unbind !== noop;\\n  }\\n\\n  function start() {\\n    !!isActive() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot start scroll listener when already active') : invariant(false) : void 0;\\n    unbind = bindEvents(window, [binding]);\\n  }\\n\\n  function stop() {\\n    !isActive() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot stop scroll listener when not active') : invariant(false) : void 0;\\n    scheduled.cancel();\\n    unbind();\\n    unbind = noop;\\n  }\\n\\n  return {\\n    start: start,\\n    stop: stop,\\n    isActive: isActive\\n  };\\n}\\n\\nvar shouldEnd = function shouldEnd(action) {\\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';\\n};\\n\\nvar scrollListener = (function (store) {\\n  var listener = getScrollListener({\\n    onWindowScroll: function onWindowScroll(newScroll) {\\n      store.dispatch(moveByWindowScroll({\\n        newScroll: newScroll\\n      }));\\n    }\\n  });\\n  return function (next) {\\n    return function (action) {\\n      if (!listener.isActive() && action.type === 'INITIAL_PUBLISH') {\\n        listener.start();\\n      }\\n\\n      if (listener.isActive() && shouldEnd(action)) {\\n        listener.stop();\\n      }\\n\\n      next(action);\\n    };\\n  };\\n});\\n\\nvar getExpiringAnnounce = (function (announce) {\\n  var wasCalled = false;\\n  var isExpired = false;\\n  var timeoutId = setTimeout(function () {\\n    isExpired = true;\\n  });\\n\\n  var result = function result(message) {\\n    if (wasCalled) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning('Announcement already made. Not making a second announcement') : void 0;\\n      return;\\n    }\\n\\n    if (isExpired) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n        Announcements cannot be made asynchronously.\\\\n        Default message has already been announced.\\\\n      \\\") : void 0;\\n      return;\\n    }\\n\\n    wasCalled = true;\\n    announce(message);\\n    clearTimeout(timeoutId);\\n  };\\n\\n  result.wasCalled = function () {\\n    return wasCalled;\\n  };\\n\\n  return result;\\n});\\n\\nvar getAsyncMarshal = (function () {\\n  var entries = [];\\n\\n  var execute = function execute(timerId) {\\n    var index = findIndex(entries, function (item) {\\n      return item.timerId === timerId;\\n    });\\n    !(index !== -1) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find timer') : invariant(false) : void 0;\\n\\n    var _entries$splice = entries.splice(index, 1),\\n        entry = _entries$splice[0];\\n\\n    entry.callback();\\n  };\\n\\n  var add = function add(fn) {\\n    var timerId = setTimeout(function () {\\n      return execute(timerId);\\n    });\\n    var entry = {\\n      timerId: timerId,\\n      callback: fn\\n    };\\n    entries.push(entry);\\n  };\\n\\n  var flush = function flush() {\\n    if (!entries.length) {\\n      return;\\n    }\\n\\n    var shallow = [].concat(entries);\\n    entries.length = 0;\\n    shallow.forEach(function (entry) {\\n      clearTimeout(entry.timerId);\\n      entry.callback();\\n    });\\n  };\\n\\n  return {\\n    add: add,\\n    flush: flush\\n  };\\n});\\n\\nvar areLocationsEqual = function areLocationsEqual(first, second) {\\n  if (first == null && second == null) {\\n    return true;\\n  }\\n\\n  if (first == null || second == null) {\\n    return false;\\n  }\\n\\n  return first.droppableId === second.droppableId && first.index === second.index;\\n};\\nvar isCombineEqual = function isCombineEqual(first, second) {\\n  if (first == null && second == null) {\\n    return true;\\n  }\\n\\n  if (first == null || second == null) {\\n    return false;\\n  }\\n\\n  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\\n};\\nvar isCriticalEqual = function isCriticalEqual(first, second) {\\n  if (first === second) {\\n    return true;\\n  }\\n\\n  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\\n  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\\n  return isDraggableEqual && isDroppableEqual;\\n};\\n\\nvar withTimings = function withTimings(key, fn) {\\n  start(key);\\n  fn();\\n  finish(key);\\n};\\n\\nvar getDragStart = function getDragStart(critical, mode) {\\n  return {\\n    draggableId: critical.draggable.id,\\n    type: critical.droppable.type,\\n    source: {\\n      droppableId: critical.droppable.id,\\n      index: critical.draggable.index\\n    },\\n    mode: mode\\n  };\\n};\\n\\nvar execute = function execute(responder, data, announce, getDefaultMessage) {\\n  if (!responder) {\\n    announce(getDefaultMessage(data));\\n    return;\\n  }\\n\\n  var willExpire = getExpiringAnnounce(announce);\\n  var provided = {\\n    announce: willExpire\\n  };\\n  responder(data, provided);\\n\\n  if (!willExpire.wasCalled()) {\\n    announce(getDefaultMessage(data));\\n  }\\n};\\n\\nvar getPublisher = (function (getResponders, announce) {\\n  var asyncMarshal = getAsyncMarshal();\\n  var dragging = null;\\n\\n  var beforeStart = function beforeStart(critical, mode) {\\n    !!dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\\n    withTimings('onBeforeDragStart', function () {\\n      var fn = getResponders().onBeforeDragStart;\\n\\n      if (fn) {\\n        fn(getDragStart(critical, mode));\\n      }\\n    });\\n  };\\n\\n  var start = function start(critical, mode) {\\n    !!dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\\n    var data = getDragStart(critical, mode);\\n    dragging = {\\n      mode: mode,\\n      lastCritical: critical,\\n      lastLocation: data.source,\\n      lastCombine: null\\n    };\\n    asyncMarshal.add(function () {\\n      withTimings('onDragStart', function () {\\n        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);\\n      });\\n    });\\n  };\\n\\n  var update = function update(critical, impact) {\\n    var location = tryGetDestination(impact);\\n    var combine = tryGetCombine(impact);\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : invariant(false) : void 0;\\n    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\\n\\n    if (hasCriticalChanged) {\\n      dragging.lastCritical = critical;\\n    }\\n\\n    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\\n\\n    if (hasLocationChanged) {\\n      dragging.lastLocation = location;\\n    }\\n\\n    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\\n\\n    if (hasGroupingChanged) {\\n      dragging.lastCombine = combine;\\n    }\\n\\n    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\\n      return;\\n    }\\n\\n    var data = _extends({}, getDragStart(critical, dragging.mode), {\\n      combine: combine,\\n      destination: location\\n    });\\n\\n    asyncMarshal.add(function () {\\n      withTimings('onDragUpdate', function () {\\n        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);\\n      });\\n    });\\n  };\\n\\n  var flush = function flush() {\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Can only flush responders while dragging') : invariant(false) : void 0;\\n    asyncMarshal.flush();\\n  };\\n\\n  var drop = function drop(result) {\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot fire onDragEnd when there is no matching onDragStart') : invariant(false) : void 0;\\n    dragging = null;\\n    withTimings('onDragEnd', function () {\\n      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);\\n    });\\n  };\\n\\n  var abort = function abort() {\\n    if (!dragging) {\\n      return;\\n    }\\n\\n    var result = _extends({}, getDragStart(dragging.lastCritical, dragging.mode), {\\n      combine: null,\\n      destination: null,\\n      reason: 'CANCEL'\\n    });\\n\\n    drop(result);\\n  };\\n\\n  return {\\n    beforeStart: beforeStart,\\n    start: start,\\n    update: update,\\n    flush: flush,\\n    drop: drop,\\n    abort: abort\\n  };\\n});\\n\\nvar responders = (function (getResponders, announce) {\\n  var publisher = getPublisher(getResponders, announce);\\n  return function (store) {\\n    return function (next) {\\n      return function (action) {\\n        if (action.type === 'INITIAL_PUBLISH') {\\n          var critical = action.payload.critical;\\n          publisher.beforeStart(critical, action.payload.movementMode);\\n          next(action);\\n          publisher.start(critical, action.payload.movementMode);\\n          return;\\n        }\\n\\n        if (action.type === 'DROP_COMPLETE') {\\n          var result = action.payload.completed.result;\\n          publisher.flush();\\n          next(action);\\n          publisher.drop(result);\\n          return;\\n        }\\n\\n        next(action);\\n\\n        if (action.type === 'FLUSH') {\\n          publisher.abort();\\n          return;\\n        }\\n\\n        var state = store.getState();\\n\\n        if (state.phase === 'DRAGGING') {\\n          publisher.update(state.critical, state.impact);\\n        }\\n      };\\n    };\\n  };\\n});\\n\\nvar dropAnimationFinish = (function (store) {\\n  return function (next) {\\n    return function (action) {\\n      if (action.type !== 'DROP_ANIMATION_FINISHED') {\\n        next(action);\\n        return;\\n      }\\n\\n      var state = store.getState();\\n      !(state.phase === 'DROP_ANIMATING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot finish a drop animating when no drop is occurring') : invariant(false) : void 0;\\n      store.dispatch(completeDrop({\\n        completed: state.completed\\n      }));\\n    };\\n  };\\n});\\n\\nvar dropAnimationFlushOnScroll = (function (store) {\\n  var unbind = null;\\n  var frameId = null;\\n\\n  function clear() {\\n    if (frameId) {\\n      cancelAnimationFrame(frameId);\\n      frameId = null;\\n    }\\n\\n    if (unbind) {\\n      unbind();\\n      unbind = null;\\n    }\\n  }\\n\\n  return function (next) {\\n    return function (action) {\\n      if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATION_FINISHED') {\\n        clear();\\n      }\\n\\n      next(action);\\n\\n      if (action.type !== 'DROP_ANIMATE') {\\n        return;\\n      }\\n\\n      var binding = {\\n        eventName: 'scroll',\\n        options: {\\n          capture: true,\\n          passive: false,\\n          once: true\\n        },\\n        fn: function flushDropAnimation() {\\n          var state = store.getState();\\n\\n          if (state.phase === 'DROP_ANIMATING') {\\n            store.dispatch(dropAnimationFinished());\\n          }\\n        }\\n      };\\n      frameId = requestAnimationFrame(function () {\\n        frameId = null;\\n        unbind = bindEvents(window, [binding]);\\n      });\\n    };\\n  };\\n});\\n\\nvar dimensionMarshalStopper = (function (marshal) {\\n  return function () {\\n    return function (next) {\\n      return function (action) {\\n        if (action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' || action.type === 'DROP_ANIMATE') {\\n          marshal.stopPublishing();\\n        }\\n\\n        next(action);\\n      };\\n    };\\n  };\\n});\\n\\nvar focus = (function (marshal) {\\n  var isWatching = false;\\n  return function () {\\n    return function (next) {\\n      return function (action) {\\n        if (action.type === 'INITIAL_PUBLISH') {\\n          isWatching = true;\\n          marshal.tryRecordFocus(action.payload.critical.draggable.id);\\n          next(action);\\n          marshal.tryRestoreFocusRecorded();\\n          return;\\n        }\\n\\n        next(action);\\n\\n        if (!isWatching) {\\n          return;\\n        }\\n\\n        if (action.type === 'FLUSH') {\\n          isWatching = false;\\n          marshal.tryRestoreFocusRecorded();\\n          return;\\n        }\\n\\n        if (action.type === 'DROP_COMPLETE') {\\n          isWatching = false;\\n          var result = action.payload.completed.result;\\n\\n          if (result.combine) {\\n            marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\\n          }\\n\\n          marshal.tryRestoreFocusRecorded();\\n        }\\n      };\\n    };\\n  };\\n});\\n\\nvar shouldStop = function shouldStop(action) {\\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';\\n};\\n\\nvar autoScroll = (function (autoScroller) {\\n  return function (store) {\\n    return function (next) {\\n      return function (action) {\\n        if (shouldStop(action)) {\\n          autoScroller.stop();\\n          next(action);\\n          return;\\n        }\\n\\n        if (action.type === 'INITIAL_PUBLISH') {\\n          next(action);\\n          var state = store.getState();\\n          !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected phase to be DRAGGING after INITIAL_PUBLISH') : invariant(false) : void 0;\\n          autoScroller.start(state);\\n          return;\\n        }\\n\\n        next(action);\\n        autoScroller.scroll(store.getState());\\n      };\\n    };\\n  };\\n});\\n\\nvar pendingDrop = (function (store) {\\n  return function (next) {\\n    return function (action) {\\n      next(action);\\n\\n      if (action.type !== 'PUBLISH_WHILE_DRAGGING') {\\n        return;\\n      }\\n\\n      var postActionState = store.getState();\\n\\n      if (postActionState.phase !== 'DROP_PENDING') {\\n        return;\\n      }\\n\\n      if (postActionState.isWaiting) {\\n        return;\\n      }\\n\\n      store.dispatch(drop({\\n        reason: postActionState.reason\\n      }));\\n    };\\n  };\\n});\\n\\nvar composeEnhancers = process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : redux.compose;\\nvar createStore = (function (_ref) {\\n  var dimensionMarshal = _ref.dimensionMarshal,\\n      focusMarshal = _ref.focusMarshal,\\n      styleMarshal = _ref.styleMarshal,\\n      getResponders = _ref.getResponders,\\n      announce = _ref.announce,\\n      autoScroller = _ref.autoScroller;\\n  return redux.createStore(reducer, composeEnhancers(redux.applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\\n});\\n\\nvar clean$1 = function clean() {\\n  return {\\n    additions: {},\\n    removals: {},\\n    modified: {}\\n  };\\n};\\n\\nvar timingKey = 'Publish collection from DOM';\\nfunction createPublisher(_ref) {\\n  var registry = _ref.registry,\\n      callbacks = _ref.callbacks;\\n  var staging = clean$1();\\n  var frameId = null;\\n\\n  var collect = function collect() {\\n    if (frameId) {\\n      return;\\n    }\\n\\n    callbacks.collectionStarting();\\n    frameId = requestAnimationFrame(function () {\\n      frameId = null;\\n      start(timingKey);\\n      var _staging = staging,\\n          additions = _staging.additions,\\n          removals = _staging.removals,\\n          modified = _staging.modified;\\n\\n      var added = _Object$keys(additions).map(function (id) {\\n        return registry.draggable.getById(id).getDimension(origin);\\n      }).sort(function (a, b) {\\n        return a.descriptor.index - b.descriptor.index;\\n      });\\n\\n      var updated = _Object$keys(modified).map(function (id) {\\n        var entry = registry.droppable.getById(id);\\n        var scroll = entry.callbacks.getScrollWhileDragging();\\n        return {\\n          droppableId: id,\\n          scroll: scroll\\n        };\\n      });\\n\\n      var result = {\\n        additions: added,\\n        removals: _Object$keys(removals),\\n        modified: updated\\n      };\\n      staging = clean$1();\\n      finish(timingKey);\\n      callbacks.publish(result);\\n    });\\n  };\\n\\n  var add = function add(entry) {\\n    var id = entry.descriptor.id;\\n    staging.additions[id] = entry;\\n    staging.modified[entry.descriptor.droppableId] = true;\\n\\n    if (staging.removals[id]) {\\n      delete staging.removals[id];\\n    }\\n\\n    collect();\\n  };\\n\\n  var remove = function remove(entry) {\\n    var descriptor = entry.descriptor;\\n    staging.removals[descriptor.id] = true;\\n    staging.modified[descriptor.droppableId] = true;\\n\\n    if (staging.additions[descriptor.id]) {\\n      delete staging.additions[descriptor.id];\\n    }\\n\\n    collect();\\n  };\\n\\n  var stop = function stop() {\\n    if (!frameId) {\\n      return;\\n    }\\n\\n    cancelAnimationFrame(frameId);\\n    frameId = null;\\n    staging = clean$1();\\n  };\\n\\n  return {\\n    add: add,\\n    remove: remove,\\n    stop: stop\\n  };\\n}\\n\\nvar getMaxScroll = (function (_ref) {\\n  var scrollHeight = _ref.scrollHeight,\\n      scrollWidth = _ref.scrollWidth,\\n      height = _ref.height,\\n      width = _ref.width;\\n  var maxScroll = subtract({\\n    x: scrollWidth,\\n    y: scrollHeight\\n  }, {\\n    x: width,\\n    y: height\\n  });\\n  var adjustedMaxScroll = {\\n    x: Math.max(0, maxScroll.x),\\n    y: Math.max(0, maxScroll.y)\\n  };\\n  return adjustedMaxScroll;\\n});\\n\\nvar getDocumentElement = (function () {\\n  var doc = document.documentElement;\\n  !doc ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot find document.documentElement') : invariant(false) : void 0;\\n  return doc;\\n});\\n\\nvar getMaxWindowScroll = (function () {\\n  var doc = getDocumentElement();\\n  var maxScroll = getMaxScroll({\\n    scrollHeight: doc.scrollHeight,\\n    scrollWidth: doc.scrollWidth,\\n    width: doc.clientWidth,\\n    height: doc.clientHeight\\n  });\\n  return maxScroll;\\n});\\n\\nvar getViewport = (function () {\\n  var scroll = getWindowScroll();\\n  var maxScroll = getMaxWindowScroll();\\n  var top = scroll.y;\\n  var left = scroll.x;\\n  var doc = getDocumentElement();\\n  var width = doc.clientWidth;\\n  var height = doc.clientHeight;\\n  var right = left + width;\\n  var bottom = top + height;\\n  var frame = cssBoxModel.getRect({\\n    top: top,\\n    left: left,\\n    right: right,\\n    bottom: bottom\\n  });\\n  var viewport = {\\n    frame: frame,\\n    scroll: {\\n      initial: scroll,\\n      current: scroll,\\n      max: maxScroll,\\n      diff: {\\n        value: origin,\\n        displacement: origin\\n      }\\n    }\\n  };\\n  return viewport;\\n});\\n\\nvar getInitialPublish = (function (_ref) {\\n  var critical = _ref.critical,\\n      scrollOptions = _ref.scrollOptions,\\n      registry = _ref.registry;\\n  var timingKey = 'Initial collection from DOM';\\n  start(timingKey);\\n  var viewport = getViewport();\\n  var windowScroll = viewport.scroll.current;\\n  var home = critical.droppable;\\n  var droppables = registry.droppable.getAllByType(home.type).map(function (entry) {\\n    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);\\n  });\\n  var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function (entry) {\\n    return entry.getDimension(windowScroll);\\n  });\\n  var dimensions = {\\n    draggables: toDraggableMap(draggables),\\n    droppables: toDroppableMap(droppables)\\n  };\\n  finish(timingKey);\\n  var result = {\\n    dimensions: dimensions,\\n    critical: critical,\\n    viewport: viewport\\n  };\\n  return result;\\n});\\n\\nfunction shouldPublishUpdate(registry, dragging, entry) {\\n  if (entry.descriptor.id === dragging.id) {\\n    return false;\\n  }\\n\\n  if (entry.descriptor.type !== dragging.type) {\\n    return false;\\n  }\\n\\n  var home = registry.droppable.getById(entry.descriptor.droppableId);\\n\\n  if (home.descriptor.mode !== 'virtual') {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      You are attempting to add or remove a Draggable [id: \\\" + entry.descriptor.id + \\\"]\\\\n      while a drag is occurring. This is only supported for virtual lists.\\\\n\\\\n      See https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/patterns/virtual-lists.md\\\\n    \\\") : void 0;\\n    return false;\\n  }\\n\\n  return true;\\n}\\n\\nvar createDimensionMarshal = (function (registry, callbacks) {\\n  var collection = null;\\n  var publisher = createPublisher({\\n    callbacks: {\\n      publish: callbacks.publishWhileDragging,\\n      collectionStarting: callbacks.collectionStarting\\n    },\\n    registry: registry\\n  });\\n\\n  var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {\\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot update is enabled flag of Droppable \\\" + id + \\\" as it is not registered\\\") : invariant(false) : void 0;\\n\\n    if (!collection) {\\n      return;\\n    }\\n\\n    callbacks.updateDroppableIsEnabled({\\n      id: id,\\n      isEnabled: isEnabled\\n    });\\n  };\\n\\n  var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(id, isCombineEnabled) {\\n    if (!collection) {\\n      return;\\n    }\\n\\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot update isCombineEnabled flag of Droppable \\\" + id + \\\" as it is not registered\\\") : invariant(false) : void 0;\\n    callbacks.updateDroppableIsCombineEnabled({\\n      id: id,\\n      isCombineEnabled: isCombineEnabled\\n    });\\n  };\\n\\n  var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {\\n    if (!collection) {\\n      return;\\n    }\\n\\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot update the scroll on Droppable \\\" + id + \\\" as it is not registered\\\") : invariant(false) : void 0;\\n    callbacks.updateDroppableScroll({\\n      id: id,\\n      newScroll: newScroll\\n    });\\n  };\\n\\n  var scrollDroppable = function scrollDroppable(id, change) {\\n    if (!collection) {\\n      return;\\n    }\\n\\n    registry.droppable.getById(id).callbacks.scroll(change);\\n  };\\n\\n  var stopPublishing = function stopPublishing() {\\n    if (!collection) {\\n      return;\\n    }\\n\\n    publisher.stop();\\n    var home = collection.critical.droppable;\\n    registry.droppable.getAllByType(home.type).forEach(function (entry) {\\n      return entry.callbacks.dragStopped();\\n    });\\n    collection.unsubscribe();\\n    collection = null;\\n  };\\n\\n  var subscriber = function subscriber(event) {\\n    !collection ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Should only be subscribed when a collection is occurring') : invariant(false) : void 0;\\n    var dragging = collection.critical.draggable;\\n\\n    if (event.type === 'ADDITION') {\\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\\n        publisher.add(event.value);\\n      }\\n    }\\n\\n    if (event.type === 'REMOVAL') {\\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\\n        publisher.remove(event.value);\\n      }\\n    }\\n  };\\n\\n  var startPublishing = function startPublishing(request) {\\n    !!collection ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot start capturing critical dimensions as there is already a collection') : invariant(false) : void 0;\\n    var entry = registry.draggable.getById(request.draggableId);\\n    var home = registry.droppable.getById(entry.descriptor.droppableId);\\n    var critical = {\\n      draggable: entry.descriptor,\\n      droppable: home.descriptor\\n    };\\n    var unsubscribe = registry.subscribe(subscriber);\\n    collection = {\\n      critical: critical,\\n      unsubscribe: unsubscribe\\n    };\\n    return getInitialPublish({\\n      critical: critical,\\n      registry: registry,\\n      scrollOptions: request.scrollOptions\\n    });\\n  };\\n\\n  var marshal = {\\n    updateDroppableIsEnabled: updateDroppableIsEnabled,\\n    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\\n    scrollDroppable: scrollDroppable,\\n    updateDroppableScroll: updateDroppableScroll,\\n    startPublishing: startPublishing,\\n    stopPublishing: stopPublishing\\n  };\\n  return marshal;\\n});\\n\\nvar canStartDrag = (function (state, id) {\\n  if (state.phase === 'IDLE') {\\n    return true;\\n  }\\n\\n  if (state.phase !== 'DROP_ANIMATING') {\\n    return false;\\n  }\\n\\n  if (state.completed.result.draggableId === id) {\\n    return false;\\n  }\\n\\n  return state.completed.result.reason === 'DROP';\\n});\\n\\nvar scrollWindow = (function (change) {\\n  window.scrollBy(change.x, change.y);\\n});\\n\\nvar getScrollableDroppables = memoizeOne(function (droppables) {\\n  return toDroppableList(droppables).filter(function (droppable) {\\n    if (!droppable.isEnabled) {\\n      return false;\\n    }\\n\\n    if (!droppable.frame) {\\n      return false;\\n    }\\n\\n    return true;\\n  });\\n});\\n\\nvar getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {\\n  var maybe = find(getScrollableDroppables(droppables), function (droppable) {\\n    !droppable.frame ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Invalid result') : invariant(false) : void 0;\\n    return isPositionInFrame(droppable.frame.pageMarginBox)(target);\\n  });\\n  return maybe;\\n};\\n\\nvar getBestScrollableDroppable = (function (_ref) {\\n  var center = _ref.center,\\n      destination = _ref.destination,\\n      droppables = _ref.droppables;\\n\\n  if (destination) {\\n    var _dimension = droppables[destination];\\n\\n    if (!_dimension.frame) {\\n      return null;\\n    }\\n\\n    return _dimension;\\n  }\\n\\n  var dimension = getScrollableDroppableOver(center, droppables);\\n  return dimension;\\n});\\n\\nvar config = {\\n  startFromPercentage: 0.25,\\n  maxScrollAtPercentage: 0.05,\\n  maxPixelScroll: 28,\\n  ease: function ease(percentage) {\\n    return Math.pow(percentage, 2);\\n  },\\n  durationDampening: {\\n    stopDampeningAt: 1200,\\n    accelerateAt: 360\\n  }\\n};\\n\\nvar getDistanceThresholds = (function (container, axis) {\\n  var startScrollingFrom = container[axis.size] * config.startFromPercentage;\\n  var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;\\n  var thresholds = {\\n    startScrollingFrom: startScrollingFrom,\\n    maxScrollValueAt: maxScrollValueAt\\n  };\\n  return thresholds;\\n});\\n\\nvar getPercentage = (function (_ref) {\\n  var startOfRange = _ref.startOfRange,\\n      endOfRange = _ref.endOfRange,\\n      current = _ref.current;\\n  var range = endOfRange - startOfRange;\\n\\n  if (range === 0) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      Detected distance range of 0 in the fluid auto scroller\\\\n      This is unexpected and would cause a divide by 0 issue.\\\\n      Not allowing an auto scroll\\\\n    \\\") : void 0;\\n    return 0;\\n  }\\n\\n  var currentInRange = current - startOfRange;\\n  var percentage = currentInRange / range;\\n  return percentage;\\n});\\n\\nvar minScroll = 1;\\n\\nvar getValueFromDistance = (function (distanceToEdge, thresholds) {\\n  if (distanceToEdge > thresholds.startScrollingFrom) {\\n    return 0;\\n  }\\n\\n  if (distanceToEdge <= thresholds.maxScrollValueAt) {\\n    return config.maxPixelScroll;\\n  }\\n\\n  if (distanceToEdge === thresholds.startScrollingFrom) {\\n    return minScroll;\\n  }\\n\\n  var percentageFromMaxScrollValueAt = getPercentage({\\n    startOfRange: thresholds.maxScrollValueAt,\\n    endOfRange: thresholds.startScrollingFrom,\\n    current: distanceToEdge\\n  });\\n  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\\n  var scroll = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);\\n  return Math.ceil(scroll);\\n});\\n\\nvar accelerateAt = config.durationDampening.accelerateAt;\\nvar stopAt = config.durationDampening.stopDampeningAt;\\nvar dampenValueByTime = (function (proposedScroll, dragStartTime) {\\n  var startOfRange = dragStartTime;\\n  var endOfRange = stopAt;\\n\\n  var now = _Date$now();\\n\\n  var runTime = now - startOfRange;\\n\\n  if (runTime >= stopAt) {\\n    return proposedScroll;\\n  }\\n\\n  if (runTime < accelerateAt) {\\n    return minScroll;\\n  }\\n\\n  var betweenAccelerateAtAndStopAtPercentage = getPercentage({\\n    startOfRange: accelerateAt,\\n    endOfRange: endOfRange,\\n    current: runTime\\n  });\\n  var scroll = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);\\n  return Math.ceil(scroll);\\n});\\n\\nvar getValue = (function (_ref) {\\n  var distanceToEdge = _ref.distanceToEdge,\\n      thresholds = _ref.thresholds,\\n      dragStartTime = _ref.dragStartTime,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\\n  var scroll = getValueFromDistance(distanceToEdge, thresholds);\\n\\n  if (scroll === 0) {\\n    return 0;\\n  }\\n\\n  if (!shouldUseTimeDampening) {\\n    return scroll;\\n  }\\n\\n  return Math.max(dampenValueByTime(scroll, dragStartTime), minScroll);\\n});\\n\\nvar getScrollOnAxis = (function (_ref) {\\n  var container = _ref.container,\\n      distanceToEdges = _ref.distanceToEdges,\\n      dragStartTime = _ref.dragStartTime,\\n      axis = _ref.axis,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\\n  var thresholds = getDistanceThresholds(container, axis);\\n  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\\n\\n  if (isCloserToEnd) {\\n    return getValue({\\n      distanceToEdge: distanceToEdges[axis.end],\\n      thresholds: thresholds,\\n      dragStartTime: dragStartTime,\\n      shouldUseTimeDampening: shouldUseTimeDampening\\n    });\\n  }\\n\\n  return -1 * getValue({\\n    distanceToEdge: distanceToEdges[axis.start],\\n    thresholds: thresholds,\\n    dragStartTime: dragStartTime,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n});\\n\\nvar adjustForSizeLimits = (function (_ref) {\\n  var container = _ref.container,\\n      subject = _ref.subject,\\n      proposedScroll = _ref.proposedScroll;\\n  var isTooBigVertically = subject.height > container.height;\\n  var isTooBigHorizontally = subject.width > container.width;\\n\\n  if (!isTooBigHorizontally && !isTooBigVertically) {\\n    return proposedScroll;\\n  }\\n\\n  if (isTooBigHorizontally && isTooBigVertically) {\\n    return null;\\n  }\\n\\n  return {\\n    x: isTooBigHorizontally ? 0 : proposedScroll.x,\\n    y: isTooBigVertically ? 0 : proposedScroll.y\\n  };\\n});\\n\\nvar clean$2 = apply(function (value) {\\n  return value === 0 ? 0 : value;\\n});\\nvar getScroll = (function (_ref) {\\n  var dragStartTime = _ref.dragStartTime,\\n      container = _ref.container,\\n      subject = _ref.subject,\\n      center = _ref.center,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\\n  var distanceToEdges = {\\n    top: center.y - container.top,\\n    right: container.right - center.x,\\n    bottom: container.bottom - center.y,\\n    left: center.x - container.left\\n  };\\n  var y = getScrollOnAxis({\\n    container: container,\\n    distanceToEdges: distanceToEdges,\\n    dragStartTime: dragStartTime,\\n    axis: vertical,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n  var x = getScrollOnAxis({\\n    container: container,\\n    distanceToEdges: distanceToEdges,\\n    dragStartTime: dragStartTime,\\n    axis: horizontal,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n  var required = clean$2({\\n    x: x,\\n    y: y\\n  });\\n\\n  if (isEqual(required, origin)) {\\n    return null;\\n  }\\n\\n  var limited = adjustForSizeLimits({\\n    container: container,\\n    subject: subject,\\n    proposedScroll: required\\n  });\\n\\n  if (!limited) {\\n    return null;\\n  }\\n\\n  return isEqual(limited, origin) ? null : limited;\\n});\\n\\nvar smallestSigned = apply(function (value) {\\n  if (value === 0) {\\n    return 0;\\n  }\\n\\n  return value > 0 ? 1 : -1;\\n});\\nvar getOverlap = function () {\\n  var getRemainder = function getRemainder(target, max) {\\n    if (target < 0) {\\n      return target;\\n    }\\n\\n    if (target > max) {\\n      return target - max;\\n    }\\n\\n    return 0;\\n  };\\n\\n  return function (_ref) {\\n    var current = _ref.current,\\n        max = _ref.max,\\n        change = _ref.change;\\n    var targetScroll = add(current, change);\\n    var overlap = {\\n      x: getRemainder(targetScroll.x, max.x),\\n      y: getRemainder(targetScroll.y, max.y)\\n    };\\n\\n    if (isEqual(overlap, origin)) {\\n      return null;\\n    }\\n\\n    return overlap;\\n  };\\n}();\\nvar canPartiallyScroll = function canPartiallyScroll(_ref2) {\\n  var rawMax = _ref2.max,\\n      current = _ref2.current,\\n      change = _ref2.change;\\n  var max = {\\n    x: Math.max(current.x, rawMax.x),\\n    y: Math.max(current.y, rawMax.y)\\n  };\\n  var smallestChange = smallestSigned(change);\\n  var overlap = getOverlap({\\n    max: max,\\n    current: current,\\n    change: smallestChange\\n  });\\n\\n  if (!overlap) {\\n    return true;\\n  }\\n\\n  if (smallestChange.x !== 0 && overlap.x === 0) {\\n    return true;\\n  }\\n\\n  if (smallestChange.y !== 0 && overlap.y === 0) {\\n    return true;\\n  }\\n\\n  return false;\\n};\\nvar canScrollWindow = function canScrollWindow(viewport, change) {\\n  return canPartiallyScroll({\\n    current: viewport.scroll.current,\\n    max: viewport.scroll.max,\\n    change: change\\n  });\\n};\\nvar getWindowOverlap = function getWindowOverlap(viewport, change) {\\n  if (!canScrollWindow(viewport, change)) {\\n    return null;\\n  }\\n\\n  var max = viewport.scroll.max;\\n  var current = viewport.scroll.current;\\n  return getOverlap({\\n    current: current,\\n    max: max,\\n    change: change\\n  });\\n};\\nvar canScrollDroppable = function canScrollDroppable(droppable, change) {\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    return false;\\n  }\\n\\n  return canPartiallyScroll({\\n    current: frame.scroll.current,\\n    max: frame.scroll.max,\\n    change: change\\n  });\\n};\\nvar getDroppableOverlap = function getDroppableOverlap(droppable, change) {\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    return null;\\n  }\\n\\n  if (!canScrollDroppable(droppable, change)) {\\n    return null;\\n  }\\n\\n  return getOverlap({\\n    current: frame.scroll.current,\\n    max: frame.scroll.max,\\n    change: change\\n  });\\n};\\n\\nvar getWindowScrollChange = (function (_ref) {\\n  var viewport = _ref.viewport,\\n      subject = _ref.subject,\\n      center = _ref.center,\\n      dragStartTime = _ref.dragStartTime,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\\n  var scroll = getScroll({\\n    dragStartTime: dragStartTime,\\n    container: viewport.frame,\\n    subject: subject,\\n    center: center,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n  return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\\n});\\n\\nvar getDroppableScrollChange = (function (_ref) {\\n  var droppable = _ref.droppable,\\n      subject = _ref.subject,\\n      center = _ref.center,\\n      dragStartTime = _ref.dragStartTime,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    return null;\\n  }\\n\\n  var scroll = getScroll({\\n    dragStartTime: dragStartTime,\\n    container: frame.pageMarginBox,\\n    subject: subject,\\n    center: center,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n  return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\\n});\\n\\nvar scroll$1 = (function (_ref) {\\n  var state = _ref.state,\\n      dragStartTime = _ref.dragStartTime,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening,\\n      scrollWindow = _ref.scrollWindow,\\n      scrollDroppable = _ref.scrollDroppable;\\n  var center = state.current.page.borderBoxCenter;\\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\\n  var subject = draggable.page.marginBox;\\n\\n  if (state.isWindowScrollAllowed) {\\n    var viewport = state.viewport;\\n\\n    var _change = getWindowScrollChange({\\n      dragStartTime: dragStartTime,\\n      viewport: viewport,\\n      subject: subject,\\n      center: center,\\n      shouldUseTimeDampening: shouldUseTimeDampening\\n    });\\n\\n    if (_change) {\\n      scrollWindow(_change);\\n      return;\\n    }\\n  }\\n\\n  var droppable = getBestScrollableDroppable({\\n    center: center,\\n    destination: whatIsDraggedOver(state.impact),\\n    droppables: state.dimensions.droppables\\n  });\\n\\n  if (!droppable) {\\n    return;\\n  }\\n\\n  var change = getDroppableScrollChange({\\n    dragStartTime: dragStartTime,\\n    droppable: droppable,\\n    subject: subject,\\n    center: center,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n\\n  if (change) {\\n    scrollDroppable(droppable.descriptor.id, change);\\n  }\\n});\\n\\nvar createFluidScroller = (function (_ref) {\\n  var scrollWindow = _ref.scrollWindow,\\n      scrollDroppable = _ref.scrollDroppable;\\n  var scheduleWindowScroll = rafSchd(scrollWindow);\\n  var scheduleDroppableScroll = rafSchd(scrollDroppable);\\n  var dragging = null;\\n\\n  var tryScroll = function tryScroll(state) {\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot fluid scroll if not dragging') : invariant(false) : void 0;\\n    var _dragging = dragging,\\n        shouldUseTimeDampening = _dragging.shouldUseTimeDampening,\\n        dragStartTime = _dragging.dragStartTime;\\n    scroll$1({\\n      state: state,\\n      scrollWindow: scheduleWindowScroll,\\n      scrollDroppable: scheduleDroppableScroll,\\n      dragStartTime: dragStartTime,\\n      shouldUseTimeDampening: shouldUseTimeDampening\\n    });\\n  };\\n\\n  var start$1 = function start$1(state) {\\n    start('starting fluid scroller');\\n    !!dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot start auto scrolling when already started') : invariant(false) : void 0;\\n\\n    var dragStartTime = _Date$now();\\n\\n    var wasScrollNeeded = false;\\n\\n    var fakeScrollCallback = function fakeScrollCallback() {\\n      wasScrollNeeded = true;\\n    };\\n\\n    scroll$1({\\n      state: state,\\n      dragStartTime: 0,\\n      shouldUseTimeDampening: false,\\n      scrollWindow: fakeScrollCallback,\\n      scrollDroppable: fakeScrollCallback\\n    });\\n    dragging = {\\n      dragStartTime: dragStartTime,\\n      shouldUseTimeDampening: wasScrollNeeded\\n    };\\n    finish('starting fluid scroller');\\n\\n    if (wasScrollNeeded) {\\n      tryScroll(state);\\n    }\\n  };\\n\\n  var stop = function stop() {\\n    if (!dragging) {\\n      return;\\n    }\\n\\n    scheduleWindowScroll.cancel();\\n    scheduleDroppableScroll.cancel();\\n    dragging = null;\\n  };\\n\\n  return {\\n    start: start$1,\\n    stop: stop,\\n    scroll: tryScroll\\n  };\\n});\\n\\nvar createJumpScroller = (function (_ref) {\\n  var move = _ref.move,\\n      scrollDroppable = _ref.scrollDroppable,\\n      scrollWindow = _ref.scrollWindow;\\n\\n  var moveByOffset = function moveByOffset(state, offset) {\\n    var client = add(state.current.client.selection, offset);\\n    move({\\n      client: client\\n    });\\n  };\\n\\n  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {\\n    if (!canScrollDroppable(droppable, change)) {\\n      return change;\\n    }\\n\\n    var overlap = getDroppableOverlap(droppable, change);\\n\\n    if (!overlap) {\\n      scrollDroppable(droppable.descriptor.id, change);\\n      return null;\\n    }\\n\\n    var whatTheDroppableCanScroll = subtract(change, overlap);\\n    scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\\n    var remainder = subtract(change, whatTheDroppableCanScroll);\\n    return remainder;\\n  };\\n\\n  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(isWindowScrollAllowed, viewport, change) {\\n    if (!isWindowScrollAllowed) {\\n      return change;\\n    }\\n\\n    if (!canScrollWindow(viewport, change)) {\\n      return change;\\n    }\\n\\n    var overlap = getWindowOverlap(viewport, change);\\n\\n    if (!overlap) {\\n      scrollWindow(change);\\n      return null;\\n    }\\n\\n    var whatTheWindowCanScroll = subtract(change, overlap);\\n    scrollWindow(whatTheWindowCanScroll);\\n    var remainder = subtract(change, whatTheWindowCanScroll);\\n    return remainder;\\n  };\\n\\n  var jumpScroller = function jumpScroller(state) {\\n    var request = state.scrollJumpRequest;\\n\\n    if (!request) {\\n      return;\\n    }\\n\\n    var destination = whatIsDraggedOver(state.impact);\\n    !destination ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : invariant(false) : void 0;\\n    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\\n\\n    if (!droppableRemainder) {\\n      return;\\n    }\\n\\n    var viewport = state.viewport;\\n    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\\n\\n    if (!windowRemainder) {\\n      return;\\n    }\\n\\n    moveByOffset(state, windowRemainder);\\n  };\\n\\n  return jumpScroller;\\n});\\n\\nvar createAutoScroller = (function (_ref) {\\n  var scrollDroppable = _ref.scrollDroppable,\\n      scrollWindow = _ref.scrollWindow,\\n      move = _ref.move;\\n  var fluidScroller = createFluidScroller({\\n    scrollWindow: scrollWindow,\\n    scrollDroppable: scrollDroppable\\n  });\\n  var jumpScroll = createJumpScroller({\\n    move: move,\\n    scrollWindow: scrollWindow,\\n    scrollDroppable: scrollDroppable\\n  });\\n\\n  var scroll = function scroll(state) {\\n    if (state.phase !== 'DRAGGING') {\\n      return;\\n    }\\n\\n    if (state.movementMode === 'FLUID') {\\n      fluidScroller.scroll(state);\\n      return;\\n    }\\n\\n    if (!state.scrollJumpRequest) {\\n      return;\\n    }\\n\\n    jumpScroll(state);\\n  };\\n\\n  var scroller = {\\n    scroll: scroll,\\n    start: fluidScroller.start,\\n    stop: fluidScroller.stop\\n  };\\n  return scroller;\\n});\\n\\nvar prefix$1 = 'data-rbd';\\nvar dragHandle = function () {\\n  var base = prefix$1 + \\\"-drag-handle\\\";\\n  return {\\n    base: base,\\n    draggableId: base + \\\"-draggable-id\\\",\\n    contextId: base + \\\"-context-id\\\"\\n  };\\n}();\\nvar draggable = function () {\\n  var base = prefix$1 + \\\"-draggable\\\";\\n  return {\\n    base: base,\\n    contextId: base + \\\"-context-id\\\",\\n    id: base + \\\"-id\\\"\\n  };\\n}();\\nvar droppable = function () {\\n  var base = prefix$1 + \\\"-droppable\\\";\\n  return {\\n    base: base,\\n    contextId: base + \\\"-context-id\\\",\\n    id: base + \\\"-id\\\"\\n  };\\n}();\\nvar scrollContainer = {\\n  contextId: prefix$1 + \\\"-scroll-container-context-id\\\"\\n};\\n\\nvar makeGetSelector = function makeGetSelector(context) {\\n  return function (attribute) {\\n    return \\\"[\\\" + attribute + \\\"=\\\\\\\"\\\" + context + \\\"\\\\\\\"]\\\";\\n  };\\n};\\n\\nvar getStyles = function getStyles(rules, property) {\\n  return rules.map(function (rule) {\\n    var value = rule.styles[property];\\n\\n    if (!value) {\\n      return '';\\n    }\\n\\n    return rule.selector + \\\" { \\\" + value + \\\" }\\\";\\n  }).join(' ');\\n};\\n\\nvar noPointerEvents = 'pointer-events: none;';\\nvar getStyles$1 = (function (contextId) {\\n  var getSelector = makeGetSelector(contextId);\\n\\n  var dragHandle$1 = function () {\\n    var grabCursor = \\\"\\\\n      cursor: -webkit-grab;\\\\n      cursor: grab;\\\\n    \\\";\\n    return {\\n      selector: getSelector(dragHandle.contextId),\\n      styles: {\\n        always: \\\"\\\\n          -webkit-touch-callout: none;\\\\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\\\\n          touch-action: manipulation;\\\\n        \\\",\\n        resting: grabCursor,\\n        dragging: noPointerEvents,\\n        dropAnimating: grabCursor\\n      }\\n    };\\n  }();\\n\\n  var draggable$1 = function () {\\n    var transition = \\\"\\\\n      transition: \\\" + transitions.outOfTheWay + \\\";\\\\n    \\\";\\n    return {\\n      selector: getSelector(draggable.contextId),\\n      styles: {\\n        dragging: transition,\\n        dropAnimating: transition,\\n        userCancel: transition\\n      }\\n    };\\n  }();\\n\\n  var droppable$1 = {\\n    selector: getSelector(droppable.contextId),\\n    styles: {\\n      always: \\\"overflow-anchor: none;\\\"\\n    }\\n  };\\n  var body = {\\n    selector: 'body',\\n    styles: {\\n      dragging: \\\"\\\\n        cursor: grabbing;\\\\n        cursor: -webkit-grabbing;\\\\n        user-select: none;\\\\n        -webkit-user-select: none;\\\\n        -moz-user-select: none;\\\\n        -ms-user-select: none;\\\\n        overflow-anchor: none;\\\\n      \\\"\\n    }\\n  };\\n  var rules = [draggable$1, dragHandle$1, droppable$1, body];\\n  return {\\n    always: getStyles(rules, 'always'),\\n    resting: getStyles(rules, 'resting'),\\n    dragging: getStyles(rules, 'dragging'),\\n    dropAnimating: getStyles(rules, 'dropAnimating'),\\n    userCancel: getStyles(rules, 'userCancel')\\n  };\\n});\\n\\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\\n\\nvar getHead = function getHead() {\\n  var head = document.querySelector('head');\\n  !head ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot find the head to append a style to') : invariant(false) : void 0;\\n  return head;\\n};\\n\\nvar createStyleEl = function createStyleEl(nonce) {\\n  var el = document.createElement('style');\\n\\n  if (nonce) {\\n    el.setAttribute('nonce', nonce);\\n  }\\n\\n  el.type = 'text/css';\\n  return el;\\n};\\n\\nfunction useStyleMarshal(contextId, nonce) {\\n  var styles = useMemoOne.useMemo(function () {\\n    return getStyles$1(contextId);\\n  }, [contextId]);\\n  var alwaysRef = React.useRef(null);\\n  var dynamicRef = React.useRef(null);\\n  var setDynamicStyle = useMemoOne.useCallback(memoizeOne(function (proposed) {\\n    var el = dynamicRef.current;\\n    !el ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;\\n    el.textContent = proposed;\\n  }), []);\\n  var setAlwaysStyle = useMemoOne.useCallback(function (proposed) {\\n    var el = alwaysRef.current;\\n    !el ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;\\n    el.textContent = proposed;\\n  }, []);\\n  useIsomorphicLayoutEffect(function () {\\n    !(!alwaysRef.current && !dynamicRef.current) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'style elements already mounted') : invariant(false) : void 0;\\n    var always = createStyleEl(nonce);\\n    var dynamic = createStyleEl(nonce);\\n    alwaysRef.current = always;\\n    dynamicRef.current = dynamic;\\n    always.setAttribute(prefix$1 + \\\"-always\\\", contextId);\\n    dynamic.setAttribute(prefix$1 + \\\"-dynamic\\\", contextId);\\n    getHead().appendChild(always);\\n    getHead().appendChild(dynamic);\\n    setAlwaysStyle(styles.always);\\n    setDynamicStyle(styles.resting);\\n    return function () {\\n      var remove = function remove(ref) {\\n        var current = ref.current;\\n        !current ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot unmount ref as it is not set') : invariant(false) : void 0;\\n        getHead().removeChild(current);\\n        ref.current = null;\\n      };\\n\\n      remove(alwaysRef);\\n      remove(dynamicRef);\\n    };\\n  }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);\\n  var dragging = useMemoOne.useCallback(function () {\\n    return setDynamicStyle(styles.dragging);\\n  }, [setDynamicStyle, styles.dragging]);\\n  var dropping = useMemoOne.useCallback(function (reason) {\\n    if (reason === 'DROP') {\\n      setDynamicStyle(styles.dropAnimating);\\n      return;\\n    }\\n\\n    setDynamicStyle(styles.userCancel);\\n  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);\\n  var resting = useMemoOne.useCallback(function () {\\n    if (!dynamicRef.current) {\\n      return;\\n    }\\n\\n    setDynamicStyle(styles.resting);\\n  }, [setDynamicStyle, styles.resting]);\\n  var marshal = useMemoOne.useMemo(function () {\\n    return {\\n      dragging: dragging,\\n      dropping: dropping,\\n      resting: resting\\n    };\\n  }, [dragging, dropping, resting]);\\n  return marshal;\\n}\\n\\nvar getWindowFromEl = (function (el) {\\n  return el && el.ownerDocument ? el.ownerDocument.defaultView : window;\\n});\\n\\nfunction isHtmlElement(el) {\\n  return el instanceof getWindowFromEl(el).HTMLElement;\\n}\\n\\nfunction findDragHandle(contextId, draggableId) {\\n  var selector = \\\"[\\\" + dragHandle.contextId + \\\"=\\\\\\\"\\\" + contextId + \\\"\\\\\\\"]\\\";\\n  var possible = toArray(document.querySelectorAll(selector));\\n\\n  if (!possible.length) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"Unable to find any drag handles in the context \\\\\\\"\\\" + contextId + \\\"\\\\\\\"\\\") : void 0;\\n    return null;\\n  }\\n\\n  var handle = find(possible, function (el) {\\n    return el.getAttribute(dragHandle.draggableId) === draggableId;\\n  });\\n\\n  if (!handle) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"Unable to find drag handle with id \\\\\\\"\\\" + draggableId + \\\"\\\\\\\" as no handle with a matching id was found\\\") : void 0;\\n    return null;\\n  }\\n\\n  if (!isHtmlElement(handle)) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning('drag handle needs to be a HTMLElement') : void 0;\\n    return null;\\n  }\\n\\n  return handle;\\n}\\n\\nfunction useFocusMarshal(contextId) {\\n  var entriesRef = React.useRef({});\\n  var recordRef = React.useRef(null);\\n  var restoreFocusFrameRef = React.useRef(null);\\n  var isMountedRef = React.useRef(false);\\n  var register = useMemoOne.useCallback(function register(id, focus) {\\n    var entry = {\\n      id: id,\\n      focus: focus\\n    };\\n    entriesRef.current[id] = entry;\\n    return function unregister() {\\n      var entries = entriesRef.current;\\n      var current = entries[id];\\n\\n      if (current !== entry) {\\n        delete entries[id];\\n      }\\n    };\\n  }, []);\\n  var tryGiveFocus = useMemoOne.useCallback(function tryGiveFocus(tryGiveFocusTo) {\\n    var handle = findDragHandle(contextId, tryGiveFocusTo);\\n\\n    if (handle && handle !== document.activeElement) {\\n      handle.focus();\\n    }\\n  }, [contextId]);\\n  var tryShiftRecord = useMemoOne.useCallback(function tryShiftRecord(previous, redirectTo) {\\n    if (recordRef.current === previous) {\\n      recordRef.current = redirectTo;\\n    }\\n  }, []);\\n  var tryRestoreFocusRecorded = useMemoOne.useCallback(function tryRestoreFocusRecorded() {\\n    if (restoreFocusFrameRef.current) {\\n      return;\\n    }\\n\\n    if (!isMountedRef.current) {\\n      return;\\n    }\\n\\n    restoreFocusFrameRef.current = requestAnimationFrame(function () {\\n      restoreFocusFrameRef.current = null;\\n      var record = recordRef.current;\\n\\n      if (record) {\\n        tryGiveFocus(record);\\n      }\\n    });\\n  }, [tryGiveFocus]);\\n  var tryRecordFocus = useMemoOne.useCallback(function tryRecordFocus(id) {\\n    recordRef.current = null;\\n    var focused = document.activeElement;\\n\\n    if (!focused) {\\n      return;\\n    }\\n\\n    if (focused.getAttribute(dragHandle.draggableId) !== id) {\\n      return;\\n    }\\n\\n    recordRef.current = id;\\n  }, []);\\n  useIsomorphicLayoutEffect(function () {\\n    isMountedRef.current = true;\\n    return function clearFrameOnUnmount() {\\n      isMountedRef.current = false;\\n      var frameId = restoreFocusFrameRef.current;\\n\\n      if (frameId) {\\n        cancelAnimationFrame(frameId);\\n      }\\n    };\\n  }, []);\\n  var marshal = useMemoOne.useMemo(function () {\\n    return {\\n      register: register,\\n      tryRecordFocus: tryRecordFocus,\\n      tryRestoreFocusRecorded: tryRestoreFocusRecorded,\\n      tryShiftRecord: tryShiftRecord\\n    };\\n  }, [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);\\n  return marshal;\\n}\\n\\nfunction createRegistry() {\\n  var entries = {\\n    draggables: {},\\n    droppables: {}\\n  };\\n  var subscribers = [];\\n\\n  function subscribe(cb) {\\n    subscribers.push(cb);\\n    return function unsubscribe() {\\n      var index = subscribers.indexOf(cb);\\n\\n      if (index === -1) {\\n        return;\\n      }\\n\\n      subscribers.splice(index, 1);\\n    };\\n  }\\n\\n  function notify(event) {\\n    if (subscribers.length) {\\n      subscribers.forEach(function (cb) {\\n        return cb(event);\\n      });\\n    }\\n  }\\n\\n  function findDraggableById(id) {\\n    return entries.draggables[id] || null;\\n  }\\n\\n  function getDraggableById(id) {\\n    var entry = findDraggableById(id);\\n    !entry ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot find draggable entry with id [\\\" + id + \\\"]\\\") : invariant(false) : void 0;\\n    return entry;\\n  }\\n\\n  var draggableAPI = {\\n    register: function register(entry) {\\n      entries.draggables[entry.descriptor.id] = entry;\\n      notify({\\n        type: 'ADDITION',\\n        value: entry\\n      });\\n    },\\n    update: function update(entry, last) {\\n      var current = entries.draggables[last.descriptor.id];\\n\\n      if (!current) {\\n        return;\\n      }\\n\\n      if (current.uniqueId !== entry.uniqueId) {\\n        return;\\n      }\\n\\n      delete entries.draggables[last.descriptor.id];\\n      entries.draggables[entry.descriptor.id] = entry;\\n    },\\n    unregister: function unregister(entry) {\\n      var draggableId = entry.descriptor.id;\\n      var current = findDraggableById(draggableId);\\n\\n      if (!current) {\\n        return;\\n      }\\n\\n      if (entry.uniqueId !== current.uniqueId) {\\n        return;\\n      }\\n\\n      delete entries.draggables[draggableId];\\n      notify({\\n        type: 'REMOVAL',\\n        value: entry\\n      });\\n    },\\n    getById: getDraggableById,\\n    findById: findDraggableById,\\n    exists: function exists(id) {\\n      return Boolean(findDraggableById(id));\\n    },\\n    getAllByType: function getAllByType(type) {\\n      return values(entries.draggables).filter(function (entry) {\\n        return entry.descriptor.type === type;\\n      });\\n    }\\n  };\\n\\n  function findDroppableById(id) {\\n    return entries.droppables[id] || null;\\n  }\\n\\n  function getDroppableById(id) {\\n    var entry = findDroppableById(id);\\n    !entry ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot find droppable entry with id [\\\" + id + \\\"]\\\") : invariant(false) : void 0;\\n    return entry;\\n  }\\n\\n  var droppableAPI = {\\n    register: function register(entry) {\\n      entries.droppables[entry.descriptor.id] = entry;\\n    },\\n    unregister: function unregister(entry) {\\n      var current = findDroppableById(entry.descriptor.id);\\n\\n      if (!current) {\\n        return;\\n      }\\n\\n      if (entry.uniqueId !== current.uniqueId) {\\n        return;\\n      }\\n\\n      delete entries.droppables[entry.descriptor.id];\\n    },\\n    getById: getDroppableById,\\n    findById: findDroppableById,\\n    exists: function exists(id) {\\n      return Boolean(findDroppableById(id));\\n    },\\n    getAllByType: function getAllByType(type) {\\n      return values(entries.droppables).filter(function (entry) {\\n        return entry.descriptor.type === type;\\n      });\\n    }\\n  };\\n\\n  function clean() {\\n    entries.draggables = {};\\n    entries.droppables = {};\\n    subscribers.length = 0;\\n  }\\n\\n  return {\\n    draggable: draggableAPI,\\n    droppable: droppableAPI,\\n    subscribe: subscribe,\\n    clean: clean\\n  };\\n}\\n\\nfunction useRegistry() {\\n  var registry = useMemoOne.useMemo(createRegistry, []);\\n  React.useEffect(function () {\\n    return function unmount() {\\n      requestAnimationFrame(registry.clean);\\n    };\\n  }, [registry]);\\n  return registry;\\n}\\n\\nvar StoreContext = React__default.createContext(null);\\n\\nvar getBodyElement = (function () {\\n  var body = document.body;\\n  !body ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot find document.body') : invariant(false) : void 0;\\n  return body;\\n});\\n\\nvar visuallyHidden = {\\n  position: 'absolute',\\n  width: '1px',\\n  height: '1px',\\n  margin: '-1px',\\n  border: '0',\\n  padding: '0',\\n  overflow: 'hidden',\\n  clip: 'rect(0 0 0 0)',\\n  'clip-path': 'inset(100%)'\\n};\\n\\nvar getId = function getId(contextId) {\\n  return \\\"rbd-announcement-\\\" + contextId;\\n};\\nfunction useAnnouncer(contextId) {\\n  var id = useMemoOne.useMemo(function () {\\n    return getId(contextId);\\n  }, [contextId]);\\n  var ref = React.useRef(null);\\n  React.useEffect(function () {\\n    !!ref.current ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Announcement node already mounted') : invariant(false) : void 0;\\n    var el = document.createElement('div');\\n    ref.current = el;\\n    el.id = id;\\n    el.setAttribute('aria-live', 'assertive');\\n    el.setAttribute('role', 'log');\\n    el.setAttribute('aria-atomic', 'true');\\n\\n    _Object$assign(el.style, visuallyHidden);\\n\\n    getBodyElement().appendChild(el);\\n    return function () {\\n      setTimeout(function remove() {\\n        var toBeRemoved = ref.current;\\n        !toBeRemoved ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot unmount announcement node') : invariant(false) : void 0;\\n        getBodyElement().removeChild(toBeRemoved);\\n        ref.current = null;\\n      });\\n    };\\n  }, [id]);\\n  var announce = useMemoOne.useCallback(function (message) {\\n    var el = ref.current;\\n\\n    if (el) {\\n      el.textContent = message;\\n      return;\\n    }\\n\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      A screen reader message was trying to be announced but it was unable to do so.\\\\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\\\\n      Consider calling provided.announce() before the unmount so that the instruction will\\\\n      not be lost for users relying on a screen reader.\\\\n\\\\n      Message not passed to screen reader:\\\\n\\\\n      \\\\\\\"\\\" + message + \\\"\\\\\\\"\\\\n    \\\") : void 0;\\n  }, []);\\n  return announce;\\n}\\n\\nvar getId$1 = function getId(contextId) {\\n  return \\\"rbd-lift-instruction-\\\" + contextId;\\n};\\nfunction useLiftInstruction(contextId, liftInstruction) {\\n  var id = useMemoOne.useMemo(function () {\\n    return getId$1(contextId);\\n  }, [contextId]);\\n  React.useEffect(function mount() {\\n    var el = document.createElement('div');\\n    el.id = id;\\n    el.textContent = liftInstruction;\\n\\n    _Object$assign(el.style, visuallyHidden);\\n\\n    getBodyElement().appendChild(el);\\n    return function unmount() {\\n      getBodyElement().removeChild(el);\\n    };\\n  }, [id, liftInstruction]);\\n  return id;\\n}\\n\\nvar AppContext = React__default.createContext(null);\\n\\nvar peerDependencies = {\\n\\treact: \\\"^16.8.5\\\",\\n\\t\\\"react-dom\\\": \\\"^16.8.5\\\"\\n};\\n\\nvar semver = /(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)/;\\n\\nvar getVersion = function getVersion(value) {\\n  var result = semver.exec(value);\\n  !(result != null) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Unable to parse React version \\\" + value) : invariant(false) : void 0;\\n  var major = Number(result[1]);\\n  var minor = Number(result[2]);\\n  var patch = Number(result[3]);\\n  return {\\n    major: major,\\n    minor: minor,\\n    patch: patch,\\n    raw: value\\n  };\\n};\\n\\nvar isSatisfied = function isSatisfied(expected, actual) {\\n  if (actual.major > expected.major) {\\n    return true;\\n  }\\n\\n  if (actual.major < expected.major) {\\n    return false;\\n  }\\n\\n  if (actual.minor > expected.minor) {\\n    return true;\\n  }\\n\\n  if (actual.minor < expected.minor) {\\n    return false;\\n  }\\n\\n  return actual.patch >= expected.patch;\\n};\\n\\nvar checkReactVersion = (function (peerDepValue, actualValue) {\\n  var peerDep = getVersion(peerDepValue);\\n  var actual = getVersion(actualValue);\\n\\n  if (isSatisfied(peerDep, actual)) {\\n    return;\\n  }\\n\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n    React version: [\\\" + actual.raw + \\\"]\\\\n    does not satisfy expected peer dependency version: [\\\" + peerDep.raw + \\\"]\\\\n\\\\n    This can result in run time bugs, and even fatal crashes\\\\n  \\\") : void 0;\\n});\\n\\nvar suffix = \\\"\\\\n  We expect a html5 doctype: <!doctype html>\\\\n  This is to ensure consistent browser layout and measurement\\\\n\\\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\\\n\\\";\\nvar checkDoctype = (function (doc) {\\n  var doctype = doc.doctype;\\n\\n  if (!doctype) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      No <!doctype html> found.\\\\n\\\\n      \\\" + suffix + \\\"\\\\n    \\\") : void 0;\\n    return;\\n  }\\n\\n  if (doctype.name.toLowerCase() !== 'html') {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      Unexpected <!doctype> found: (\\\" + doctype.name + \\\")\\\\n\\\\n      \\\" + suffix + \\\"\\\\n    \\\") : void 0;\\n  }\\n\\n  if (doctype.publicId !== '') {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      Unexpected <!doctype> publicId found: (\\\" + doctype.publicId + \\\")\\\\n      A html5 doctype does not have a publicId\\\\n\\\\n      \\\" + suffix + \\\"\\\\n    \\\") : void 0;\\n  }\\n});\\n\\nfunction useDev(useHook) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    useHook();\\n  }\\n}\\n\\nfunction useDevSetupWarning(fn, inputs) {\\n  useDev(function () {\\n    React.useEffect(function () {\\n      try {\\n        fn();\\n      } catch (e) {\\n        error(\\\"\\\\n          A setup problem was encountered.\\\\n\\\\n          > \\\" + e.message + \\\"\\\\n        \\\");\\n      }\\n    }, inputs);\\n  });\\n}\\n\\nfunction useStartupValidation() {\\n  useDevSetupWarning(function () {\\n    checkReactVersion(peerDependencies.react, React__default.version);\\n    checkDoctype(document);\\n  }, []);\\n}\\n\\nfunction usePrevious(current) {\\n  var ref = React.useRef(current);\\n  React.useEffect(function () {\\n    ref.current = current;\\n  });\\n  return ref;\\n}\\n\\nfunction create() {\\n  var lock = null;\\n\\n  function isClaimed() {\\n    return Boolean(lock);\\n  }\\n\\n  function isActive(value) {\\n    return value === lock;\\n  }\\n\\n  function claim(abandon) {\\n    !!lock ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot claim lock as it is already claimed') : invariant(false) : void 0;\\n    var newLock = {\\n      abandon: abandon\\n    };\\n    lock = newLock;\\n    return newLock;\\n  }\\n\\n  function release() {\\n    !lock ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot release lock when there is no lock') : invariant(false) : void 0;\\n    lock = null;\\n  }\\n\\n  function tryAbandon() {\\n    if (lock) {\\n      lock.abandon();\\n      release();\\n    }\\n  }\\n\\n  return {\\n    isClaimed: isClaimed,\\n    isActive: isActive,\\n    claim: claim,\\n    release: release,\\n    tryAbandon: tryAbandon\\n  };\\n}\\n\\nvar tab = 9;\\nvar enter = 13;\\nvar escape = 27;\\nvar space = 32;\\nvar pageUp = 33;\\nvar pageDown = 34;\\nvar end = 35;\\nvar home = 36;\\nvar arrowLeft = 37;\\nvar arrowUp = 38;\\nvar arrowRight = 39;\\nvar arrowDown = 40;\\n\\nvar _preventedKeys;\\nvar preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);\\nvar preventStandardKeyEvents = (function (event) {\\n  if (preventedKeys[event.keyCode]) {\\n    event.preventDefault();\\n  }\\n});\\n\\nvar supportedEventName = function () {\\n  var base = 'visibilitychange';\\n\\n  if (typeof document === 'undefined') {\\n    return base;\\n  }\\n\\n  var candidates = [base, \\\"ms\\\" + base, \\\"webkit\\\" + base, \\\"moz\\\" + base, \\\"o\\\" + base];\\n  var supported = find(candidates, function (eventName) {\\n    return \\\"on\\\" + eventName in document;\\n  });\\n  return supported || base;\\n}();\\n\\nvar primaryButton = 0;\\nvar sloppyClickThreshold = 5;\\n\\nfunction isSloppyClickThresholdExceeded(original, current) {\\n  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\\n}\\n\\nvar idle$1 = {\\n  type: 'IDLE'\\n};\\n\\nfunction getCaptureBindings(_ref) {\\n  var cancel = _ref.cancel,\\n      completed = _ref.completed,\\n      getPhase = _ref.getPhase,\\n      setPhase = _ref.setPhase;\\n  return [{\\n    eventName: 'mousemove',\\n    fn: function fn(event) {\\n      var button = event.button,\\n          clientX = event.clientX,\\n          clientY = event.clientY;\\n\\n      if (button !== primaryButton) {\\n        return;\\n      }\\n\\n      var point = {\\n        x: clientX,\\n        y: clientY\\n      };\\n      var phase = getPhase();\\n\\n      if (phase.type === 'DRAGGING') {\\n        event.preventDefault();\\n        phase.actions.move(point);\\n        return;\\n      }\\n\\n      !(phase.type === 'PENDING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot be IDLE') : invariant(false) : void 0;\\n      var pending = phase.point;\\n\\n      if (!isSloppyClickThresholdExceeded(pending, point)) {\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      var actions = phase.actions.fluidLift(point);\\n      setPhase({\\n        type: 'DRAGGING',\\n        actions: actions\\n      });\\n    }\\n  }, {\\n    eventName: 'mouseup',\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n\\n      if (phase.type !== 'DRAGGING') {\\n        cancel();\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      phase.actions.drop({\\n        shouldBlockNextClick: true\\n      });\\n      completed();\\n    }\\n  }, {\\n    eventName: 'mousedown',\\n    fn: function fn(event) {\\n      if (getPhase().type === 'DRAGGING') {\\n        event.preventDefault();\\n      }\\n\\n      cancel();\\n    }\\n  }, {\\n    eventName: 'keydown',\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n\\n      if (phase.type === 'PENDING') {\\n        cancel();\\n        return;\\n      }\\n\\n      if (event.keyCode === escape) {\\n        event.preventDefault();\\n        cancel();\\n        return;\\n      }\\n\\n      preventStandardKeyEvents(event);\\n    }\\n  }, {\\n    eventName: 'resize',\\n    fn: cancel\\n  }, {\\n    eventName: 'scroll',\\n    options: {\\n      passive: true,\\n      capture: false\\n    },\\n    fn: function fn() {\\n      if (getPhase().type === 'PENDING') {\\n        cancel();\\n      }\\n    }\\n  }, {\\n    eventName: 'webkitmouseforcedown',\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n      !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Unexpected phase') : invariant(false) : void 0;\\n\\n      if (phase.actions.shouldRespectForcePress()) {\\n        cancel();\\n        return;\\n      }\\n\\n      event.preventDefault();\\n    }\\n  }, {\\n    eventName: supportedEventName,\\n    fn: cancel\\n  }];\\n}\\n\\nfunction useMouseSensor(api) {\\n  var phaseRef = React.useRef(idle$1);\\n  var unbindEventsRef = React.useRef(noop);\\n  var startCaptureBinding = useMemoOne.useMemo(function () {\\n    return {\\n      eventName: 'mousedown',\\n      fn: function onMouseDown(event) {\\n        if (event.defaultPrevented) {\\n          return;\\n        }\\n\\n        if (event.button !== primaryButton) {\\n          return;\\n        }\\n\\n        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\\n          return;\\n        }\\n\\n        var draggableId = api.findClosestDraggableId(event);\\n\\n        if (!draggableId) {\\n          return;\\n        }\\n\\n        var actions = api.tryGetLock(draggableId, stop, {\\n          sourceEvent: event\\n        });\\n\\n        if (!actions) {\\n          return;\\n        }\\n\\n        event.preventDefault();\\n        var point = {\\n          x: event.clientX,\\n          y: event.clientY\\n        };\\n        unbindEventsRef.current();\\n        startPendingDrag(actions, point);\\n      }\\n    };\\n  }, [api]);\\n  var preventForcePressBinding = useMemoOne.useMemo(function () {\\n    return {\\n      eventName: 'webkitmouseforcewillbegin',\\n      fn: function fn(event) {\\n        if (event.defaultPrevented) {\\n          return;\\n        }\\n\\n        var id = api.findClosestDraggableId(event);\\n\\n        if (!id) {\\n          return;\\n        }\\n\\n        var options = api.findOptionsForDraggable(id);\\n\\n        if (!options) {\\n          return;\\n        }\\n\\n        if (options.shouldRespectForcePress) {\\n          return;\\n        }\\n\\n        if (!api.canGetLock(id)) {\\n          return;\\n        }\\n\\n        event.preventDefault();\\n      }\\n    };\\n  }, [api]);\\n  var listenForCapture = useMemoOne.useCallback(function listenForCapture() {\\n    var options = {\\n      passive: false,\\n      capture: true\\n    };\\n    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);\\n  }, [preventForcePressBinding, startCaptureBinding]);\\n  var stop = useMemoOne.useCallback(function () {\\n    var current = phaseRef.current;\\n\\n    if (current.type === 'IDLE') {\\n      return;\\n    }\\n\\n    phaseRef.current = idle$1;\\n    unbindEventsRef.current();\\n    listenForCapture();\\n  }, [listenForCapture]);\\n  var cancel = useMemoOne.useCallback(function () {\\n    var phase = phaseRef.current;\\n    stop();\\n\\n    if (phase.type === 'DRAGGING') {\\n      phase.actions.cancel({\\n        shouldBlockNextClick: true\\n      });\\n    }\\n\\n    if (phase.type === 'PENDING') {\\n      phase.actions.abort();\\n    }\\n  }, [stop]);\\n  var bindCapturingEvents = useMemoOne.useCallback(function bindCapturingEvents() {\\n    var options = {\\n      capture: true,\\n      passive: false\\n    };\\n    var bindings = getCaptureBindings({\\n      cancel: cancel,\\n      completed: stop,\\n      getPhase: function getPhase() {\\n        return phaseRef.current;\\n      },\\n      setPhase: function setPhase(phase) {\\n        phaseRef.current = phase;\\n      }\\n    });\\n    unbindEventsRef.current = bindEvents(window, bindings, options);\\n  }, [cancel, stop]);\\n  var startPendingDrag = useMemoOne.useCallback(function startPendingDrag(actions, point) {\\n    !(phaseRef.current.type === 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected to move from IDLE to PENDING drag') : invariant(false) : void 0;\\n    phaseRef.current = {\\n      type: 'PENDING',\\n      point: point,\\n      actions: actions\\n    };\\n    bindCapturingEvents();\\n  }, [bindCapturingEvents]);\\n  useIsomorphicLayoutEffect(function mount() {\\n    listenForCapture();\\n    return function unmount() {\\n      unbindEventsRef.current();\\n    };\\n  }, [listenForCapture]);\\n}\\n\\nvar _scrollJumpKeys;\\n\\nfunction noop$1() {}\\n\\nvar scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);\\n\\nfunction getDraggingBindings(actions, stop) {\\n  function cancel() {\\n    stop();\\n    actions.cancel();\\n  }\\n\\n  function drop() {\\n    stop();\\n    actions.drop();\\n  }\\n\\n  return [{\\n    eventName: 'keydown',\\n    fn: function fn(event) {\\n      if (event.keyCode === escape) {\\n        event.preventDefault();\\n        cancel();\\n        return;\\n      }\\n\\n      if (event.keyCode === space) {\\n        event.preventDefault();\\n        drop();\\n        return;\\n      }\\n\\n      if (event.keyCode === arrowDown) {\\n        event.preventDefault();\\n        actions.moveDown();\\n        return;\\n      }\\n\\n      if (event.keyCode === arrowUp) {\\n        event.preventDefault();\\n        actions.moveUp();\\n        return;\\n      }\\n\\n      if (event.keyCode === arrowRight) {\\n        event.preventDefault();\\n        actions.moveRight();\\n        return;\\n      }\\n\\n      if (event.keyCode === arrowLeft) {\\n        event.preventDefault();\\n        actions.moveLeft();\\n        return;\\n      }\\n\\n      if (scrollJumpKeys[event.keyCode]) {\\n        event.preventDefault();\\n        return;\\n      }\\n\\n      preventStandardKeyEvents(event);\\n    }\\n  }, {\\n    eventName: 'mousedown',\\n    fn: cancel\\n  }, {\\n    eventName: 'mouseup',\\n    fn: cancel\\n  }, {\\n    eventName: 'click',\\n    fn: cancel\\n  }, {\\n    eventName: 'touchstart',\\n    fn: cancel\\n  }, {\\n    eventName: 'resize',\\n    fn: cancel\\n  }, {\\n    eventName: 'wheel',\\n    fn: cancel,\\n    options: {\\n      passive: true\\n    }\\n  }, {\\n    eventName: supportedEventName,\\n    fn: cancel\\n  }];\\n}\\n\\nfunction useKeyboardSensor(api) {\\n  var unbindEventsRef = React.useRef(noop$1);\\n  var startCaptureBinding = useMemoOne.useMemo(function () {\\n    return {\\n      eventName: 'keydown',\\n      fn: function onKeyDown(event) {\\n        if (event.defaultPrevented) {\\n          return;\\n        }\\n\\n        if (event.keyCode !== space) {\\n          return;\\n        }\\n\\n        var draggableId = api.findClosestDraggableId(event);\\n\\n        if (!draggableId) {\\n          return;\\n        }\\n\\n        var preDrag = api.tryGetLock(draggableId, stop, {\\n          sourceEvent: event\\n        });\\n\\n        if (!preDrag) {\\n          return;\\n        }\\n\\n        event.preventDefault();\\n        var isCapturing = true;\\n        var actions = preDrag.snapLift();\\n        unbindEventsRef.current();\\n\\n        function stop() {\\n          !isCapturing ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot stop capturing a keyboard drag when not capturing') : invariant(false) : void 0;\\n          isCapturing = false;\\n          unbindEventsRef.current();\\n          listenForCapture();\\n        }\\n\\n        unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\\n          capture: true,\\n          passive: false\\n        });\\n      }\\n    };\\n  }, [api]);\\n  var listenForCapture = useMemoOne.useCallback(function tryStartCapture() {\\n    var options = {\\n      passive: false,\\n      capture: true\\n    };\\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\\n  }, [startCaptureBinding]);\\n  useIsomorphicLayoutEffect(function mount() {\\n    listenForCapture();\\n    return function unmount() {\\n      unbindEventsRef.current();\\n    };\\n  }, [listenForCapture]);\\n}\\n\\nvar idle$2 = {\\n  type: 'IDLE'\\n};\\nvar timeForLongPress = 120;\\nvar forcePressThreshold = 0.15;\\n\\nfunction getWindowBindings(_ref) {\\n  var cancel = _ref.cancel,\\n      getPhase = _ref.getPhase;\\n  return [{\\n    eventName: 'orientationchange',\\n    fn: cancel\\n  }, {\\n    eventName: 'resize',\\n    fn: cancel\\n  }, {\\n    eventName: 'contextmenu',\\n    fn: function fn(event) {\\n      event.preventDefault();\\n    }\\n  }, {\\n    eventName: 'keydown',\\n    fn: function fn(event) {\\n      if (getPhase().type !== 'DRAGGING') {\\n        cancel();\\n        return;\\n      }\\n\\n      if (event.keyCode === escape) {\\n        event.preventDefault();\\n      }\\n\\n      cancel();\\n    }\\n  }, {\\n    eventName: supportedEventName,\\n    fn: cancel\\n  }];\\n}\\n\\nfunction getHandleBindings(_ref2) {\\n  var cancel = _ref2.cancel,\\n      completed = _ref2.completed,\\n      getPhase = _ref2.getPhase;\\n  return [{\\n    eventName: 'touchmove',\\n    options: {\\n      capture: false\\n    },\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n\\n      if (phase.type !== 'DRAGGING') {\\n        cancel();\\n        return;\\n      }\\n\\n      phase.hasMoved = true;\\n      var _event$touches$ = event.touches[0],\\n          clientX = _event$touches$.clientX,\\n          clientY = _event$touches$.clientY;\\n      var point = {\\n        x: clientX,\\n        y: clientY\\n      };\\n      event.preventDefault();\\n      phase.actions.move(point);\\n    }\\n  }, {\\n    eventName: 'touchend',\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n\\n      if (phase.type !== 'DRAGGING') {\\n        cancel();\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      phase.actions.drop({\\n        shouldBlockNextClick: true\\n      });\\n      completed();\\n    }\\n  }, {\\n    eventName: 'touchcancel',\\n    fn: function fn(event) {\\n      if (getPhase().type !== 'DRAGGING') {\\n        cancel();\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      cancel();\\n    }\\n  }, {\\n    eventName: 'touchforcechange',\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n      !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false) : invariant(false) : void 0;\\n      var touch = event.touches[0];\\n\\n      if (!touch) {\\n        return;\\n      }\\n\\n      var isForcePress = touch.force >= forcePressThreshold;\\n\\n      if (!isForcePress) {\\n        return;\\n      }\\n\\n      var shouldRespect = phase.actions.shouldRespectForcePress();\\n\\n      if (phase.type === 'PENDING') {\\n        if (shouldRespect) {\\n          cancel();\\n        }\\n\\n        return;\\n      }\\n\\n      if (shouldRespect) {\\n        if (phase.hasMoved) {\\n          event.preventDefault();\\n          return;\\n        }\\n\\n        cancel();\\n        return;\\n      }\\n\\n      event.preventDefault();\\n    }\\n  }, {\\n    eventName: supportedEventName,\\n    fn: cancel\\n  }];\\n}\\n\\nfunction useMouseSensor$1(api) {\\n  var phaseRef = React.useRef(idle$2);\\n  var unbindEventsRef = React.useRef(noop);\\n  var getPhase = useMemoOne.useCallback(function getPhase() {\\n    return phaseRef.current;\\n  }, []);\\n  var setPhase = useMemoOne.useCallback(function setPhase(phase) {\\n    phaseRef.current = phase;\\n  }, []);\\n  var startCaptureBinding = useMemoOne.useMemo(function () {\\n    return {\\n      eventName: 'touchstart',\\n      fn: function onTouchStart(event) {\\n        if (event.defaultPrevented) {\\n          return;\\n        }\\n\\n        var draggableId = api.findClosestDraggableId(event);\\n\\n        if (!draggableId) {\\n          return;\\n        }\\n\\n        var actions = api.tryGetLock(draggableId, stop, {\\n          sourceEvent: event\\n        });\\n\\n        if (!actions) {\\n          return;\\n        }\\n\\n        var touch = event.touches[0];\\n        var clientX = touch.clientX,\\n            clientY = touch.clientY;\\n        var point = {\\n          x: clientX,\\n          y: clientY\\n        };\\n        unbindEventsRef.current();\\n        startPendingDrag(actions, point);\\n      }\\n    };\\n  }, [api]);\\n  var listenForCapture = useMemoOne.useCallback(function listenForCapture() {\\n    var options = {\\n      capture: true,\\n      passive: false\\n    };\\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\\n  }, [startCaptureBinding]);\\n  var stop = useMemoOne.useCallback(function () {\\n    var current = phaseRef.current;\\n\\n    if (current.type === 'IDLE') {\\n      return;\\n    }\\n\\n    if (current.type === 'PENDING') {\\n      clearTimeout(current.longPressTimerId);\\n    }\\n\\n    setPhase(idle$2);\\n    unbindEventsRef.current();\\n    listenForCapture();\\n  }, [listenForCapture, setPhase]);\\n  var cancel = useMemoOne.useCallback(function () {\\n    var phase = phaseRef.current;\\n    stop();\\n\\n    if (phase.type === 'DRAGGING') {\\n      phase.actions.cancel({\\n        shouldBlockNextClick: true\\n      });\\n    }\\n\\n    if (phase.type === 'PENDING') {\\n      phase.actions.abort();\\n    }\\n  }, [stop]);\\n  var bindCapturingEvents = useMemoOne.useCallback(function bindCapturingEvents() {\\n    var options = {\\n      capture: true,\\n      passive: false\\n    };\\n    var args = {\\n      cancel: cancel,\\n      completed: stop,\\n      getPhase: getPhase\\n    };\\n    var unbindTarget = bindEvents(window, getHandleBindings(args), options);\\n    var unbindWindow = bindEvents(window, getWindowBindings(args), options);\\n\\n    unbindEventsRef.current = function unbindAll() {\\n      unbindTarget();\\n      unbindWindow();\\n    };\\n  }, [cancel, getPhase, stop]);\\n  var startDragging = useMemoOne.useCallback(function startDragging() {\\n    var phase = getPhase();\\n    !(phase.type === 'PENDING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot start dragging from phase \\\" + phase.type) : invariant(false) : void 0;\\n    var actions = phase.actions.fluidLift(phase.point);\\n    setPhase({\\n      type: 'DRAGGING',\\n      actions: actions,\\n      hasMoved: false\\n    });\\n  }, [getPhase, setPhase]);\\n  var startPendingDrag = useMemoOne.useCallback(function startPendingDrag(actions, point) {\\n    !(getPhase().type === 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected to move from IDLE to PENDING drag') : invariant(false) : void 0;\\n    var longPressTimerId = setTimeout(startDragging, timeForLongPress);\\n    setPhase({\\n      type: 'PENDING',\\n      point: point,\\n      actions: actions,\\n      longPressTimerId: longPressTimerId\\n    });\\n    bindCapturingEvents();\\n  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);\\n  useIsomorphicLayoutEffect(function mount() {\\n    listenForCapture();\\n    return function unmount() {\\n      unbindEventsRef.current();\\n      var phase = getPhase();\\n\\n      if (phase.type === 'PENDING') {\\n        clearTimeout(phase.longPressTimerId);\\n        setPhase(idle$2);\\n      }\\n    };\\n  }, [getPhase, listenForCapture, setPhase]);\\n  useIsomorphicLayoutEffect(function webkitHack() {\\n    var unbind = bindEvents(window, [{\\n      eventName: 'touchmove',\\n      fn: function fn() {},\\n      options: {\\n        capture: false,\\n        passive: false\\n      }\\n    }]);\\n    return unbind;\\n  }, []);\\n}\\n\\nfunction useValidateSensorHooks(sensorHooks) {\\n  useDev(function () {\\n    var previousRef = usePrevious(sensorHooks);\\n    useDevSetupWarning(function () {\\n      !(previousRef.current.length === sensorHooks.length) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot change the amount of sensor hooks after mounting') : invariant(false) : void 0;\\n    });\\n  });\\n}\\n\\nvar interactiveTagNames = {\\n  input: true,\\n  button: true,\\n  textarea: true,\\n  select: true,\\n  option: true,\\n  optgroup: true,\\n  video: true,\\n  audio: true\\n};\\n\\nfunction isAnInteractiveElement(parent, current) {\\n  if (current == null) {\\n    return false;\\n  }\\n\\n  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);\\n\\n  if (hasAnInteractiveTag) {\\n    return true;\\n  }\\n\\n  var attribute = current.getAttribute('contenteditable');\\n\\n  if (attribute === 'true' || attribute === '') {\\n    return true;\\n  }\\n\\n  if (current === parent) {\\n    return false;\\n  }\\n\\n  return isAnInteractiveElement(parent, current.parentElement);\\n}\\n\\nfunction isEventInInteractiveElement(draggable, event) {\\n  var target = event.target;\\n\\n  if (!isHtmlElement(target)) {\\n    return false;\\n  }\\n\\n  return isAnInteractiveElement(draggable, target);\\n}\\n\\nvar getBorderBoxCenterPosition = (function (el) {\\n  return cssBoxModel.getRect(el.getBoundingClientRect()).center;\\n});\\n\\nfunction isElement(el) {\\n  return el instanceof getWindowFromEl(el).Element;\\n}\\n\\nvar supportedMatchesName = function () {\\n  var base = 'matches';\\n\\n  if (typeof document === 'undefined') {\\n    return base;\\n  }\\n\\n  var candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];\\n  var value = find(candidates, function (name) {\\n    return name in Element.prototype;\\n  });\\n  return value || base;\\n}();\\n\\nfunction closestPonyfill(el, selector) {\\n  if (el == null) {\\n    return null;\\n  }\\n\\n  if (el[supportedMatchesName](selector)) {\\n    return el;\\n  }\\n\\n  return closestPonyfill(el.parentElement, selector);\\n}\\n\\nfunction closest$1(el, selector) {\\n  if (el.closest) {\\n    return el.closest(selector);\\n  }\\n\\n  return closestPonyfill(el, selector);\\n}\\n\\nfunction getSelector(contextId) {\\n  return \\\"[\\\" + dragHandle.contextId + \\\"=\\\\\\\"\\\" + contextId + \\\"\\\\\\\"]\\\";\\n}\\n\\nfunction findClosestDragHandleFromEvent(contextId, event) {\\n  var target = event.target;\\n\\n  if (!isElement(target)) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning('event.target must be a Element') : void 0;\\n    return null;\\n  }\\n\\n  var selector = getSelector(contextId);\\n  var handle = closest$1(target, selector);\\n\\n  if (!handle) {\\n    return null;\\n  }\\n\\n  if (!isHtmlElement(handle)) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning('drag handle must be a HTMLElement') : void 0;\\n    return null;\\n  }\\n\\n  return handle;\\n}\\n\\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\\n  var handle = findClosestDragHandleFromEvent(contextId, event);\\n\\n  if (!handle) {\\n    return null;\\n  }\\n\\n  return handle.getAttribute(dragHandle.draggableId);\\n}\\n\\nfunction findDraggable(contextId, draggableId) {\\n  var selector = \\\"[\\\" + draggable.contextId + \\\"=\\\\\\\"\\\" + contextId + \\\"\\\\\\\"]\\\";\\n  var possible = toArray(document.querySelectorAll(selector));\\n  var draggable$1 = find(possible, function (el) {\\n    return el.getAttribute(draggable.id) === draggableId;\\n  });\\n\\n  if (!draggable$1) {\\n    return null;\\n  }\\n\\n  if (!isHtmlElement(draggable$1)) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning('Draggable element is not a HTMLElement') : void 0;\\n    return null;\\n  }\\n\\n  return draggable$1;\\n}\\n\\nfunction preventDefault(event) {\\n  event.preventDefault();\\n}\\n\\nfunction _isActive(_ref) {\\n  var expected = _ref.expected,\\n      phase = _ref.phase,\\n      isLockActive = _ref.isLockActive,\\n      shouldWarn = _ref.shouldWarn;\\n\\n  if (!isLockActive()) {\\n    if (shouldWarn) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n        Cannot perform action.\\\\n        The sensor no longer has an action lock.\\\\n\\\\n        Tips:\\\\n\\\\n        - Throw away your action handlers when forceStop() is called\\\\n        - Check actions.isActive() if you really need to\\\\n      \\\") : void 0;\\n    }\\n\\n    return false;\\n  }\\n\\n  if (expected !== phase) {\\n    if (shouldWarn) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n        Cannot perform action.\\\\n        The actions you used belong to an outdated phase\\\\n\\\\n        Current phase: \\\" + expected + \\\"\\\\n        You called an action from outdated phase: \\\" + phase + \\\"\\\\n\\\\n        Tips:\\\\n\\\\n        - Do not use preDragActions actions after calling preDragActions.lift()\\\\n      \\\") : void 0;\\n    }\\n\\n    return false;\\n  }\\n\\n  return true;\\n}\\n\\nfunction canStart(_ref2) {\\n  var lockAPI = _ref2.lockAPI,\\n      store = _ref2.store,\\n      registry = _ref2.registry,\\n      draggableId = _ref2.draggableId;\\n\\n  if (lockAPI.isClaimed()) {\\n    return false;\\n  }\\n\\n  var entry = registry.draggable.findById(draggableId);\\n\\n  if (!entry) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"Unable to find draggable with id: \\\" + draggableId) : void 0;\\n    return false;\\n  }\\n\\n  if (!entry.options.isEnabled) {\\n    return false;\\n  }\\n\\n  if (!canStartDrag(store.getState(), draggableId)) {\\n    return false;\\n  }\\n\\n  return true;\\n}\\n\\nfunction tryStart(_ref3) {\\n  var lockAPI = _ref3.lockAPI,\\n      contextId = _ref3.contextId,\\n      store = _ref3.store,\\n      registry = _ref3.registry,\\n      draggableId = _ref3.draggableId,\\n      forceSensorStop = _ref3.forceSensorStop,\\n      sourceEvent = _ref3.sourceEvent;\\n  var shouldStart = canStart({\\n    lockAPI: lockAPI,\\n    store: store,\\n    registry: registry,\\n    draggableId: draggableId\\n  });\\n\\n  if (!shouldStart) {\\n    return null;\\n  }\\n\\n  var entry = registry.draggable.getById(draggableId);\\n  var el = findDraggable(contextId, entry.descriptor.id);\\n\\n  if (!el) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"Unable to find draggable element with id: \\\" + draggableId) : void 0;\\n    return null;\\n  }\\n\\n  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\\n    return null;\\n  }\\n\\n  var lock = lockAPI.claim(forceSensorStop || noop);\\n  var phase = 'PRE_DRAG';\\n\\n  function getShouldRespectForcePress() {\\n    return entry.options.shouldRespectForcePress;\\n  }\\n\\n  function isLockActive() {\\n    return lockAPI.isActive(lock);\\n  }\\n\\n  function tryDispatch(expected, getAction) {\\n    if (_isActive({\\n      expected: expected,\\n      phase: phase,\\n      isLockActive: isLockActive,\\n      shouldWarn: true\\n    })) {\\n      store.dispatch(getAction());\\n    }\\n  }\\n\\n  var tryDispatchWhenDragging = tryDispatch.bind(this, 'DRAGGING');\\n\\n  function lift$1(args) {\\n    function completed() {\\n      lockAPI.release();\\n      phase = 'COMPLETED';\\n    }\\n\\n    if (phase !== 'PRE_DRAG') {\\n      completed();\\n      !(phase === 'PRE_DRAG') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot lift in phase \\\" + phase) : invariant(false) : void 0;\\n    }\\n\\n    store.dispatch(lift(args.liftActionArgs));\\n    phase = 'DRAGGING';\\n\\n    function finish(reason, options) {\\n      if (options === void 0) {\\n        options = {\\n          shouldBlockNextClick: false\\n        };\\n      }\\n\\n      args.cleanup();\\n\\n      if (options.shouldBlockNextClick) {\\n        var unbind = bindEvents(window, [{\\n          eventName: 'click',\\n          fn: preventDefault,\\n          options: {\\n            once: true,\\n            passive: false,\\n            capture: true\\n          }\\n        }]);\\n        setTimeout(unbind);\\n      }\\n\\n      completed();\\n      store.dispatch(drop({\\n        reason: reason\\n      }));\\n    }\\n\\n    return _extends({\\n      isActive: function isActive() {\\n        return _isActive({\\n          expected: 'DRAGGING',\\n          phase: phase,\\n          isLockActive: isLockActive,\\n          shouldWarn: false\\n        });\\n      },\\n      shouldRespectForcePress: getShouldRespectForcePress,\\n      drop: function drop(options) {\\n        return finish('DROP', options);\\n      },\\n      cancel: function cancel(options) {\\n        return finish('CANCEL', options);\\n      }\\n    }, args.actions);\\n  }\\n\\n  function fluidLift(clientSelection) {\\n    var move$1 = rafSchd(function (client) {\\n      tryDispatchWhenDragging(function () {\\n        return move({\\n          client: client\\n        });\\n      });\\n    });\\n    var api = lift$1({\\n      liftActionArgs: {\\n        id: draggableId,\\n        clientSelection: clientSelection,\\n        movementMode: 'FLUID'\\n      },\\n      cleanup: function cleanup() {\\n        return move$1.cancel();\\n      },\\n      actions: {\\n        move: move$1\\n      }\\n    });\\n    return _extends({}, api, {\\n      move: move$1\\n    });\\n  }\\n\\n  function snapLift() {\\n    var actions = {\\n      moveUp: function moveUp$1() {\\n        return tryDispatchWhenDragging(moveUp);\\n      },\\n      moveRight: function moveRight$1() {\\n        return tryDispatchWhenDragging(moveRight);\\n      },\\n      moveDown: function moveDown$1() {\\n        return tryDispatchWhenDragging(moveDown);\\n      },\\n      moveLeft: function moveLeft$1() {\\n        return tryDispatchWhenDragging(moveLeft);\\n      }\\n    };\\n    return lift$1({\\n      liftActionArgs: {\\n        id: draggableId,\\n        clientSelection: getBorderBoxCenterPosition(el),\\n        movementMode: 'SNAP'\\n      },\\n      cleanup: noop,\\n      actions: actions\\n    });\\n  }\\n\\n  function abortPreDrag() {\\n    var shouldRelease = _isActive({\\n      expected: 'PRE_DRAG',\\n      phase: phase,\\n      isLockActive: isLockActive,\\n      shouldWarn: true\\n    });\\n\\n    if (shouldRelease) {\\n      lockAPI.release();\\n    }\\n  }\\n\\n  var preDrag = {\\n    isActive: function isActive() {\\n      return _isActive({\\n        expected: 'PRE_DRAG',\\n        phase: phase,\\n        isLockActive: isLockActive,\\n        shouldWarn: false\\n      });\\n    },\\n    shouldRespectForcePress: getShouldRespectForcePress,\\n    fluidLift: fluidLift,\\n    snapLift: snapLift,\\n    abort: abortPreDrag\\n  };\\n  return preDrag;\\n}\\n\\nvar defaultSensors = [useMouseSensor, useKeyboardSensor, useMouseSensor$1];\\nfunction useSensorMarshal(_ref4) {\\n  var contextId = _ref4.contextId,\\n      store = _ref4.store,\\n      registry = _ref4.registry,\\n      customSensors = _ref4.customSensors,\\n      enableDefaultSensors = _ref4.enableDefaultSensors;\\n  var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);\\n  var lockAPI = React.useState(function () {\\n    return create();\\n  })[0];\\n  var tryAbandonLock = useMemoOne.useCallback(function tryAbandonLock(previous, current) {\\n    if (previous.isDragging && !current.isDragging) {\\n      lockAPI.tryAbandon();\\n    }\\n  }, [lockAPI]);\\n  useIsomorphicLayoutEffect(function listenToStore() {\\n    var previous = store.getState();\\n    var unsubscribe = store.subscribe(function () {\\n      var current = store.getState();\\n      tryAbandonLock(previous, current);\\n      previous = current;\\n    });\\n    return unsubscribe;\\n  }, [lockAPI, store, tryAbandonLock]);\\n  useIsomorphicLayoutEffect(function () {\\n    return lockAPI.tryAbandon;\\n  }, [lockAPI.tryAbandon]);\\n  var canGetLock = useMemoOne.useCallback(function (draggableId) {\\n    return canStart({\\n      lockAPI: lockAPI,\\n      registry: registry,\\n      store: store,\\n      draggableId: draggableId\\n    });\\n  }, [lockAPI, registry, store]);\\n  var tryGetLock = useMemoOne.useCallback(function (draggableId, forceStop, options) {\\n    return tryStart({\\n      lockAPI: lockAPI,\\n      registry: registry,\\n      contextId: contextId,\\n      store: store,\\n      draggableId: draggableId,\\n      forceSensorStop: forceStop,\\n      sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\\n    });\\n  }, [contextId, lockAPI, registry, store]);\\n  var findClosestDraggableId = useMemoOne.useCallback(function (event) {\\n    return tryGetClosestDraggableIdFromEvent(contextId, event);\\n  }, [contextId]);\\n  var findOptionsForDraggable = useMemoOne.useCallback(function (id) {\\n    var entry = registry.draggable.findById(id);\\n    return entry ? entry.options : null;\\n  }, [registry.draggable]);\\n  var tryReleaseLock = useMemoOne.useCallback(lockAPI.tryAbandon, [lockAPI]);\\n  var isLockClaimed = useMemoOne.useCallback(lockAPI.isClaimed, [lockAPI]);\\n  var api = useMemoOne.useMemo(function () {\\n    return {\\n      canGetLock: canGetLock,\\n      tryGetLock: tryGetLock,\\n      findClosestDraggableId: findClosestDraggableId,\\n      findOptionsForDraggable: findOptionsForDraggable,\\n      tryReleaseLock: tryReleaseLock,\\n      isLockClaimed: isLockClaimed\\n    };\\n  }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);\\n  useValidateSensorHooks(useSensors);\\n\\n  for (var i = 0; i < useSensors.length; i++) {\\n    useSensors[i](api);\\n  }\\n}\\n\\nvar createResponders = function createResponders(props) {\\n  return {\\n    onBeforeDragStart: props.onBeforeDragStart,\\n    onDragStart: props.onDragStart,\\n    onDragEnd: props.onDragEnd,\\n    onDragUpdate: props.onDragUpdate\\n  };\\n};\\n\\nfunction getStore(lazyRef) {\\n  !lazyRef.current ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find store from lazy ref') : invariant(false) : void 0;\\n  return lazyRef.current;\\n}\\n\\nfunction App(props) {\\n  var contextId = props.contextId,\\n      setCallbacks = props.setCallbacks,\\n      sensors = props.sensors,\\n      nonce = props.nonce,\\n      liftInstruction = props.liftInstruction;\\n  var lazyStoreRef = React.useRef(null);\\n  useStartupValidation();\\n  var lastPropsRef = usePrevious(props);\\n  var getResponders = useMemoOne.useCallback(function () {\\n    return createResponders(lastPropsRef.current);\\n  }, [lastPropsRef]);\\n  var announce = useAnnouncer(contextId);\\n  var liftInstructionId = useLiftInstruction(contextId, liftInstruction);\\n  var styleMarshal = useStyleMarshal(contextId, nonce);\\n  var lazyDispatch = useMemoOne.useCallback(function (action) {\\n    getStore(lazyStoreRef).dispatch(action);\\n  }, []);\\n  var marshalCallbacks = useMemoOne.useMemo(function () {\\n    return redux.bindActionCreators({\\n      publishWhileDragging: publishWhileDragging,\\n      updateDroppableScroll: updateDroppableScroll,\\n      updateDroppableIsEnabled: updateDroppableIsEnabled,\\n      updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\\n      collectionStarting: collectionStarting\\n    }, lazyDispatch);\\n  }, [lazyDispatch]);\\n  var registry = useRegistry();\\n  var dimensionMarshal = useMemoOne.useMemo(function () {\\n    return createDimensionMarshal(registry, marshalCallbacks);\\n  }, [registry, marshalCallbacks]);\\n  var autoScroller = useMemoOne.useMemo(function () {\\n    return createAutoScroller(_extends({\\n      scrollWindow: scrollWindow,\\n      scrollDroppable: dimensionMarshal.scrollDroppable\\n    }, redux.bindActionCreators({\\n      move: move\\n    }, lazyDispatch)));\\n  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);\\n  var focusMarshal = useFocusMarshal(contextId);\\n  var store = useMemoOne.useMemo(function () {\\n    return createStore({\\n      announce: announce,\\n      autoScroller: autoScroller,\\n      dimensionMarshal: dimensionMarshal,\\n      focusMarshal: focusMarshal,\\n      getResponders: getResponders,\\n      styleMarshal: styleMarshal\\n    });\\n  }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (lazyStoreRef.current && lazyStoreRef.current !== store) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning('unexpected store change') : void 0;\\n    }\\n  }\\n\\n  lazyStoreRef.current = store;\\n  var tryResetStore = useMemoOne.useCallback(function () {\\n    var current = getStore(lazyStoreRef);\\n    var state = current.getState();\\n\\n    if (state.phase !== 'IDLE') {\\n      current.dispatch(flush());\\n    }\\n  }, []);\\n  var isDragging = useMemoOne.useCallback(function () {\\n    var state = getStore(lazyStoreRef).getState();\\n    return state.isDragging || state.phase === 'DROP_ANIMATING';\\n  }, []);\\n  var appCallbacks = useMemoOne.useMemo(function () {\\n    return {\\n      isDragging: isDragging,\\n      tryAbort: tryResetStore\\n    };\\n  }, [isDragging, tryResetStore]);\\n  setCallbacks(appCallbacks);\\n  var getCanLift = useMemoOne.useCallback(function (id) {\\n    return canStartDrag(getStore(lazyStoreRef).getState(), id);\\n  }, []);\\n  var getIsMovementAllowed = useMemoOne.useCallback(function () {\\n    return isMovementAllowed(getStore(lazyStoreRef).getState());\\n  }, []);\\n  var appContext = useMemoOne.useMemo(function () {\\n    return {\\n      marshal: dimensionMarshal,\\n      focus: focusMarshal,\\n      contextId: contextId,\\n      canLift: getCanLift,\\n      isMovementAllowed: getIsMovementAllowed,\\n      liftInstructionId: liftInstructionId,\\n      registry: registry\\n    };\\n  }, [contextId, dimensionMarshal, focusMarshal, getCanLift, getIsMovementAllowed, liftInstructionId, registry]);\\n  useSensorMarshal({\\n    contextId: contextId,\\n    store: store,\\n    registry: registry,\\n    customSensors: sensors,\\n    enableDefaultSensors: props.enableDefaultSensors !== false\\n  });\\n  React.useEffect(function () {\\n    return tryResetStore;\\n  }, [tryResetStore]);\\n  return React__default.createElement(AppContext.Provider, {\\n    value: appContext\\n  }, React__default.createElement(reactRedux.Provider, {\\n    context: StoreContext,\\n    store: store\\n  }, props.children));\\n}\\n\\nvar instanceCount = 0;\\nfunction resetServerContext() {\\n  instanceCount = 0;\\n}\\nfunction DragDropContext(props) {\\n  var contextId = useMemoOne.useMemo(function () {\\n    return \\\"\\\" + instanceCount++;\\n  }, []);\\n  var liftInstruction = props.liftInstruction || preset.liftInstruction;\\n  return React__default.createElement(ErrorBoundary, null, function (setCallbacks) {\\n    return React__default.createElement(App, {\\n      nonce: props.nonce,\\n      contextId: contextId,\\n      setCallbacks: setCallbacks,\\n      liftInstruction: liftInstruction,\\n      enableDefaultSensors: props.enableDefaultSensors,\\n      sensors: props.sensors,\\n      onBeforeDragStart: props.onBeforeDragStart,\\n      onDragStart: props.onDragStart,\\n      onDragUpdate: props.onDragUpdate,\\n      onDragEnd: props.onDragEnd\\n    }, props.children);\\n  });\\n}\\n\\nvar isEqual$1 = function isEqual(base) {\\n  return function (value) {\\n    return base === value;\\n  };\\n};\\n\\nvar isScroll = isEqual$1('scroll');\\nvar isAuto = isEqual$1('auto');\\nvar isVisible$1 = isEqual$1('visible');\\n\\nvar isEither = function isEither(overflow, fn) {\\n  return fn(overflow.overflowX) || fn(overflow.overflowY);\\n};\\n\\nvar isBoth = function isBoth(overflow, fn) {\\n  return fn(overflow.overflowX) && fn(overflow.overflowY);\\n};\\n\\nvar isElementScrollable = function isElementScrollable(el) {\\n  var style = window.getComputedStyle(el);\\n  var overflow = {\\n    overflowX: style.overflowX,\\n    overflowY: style.overflowY\\n  };\\n  return isEither(overflow, isScroll) || isEither(overflow, isAuto);\\n};\\n\\nvar isBodyScrollable = function isBodyScrollable() {\\n  if (process.env.NODE_ENV === 'production') {\\n    return false;\\n  }\\n\\n  var body = getBodyElement();\\n  var html = document.documentElement;\\n  !html ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false) : invariant(false) : void 0;\\n\\n  if (!isElementScrollable(body)) {\\n    return false;\\n  }\\n\\n  var htmlStyle = window.getComputedStyle(html);\\n  var htmlOverflow = {\\n    overflowX: htmlStyle.overflowX,\\n    overflowY: htmlStyle.overflowY\\n  };\\n\\n  if (isBoth(htmlOverflow, isVisible$1)) {\\n    return false;\\n  }\\n\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n    We have detected that your <body> element might be a scroll container.\\\\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\\\\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\\\\n\\\\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\\\\n    we will be treating the <body> as *not* a scroll container\\\\n\\\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\\\\n  \\\") : void 0;\\n  return false;\\n};\\n\\nvar getClosestScrollable = function getClosestScrollable(el) {\\n  if (el == null) {\\n    return null;\\n  }\\n\\n  if (el === document.body) {\\n    return isBodyScrollable() ? el : null;\\n  }\\n\\n  if (el === document.documentElement) {\\n    return null;\\n  }\\n\\n  if (!isElementScrollable(el)) {\\n    return getClosestScrollable(el.parentElement);\\n  }\\n\\n  return el;\\n};\\n\\nvar checkForNestedScrollContainers = (function (scrollable) {\\n  if (!scrollable) {\\n    return;\\n  }\\n\\n  var anotherScrollParent = getClosestScrollable(scrollable.parentElement);\\n\\n  if (!anotherScrollParent) {\\n    return;\\n  }\\n\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n    Droppable: unsupported nested scroll container detected.\\\\n    A Droppable can only have one scroll parent (which can be itself)\\\\n    Nested scroll containers are currently not supported.\\\\n\\\\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\\\\n  \\\") : void 0;\\n});\\n\\nvar getScroll$1 = (function (el) {\\n  return {\\n    x: el.scrollLeft,\\n    y: el.scrollTop\\n  };\\n});\\n\\nvar getIsFixed = function getIsFixed(el) {\\n  if (!el) {\\n    return false;\\n  }\\n\\n  var style = window.getComputedStyle(el);\\n\\n  if (style.position === 'fixed') {\\n    return true;\\n  }\\n\\n  return getIsFixed(el.parentElement);\\n};\\n\\nvar getEnv = (function (start) {\\n  var closestScrollable = getClosestScrollable(start);\\n  var isFixedOnPage = getIsFixed(start);\\n  return {\\n    closestScrollable: closestScrollable,\\n    isFixedOnPage: isFixedOnPage\\n  };\\n});\\n\\nvar getDroppableDimension = (function (_ref) {\\n  var descriptor = _ref.descriptor,\\n      isEnabled = _ref.isEnabled,\\n      isCombineEnabled = _ref.isCombineEnabled,\\n      isFixedOnPage = _ref.isFixedOnPage,\\n      direction = _ref.direction,\\n      client = _ref.client,\\n      page = _ref.page,\\n      closest = _ref.closest;\\n\\n  var frame = function () {\\n    if (!closest) {\\n      return null;\\n    }\\n\\n    var scrollSize = closest.scrollSize,\\n        frameClient = closest.client;\\n    var maxScroll = getMaxScroll({\\n      scrollHeight: scrollSize.scrollHeight,\\n      scrollWidth: scrollSize.scrollWidth,\\n      height: frameClient.paddingBox.height,\\n      width: frameClient.paddingBox.width\\n    });\\n    return {\\n      pageMarginBox: closest.page.marginBox,\\n      frameClient: frameClient,\\n      scrollSize: scrollSize,\\n      shouldClipSubject: closest.shouldClipSubject,\\n      scroll: {\\n        initial: closest.scroll,\\n        current: closest.scroll,\\n        max: maxScroll,\\n        diff: {\\n          value: origin,\\n          displacement: origin\\n        }\\n      }\\n    };\\n  }();\\n\\n  var axis = direction === 'vertical' ? vertical : horizontal;\\n  var subject = getSubject({\\n    page: page,\\n    withPlaceholder: null,\\n    axis: axis,\\n    frame: frame\\n  });\\n  var dimension = {\\n    descriptor: descriptor,\\n    isCombineEnabled: isCombineEnabled,\\n    isFixedOnPage: isFixedOnPage,\\n    axis: axis,\\n    isEnabled: isEnabled,\\n    client: client,\\n    page: page,\\n    frame: frame,\\n    subject: subject\\n  };\\n  return dimension;\\n});\\n\\nvar getClient = function getClient(targetRef, closestScrollable) {\\n  var base = cssBoxModel.getBox(targetRef);\\n\\n  if (!closestScrollable) {\\n    return base;\\n  }\\n\\n  if (targetRef !== closestScrollable) {\\n    return base;\\n  }\\n\\n  var top = base.paddingBox.top - closestScrollable.scrollTop;\\n  var left = base.paddingBox.left - closestScrollable.scrollLeft;\\n  var bottom = top + closestScrollable.scrollHeight;\\n  var right = left + closestScrollable.scrollWidth;\\n  var paddingBox = {\\n    top: top,\\n    right: right,\\n    bottom: bottom,\\n    left: left\\n  };\\n  var borderBox = cssBoxModel.expand(paddingBox, base.border);\\n  var client = cssBoxModel.createBox({\\n    borderBox: borderBox,\\n    margin: base.margin,\\n    border: base.border,\\n    padding: base.padding\\n  });\\n  return client;\\n};\\n\\nvar getDimension = (function (_ref) {\\n  var ref = _ref.ref,\\n      descriptor = _ref.descriptor,\\n      env = _ref.env,\\n      windowScroll = _ref.windowScroll,\\n      direction = _ref.direction,\\n      isDropDisabled = _ref.isDropDisabled,\\n      isCombineEnabled = _ref.isCombineEnabled,\\n      shouldClipSubject = _ref.shouldClipSubject;\\n  var closestScrollable = env.closestScrollable;\\n  var client = getClient(ref, closestScrollable);\\n  var page = cssBoxModel.withScroll(client, windowScroll);\\n\\n  var closest = function () {\\n    if (!closestScrollable) {\\n      return null;\\n    }\\n\\n    var frameClient = cssBoxModel.getBox(closestScrollable);\\n    var scrollSize = {\\n      scrollHeight: closestScrollable.scrollHeight,\\n      scrollWidth: closestScrollable.scrollWidth\\n    };\\n    return {\\n      client: frameClient,\\n      page: cssBoxModel.withScroll(frameClient, windowScroll),\\n      scroll: getScroll$1(closestScrollable),\\n      scrollSize: scrollSize,\\n      shouldClipSubject: shouldClipSubject\\n    };\\n  }();\\n\\n  var dimension = getDroppableDimension({\\n    descriptor: descriptor,\\n    isEnabled: !isDropDisabled,\\n    isCombineEnabled: isCombineEnabled,\\n    isFixedOnPage: env.isFixedOnPage,\\n    direction: direction,\\n    client: client,\\n    page: page,\\n    closest: closest\\n  });\\n  return dimension;\\n});\\n\\nvar immediate = {\\n  passive: false\\n};\\nvar delayed = {\\n  passive: true\\n};\\nvar getListenerOptions = (function (options) {\\n  return options.shouldPublishImmediately ? immediate : delayed;\\n});\\n\\nfunction useRequiredContext(Context) {\\n  var result = React.useContext(Context);\\n  !result ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find required context') : invariant(false) : void 0;\\n  return result;\\n}\\n\\nvar count = 0;\\nfunction useUniqueId(prefix) {\\n  var countRef = React.useRef(count++);\\n  return prefix + \\\"::\\\" + countRef.current;\\n}\\n\\nvar getClosestScrollableFromDrag = function getClosestScrollableFromDrag(dragging) {\\n  return dragging && dragging.env.closestScrollable || null;\\n};\\n\\nfunction useDroppablePublisher(args) {\\n  var whileDraggingRef = React.useRef(null);\\n  var appContext = useRequiredContext(AppContext);\\n  var uniqueId = useUniqueId('droppable');\\n  var registry = appContext.registry,\\n      marshal = appContext.marshal;\\n  var previousRef = usePrevious(args);\\n  var descriptor = useMemoOne.useMemo(function () {\\n    return {\\n      id: args.droppableId,\\n      type: args.type,\\n      mode: args.mode\\n    };\\n  }, [args.droppableId, args.mode, args.type]);\\n  var publishedDescriptorRef = React.useRef(descriptor);\\n  var memoizedUpdateScroll = useMemoOne.useMemo(function () {\\n    return memoizeOne(function (x, y) {\\n      !whileDraggingRef.current ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Can only update scroll when dragging') : invariant(false) : void 0;\\n      var scroll = {\\n        x: x,\\n        y: y\\n      };\\n      marshal.updateDroppableScroll(descriptor.id, scroll);\\n    });\\n  }, [descriptor.id, marshal]);\\n  var getClosestScroll = useMemoOne.useCallback(function () {\\n    var dragging = whileDraggingRef.current;\\n\\n    if (!dragging || !dragging.env.closestScrollable) {\\n      return origin;\\n    }\\n\\n    return getScroll$1(dragging.env.closestScrollable);\\n  }, []);\\n  var updateScroll = useMemoOne.useCallback(function () {\\n    var scroll = getClosestScroll();\\n    memoizedUpdateScroll(scroll.x, scroll.y);\\n  }, [getClosestScroll, memoizedUpdateScroll]);\\n  var scheduleScrollUpdate = useMemoOne.useMemo(function () {\\n    return rafSchd(updateScroll);\\n  }, [updateScroll]);\\n  var onClosestScroll = useMemoOne.useCallback(function () {\\n    var dragging = whileDraggingRef.current;\\n    var closest = getClosestScrollableFromDrag(dragging);\\n    !(dragging && closest) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find scroll options while scrolling') : invariant(false) : void 0;\\n    var options = dragging.scrollOptions;\\n\\n    if (options.shouldPublishImmediately) {\\n      updateScroll();\\n      return;\\n    }\\n\\n    scheduleScrollUpdate();\\n  }, [scheduleScrollUpdate, updateScroll]);\\n  var getDimensionAndWatchScroll = useMemoOne.useCallback(function (windowScroll, options) {\\n    !!whileDraggingRef.current ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot collect a droppable while a drag is occurring') : invariant(false) : void 0;\\n    var previous = previousRef.current;\\n    var ref = previous.getDroppableRef();\\n    !ref ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot collect without a droppable ref') : invariant(false) : void 0;\\n    var env = getEnv(ref);\\n    var dragging = {\\n      ref: ref,\\n      descriptor: descriptor,\\n      env: env,\\n      scrollOptions: options\\n    };\\n    whileDraggingRef.current = dragging;\\n    var dimension = getDimension({\\n      ref: ref,\\n      descriptor: descriptor,\\n      env: env,\\n      windowScroll: windowScroll,\\n      direction: previous.direction,\\n      isDropDisabled: previous.isDropDisabled,\\n      isCombineEnabled: previous.isCombineEnabled,\\n      shouldClipSubject: !previous.ignoreContainerClipping\\n    });\\n    var scrollable = env.closestScrollable;\\n\\n    if (scrollable) {\\n      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\\n      scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        checkForNestedScrollContainers(scrollable);\\n      }\\n    }\\n\\n    return dimension;\\n  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);\\n  var getScrollWhileDragging = useMemoOne.useCallback(function () {\\n    var dragging = whileDraggingRef.current;\\n    var closest = getClosestScrollableFromDrag(dragging);\\n    !(dragging && closest) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Can only recollect Droppable client for Droppables that have a scroll container') : invariant(false) : void 0;\\n    return getScroll$1(closest);\\n  }, []);\\n  var dragStopped = useMemoOne.useCallback(function () {\\n    var dragging = whileDraggingRef.current;\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot stop drag when no active drag') : invariant(false) : void 0;\\n    var closest = getClosestScrollableFromDrag(dragging);\\n    whileDraggingRef.current = null;\\n\\n    if (!closest) {\\n      return;\\n    }\\n\\n    scheduleScrollUpdate.cancel();\\n    closest.removeAttribute(scrollContainer.contextId);\\n    closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\\n  }, [onClosestScroll, scheduleScrollUpdate]);\\n  var scroll = useMemoOne.useCallback(function (change) {\\n    var dragging = whileDraggingRef.current;\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot scroll when there is no drag') : invariant(false) : void 0;\\n    var closest = getClosestScrollableFromDrag(dragging);\\n    !closest ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : invariant(false) : void 0;\\n    closest.scrollTop += change.y;\\n    closest.scrollLeft += change.x;\\n  }, []);\\n  var callbacks = useMemoOne.useMemo(function () {\\n    return {\\n      getDimensionAndWatchScroll: getDimensionAndWatchScroll,\\n      getScrollWhileDragging: getScrollWhileDragging,\\n      dragStopped: dragStopped,\\n      scroll: scroll\\n    };\\n  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll]);\\n  var entry = useMemoOne.useMemo(function () {\\n    return {\\n      uniqueId: uniqueId,\\n      descriptor: descriptor,\\n      callbacks: callbacks\\n    };\\n  }, [callbacks, descriptor, uniqueId]);\\n  useIsomorphicLayoutEffect(function () {\\n    publishedDescriptorRef.current = entry.descriptor;\\n    registry.droppable.register(entry);\\n    return function () {\\n      if (whileDraggingRef.current) {\\n        process.env.NODE_ENV !== \\\"production\\\" ? warning('Unsupported: changing the droppableId or type of a Droppable during a drag') : void 0;\\n        dragStopped();\\n      }\\n\\n      registry.droppable.unregister(entry);\\n    };\\n  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);\\n  useIsomorphicLayoutEffect(function () {\\n    if (!whileDraggingRef.current) {\\n      return;\\n    }\\n\\n    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\\n  }, [args.isDropDisabled, marshal]);\\n  useIsomorphicLayoutEffect(function () {\\n    if (!whileDraggingRef.current) {\\n      return;\\n    }\\n\\n    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\\n  }, [args.isCombineEnabled, marshal]);\\n}\\n\\nfunction noop$2() {}\\n\\nvar empty = {\\n  width: 0,\\n  height: 0,\\n  margin: noSpacing\\n};\\n\\nvar getSize = function getSize(_ref) {\\n  var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount,\\n      placeholder = _ref.placeholder,\\n      animate = _ref.animate;\\n\\n  if (isAnimatingOpenOnMount) {\\n    return empty;\\n  }\\n\\n  if (animate === 'close') {\\n    return empty;\\n  }\\n\\n  return {\\n    height: placeholder.client.borderBox.height,\\n    width: placeholder.client.borderBox.width,\\n    margin: placeholder.client.margin\\n  };\\n};\\n\\nvar getStyle = function getStyle(_ref2) {\\n  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount,\\n      placeholder = _ref2.placeholder,\\n      animate = _ref2.animate;\\n  var size = getSize({\\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\\n    placeholder: placeholder,\\n    animate: animate\\n  });\\n  return {\\n    display: placeholder.display,\\n    boxSizing: 'border-box',\\n    width: size.width,\\n    height: size.height,\\n    marginTop: size.margin.top,\\n    marginRight: size.margin.right,\\n    marginBottom: size.margin.bottom,\\n    marginLeft: size.margin.left,\\n    flexShrink: '0',\\n    flexGrow: '0',\\n    pointerEvents: 'none',\\n    transition: animate !== 'none' ? transitions.placeholder : null\\n  };\\n};\\n\\nfunction Placeholder(props) {\\n  var animateOpenTimerRef = React.useRef(null);\\n  var tryClearAnimateOpenTimer = useMemoOne.useCallback(function () {\\n    if (!animateOpenTimerRef.current) {\\n      return;\\n    }\\n\\n    clearTimeout(animateOpenTimerRef.current);\\n    animateOpenTimerRef.current = null;\\n  }, []);\\n  var animate = props.animate,\\n      onTransitionEnd = props.onTransitionEnd,\\n      onClose = props.onClose,\\n      contextId = props.contextId;\\n\\n  var _useState = React.useState(props.animate === 'open'),\\n      isAnimatingOpenOnMount = _useState[0],\\n      setIsAnimatingOpenOnMount = _useState[1];\\n\\n  React.useEffect(function () {\\n    if (!isAnimatingOpenOnMount) {\\n      return noop$2;\\n    }\\n\\n    if (animate !== 'open') {\\n      tryClearAnimateOpenTimer();\\n      setIsAnimatingOpenOnMount(false);\\n      return noop$2;\\n    }\\n\\n    if (animateOpenTimerRef.current) {\\n      return noop$2;\\n    }\\n\\n    animateOpenTimerRef.current = setTimeout(function () {\\n      animateOpenTimerRef.current = null;\\n      setIsAnimatingOpenOnMount(false);\\n    });\\n    return tryClearAnimateOpenTimer;\\n  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);\\n  var onSizeChangeEnd = useMemoOne.useCallback(function (event) {\\n    if (event.propertyName !== 'height') {\\n      return;\\n    }\\n\\n    onTransitionEnd();\\n\\n    if (animate === 'close') {\\n      onClose();\\n    }\\n  }, [animate, onClose, onTransitionEnd]);\\n  var style = getStyle({\\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\\n    animate: props.animate,\\n    placeholder: props.placeholder\\n  });\\n  return React__default.createElement(props.placeholder.tagName, {\\n    style: style,\\n    'data-rbd-placeholder-context-id': contextId,\\n    onTransitionEnd: onSizeChangeEnd,\\n    ref: props.innerRef\\n  });\\n}\\n\\nvar Placeholder$1 = React__default.memo(Placeholder);\\n\\nvar DroppableContext = React__default.createContext(null);\\n\\nfunction checkIsValidInnerRef(el) {\\n  !(el && isHtmlElement(el)) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"\\\\n    provided.innerRef has not been provided with a HTMLElement.\\\\n\\\\n    You can find a guide on using the innerRef callback functions at:\\\\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\\\\n  \\\") : invariant(false) : void 0;\\n}\\n\\nfunction isBoolean(value) {\\n  return typeof value === 'boolean';\\n}\\n\\nfunction runChecks(args, checks) {\\n  checks.forEach(function (check) {\\n    return check(args);\\n  });\\n}\\n\\nvar shared = [function required(_ref) {\\n  var props = _ref.props;\\n  !props.droppableId ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'A Droppable requires a droppableId prop') : invariant(false) : void 0;\\n  !(typeof props.droppableId === 'string') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"A Droppable requires a [string] droppableId. Provided: [\\\" + typeof props.droppableId + \\\"]\\\") : invariant(false) : void 0;\\n}, function _boolean(_ref2) {\\n  var props = _ref2.props;\\n  !isBoolean(props.isDropDisabled) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'isDropDisabled must be a boolean') : invariant(false) : void 0;\\n  !isBoolean(props.isCombineEnabled) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'isCombineEnabled must be a boolean') : invariant(false) : void 0;\\n  !isBoolean(props.ignoreContainerClipping) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'ignoreContainerClipping must be a boolean') : invariant(false) : void 0;\\n}, function ref(_ref3) {\\n  var getDroppableRef = _ref3.getDroppableRef;\\n  checkIsValidInnerRef(getDroppableRef());\\n}];\\nvar standard = [function placeholder(_ref4) {\\n  var props = _ref4.props,\\n      getPlaceholderRef = _ref4.getPlaceholderRef;\\n\\n  if (!props.placeholder) {\\n    return;\\n  }\\n\\n  var ref = getPlaceholderRef();\\n\\n  if (ref) {\\n    return;\\n  }\\n\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      Droppable setup issue [droppableId: \\\\\\\"\\\" + props.droppableId + \\\"\\\\\\\"]:\\\\n      DroppableProvided > placeholder could not be found.\\\\n\\\\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\\\\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\\\\n    \\\") : void 0;\\n}];\\nvar virtual = [function hasClone(_ref5) {\\n  var props = _ref5.props;\\n  !props.renderClone ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Must provide a clone render function (renderClone) for virtual lists') : invariant(false) : void 0;\\n}, function hasNoPlaceholder(_ref6) {\\n  var getPlaceholderRef = _ref6.getPlaceholderRef;\\n  !!getPlaceholderRef() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected virtual list to not have a placeholder') : invariant(false) : void 0;\\n}];\\nfunction useValidation(args) {\\n  useDevSetupWarning(function () {\\n    runChecks(args, shared);\\n\\n    if (args.props.mode === 'standard') {\\n      runChecks(args, standard);\\n    }\\n\\n    if (args.props.mode === 'virtual') {\\n      runChecks(args, virtual);\\n    }\\n  });\\n}\\n\\nvar AnimateInOut = function (_React$PureComponent) {\\n  _inheritsLoose(AnimateInOut, _React$PureComponent);\\n\\n  function AnimateInOut() {\\n    var _this;\\n\\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\\n    _this.state = {\\n      isVisible: Boolean(_this.props.on),\\n      data: _this.props.on,\\n      animate: _this.props.shouldAnimate && _this.props.on ? 'open' : 'none'\\n    };\\n\\n    _this.onClose = function () {\\n      if (_this.state.animate !== 'close') {\\n        return;\\n      }\\n\\n      _this.setState({\\n        isVisible: false\\n      });\\n    };\\n\\n    return _this;\\n  }\\n\\n  AnimateInOut.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\\n    if (!props.shouldAnimate) {\\n      return {\\n        isVisible: Boolean(props.on),\\n        data: props.on,\\n        animate: 'none'\\n      };\\n    }\\n\\n    if (props.on) {\\n      return {\\n        isVisible: true,\\n        data: props.on,\\n        animate: 'open'\\n      };\\n    }\\n\\n    if (state.isVisible) {\\n      return {\\n        isVisible: true,\\n        data: state.data,\\n        animate: 'close'\\n      };\\n    }\\n\\n    return {\\n      isVisible: false,\\n      animate: 'close',\\n      data: null\\n    };\\n  };\\n\\n  var _proto = AnimateInOut.prototype;\\n\\n  _proto.render = function render() {\\n    if (!this.state.isVisible) {\\n      return null;\\n    }\\n\\n    var provided = {\\n      onClose: this.onClose,\\n      data: this.state.data,\\n      animate: this.state.animate\\n    };\\n    return this.props.children(provided);\\n  };\\n\\n  return AnimateInOut;\\n}(React__default.PureComponent);\\n\\nvar zIndexOptions = {\\n  dragging: 5000,\\n  dropAnimating: 4500\\n};\\n\\nvar getDraggingTransition = function getDraggingTransition(shouldAnimateDragMovement, dropping) {\\n  if (dropping) {\\n    return transitions.drop(dropping.duration);\\n  }\\n\\n  if (shouldAnimateDragMovement) {\\n    return transitions.snap;\\n  }\\n\\n  return transitions.fluid;\\n};\\n\\nvar getDraggingOpacity = function getDraggingOpacity(isCombining, isDropAnimating) {\\n  if (!isCombining) {\\n    return null;\\n  }\\n\\n  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\\n};\\n\\nvar getShouldDraggingAnimate = function getShouldDraggingAnimate(dragging) {\\n  if (dragging.forceShouldAnimate != null) {\\n    return dragging.forceShouldAnimate;\\n  }\\n\\n  return dragging.mode === 'SNAP';\\n};\\n\\nfunction getDraggingStyle(dragging) {\\n  var dimension = dragging.dimension;\\n  var box = dimension.client;\\n  var offset = dragging.offset,\\n      combineWith = dragging.combineWith,\\n      dropping = dragging.dropping;\\n  var isCombining = Boolean(combineWith);\\n  var shouldAnimate = getShouldDraggingAnimate(dragging);\\n  var isDropAnimating = Boolean(dropping);\\n  var transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\\n  var style = {\\n    position: 'fixed',\\n    top: box.marginBox.top,\\n    left: box.marginBox.left,\\n    boxSizing: 'border-box',\\n    width: box.borderBox.width,\\n    height: box.borderBox.height,\\n    transition: getDraggingTransition(shouldAnimate, dropping),\\n    transform: transform,\\n    opacity: getDraggingOpacity(isCombining, isDropAnimating),\\n    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\\n    pointerEvents: 'none'\\n  };\\n  return style;\\n}\\n\\nfunction getSecondaryStyle(secondary) {\\n  return {\\n    transform: transforms.moveTo(secondary.offset),\\n    transition: secondary.shouldAnimateDisplacement ? null : 'none'\\n  };\\n}\\n\\nfunction getStyle$1(mapped) {\\n  return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\\n}\\n\\nfunction getDimension$1(descriptor, el, windowScroll) {\\n  if (windowScroll === void 0) {\\n    windowScroll = origin;\\n  }\\n\\n  var computedStyles = window.getComputedStyle(el);\\n  var borderBox = el.getBoundingClientRect();\\n  var client = cssBoxModel.calculateBox(borderBox, computedStyles);\\n  var page = cssBoxModel.withScroll(client, windowScroll);\\n  var placeholder = {\\n    client: client,\\n    tagName: el.tagName.toLowerCase(),\\n    display: computedStyles.display\\n  };\\n  var displaceBy = {\\n    x: client.marginBox.width,\\n    y: client.marginBox.height\\n  };\\n  var dimension = {\\n    descriptor: descriptor,\\n    placeholder: placeholder,\\n    displaceBy: displaceBy,\\n    client: client,\\n    page: page\\n  };\\n  return dimension;\\n}\\n\\nfunction useDraggablePublisher(args) {\\n  var uniqueId = useUniqueId('draggable');\\n  var descriptor = args.descriptor,\\n      registry = args.registry,\\n      getDraggableRef = args.getDraggableRef,\\n      canDragInteractiveElements = args.canDragInteractiveElements,\\n      shouldRespectForcePress = args.shouldRespectForcePress,\\n      isEnabled = args.isEnabled;\\n  var options = useMemoOne.useMemo(function () {\\n    return {\\n      canDragInteractiveElements: canDragInteractiveElements,\\n      shouldRespectForcePress: shouldRespectForcePress,\\n      isEnabled: isEnabled\\n    };\\n  }, [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);\\n  var getDimension = useMemoOne.useCallback(function (windowScroll) {\\n    var el = getDraggableRef();\\n    !el ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot get dimension when no ref is set') : invariant(false) : void 0;\\n    return getDimension$1(descriptor, el, windowScroll);\\n  }, [descriptor, getDraggableRef]);\\n  var entry = useMemoOne.useMemo(function () {\\n    return {\\n      uniqueId: uniqueId,\\n      descriptor: descriptor,\\n      options: options,\\n      getDimension: getDimension\\n    };\\n  }, [descriptor, getDimension, options, uniqueId]);\\n  var publishedRef = React.useRef(entry);\\n  var isFirstPublishRef = React.useRef(true);\\n  useIsomorphicLayoutEffect(function () {\\n    registry.draggable.register(publishedRef.current);\\n    return function () {\\n      return registry.draggable.unregister(publishedRef.current);\\n    };\\n  }, [registry.draggable]);\\n  useIsomorphicLayoutEffect(function () {\\n    if (isFirstPublishRef.current) {\\n      isFirstPublishRef.current = false;\\n      return;\\n    }\\n\\n    var last = publishedRef.current;\\n    publishedRef.current = entry;\\n    registry.draggable.update(entry, last);\\n  }, [entry, registry.draggable]);\\n}\\n\\nfunction useValidation$1(props, contextId, getRef) {\\n  useDevSetupWarning(function () {\\n    function prefix(id) {\\n      return \\\"Draggable[id: \\\" + id + \\\"]: \\\";\\n    }\\n\\n    var id = props.draggableId;\\n    !id ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Draggable requires a draggableId') : invariant(false) : void 0;\\n    !(typeof id === 'string') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Draggable requires a [string] draggableId.\\\\n      Provided: [type: \\\" + typeof id + \\\"] (value: \\\" + id + \\\")\\\") : invariant(false) : void 0;\\n    !_Number$isInteger(props.index) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, prefix(id) + \\\" requires an integer index prop\\\") : invariant(false) : void 0;\\n\\n    if (props.mapped.type === 'DRAGGING') {\\n      return;\\n    }\\n\\n    checkIsValidInnerRef(getRef());\\n\\n    if (props.isEnabled) {\\n      !findDragHandle(contextId, id) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, prefix(id) + \\\" Unable to find drag handle\\\") : invariant(false) : void 0;\\n    }\\n  });\\n}\\nfunction useClonePropValidation(isClone) {\\n  useDev(function () {\\n    var initialRef = React.useRef(isClone);\\n    useDevSetupWarning(function () {\\n      !(isClone === initialRef.current) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Draggable isClone prop value changed during component life') : invariant(false) : void 0;\\n    }, [isClone]);\\n  });\\n}\\n\\nfunction preventHtml5Dnd(event) {\\n  event.preventDefault();\\n}\\n\\nfunction Draggable(props) {\\n  var ref = React.useRef(null);\\n  var setRef = useMemoOne.useCallback(function (el) {\\n    ref.current = el;\\n  }, []);\\n  var getRef = useMemoOne.useCallback(function () {\\n    return ref.current;\\n  }, []);\\n\\n  var _useRequiredContext = useRequiredContext(AppContext),\\n      contextId = _useRequiredContext.contextId,\\n      liftInstructionId = _useRequiredContext.liftInstructionId,\\n      registry = _useRequiredContext.registry;\\n\\n  var _useRequiredContext2 = useRequiredContext(DroppableContext),\\n      type = _useRequiredContext2.type,\\n      droppableId = _useRequiredContext2.droppableId;\\n\\n  var descriptor = useMemoOne.useMemo(function () {\\n    return {\\n      id: props.draggableId,\\n      index: props.index,\\n      type: type,\\n      droppableId: droppableId\\n    };\\n  }, [props.draggableId, props.index, type, droppableId]);\\n  var children = props.children,\\n      draggableId = props.draggableId,\\n      isEnabled = props.isEnabled,\\n      shouldRespectForcePress = props.shouldRespectForcePress,\\n      canDragInteractiveElements = props.canDragInteractiveElements,\\n      isClone = props.isClone,\\n      mapped = props.mapped,\\n      dropAnimationFinishedAction = props.dropAnimationFinished;\\n  useValidation$1(props, contextId, getRef);\\n  useClonePropValidation(isClone);\\n\\n  if (!isClone) {\\n    var forPublisher = useMemoOne.useMemo(function () {\\n      return {\\n        descriptor: descriptor,\\n        registry: registry,\\n        getDraggableRef: getRef,\\n        canDragInteractiveElements: canDragInteractiveElements,\\n        shouldRespectForcePress: shouldRespectForcePress,\\n        isEnabled: isEnabled\\n      };\\n    }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);\\n    useDraggablePublisher(forPublisher);\\n  }\\n\\n  var dragHandleProps = useMemoOne.useMemo(function () {\\n    return isEnabled ? {\\n      tabIndex: 0,\\n      'data-rbd-drag-handle-draggable-id': draggableId,\\n      'data-rbd-drag-handle-context-id': contextId,\\n      'aria-labelledby': liftInstructionId,\\n      draggable: false,\\n      onDragStart: preventHtml5Dnd\\n    } : null;\\n  }, [contextId, draggableId, isEnabled, liftInstructionId]);\\n  var onMoveEnd = useMemoOne.useCallback(function (event) {\\n    if (mapped.type !== 'DRAGGING') {\\n      return;\\n    }\\n\\n    if (!mapped.dropping) {\\n      return;\\n    }\\n\\n    if (event.propertyName !== 'transform') {\\n      return;\\n    }\\n\\n    dropAnimationFinishedAction();\\n  }, [dropAnimationFinishedAction, mapped]);\\n  var provided = useMemoOne.useMemo(function () {\\n    var style = getStyle$1(mapped);\\n    var onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : null;\\n    var result = {\\n      innerRef: setRef,\\n      draggableProps: {\\n        'data-rbd-draggable-context-id': contextId,\\n        'data-rbd-draggable-id': draggableId,\\n        style: style,\\n        onTransitionEnd: onTransitionEnd\\n      },\\n      dragHandleProps: dragHandleProps\\n    };\\n    return result;\\n  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);\\n  var rubric = useMemoOne.useMemo(function () {\\n    return {\\n      draggableId: descriptor.id,\\n      type: descriptor.type,\\n      source: {\\n        index: descriptor.index,\\n        droppableId: descriptor.droppableId\\n      }\\n    };\\n  }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);\\n  return children(provided, mapped.snapshot, rubric);\\n}\\n\\nvar isStrictEqual = (function (a, b) {\\n  return a === b;\\n});\\n\\nvar whatIsDraggedOverFromResult = (function (result) {\\n  var combine = result.combine,\\n      destination = result.destination;\\n\\n  if (destination) {\\n    return destination.droppableId;\\n  }\\n\\n  if (combine) {\\n    return combine.droppableId;\\n  }\\n\\n  return null;\\n});\\n\\nvar getCombineWithFromResult = function getCombineWithFromResult(result) {\\n  return result.combine ? result.combine.draggableId : null;\\n};\\n\\nvar getCombineWithFromImpact = function getCombineWithFromImpact(impact) {\\n  return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;\\n};\\n\\nfunction getDraggableSelector() {\\n  var memoizedOffset = memoizeOne(function (x, y) {\\n    return {\\n      x: x,\\n      y: y\\n    };\\n  });\\n  var getMemoizedSnapshot = memoizeOne(function (mode, isClone, draggingOver, combineWith, dropping) {\\n    return {\\n      isDragging: true,\\n      isClone: isClone,\\n      isDropAnimating: Boolean(dropping),\\n      dropAnimation: dropping,\\n      mode: mode,\\n      draggingOver: draggingOver,\\n      combineWith: combineWith,\\n      combineTargetFor: null\\n    };\\n  });\\n  var getMemoizedProps = memoizeOne(function (offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {\\n    return {\\n      mapped: {\\n        type: 'DRAGGING',\\n        dropping: null,\\n        draggingOver: draggingOver,\\n        combineWith: combineWith,\\n        mode: mode,\\n        offset: offset,\\n        dimension: dimension,\\n        forceShouldAnimate: forceShouldAnimate,\\n        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\\n      }\\n    };\\n  });\\n\\n  var selector = function selector(state, ownProps) {\\n    if (state.isDragging) {\\n      if (state.critical.draggable.id !== ownProps.draggableId) {\\n        return null;\\n      }\\n\\n      var offset = state.current.client.offset;\\n      var dimension = state.dimensions.draggables[ownProps.draggableId];\\n      var draggingOver = whatIsDraggedOver(state.impact);\\n      var combineWith = getCombineWithFromImpact(state.impact);\\n      var forceShouldAnimate = state.forceShouldAnimate;\\n      return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\\n    }\\n\\n    if (state.phase === 'DROP_ANIMATING') {\\n      var completed = state.completed;\\n\\n      if (completed.result.draggableId !== ownProps.draggableId) {\\n        return null;\\n      }\\n\\n      var isClone = ownProps.isClone;\\n      var _dimension = state.dimensions.draggables[ownProps.draggableId];\\n      var result = completed.result;\\n      var mode = result.mode;\\n\\n      var _draggingOver = whatIsDraggedOverFromResult(result);\\n\\n      var _combineWith = getCombineWithFromResult(result);\\n\\n      var duration = state.dropDuration;\\n      var dropping = {\\n        duration: duration,\\n        curve: curves.drop,\\n        moveTo: state.newHomeClientOffset,\\n        opacity: _combineWith ? combine.opacity.drop : null,\\n        scale: _combineWith ? combine.scale.drop : null\\n      };\\n      return {\\n        mapped: {\\n          type: 'DRAGGING',\\n          offset: state.newHomeClientOffset,\\n          dimension: _dimension,\\n          dropping: dropping,\\n          draggingOver: _draggingOver,\\n          combineWith: _combineWith,\\n          mode: mode,\\n          forceShouldAnimate: null,\\n          snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)\\n        }\\n      };\\n    }\\n\\n    return null;\\n  };\\n\\n  return selector;\\n}\\n\\nfunction getSecondarySnapshot(combineTargetFor) {\\n  return {\\n    isDragging: false,\\n    isDropAnimating: false,\\n    isClone: false,\\n    dropAnimation: null,\\n    mode: null,\\n    draggingOver: null,\\n    combineTargetFor: combineTargetFor,\\n    combineWith: null\\n  };\\n}\\n\\nvar atRest = {\\n  mapped: {\\n    type: 'SECONDARY',\\n    offset: origin,\\n    combineTargetFor: null,\\n    shouldAnimateDisplacement: true,\\n    snapshot: getSecondarySnapshot(null)\\n  }\\n};\\n\\nfunction getSecondarySelector() {\\n  var memoizedOffset = memoizeOne(function (x, y) {\\n    return {\\n      x: x,\\n      y: y\\n    };\\n  });\\n  var getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);\\n  var getMemoizedProps = memoizeOne(function (offset, combineTargetFor, shouldAnimateDisplacement) {\\n    if (combineTargetFor === void 0) {\\n      combineTargetFor = null;\\n    }\\n\\n    return {\\n      mapped: {\\n        type: 'SECONDARY',\\n        offset: offset,\\n        combineTargetFor: combineTargetFor,\\n        shouldAnimateDisplacement: shouldAnimateDisplacement,\\n        snapshot: getMemoizedSnapshot(combineTargetFor)\\n      }\\n    };\\n  });\\n\\n  var getFallback = function getFallback(combineTargetFor) {\\n    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\\n  };\\n\\n  var getProps = function getProps(ownId, draggingId, impact, afterCritical) {\\n    var visualDisplacement = impact.displaced.visible[ownId];\\n    var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\\n    var combine = tryGetCombine(impact);\\n    var combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\\n\\n    if (!visualDisplacement) {\\n      if (!isAfterCriticalInVirtualList) {\\n        return getFallback(combineTargetFor);\\n      }\\n\\n      if (impact.displaced.invisible[ownId]) {\\n        return null;\\n      }\\n\\n      var change = negate(afterCritical.displacedBy.point);\\n\\n      var _offset = memoizedOffset(change.x, change.y);\\n\\n      return getMemoizedProps(_offset, combineTargetFor, true);\\n    }\\n\\n    if (isAfterCriticalInVirtualList) {\\n      return getFallback(combineTargetFor);\\n    }\\n\\n    var displaceBy = impact.displacedBy.point;\\n    var offset = memoizedOffset(displaceBy.x, displaceBy.y);\\n    return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\\n  };\\n\\n  var selector = function selector(state, ownProps) {\\n    if (state.isDragging) {\\n      if (state.critical.draggable.id === ownProps.draggableId) {\\n        return null;\\n      }\\n\\n      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\\n    }\\n\\n    if (state.phase === 'DROP_ANIMATING') {\\n      var completed = state.completed;\\n\\n      if (completed.result.draggableId === ownProps.draggableId) {\\n        return null;\\n      }\\n\\n      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\\n    }\\n\\n    return null;\\n  };\\n\\n  return selector;\\n}\\n\\nvar makeMapStateToProps = function makeMapStateToProps() {\\n  var draggingSelector = getDraggableSelector();\\n  var secondarySelector = getSecondarySelector();\\n\\n  var selector = function selector(state, ownProps) {\\n    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\\n  };\\n\\n  return selector;\\n};\\nvar mapDispatchToProps = {\\n  dropAnimationFinished: dropAnimationFinished\\n};\\nvar ConnectedDraggable = reactRedux.connect(makeMapStateToProps, mapDispatchToProps, null, {\\n  context: StoreContext,\\n  pure: true,\\n  areStatePropsEqual: isStrictEqual\\n})(Draggable);\\n\\nfunction PrivateDraggable(props) {\\n  var droppableContext = useRequiredContext(DroppableContext);\\n  var isUsingCloneFor = droppableContext.isUsingCloneFor;\\n\\n  if (isUsingCloneFor === props.draggableId && !props.isClone) {\\n    return null;\\n  }\\n\\n  return React__default.createElement(ConnectedDraggable, props);\\n}\\nfunction PublicDraggable(props) {\\n  var isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;\\n  var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\\n  var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\\n  return React__default.createElement(PrivateDraggable, _extends({}, props, {\\n    isClone: false,\\n    isEnabled: isEnabled,\\n    canDragInteractiveElements: canDragInteractiveElements,\\n    shouldRespectForcePress: shouldRespectForcePress\\n  }));\\n}\\n\\nfunction Droppable(props) {\\n  var appContext = React.useContext(AppContext);\\n  !appContext ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find app context') : invariant(false) : void 0;\\n  var contextId = appContext.contextId,\\n      isMovementAllowed = appContext.isMovementAllowed;\\n  var droppableRef = React.useRef(null);\\n  var placeholderRef = React.useRef(null);\\n  var children = props.children,\\n      droppableId = props.droppableId,\\n      type = props.type,\\n      mode = props.mode,\\n      direction = props.direction,\\n      ignoreContainerClipping = props.ignoreContainerClipping,\\n      isDropDisabled = props.isDropDisabled,\\n      isCombineEnabled = props.isCombineEnabled,\\n      snapshot = props.snapshot,\\n      useClone = props.useClone,\\n      updateViewportMaxScroll = props.updateViewportMaxScroll,\\n      getContainerForClone = props.getContainerForClone;\\n  var getDroppableRef = useMemoOne.useCallback(function () {\\n    return droppableRef.current;\\n  }, []);\\n  var setDroppableRef = useMemoOne.useCallback(function (value) {\\n    droppableRef.current = value;\\n  }, []);\\n  var getPlaceholderRef = useMemoOne.useCallback(function () {\\n    return placeholderRef.current;\\n  }, []);\\n  var setPlaceholderRef = useMemoOne.useCallback(function (value) {\\n    placeholderRef.current = value;\\n  }, []);\\n  useValidation({\\n    props: props,\\n    getDroppableRef: getDroppableRef,\\n    getPlaceholderRef: getPlaceholderRef\\n  });\\n  var onPlaceholderTransitionEnd = useMemoOne.useCallback(function () {\\n    if (isMovementAllowed()) {\\n      updateViewportMaxScroll({\\n        maxScroll: getMaxWindowScroll()\\n      });\\n    }\\n  }, [isMovementAllowed, updateViewportMaxScroll]);\\n  useDroppablePublisher({\\n    droppableId: droppableId,\\n    type: type,\\n    mode: mode,\\n    direction: direction,\\n    isDropDisabled: isDropDisabled,\\n    isCombineEnabled: isCombineEnabled,\\n    ignoreContainerClipping: ignoreContainerClipping,\\n    getDroppableRef: getDroppableRef\\n  });\\n  var placeholder = React__default.createElement(AnimateInOut, {\\n    on: props.placeholder,\\n    shouldAnimate: props.shouldAnimatePlaceholder\\n  }, function (_ref) {\\n    var onClose = _ref.onClose,\\n        data = _ref.data,\\n        animate = _ref.animate;\\n    return React__default.createElement(Placeholder$1, {\\n      placeholder: data,\\n      onClose: onClose,\\n      innerRef: setPlaceholderRef,\\n      animate: animate,\\n      contextId: contextId,\\n      onTransitionEnd: onPlaceholderTransitionEnd\\n    });\\n  });\\n  var provided = useMemoOne.useMemo(function () {\\n    return {\\n      innerRef: setDroppableRef,\\n      placeholder: placeholder,\\n      droppableProps: {\\n        'data-rbd-droppable-id': droppableId,\\n        'data-rbd-droppable-context-id': contextId\\n      }\\n    };\\n  }, [contextId, droppableId, placeholder, setDroppableRef]);\\n  var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\\n  var droppableContext = useMemoOne.useMemo(function () {\\n    return {\\n      droppableId: droppableId,\\n      type: type,\\n      isUsingCloneFor: isUsingCloneFor\\n    };\\n  }, [droppableId, isUsingCloneFor, type]);\\n\\n  function getClone() {\\n    if (!useClone) {\\n      return null;\\n    }\\n\\n    var dragging = useClone.dragging,\\n        render = useClone.render;\\n    var node = React__default.createElement(PrivateDraggable, {\\n      draggableId: dragging.draggableId,\\n      index: dragging.source.index,\\n      isClone: true,\\n      isEnabled: true,\\n      shouldRespectForcePress: false,\\n      canDragInteractiveElements: true\\n    }, function (draggableProvided, draggableSnapshot) {\\n      return render(draggableProvided, draggableSnapshot, dragging);\\n    });\\n    return ReactDOM.createPortal(node, getContainerForClone());\\n  }\\n\\n  return React__default.createElement(DroppableContext.Provider, {\\n    value: droppableContext\\n  }, children(provided, snapshot), getClone());\\n}\\n\\nvar isMatchingType = function isMatchingType(type, critical) {\\n  return type === critical.droppable.type;\\n};\\n\\nvar getDraggable = function getDraggable(critical, dimensions) {\\n  return dimensions.draggables[critical.draggable.id];\\n};\\n\\nvar makeMapStateToProps$1 = function makeMapStateToProps() {\\n  var idleWithAnimation = {\\n    placeholder: null,\\n    shouldAnimatePlaceholder: true,\\n    snapshot: {\\n      isDraggingOver: false,\\n      draggingOverWith: null,\\n      draggingFromThisWith: null,\\n      isUsingPlaceholder: false\\n    },\\n    useClone: null\\n  };\\n\\n  var idleWithoutAnimation = _extends({}, idleWithAnimation, {\\n    shouldAnimatePlaceholder: false\\n  });\\n\\n  var getDraggableRubric = memoizeOne(function (descriptor) {\\n    return {\\n      draggableId: descriptor.id,\\n      type: descriptor.type,\\n      source: {\\n        index: descriptor.index,\\n        droppableId: descriptor.droppableId\\n      }\\n    };\\n  });\\n  var getMapProps = memoizeOne(function (id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {\\n    var draggableId = dragging.descriptor.id;\\n    var isHome = dragging.descriptor.droppableId === id;\\n\\n    if (isHome) {\\n      var useClone = renderClone ? {\\n        render: renderClone,\\n        dragging: getDraggableRubric(dragging.descriptor)\\n      } : null;\\n      var _snapshot = {\\n        isDraggingOver: isDraggingOverForConsumer,\\n        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\\n        draggingFromThisWith: draggableId,\\n        isUsingPlaceholder: true\\n      };\\n      return {\\n        placeholder: dragging.placeholder,\\n        shouldAnimatePlaceholder: false,\\n        snapshot: _snapshot,\\n        useClone: useClone\\n      };\\n    }\\n\\n    if (!isEnabled) {\\n      return idleWithoutAnimation;\\n    }\\n\\n    if (!isDraggingOverForImpact) {\\n      return idleWithAnimation;\\n    }\\n\\n    var snapshot = {\\n      isDraggingOver: isDraggingOverForConsumer,\\n      draggingOverWith: draggableId,\\n      draggingFromThisWith: null,\\n      isUsingPlaceholder: true\\n    };\\n    return {\\n      placeholder: dragging.placeholder,\\n      shouldAnimatePlaceholder: true,\\n      snapshot: snapshot,\\n      useClone: null\\n    };\\n  });\\n\\n  var selector = function selector(state, ownProps) {\\n    var id = ownProps.droppableId;\\n    var type = ownProps.type;\\n    var isEnabled = !ownProps.isDropDisabled;\\n    var renderClone = ownProps.renderClone;\\n\\n    if (state.isDragging) {\\n      var critical = state.critical;\\n\\n      if (!isMatchingType(type, critical)) {\\n        return idleWithoutAnimation;\\n      }\\n\\n      var dragging = getDraggable(critical, state.dimensions);\\n      var isDraggingOver = whatIsDraggedOver(state.impact) === id;\\n      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\\n    }\\n\\n    if (state.phase === 'DROP_ANIMATING') {\\n      var completed = state.completed;\\n\\n      if (!isMatchingType(type, completed.critical)) {\\n        return idleWithoutAnimation;\\n      }\\n\\n      var _dragging = getDraggable(completed.critical, state.dimensions);\\n\\n      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);\\n    }\\n\\n    if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {\\n      var _completed = state.completed;\\n\\n      if (!isMatchingType(type, _completed.critical)) {\\n        return idleWithoutAnimation;\\n      }\\n\\n      var wasOver = whatIsDraggedOver(_completed.impact) === id;\\n      var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === 'COMBINE');\\n      var isHome = _completed.critical.droppable.id === id;\\n\\n      if (wasOver) {\\n        return wasCombining ? idleWithAnimation : idleWithoutAnimation;\\n      }\\n\\n      if (isHome) {\\n        return idleWithAnimation;\\n      }\\n\\n      return idleWithoutAnimation;\\n    }\\n\\n    return idleWithoutAnimation;\\n  };\\n\\n  return selector;\\n};\\nvar mapDispatchToProps$1 = {\\n  updateViewportMaxScroll: updateViewportMaxScroll\\n};\\n\\nfunction getBody() {\\n  !document.body ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'document.body is not ready') : invariant(false) : void 0;\\n  return document.body;\\n}\\n\\nvar defaultProps = {\\n  mode: 'standard',\\n  type: 'DEFAULT',\\n  direction: 'vertical',\\n  isDropDisabled: false,\\n  isCombineEnabled: false,\\n  ignoreContainerClipping: false,\\n  renderClone: null,\\n  getContainerForClone: getBody\\n};\\nvar ConnectedDroppable = reactRedux.connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {\\n  context: StoreContext,\\n  pure: true,\\n  areStatePropsEqual: isStrictEqual\\n})(Droppable);\\nConnectedDroppable.defaultProps = defaultProps;\\n\\nexports.DragDropContext = DragDropContext;\\nexports.Draggable = PublicDraggable;\\nexports.Droppable = ConnectedDroppable;\\nexports.resetServerContext = resetServerContext;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopDefault\",\"ex\",\"log\",\"type\",\"message\",\"noop\",\"bindEvents\",\"el\",\"bindings\",\"sharedOptions\",\"unbindings\",\"map\",\"binding\",\"options\",\"_extends\",\"addEventListener\",\"eventName\",\"fn\",\"unbind\",\"removeEventListener\",\"unbindAll\",\"forEach\",\"RbdInvariant\",\"invariant\",\"condition\",\"prefix\",\"findIndex\",\"list\",\"predicate\",\"i\",\"length\",\"find\",\"index\",\"tryGetDestination\",\"impact\",\"at\",\"destination\",\"tryGetCombine\",\"combine\",\"getDisplacementGroups\",\"_ref\",\"displacedBy\",\"viewport\",\"forceShouldAnimate\",\"last\",\"afterDragging\",\"reduce\",\"process\",\"groups\",\"draggable\",\"cssBoxModel\",\"getRect\",\"expand\",\"page\",\"marginBox\",\"expandBy\",\"top\",\"point\",\"y\",\"right\",\"bottom\",\"left\",\"x\",\"id\",\"descriptor\",\"all\",\"push\",\"isVisible\",\"args\",\"target\",\"withDroppableDisplacement\",\"isVisibleThroughFrameFn\",\"isPartiallyVisibleThroughFrame\",\"invisible\",\"visible\",\"previous\",\"shouldAnimate\",\"displacement\",\"draggableId\",\"goAtEnd\",\"insideDestination\",\"inHomeList\",\"indexOfLastItem\",\"displaced\",\"emptyGroups\",\"droppableId\",\"newIndex\",\"calculateReorderImpact\",\"_ref2\",\"isHomeOf\",\"match\",\"item\",\"withoutDragging\",\"removeDraggableFromList\",\"sliceFrom\",\"indexOf\",\"impacted\",\"slice\",\"frame\",\"getDraggables\",\"ids\",\"draggables\",\"isMovementAllowed\",\"state\",\"phase\",\"atIndex\",\"closest\",\"calculateCombineImpact\",\"combineWithId\",\"destinationId\",\"userDirection\",\"previousImpact\",\"lastCombineImpact\",\"whenEntered\",\"getDraggables$1\",\"removeScrollJumpRequest\",\"isDragging\",\"movementMode\",\"scrollJumpRequest\",\"getWindowScrollBinding\",\"update\",\"passive\",\"capture\",\"event\",\"window\",\"document\",\"getScrollListener\",\"isActive\",\"onWindowScroll\",\"scheduled\",\"rafSchd\",\"updateScroll\",\"pageXOffset\",\"pageYOffset\",\"start\",\"stop\",\"cancel\",\"createPublisher\",\"registry\",\"callbacks\",\"staging\",\"clean$1\",\"frameId\",\"collect\",\"collectionStarting\",\"requestAnimationFrame\",\"_staging\",\"removals\",\"modified\",\"added\",\"_Object$keys\",\"additions\",\"getById\",\"getDimension\",\"origin\",\"sort\",\"a\",\"b\",\"updated\",\"scroll\",\"droppable\",\"entry\",\"getScrollWhileDragging\",\"result\",\"publish\",\"add\",\"remove\",\"cancelAnimationFrame\",\"shouldPublishUpdate\",\"dragging\",\"home\",\"mode\",\"useStyleMarshal\",\"contextId\",\"nonce\",\"styles\",\"useMemoOne\",\"useMemo\",\"getSelector\",\"makeGetSelector\",\"dragHandle$1\",\"selector\",\"dragHandle\",\"always\",\"resting\",\"grabCursor\",\"noPointerEvents\",\"dropAnimating\",\"transition\",\"transitions\",\"outOfTheWay\",\"userCancel\",\"droppable$1\",\"rules\",\"draggable$1\",\"body\",\"getStyles\",\"alwaysRef\",\"React\",\"useRef\",\"dynamicRef\",\"setDynamicStyle\",\"useCallback\",\"memoizeOne\",\"proposed\",\"current\",\"textContent\",\"setAlwaysStyle\",\"useIsomorphicLayoutEffect\",\"createStyleEl\",\"dynamic\",\"setAttribute\",\"getHead\",\"appendChild\",\"ref\",\"removeChild\",\"dropping\",\"reason\",\"marshal\",\"isHtmlElement\",\"HTMLElement\",\"ownerDocument\",\"defaultView\",\"findDragHandle\",\"possible\",\"Array\",\"prototype\",\"call\",\"querySelectorAll\",\"handle\",\"getAttribute\",\"useFocusMarshal\",\"entriesRef\",\"recordRef\",\"restoreFocusFrameRef\",\"isMountedRef\",\"register\",\"focus\",\"unregister\",\"entries\",\"tryGiveFocus\",\"tryGiveFocusTo\",\"activeElement\",\"tryShiftRecord\",\"redirectTo\",\"tryRestoreFocusRecorded\",\"record\",\"tryRecordFocus\",\"focused\",\"clearFrameOnUnmount\",\"createRegistry\",\"notify\",\"subscribers\",\"cb\",\"findDraggableById\",\"findDroppableById\",\"droppables\",\"draggableAPI\",\"value\",\"uniqueId\",\"getDraggableById\",\"findById\",\"exists\",\"getAllByType\",\"_Object$values\",\"filter\",\"droppableAPI\",\"getDroppableById\",\"subscribe\",\"unsubscribe\",\"splice\",\"clean\",\"useRegistry\",\"useEffect\",\"unmount\",\"useAnnouncer\",\"createElement\",\"_Object$assign\",\"style\",\"visuallyHidden\",\"getBodyElement\",\"setTimeout\",\"toBeRemoved\",\"announce\",\"useLiftInstruction\",\"liftInstruction\",\"mount\",\"usePrevious\",\"create\",\"release\",\"lock\",\"isClaimed\",\"claim\",\"abandon\",\"newLock\",\"tryAbandon\",\"getCaptureBindings\",\"completed\",\"getPhase\",\"setPhase\",\"primaryButton\",\"button\",\"clientX\",\"clientY\",\"preventDefault\",\"actions\",\"move\",\"pending\",\"sloppyClickThreshold\",\"Math\",\"abs\",\"fluidLift\",\"drop\",\"shouldBlockNextClick\",\"escape\",\"keyCode\",\"preventedKeys\",\"shouldRespectForcePress\",\"supportedEventName\",\"noop$1\",\"getDraggingBindings\",\"space\",\"arrowDown\",\"moveDown\",\"arrowUp\",\"moveUp\",\"arrowRight\",\"moveRight\",\"arrowLeft\",\"moveLeft\",\"scrollJumpKeys\",\"getWindowBindings\",\"getHandleBindings\",\"hasMoved\",\"_event$touches$\",\"touches\",\"touch\",\"forcePressThreshold\",\"force\",\"shouldRespect\",\"isAnInteractiveElement\",\"parent\",\"interactiveTagNames\",\"hasAnInteractiveTag\",\"tagName\",\"toLowerCase\",\"attribute\",\"parentElement\",\"isEventInInteractiveElement\",\"closestPonyfill\",\"supportedMatchesName\",\"findClosestDragHandleFromEvent\",\"Element\",\"findDraggable\",\"_isActive\",\"expected\",\"isLockActive\",\"shouldWarn\",\"canStart\",\"store\",\"lockAPI\",\"isEnabled\",\"canStartDrag\",\"getState\",\"tryStart\",\"_ref3\",\"getShouldRespectForcePress\",\"lift$1\",\"finish\",\"cleanup\",\"once\",\"dispatch\",\"payload\",\"liftActionArgs\",\"forceSensorStop\",\"sourceEvent\",\"shouldStart\",\"canDragInteractiveElements\",\"tryDispatchWhenDragging\",\"tryDispatch\",\"getAction\",\"bind\",\"preDrag\",\"clientSelection\",\"move$1\",\"client\",\"api\",\"snapLift\",\"getBoundingClientRect\",\"center\",\"moveUp$1\",\"moveRight$1\",\"moveDown$1\",\"moveLeft$1\",\"abort\",\"abortPreDrag\",\"shouldRelease\",\"useSensorMarshal\",\"_ref4\",\"useSensors\",\"concat\",\"enableDefaultSensors\",\"defaultSensors\",\"customSensors\",\"useState\",\"tryAbandonLock\",\"listenToStore\",\"canGetLock\",\"tryGetLock\",\"forceStop\",\"findClosestDraggableId\",\"findOptionsForDraggable\",\"tryReleaseLock\",\"isLockClaimed\",\"getStore\",\"lazyRef\",\"App\",\"props\",\"setCallbacks\",\"sensors\",\"lazyStoreRef\",\"lastPropsRef\",\"getResponders\",\"onBeforeDragStart\",\"onDragStart\",\"onDragEnd\",\"onDragUpdate\",\"liftInstructionId\",\"styleMarshal\",\"lazyDispatch\",\"action\",\"marshalCallbacks\",\"redux\",\"bindActionCreators\",\"publishWhileDragging\",\"updateDroppableScroll\",\"updateDroppableIsEnabled\",\"updateDroppableIsCombineEnabled\",\"dimensionMarshal\",\"createDimensionMarshal\",\"autoScroller\",\"createAutoScroller\",\"scrollWindow\",\"scrollDroppable\",\"focusMarshal\",\"createStore\",\"reducer\",\"composeEnhancers\",\"applyMiddleware\",\"dimensionMarshalStopper\",\"drop$1\",\"dropAnimationFinish\",\"dropAnimationFlushOnScroll\",\"pendingDrop\",\"autoScroll\",\"scrollListener\",\"responders\",\"tryResetStore\",\"appCallbacks\",\"tryAbort\",\"getCanLift\",\"getIsMovementAllowed\",\"appContext\",\"canLift\",\"React__default\",\"AppContext\",\"Provider\",\"reactRedux\",\"context\",\"StoreContext\",\"children\",\"useRequiredContext\",\"Context\",\"useContext\",\"useUniqueId\",\"countRef\",\"count\",\"useDroppablePublisher\",\"whileDraggingRef\",\"previousRef\",\"publishedDescriptorRef\",\"memoizedUpdateScroll\",\"getClosestScroll\",\"env\",\"closestScrollable\",\"getScroll$1\",\"scheduleScrollUpdate\",\"onClosestScroll\",\"scrollOptions\",\"shouldPublishImmediately\",\"getDimensionAndWatchScroll\",\"windowScroll\",\"getDroppableRef\",\"getClosestScrollable\",\"isFixedOnPage\",\"getIsFixed\",\"direction\",\"isDropDisabled\",\"isCombineEnabled\",\"shouldClipSubject\",\"ignoreContainerClipping\",\"base\",\"getBox\",\"paddingBox\",\"scrollTop\",\"scrollLeft\",\"borderBox\",\"scrollWidth\",\"scrollHeight\",\"border\",\"createBox\",\"margin\",\"padding\",\"withScroll\",\"frameClient\",\"scrollSize\",\"maxScroll\",\"getMaxScroll\",\"height\",\"width\",\"pageMarginBox\",\"initial\",\"max\",\"diff\",\"axis\",\"vertical\",\"horizontal\",\"subject\",\"getSubject\",\"withPlaceholder\",\"dimension\",\"scrollable\",\"scrollContainer\",\"immediate\",\"delayed\",\"dragStopped\",\"removeAttribute\",\"change\",\"noop$2\",\"useDraggablePublisher\",\"getDraggableRef\",\"computedStyles\",\"getComputedStyle\",\"calculateBox\",\"placeholder\",\"display\",\"displaceBy\",\"publishedRef\",\"isFirstPublishRef\",\"preventHtml5Dnd\",\"getDraggableSelector\",\"memoizedOffset\",\"getMemoizedSnapshot\",\"isClone\",\"draggingOver\",\"combineWith\",\"isDropAnimating\",\"dropAnimation\",\"combineTargetFor\",\"getMemoizedProps\",\"offset\",\"mapped\",\"snapshot\",\"ownProps\",\"critical\",\"dimensions\",\"whatIsDraggedOver\",\"_dimension\",\"_draggingOver\",\"whatIsDraggedOverFromResult\",\"_combineWith\",\"duration\",\"dropDuration\",\"curve\",\"curves\",\"moveTo\",\"newHomeClientOffset\",\"opacity\",\"scale\",\"getSecondarySnapshot\",\"getSecondarySelector\",\"shouldAnimateDisplacement\",\"getProps\",\"ownId\",\"draggingId\",\"afterCritical\",\"visualDisplacement\",\"isAfterCriticalInVirtualList\",\"inVirtualList\",\"effected\",\"negate\",\"_offset\",\"PrivateDraggable\",\"droppableContext\",\"DroppableContext\",\"isUsingCloneFor\",\"ConnectedDraggable\",\"Object\",\"defineProperty\",\"_inheritsLoose\",\"_Date$now\",\"ReactDOM\",\"toString\",\"RbdInvariant.prototype.toString\",\"ErrorBoundary\",\"_React$Component\",\"_this\",\"_len\",\"arguments\",\"_key\",\"apply\",\"onWindowError\",\"_this.onWindowError\",\"getCallbacks\",\"error\",\"_this.getCallbacks\",\"Error\",\"_this.setCallbacks\",\"_proto\",\"componentDidMount\",\"_proto.componentDidMount\",\"componentWillUnmount\",\"_proto.componentWillUnmount\",\"componentDidCatch\",\"_proto.componentDidCatch\",\"err\",\"setState\",\"render\",\"_proto.render\",\"Component\",\"withLocation\",\"source\",\"startPosition\",\"endPosition\",\"withCombine\",\"returnedToStart\",\"location\",\"point1\",\"point2\",\"subtract\",\"isEqual\",\"patch\",\"line\",\"otherValue\",\"distance\",\"sqrt\",\"pow\",\"points\",\"min\",\"offsetByPosition\",\"spacing\",\"getCorners\",\"increasedBy\",\"_extends2\",\"scrolled\",\"end\",\"increased\",\"active\",\"clipped\",\"newScroll\",\"scrollDiff\",\"scrollDisplacement\",\"toDroppableMap\",\"toDraggableMap\",\"toDroppableList\",\"toDraggableList\",\"getDraggablesInsideDroppable\",\"forward\",\"backward\",\"moveToNextCombine\",\"getImpact\",\"isMovingForward\",\"closestId\",\"withoutDraggable\",\"indexOfClosest\",\"d\",\"proposedIndex\",\"before\",\"noDisplacedBy\",\"noImpact\",\"isWithin\",\"lowerBound\",\"upperBound\",\"isWithinVertical\",\"isWithinHorizontal\",\"isPartiallyVisibleVertically\",\"isPartiallyVisibleHorizontally\",\"isBiggerVertically\",\"isBiggerHorizontally\",\"isTotallyVisibleThroughFrame\",\"crossAxisLine\",\"size\",\"crossAxisStart\",\"crossAxisEnd\",\"crossAxisSize\",\"isTotallyVisibleThroughFrameOnAxis\",\"toBeDisplaced\",\"displacedTarget\",\"isTotallyVisible\",\"getCombinedItemDisplacement\",\"isDisplaced\",\"getCrossAxisBorderBoxCenter\",\"isMoving\",\"goAfter\",\"moveRelativeTo\",\"goBefore\",\"whenReordering\",\"draggablePage\",\"moveInto\",\"contentBox\",\"closestAfter\",\"withDisplacement\",\"getPageBorderBoxCenterFromImpact\",\"original\",\"withoutDisplacement\",\"scrollViewport\",\"speculativelyIncrease\",\"maxScrollChange\",\"scrolledViewport\",\"scrolledDroppable\",\"withViewportScroll\",\"withDroppableScroll\",\"newImpact\",\"getClientFromPageBorderBoxCenter\",\"withoutPageScrollChange\",\"pageBorderBoxCenter\",\"isTotallyVisibleInNewLocation\",\"_ref$onlyOnMainAxis\",\"onlyOnMainAxis\",\"changeNeeded\",\"newPageBorderBoxCenter\",\"shifted\",\"moveToNextPlace\",\"previousPageBorderBoxCenter\",\"previousClientSelection\",\"isInHomeList\",\"wasAt\",\"currentIndex\",\"lastIndex\",\"_newIndex\",\"combineId\",\"combineWithIndex\",\"didCombineWithStartAfterCritical\",\"isVisibleInNewLocation\",\"cautious\",\"getKnownActive\",\"rect\",\"getBestCrossAxisDroppable\",\"isBetweenSourceClipped\",\"candidates\",\"activeOfTarget\",\"isBetweenDestinationClipped\",\"first\",\"second\",\"array\",\"contains\",\"isWithinDroppable\",\"getCurrentPageBorderBoxCenter\",\"getClosestDraggable\",\"sorted\",\"distanceToA\",\"distanceToB\",\"getDisplacedBy\",\"getRequiredGrowthForPlaceholder\",\"placeholderSize\",\"availableSpace\",\"needsToGrowBy\",\"insideDroppable\",\"spaceUsed\",\"sum\",\"addPlaceholder\",\"requiredGrowth\",\"oldFrameMaxScroll\",\"_subject\",\"newFrame\",\"moveInDirection\",\"isOver\",\"isActuallyOver\",\"isMovingOnMainAxis\",\"borderBoxCenter\",\"_state$dimensions\",\"isGoingBeforeTarget\",\"relativeTo\",\"proposedPageBorderBoxCenter\",\"isPositionInFrame\",\"getDroppableOver$1\",\"maybe\",\"isUserMovingForward\",\"getReorderImpact\",\"currentCenter\",\"pageBorderBoxCenterWithDroppableScrollChange\",\"targetCenter\",\"child\",\"didStartAfterCritical$1\",\"getCombineImpact\",\"canBeDisplacedBy\",\"twoThirdsOfSize\",\"getDragImpact\",\"patchDroppableMap\",\"forcedImpact\",\"currentWindowScroll\",\"selection\",\"now\",\"lastDroppable\",\"oldMaxScroll\",\"_subject2\",\"cleaned\",\"patched\",\"withUpdatedPlaceholders\",\"recompute\",\"getClientBorderBoxCenter\",\"refreshSnap\",\"forcedDimensions\",\"forcedViewport\",\"needsVisibilityCheck\",\"getHomeLocation\",\"getLiftEffect\",\"insideHome\",\"rawIndex\",\"adjustAdditionsForScrollChanges\",\"updatedDroppables\",\"windowScrollChange\",\"totalChange\",\"initialWindowScroll\",\"moved\",\"publishWhileDraggingInVirtual\",\"_extends3\",\"published\",\"withScrollChange\",\"existing\",\"updatedAdditions\",\"wasOver\",\"wasOverId\",\"_getLiftEffect\",\"onLiftImpact\",\"draggingState\",\"dropPending\",\"isWaiting\",\"postDroppableChange\",\"isEnabledChanging\",\"idle\",\"shouldFlush\",\"_action$payload\",\"isWindowScrollAllowed\",\"every\",\"_result\",\"_clientSelection\",\"_action$payload2\",\"_action$payload3\",\"_target\",\"_action$payload4\",\"_target2\",\"_updated\",\"_newScroll\",\"_viewport\",\"withMaxScroll\",\"_result2\",\"newState\",\"_action$payload5\",\"_result3\",\"completeDrop\",\"dropAnimationFinished\",\"next\",\"_marshal$startPublish\",\"startPublishing\",\"request\",\"combining\",\"outOfTheWayTiming\",\"fluid\",\"snap\",\"timing\",\"transforms\",\"isCombining\",\"translate\",\"dropTimeRange\",\"maxDropTime\",\"minDropTime\",\"lastImpact\",\"withoutMovement\",\"recomputedHomeImpact\",\"didDropInsideDroppable\",\"newClientCenter\",\"distance$1\",\"maxDropTimeAtDistance\",\"Number\",\"toFixed\",\"withDuration\",\"cancelDropModifier\",\"listener\",\"getExpiringAnnounce\",\"wasCalled\",\"isExpired\",\"timeoutId\",\"clearTimeout\",\"result.wasCalled\",\"getAsyncMarshal\",\"execute\",\"timerId\",\"_entries$splice\",\"callback\",\"flush\",\"shallow\",\"areLocationsEqual\",\"isCombineEqual\",\"isCriticalEqual\",\"isDroppableEqual\",\"withTimings\",\"key\",\"getDragStart\",\"responder\",\"data\",\"getDefaultMessage\",\"willExpire\",\"provided\",\"getPublisher\",\"asyncMarshal\",\"beforeStart\",\"lastCritical\",\"lastLocation\",\"lastCombine\",\"hasCriticalChanged\",\"hasLocationChanged\",\"hasGroupingChanged\",\"publisher\",\"flushDropAnimation\",\"stopPublishing\",\"isWatching\",\"postActionState\",\"compose\",\"adjustedMaxScroll\",\"getDocumentElement\",\"doc\",\"documentElement\",\"getMaxWindowScroll\",\"clientWidth\",\"clientHeight\",\"getViewport\",\"getInitialPublish\",\"collection\",\"subscriber\",\"scrollBy\",\"getScrollableDroppables\",\"getScrollableDroppableOver\",\"config\",\"startFromPercentage\",\"maxScrollAtPercentage\",\"maxPixelScroll\",\"ease\",\"percentage\",\"durationDampening\",\"stopDampeningAt\",\"accelerateAt\",\"getPercentage\",\"startOfRange\",\"range\",\"endOfRange\",\"getValueFromDistance\",\"distanceToEdge\",\"thresholds\",\"startScrollingFrom\",\"maxScrollValueAt\",\"minScroll\",\"percentageFromMaxScrollValueAt\",\"ceil\",\"stopAt\",\"dampenValueByTime\",\"proposedScroll\",\"dragStartTime\",\"runTime\",\"betweenAccelerateAtAndStopAtPercentage\",\"getValue\",\"shouldUseTimeDampening\",\"getScrollOnAxis\",\"container\",\"distanceToEdges\",\"clean$2\",\"getScroll\",\"required\",\"isTooBigVertically\",\"isTooBigHorizontally\",\"limited\",\"smallestSigned\",\"getOverlap\",\"getRemainder\",\"targetScroll\",\"overlap\",\"canPartiallyScroll\",\"rawMax\",\"smallestChange\",\"canScrollWindow\",\"canScrollDroppable\",\"scroll$1\",\"_change\",\"createFluidScroller\",\"scheduleWindowScroll\",\"scheduleDroppableScroll\",\"tryScroll\",\"_dragging\",\"start$1\",\"wasScrollNeeded\",\"fakeScrollCallback\",\"createJumpScroller\",\"jumpScroller\",\"whatTheDroppableCanScroll\",\"remainder\",\"droppableRemainder\",\"whatTheWindowCanScroll\",\"windowRemainder\",\"fluidScroller\",\"jumpScroll\",\"scroller\",\"property\",\"rule\",\"join\",\"useLayoutEffect\",\"head\",\"querySelector\",\"createContext\",\"position\",\"overflow\",\"clip\",\"_preventedKeys\",\"enter\",\"tab\",\"supported\",\"idle$1\",\"_scrollJumpKeys\",\"pageDown\",\"pageUp\",\"idle$2\",\"input\",\"textarea\",\"select\",\"option\",\"optgroup\",\"video\",\"audio\",\"name\",\"useMouseSensor\",\"phaseRef\",\"unbindEventsRef\",\"startCaptureBinding\",\"onMouseDown\",\"defaultPrevented\",\"ctrlKey\",\"metaKey\",\"shiftKey\",\"altKey\",\"startPendingDrag\",\"preventForcePressBinding\",\"listenForCapture\",\"bindCapturingEvents\",\"useKeyboardSensor\",\"onKeyDown\",\"isCapturing\",\"tryStartCapture\",\"useMouseSensor$1\",\"onTouchStart\",\"longPressTimerId\",\"unbindTarget\",\"unbindWindow\",\"unbindEventsRef.current\",\"startDragging\",\"timeForLongPress\",\"webkitHack\",\"instanceCount\",\"isEqual$1\",\"isScroll\",\"isAuto\",\"isEither\",\"overflowX\",\"overflowY\",\"empty\",\"noSpacing\",\"getStyle\",\"animate\",\"isAnimatingOpenOnMount\",\"boxSizing\",\"marginTop\",\"marginRight\",\"marginBottom\",\"marginLeft\",\"flexShrink\",\"flexGrow\",\"pointerEvents\",\"Placeholder$1\",\"memo\",\"Placeholder\",\"animateOpenTimerRef\",\"tryClearAnimateOpenTimer\",\"onTransitionEnd\",\"onClose\",\"_useState\",\"setIsAnimatingOpenOnMount\",\"onSizeChangeEnd\",\"propertyName\",\"innerRef\",\"AnimateInOut\",\"_React$PureComponent\",\"on\",\"_this.onClose\",\"getDerivedStateFromProps\",\"AnimateInOut.getDerivedStateFromProps\",\"PureComponent\",\"isStrictEqual\",\"atRest\",\"connect\",\"makeMapStateToProps\",\"draggingSelector\",\"secondarySelector\",\"mapDispatchToProps\",\"pure\",\"areStatePropsEqual\",\"Draggable\",\"setRef\",\"getRef\",\"_useRequiredContext\",\"_useRequiredContext2\",\"dropAnimationFinishedAction\",\"forPublisher\",\"dragHandleProps\",\"tabIndex\",\"onMoveEnd\",\"box\",\"transform\",\"zIndex\",\"draggableProps\",\"rubric\",\"ConnectedDroppable\",\"makeMapStateToProps$1\",\"idleWithAnimation\",\"shouldAnimatePlaceholder\",\"isDraggingOver\",\"draggingOverWith\",\"draggingFromThisWith\",\"isUsingPlaceholder\",\"useClone\",\"idleWithoutAnimation\",\"getDraggableRubric\",\"getMapProps\",\"isDraggingOverForConsumer\",\"isDraggingOverForImpact\",\"renderClone\",\"_snapshot\",\"_completed\",\"wasCombining\",\"mapDispatchToProps$1\",\"updateViewportMaxScroll\",\"Droppable\",\"droppableRef\",\"placeholderRef\",\"getContainerForClone\",\"setDroppableRef\",\"setPlaceholderRef\",\"onPlaceholderTransitionEnd\",\"droppableProps\",\"getClone\",\"node\",\"draggableProvided\",\"draggableSnapshot\",\"createPortal\",\"defaultProps\",\"getBody\",\"DragDropContext\",\"PublicDraggable\",\"isDragDisabled\",\"disableInteractiveElementBlocking\",\"resetServerContext\"]\n}\n"]