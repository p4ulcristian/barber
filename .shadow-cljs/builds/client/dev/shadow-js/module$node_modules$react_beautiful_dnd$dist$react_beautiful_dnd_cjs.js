["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.cjs.js"],"~:js","shadow$provide.module$node_modules$react_beautiful_dnd$dist$react_beautiful_dnd_cjs=function(global,require,module,exports){function _interopDefault(ex){return ex&&\"object\"===typeof ex&&\"default\"in ex?ex[\"default\"]:ex}function log(type,message){var _console;\"undefined\"!==typeof window&&window[\"__react-beautiful-dnd-disable-dev-warnings\"]||(_console=console)[type].apply(_console,[(\"\\n  %creact-beautiful-dnd\\n\\n  %c\"+message.replace(spacesAndTabs,\" \").replace(lineStartWithSpaces,\"\").trim()+\"\\n\\n  %c\\ud83d\\udc77‚Äç This is a development only message. It will be removed in production builds.\\n\").replace(spacesAndTabs,\n\" \").replace(lineStartWithSpaces,\"\").trim(),\"color: #00C584; font-size: 1.2em; font-weight: bold;\",\"line-height: 1.5\",\"color: #723874;\"])}function noop(){}function bindEvents(el,bindings,sharedOptions){var unbindings=bindings.map(function(binding){var options=_extends({},sharedOptions,{},binding.options);el.addEventListener(binding.eventName,binding.fn,options);return function(){el.removeEventListener(binding.eventName,binding.fn,options)}});return function(){unbindings.forEach(function(unbind){unbind()})}}\nfunction RbdInvariant(message){this.message=message}function invariant(condition,message){if(!condition)throw new RbdInvariant(\"Invariant failed: \"+(message||\"\"));}function findIndex(list,predicate){if(list.findIndex)return list.findIndex(predicate);for(var i=0;i<list.length;i++)if(predicate(list[i]))return i;return-1}function find(list,predicate){if(list.find)return list.find(predicate);predicate=findIndex(list,predicate);if(-1!==predicate)return list[predicate]}function tryGetDestination(impact){return impact.at&&\n\"REORDER\"===impact.at.type?impact.at.destination:null}function tryGetCombine(impact){return impact.at&&\"COMBINE\"===impact.at.type?impact.at.combine:null}function getDisplacementGroups(_ref){var destination=_ref.destination,displacedBy=_ref.displacedBy,viewport=_ref.viewport,forceShouldAnimate=_ref.forceShouldAnimate,last=_ref.last;return _ref.afterDragging.reduce(function(groups,draggable){var target=cssBoxModel.getRect(cssBoxModel.expand(draggable.page.marginBox,{top:displacedBy.point.y,right:0,\nbottom:0,left:displacedBy.point.x}));var id=draggable.descriptor.id;groups.all.push(id);if(!isVisible(_extends({},{target:target,destination:destination,viewport:viewport,withDroppableDisplacement:!0},{isVisibleThroughFrameFn:isPartiallyVisibleThroughFrame})))return groups.invisible[draggable.descriptor.id]=!0,groups;\"boolean\"===typeof forceShouldAnimate?draggable=forceShouldAnimate:last?(draggable=last.visible,draggable=last.invisible[id]?!1:(draggable=draggable[id])?draggable.shouldAnimate:!0):\ndraggable=!0;groups.visible[id]={draggableId:id,shouldAnimate:draggable};return groups},{all:[],visible:{},invisible:{}})}function goAtEnd(_ref){var insideDestination=_ref.insideDestination,displacedBy=_ref.displacedBy,destination=_ref.destination;_ref=_ref.inHomeList;insideDestination.length?(insideDestination=insideDestination[insideDestination.length-1].descriptor.index,insideDestination=_ref?insideDestination:insideDestination+1):insideDestination=0;return{displaced:emptyGroups,displacedBy:displacedBy,\nat:{type:\"REORDER\",destination:{droppableId:destination.descriptor.id,index:insideDestination}}}}function calculateReorderImpact(_ref2){var draggable=_ref2.draggable,insideDestination=_ref2.insideDestination,destination=_ref2.destination,viewport=_ref2.viewport,displacedBy=_ref2.displacedBy,last=_ref2.last,index=_ref2.index;_ref2=_ref2.forceShouldAnimate;var inHomeList=isHomeOf(draggable,destination);if(null==index)return goAtEnd({insideDestination:insideDestination,inHomeList:inHomeList,displacedBy:displacedBy,\ndestination:destination});var match=find(insideDestination,function(item){return item.descriptor.index===index});if(!match)return goAtEnd({insideDestination:insideDestination,inHomeList:inHomeList,displacedBy:displacedBy,destination:destination});draggable=removeDraggableFromList(draggable,insideDestination);insideDestination=insideDestination.indexOf(match);insideDestination=draggable.slice(insideDestination);return{displaced:getDisplacementGroups({afterDragging:insideDestination,destination:destination,\ndisplacedBy:displacedBy,last:last,viewport:viewport.frame,forceShouldAnimate:_ref2}),displacedBy:displacedBy,at:{type:\"REORDER\",destination:{droppableId:destination.descriptor.id,index:index}}}}function getDraggables(ids,draggables){return ids.map(function(id){return draggables[id]})}function isMovementAllowed(state){return\"DRAGGING\"===state.phase||\"COLLECTING\"===state.phase}function atIndex(_ref){var closest=_ref.closest;return closest?_ref.inHomeList?closest.descriptor.index>_ref.draggable.descriptor.index?\nclosest.descriptor.index-1:closest.descriptor.index:closest.descriptor.index:null}function calculateCombineImpact(_ref){var combineWithId=_ref.combineWithId,destinationId=_ref.destinationId,userDirection=_ref.userDirection;_ref=_ref.previousImpact;var lastCombineImpact=_ref.at&&\"COMBINE\"===_ref.at.type?_ref.at:null;userDirection=lastCombineImpact?combineWithId!==lastCombineImpact.combine.draggableId?userDirection:lastCombineImpact.whenEntered:userDirection;return{displacedBy:_ref.displacedBy,displaced:_ref.displaced,\nat:{type:\"COMBINE\",whenEntered:userDirection,combine:{draggableId:combineWithId,droppableId:destinationId}}}}function getDraggables$1(ids,draggables){return ids.map(function(id){return draggables[id]})}function removeScrollJumpRequest(state){return state.isDragging&&\"SNAP\"===state.movementMode?_extends({phase:\"DRAGGING\"},state,{scrollJumpRequest:null}):state}function checkIndexes(insideDestination){if(!(1>=insideDestination.length)){insideDestination=insideDestination.map(function(d){return d.descriptor.index});\nfor(var errors={},i=1;i<insideDestination.length;i++){var current=insideDestination[i];current!==insideDestination[i-1]+1&&(errors[current]=!0)}_Object$keys(errors).length&&(insideDestination=insideDestination.map(function(index){return errors[index]?\"[\\ud83d\\udd25\"+index+\"]\":\"\"+index}).join(\", \"),warning(\"\\n    Detected non-consecutive \\x3cDraggable /\\x3e indexes.\\n\\n    (This can cause unexpected bugs)\\n\\n    \"+insideDestination+\"\\n  \"))}}function getWindowScrollBinding(update){return{eventName:\"scroll\",\noptions:{passive:!0,capture:!1},fn:function(event){event.target!==window&&event.target!==window.document||update()}}}function getScrollListener(_ref){function isActive(){return unbind!==noop}var onWindowScroll=_ref.onWindowScroll,scheduled=rafSchd(function(){onWindowScroll({x:window.pageXOffset,y:window.pageYOffset})}),binding=getWindowScrollBinding(scheduled),unbind=noop;return{start:function(){isActive()?invariant(!1,\"Cannot start scroll listener when already active\"):void 0;unbind=bindEvents(window,\n[binding])},stop:function(){isActive()?void 0:invariant(!1,\"Cannot stop scroll listener when not active\");scheduled.cancel();unbind();unbind=noop},isActive:isActive}}function createPublisher(_ref){var registry=_ref.registry,callbacks=_ref.callbacks,staging=clean$1(),frameId=null,collect=function(){frameId||(callbacks.collectionStarting(),frameId=requestAnimationFrame(function(){frameId=null;var _staging=staging,removals=_staging.removals,modified=_staging.modified;_staging=_Object$keys(_staging.additions).map(function(id){return registry.draggable.getById(id).getDimension(origin)}).sort(function(a,\nb){return a.descriptor.index-b.descriptor.index});modified=_Object$keys(modified).map(function(id){var scroll=registry.droppable.getById(id).callbacks.getScrollWhileDragging();return{droppableId:id,scroll:scroll}});removals={additions:_staging,removals:_Object$keys(removals),modified:modified};staging=clean$1();callbacks.publish(removals)}))};return{add:function(entry){var id=entry.descriptor.id;staging.additions[id]=entry;staging.modified[entry.descriptor.droppableId]=!0;staging.removals[id]&&delete staging.removals[id];\ncollect()},remove:function(entry){entry=entry.descriptor;staging.removals[entry.id]=!0;staging.modified[entry.droppableId]=!0;staging.additions[entry.id]&&delete staging.additions[entry.id];collect()},stop:function(){frameId&&(cancelAnimationFrame(frameId),frameId=null,staging=clean$1())}}}function shouldPublishUpdate(registry,dragging,entry){return entry.descriptor.id===dragging.id||entry.descriptor.type!==dragging.type?!1:\"virtual\"!==registry.droppable.getById(entry.descriptor.droppableId).descriptor.mode?\n(warning(\"\\n      You are attempting to add or remove a Draggable [id: \"+entry.descriptor.id+\"]\\n      while a drag is occurring. This is only supported for virtual lists.\\n\\n      See https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/patterns/virtual-lists.md\\n    \"),!1):!0}function useStyleMarshal(contextId,nonce){var styles=useMemoOne.useMemo(function(){var getSelector=makeGetSelector(contextId),dragHandle$1={selector:getSelector(dragHandle.contextId),styles:{always:\"\\n          -webkit-touch-callout: none;\\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\\n          touch-action: manipulation;\\n        \",\nresting:\"\\n      cursor: -webkit-grab;\\n      cursor: grab;\\n    \",dragging:\"pointer-events: none;\",dropAnimating:\"\\n      cursor: -webkit-grab;\\n      cursor: grab;\\n    \"}};var draggable$1=\"\\n      transition: \"+transitions.outOfTheWay+\";\\n    \";draggable$1={selector:getSelector(draggable.contextId),styles:{dragging:draggable$1,dropAnimating:draggable$1,userCancel:draggable$1}};getSelector={selector:getSelector(JSCompiler_object_inline_contextId_2789),styles:{always:\"overflow-anchor: none;\"}};dragHandle$1=\n[draggable$1,dragHandle$1,getSelector,{selector:\"body\",styles:{dragging:\"\\n        cursor: grabbing;\\n        cursor: -webkit-grabbing;\\n        user-select: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        overflow-anchor: none;\\n      \"}}];return{always:getStyles(dragHandle$1,\"always\"),resting:getStyles(dragHandle$1,\"resting\"),dragging:getStyles(dragHandle$1,\"dragging\"),dropAnimating:getStyles(dragHandle$1,\"dropAnimating\"),userCancel:getStyles(dragHandle$1,\n\"userCancel\")}},[contextId]),alwaysRef=React.useRef(null),dynamicRef=React.useRef(null),setDynamicStyle=useMemoOne.useCallback(memoizeOne(function(proposed){var el=dynamicRef.current;el?void 0:invariant(!1,\"Cannot set dynamic style element if it is not set\");el.textContent=proposed}),[]),setAlwaysStyle=useMemoOne.useCallback(function(proposed){var el=alwaysRef.current;el?void 0:invariant(!1,\"Cannot set dynamic style element if it is not set\");el.textContent=proposed},[]);useIsomorphicLayoutEffect(function(){alwaysRef.current||\ndynamicRef.current?invariant(!1,\"style elements already mounted\"):void 0;var always=createStyleEl(nonce),dynamic=createStyleEl(nonce);alwaysRef.current=always;dynamicRef.current=dynamic;always.setAttribute(\"data-rbd-always\",contextId);dynamic.setAttribute(\"data-rbd-dynamic\",contextId);getHead().appendChild(always);getHead().appendChild(dynamic);setAlwaysStyle(styles.always);setDynamicStyle(styles.resting);return function(){var remove=function(ref){var current=ref.current;current?void 0:invariant(!1,\n\"Cannot unmount ref as it is not set\");getHead().removeChild(current);ref.current=null};remove(alwaysRef);remove(dynamicRef)}},[nonce,setAlwaysStyle,setDynamicStyle,styles.always,styles.resting,contextId]);var dragging=useMemoOne.useCallback(function(){return setDynamicStyle(styles.dragging)},[setDynamicStyle,styles.dragging]),dropping=useMemoOne.useCallback(function(reason){\"DROP\"===reason?setDynamicStyle(styles.dropAnimating):setDynamicStyle(styles.userCancel)},[setDynamicStyle,styles.dropAnimating,\nstyles.userCancel]),resting=useMemoOne.useCallback(function(){dynamicRef.current&&setDynamicStyle(styles.resting)},[setDynamicStyle,styles.resting]);return useMemoOne.useMemo(function(){return{dragging:dragging,dropping:dropping,resting:resting}},[dragging,dropping,resting])}function isHtmlElement(el){return el instanceof(el&&el.ownerDocument?el.ownerDocument.defaultView:window).HTMLElement}function findDragHandle(contextId,draggableId){var possible=Array.prototype.slice.call(document.querySelectorAll(\"[\"+\ndragHandle.contextId+'\\x3d\"'+contextId+'\"]'));if(!possible.length)return warning('Unable to find any drag handles in the context \"'+contextId+'\"'),null;contextId=find(possible,function(el){return el.getAttribute(dragHandle.draggableId)===draggableId});return contextId?isHtmlElement(contextId)?contextId:(warning(\"drag handle needs to be a HTMLElement\"),null):(warning('Unable to find drag handle with id \"'+draggableId+'\" as no handle with a matching id was found'),null)}function useFocusMarshal(contextId){var entriesRef=\nReact.useRef({}),recordRef=React.useRef(null),restoreFocusFrameRef=React.useRef(null),isMountedRef=React.useRef(!1),register=useMemoOne.useCallback(function(id,focus){var entry={id:id,focus:focus};entriesRef.current[id]=entry;return function(){var entries=entriesRef.current;entries[id]!==entry&&delete entries[id]}},[]),tryGiveFocus=useMemoOne.useCallback(function(tryGiveFocusTo){(tryGiveFocusTo=findDragHandle(contextId,tryGiveFocusTo))&&tryGiveFocusTo!==document.activeElement&&tryGiveFocusTo.focus()},\n[contextId]),tryShiftRecord=useMemoOne.useCallback(function(previous,redirectTo){recordRef.current===previous&&(recordRef.current=redirectTo)},[]),tryRestoreFocusRecorded=useMemoOne.useCallback(function(){!restoreFocusFrameRef.current&&isMountedRef.current&&(restoreFocusFrameRef.current=requestAnimationFrame(function(){restoreFocusFrameRef.current=null;var record=recordRef.current;record&&tryGiveFocus(record)}))},[tryGiveFocus]),tryRecordFocus=useMemoOne.useCallback(function(id){recordRef.current=\nnull;var focused=document.activeElement;focused&&focused.getAttribute(dragHandle.draggableId)===id&&(recordRef.current=id)},[]);useIsomorphicLayoutEffect(function(){isMountedRef.current=!0;return function(){isMountedRef.current=!1;var frameId=restoreFocusFrameRef.current;frameId&&cancelAnimationFrame(frameId)}},[]);return useMemoOne.useMemo(function(){return{register:register,tryRecordFocus:tryRecordFocus,tryRestoreFocusRecorded:tryRestoreFocusRecorded,tryShiftRecord:tryShiftRecord}},[register,tryRecordFocus,\ntryRestoreFocusRecorded,tryShiftRecord])}function createRegistry(){function notify(event){subscribers.length&&subscribers.forEach(function(cb){return cb(event)})}function findDraggableById(id){return entries.draggables[id]||null}function findDroppableById(id){return entries.droppables[id]||null}var entries={draggables:{},droppables:{}},subscribers=[];return{draggable:{register:function(entry){entries.draggables[entry.descriptor.id]=entry;notify({type:\"ADDITION\",value:entry})},update:function(entry,\nlast){var current=entries.draggables[last.descriptor.id];current&&current.uniqueId===entry.uniqueId&&(delete entries.draggables[last.descriptor.id],entries.draggables[entry.descriptor.id]=entry)},unregister:function(entry){var draggableId=entry.descriptor.id,current=findDraggableById(draggableId);current&&entry.uniqueId===current.uniqueId&&(delete entries.draggables[draggableId],notify({type:\"REMOVAL\",value:entry}))},getById:function(id){var entry=findDraggableById(id);entry?void 0:invariant(!1,\"Cannot find draggable entry with id [\"+\nid+\"]\");return entry},findById:findDraggableById,exists:function(id){return!!findDraggableById(id)},getAllByType:function(type){return _Object$values(entries.draggables).filter(function(entry){return entry.descriptor.type===type})}},droppable:{register:function(entry){entries.droppables[entry.descriptor.id]=entry},unregister:function(entry){var current=findDroppableById(entry.descriptor.id);current&&entry.uniqueId===current.uniqueId&&delete entries.droppables[entry.descriptor.id]},getById:function(id){var entry=\nfindDroppableById(id);entry?void 0:invariant(!1,\"Cannot find droppable entry with id [\"+id+\"]\");return entry},findById:findDroppableById,exists:function(id){return!!findDroppableById(id)},getAllByType:function(type){return _Object$values(entries.droppables).filter(function(entry){return entry.descriptor.type===type})}},subscribe:function(cb){subscribers.push(cb);return function(){var index=subscribers.indexOf(cb);-1!==index&&subscribers.splice(index,1)}},clean:function(){entries.draggables={};entries.droppables=\n{};subscribers.length=0}}}function useRegistry(){var registry=useMemoOne.useMemo(createRegistry,[]);React.useEffect(function(){return function(){requestAnimationFrame(registry.clean)}},[registry]);return registry}function useAnnouncer(contextId){var id=useMemoOne.useMemo(function(){return\"rbd-announcement-\"+contextId},[contextId]),ref=React.useRef(null);React.useEffect(function(){ref.current?invariant(!1,\"Announcement node already mounted\"):void 0;var el=document.createElement(\"div\");ref.current=\nel;el.id=id;el.setAttribute(\"aria-live\",\"assertive\");el.setAttribute(\"role\",\"log\");el.setAttribute(\"aria-atomic\",\"true\");_Object$assign(el.style,visuallyHidden);getBodyElement().appendChild(el);return function(){setTimeout(function(){var toBeRemoved=ref.current;toBeRemoved?void 0:invariant(!1,\"Cannot unmount announcement node\");getBodyElement().removeChild(toBeRemoved);ref.current=null})}},[id]);return useMemoOne.useCallback(function(message){var el=ref.current;el?el.textContent=message:warning('\\n      A screen reader message was trying to be announced but it was unable to do so.\\n      This can occur if you unmount your \\x3cDragDropContext /\\x3e in your onDragEnd.\\n      Consider calling provided.announce() before the unmount so that the instruction will\\n      not be lost for users relying on a screen reader.\\n\\n      Message not passed to screen reader:\\n\\n      \"'+\nmessage+'\"\\n    ')},[])}function useLiftInstruction(contextId,liftInstruction){var id=useMemoOne.useMemo(function(){return\"rbd-lift-instruction-\"+contextId},[contextId]);React.useEffect(function(){var el=document.createElement(\"div\");el.id=id;el.textContent=liftInstruction;_Object$assign(el.style,visuallyHidden);getBodyElement().appendChild(el);return function(){getBodyElement().removeChild(el)}},[id,liftInstruction]);return id}function useDevSetupWarning(fn,inputs){(function(){React.useEffect(function(){try{fn()}catch(e){error(\"\\n          A setup problem was encountered.\\n\\n          \\x3e \"+\ne.message+\"\\n        \")}},inputs)})()}function useStartupValidation(){useDevSetupWarning(function(){var actualValue=React__default.version,peerDep=getVersion(peerDependencies.react);actualValue=getVersion(actualValue);actualValue.major>peerDep.major||(actualValue.major<peerDep.major?0:actualValue.minor>peerDep.minor||(actualValue.minor<peerDep.minor?0:actualValue.patch>=peerDep.patch))||warning(\"\\n    React version: [\"+actualValue.raw+\"]\\n    does not satisfy expected peer dependency version: [\"+\npeerDep.raw+\"]\\n\\n    This can result in run time bugs, and even fatal crashes\\n  \");(peerDep=document.doctype)?(\"html\"!==peerDep.name.toLowerCase()&&warning(\"\\n      Unexpected \\x3c!doctype\\x3e found: (\"+peerDep.name+\")\\n\\n      \\n  We expect a html5 doctype: \\x3c!doctype html\\x3e\\n  This is to ensure consistent browser layout and measurement\\n\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\n\\n    \"),\"\"!==peerDep.publicId&&warning(\"\\n      Unexpected \\x3c!doctype\\x3e publicId found: (\"+\npeerDep.publicId+\")\\n      A html5 doctype does not have a publicId\\n\\n      \\n  We expect a html5 doctype: \\x3c!doctype html\\x3e\\n  This is to ensure consistent browser layout and measurement\\n\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\n\\n    \")):warning(\"\\n      No \\x3c!doctype html\\x3e found.\\n\\n      \\n  We expect a html5 doctype: \\x3c!doctype html\\x3e\\n  This is to ensure consistent browser layout and measurement\\n\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\n\\n    \")},\n[])}function usePrevious(current){var ref=React.useRef(current);React.useEffect(function(){ref.current=current});return ref}function create(){function release(){lock?void 0:invariant(!1,\"Cannot release lock when there is no lock\");lock=null}var lock=null;return{isClaimed:function(){return!!lock},isActive:function(value){return value===lock},claim:function(abandon){lock?invariant(!1,\"Cannot claim lock as it is already claimed\"):void 0;return lock=abandon={abandon:abandon}},release:release,tryAbandon:function(){lock&&\n(lock.abandon(),release())}}}function getCaptureBindings(_ref){var cancel=_ref.cancel,completed=_ref.completed,getPhase=_ref.getPhase,setPhase=_ref.setPhase;return[{eventName:\"mousemove\",fn:function(event){if(0===event.button){var point={x:event.clientX,y:event.clientY},phase=getPhase();if(\"DRAGGING\"===phase.type)event.preventDefault(),phase.actions.move(point);else{\"PENDING\"!==phase.type?invariant(!1,\"Cannot be IDLE\"):void 0;var pending=phase.point;if(5<=Math.abs(point.x-pending.x)||5<=Math.abs(point.y-\npending.y))event.preventDefault(),event=phase.actions.fluidLift(point),setPhase({type:\"DRAGGING\",actions:event})}}}},{eventName:\"mouseup\",fn:function(event){var phase=getPhase();\"DRAGGING\"!==phase.type?cancel():(event.preventDefault(),phase.actions.drop({shouldBlockNextClick:!0}),completed())}},{eventName:\"mousedown\",fn:function(event){\"DRAGGING\"===getPhase().type&&event.preventDefault();cancel()}},{eventName:\"keydown\",fn:function(event){\"PENDING\"===getPhase().type?cancel():27===event.keyCode?(event.preventDefault(),\ncancel()):preventedKeys[event.keyCode]&&event.preventDefault()}},{eventName:\"resize\",fn:cancel},{eventName:\"scroll\",options:{passive:!0,capture:!1},fn:function(){\"PENDING\"===getPhase().type&&cancel()}},{eventName:\"webkitmouseforcedown\",fn:function(event){var phase=getPhase();\"IDLE\"===phase.type?invariant(!1,\"Unexpected phase\"):void 0;phase.actions.shouldRespectForcePress()?cancel():event.preventDefault()}},{eventName:supportedEventName,fn:cancel}]}function noop$1(){}function getDraggingBindings(actions,\nstop){function cancel(){stop();actions.cancel()}return[{eventName:\"keydown\",fn:function(event){27===event.keyCode?(event.preventDefault(),cancel()):32===event.keyCode?(event.preventDefault(),stop(),actions.drop()):40===event.keyCode?(event.preventDefault(),actions.moveDown()):38===event.keyCode?(event.preventDefault(),actions.moveUp()):39===event.keyCode?(event.preventDefault(),actions.moveRight()):37===event.keyCode?(event.preventDefault(),actions.moveLeft()):scrollJumpKeys[event.keyCode]?event.preventDefault():\npreventedKeys[event.keyCode]&&event.preventDefault()}},{eventName:\"mousedown\",fn:cancel},{eventName:\"mouseup\",fn:cancel},{eventName:\"click\",fn:cancel},{eventName:\"touchstart\",fn:cancel},{eventName:\"resize\",fn:cancel},{eventName:\"wheel\",fn:cancel,options:{passive:!0}},{eventName:supportedEventName,fn:cancel}]}function getWindowBindings(_ref){var cancel=_ref.cancel,getPhase=_ref.getPhase;return[{eventName:\"orientationchange\",fn:cancel},{eventName:\"resize\",fn:cancel},{eventName:\"contextmenu\",fn:function(event){event.preventDefault()}},\n{eventName:\"keydown\",fn:function(event){\"DRAGGING\"===getPhase().type&&27===event.keyCode&&event.preventDefault();cancel()}},{eventName:supportedEventName,fn:cancel}]}function getHandleBindings(_ref2){var cancel=_ref2.cancel,completed=_ref2.completed,getPhase=_ref2.getPhase;return[{eventName:\"touchmove\",options:{capture:!1},fn:function(event){var phase=getPhase();if(\"DRAGGING\"!==phase.type)cancel();else{phase.hasMoved=!0;var _event$touches$=event.touches[0];_event$touches$={x:_event$touches$.clientX,\ny:_event$touches$.clientY};event.preventDefault();phase.actions.move(_event$touches$)}}},{eventName:\"touchend\",fn:function(event){var phase=getPhase();\"DRAGGING\"!==phase.type?cancel():(event.preventDefault(),phase.actions.drop({shouldBlockNextClick:!0}),completed())}},{eventName:\"touchcancel\",fn:function(event){\"DRAGGING\"===getPhase().type&&event.preventDefault();cancel()}},{eventName:\"touchforcechange\",fn:function(event){var phase=getPhase();\"IDLE\"===phase.type?invariant(!1):void 0;var touch=event.touches[0];\ntouch&&.15<=touch.force&&(touch=phase.actions.shouldRespectForcePress(),\"PENDING\"===phase.type?touch&&cancel():touch?phase.hasMoved?event.preventDefault():cancel():event.preventDefault())}},{eventName:supportedEventName,fn:cancel}]}function useValidateSensorHooks(sensorHooks){(function(){var previousRef=usePrevious(sensorHooks);useDevSetupWarning(function(){previousRef.current.length!==sensorHooks.length?invariant(!1,\"Cannot change the amount of sensor hooks after mounting\"):void 0})})()}function isAnInteractiveElement(parent,\ncurrent){if(null==current)return!1;if(interactiveTagNames[current.tagName.toLowerCase()])return!0;var attribute=current.getAttribute(\"contenteditable\");return\"true\"===attribute||\"\"===attribute?!0:current===parent?!1:isAnInteractiveElement(parent,current.parentElement)}function isEventInInteractiveElement(draggable,event){event=event.target;return isHtmlElement(event)?isAnInteractiveElement(draggable,event):!1}function closestPonyfill(el,selector){return null==el?null:el[supportedMatchesName](selector)?\nel:closestPonyfill(el.parentElement,selector)}function findClosestDragHandleFromEvent(contextId,event){event=event.target;if(!(event instanceof(event&&event.ownerDocument?event.ownerDocument.defaultView:window).Element))return warning(\"event.target must be a Element\"),null;contextId=\"[\"+dragHandle.contextId+'\\x3d\"'+contextId+'\"]';contextId=event.closest?event.closest(contextId):closestPonyfill(event,contextId);return contextId?isHtmlElement(contextId)?contextId:(warning(\"drag handle must be a HTMLElement\"),\nnull):null}function findDraggable(contextId,draggableId){contextId=Array.prototype.slice.call(document.querySelectorAll(\"[\"+draggable.contextId+'\\x3d\"'+contextId+'\"]'));contextId=find(contextId,function(el){return el.getAttribute(draggable.id)===draggableId});return contextId?isHtmlElement(contextId)?contextId:(warning(\"Draggable element is not a HTMLElement\"),null):null}function preventDefault(event){event.preventDefault()}function _isActive(_ref){var expected=_ref.expected,phase=_ref.phase,isLockActive=\n_ref.isLockActive;_ref=_ref.shouldWarn;return isLockActive()?expected!==phase?(_ref&&warning(\"\\n        Cannot perform action.\\n        The actions you used belong to an outdated phase\\n\\n        Current phase: \"+expected+\"\\n        You called an action from outdated phase: \"+phase+\"\\n\\n        Tips:\\n\\n        - Do not use preDragActions actions after calling preDragActions.lift()\\n      \"),!1):!0:(_ref&&warning(\"\\n        Cannot perform action.\\n        The sensor no longer has an action lock.\\n\\n        Tips:\\n\\n        - Throw away your action handlers when forceStop() is called\\n        - Check actions.isActive() if you really need to\\n      \"),\n!1)}function canStart(_ref2){var store=_ref2.store,registry=_ref2.registry,draggableId=_ref2.draggableId;if(_ref2.lockAPI.isClaimed())return!1;_ref2=registry.draggable.findById(draggableId);return _ref2?_ref2.options.isEnabled&&canStartDrag(store.getState(),draggableId)?!0:!1:(warning(\"Unable to find draggable with id: \"+draggableId),!1)}function tryStart(_ref3){function getShouldRespectForcePress(){return entry.options.shouldRespectForcePress}function isLockActive(){return lockAPI.isActive(lock)}\nfunction lift$1(args){function finish(reason,options){void 0===options&&(options={shouldBlockNextClick:!1});args.cleanup();options.shouldBlockNextClick&&(options=bindEvents(window,[{eventName:\"click\",fn:preventDefault,options:{once:!0,passive:!1,capture:!0}}]),setTimeout(options));lockAPI.release();phase=\"COMPLETED\";store.dispatch({type:\"DROP\",payload:{reason:reason}})}\"PRE_DRAG\"!==phase&&(lockAPI.release(),phase=\"COMPLETED\",\"PRE_DRAG\"!==phase?invariant(!1,\"Cannot lift in phase \"+phase):void 0);store.dispatch({type:\"LIFT\",\npayload:args.liftActionArgs});phase=\"DRAGGING\";return _extends({isActive:function(){return _isActive({expected:\"DRAGGING\",phase:phase,isLockActive:isLockActive,shouldWarn:!1})},shouldRespectForcePress:getShouldRespectForcePress,drop:function(options){return finish(\"DROP\",options)},cancel:function(options){return finish(\"CANCEL\",options)}},args.actions)}var lockAPI=_ref3.lockAPI,contextId=_ref3.contextId,store=_ref3.store,registry=_ref3.registry,draggableId=_ref3.draggableId,forceSensorStop=_ref3.forceSensorStop;\n_ref3=_ref3.sourceEvent;if(!canStart({lockAPI:lockAPI,store:store,registry:registry,draggableId:draggableId}))return null;var entry=registry.draggable.getById(draggableId),el=findDraggable(contextId,entry.descriptor.id);if(!el)return warning(\"Unable to find draggable element with id: \"+draggableId),null;if(_ref3&&!entry.options.canDragInteractiveElements&&isEventInInteractiveElement(el,_ref3))return null;var lock=lockAPI.claim(forceSensorStop||noop),phase=\"PRE_DRAG\",tryDispatchWhenDragging=function(expected,\ngetAction){_isActive({expected:expected,phase:phase,isLockActive:isLockActive,shouldWarn:!0})&&store.dispatch(getAction())}.bind(this,\"DRAGGING\");return{isActive:function(){return _isActive({expected:\"PRE_DRAG\",phase:phase,isLockActive:isLockActive,shouldWarn:!1})},shouldRespectForcePress:getShouldRespectForcePress,fluidLift:function(clientSelection){var move$1=rafSchd(function(client){tryDispatchWhenDragging(function(){return move$jscomp$0({client:client})})});clientSelection=lift$1({liftActionArgs:{id:draggableId,\nclientSelection:clientSelection,movementMode:\"FLUID\"},cleanup:function(){return move$1.cancel()},actions:{move:move$1}});return _extends({},clientSelection,{move:move$1})},snapLift:function(){return lift$1({liftActionArgs:{id:draggableId,clientSelection:cssBoxModel.getRect(el.getBoundingClientRect()).center,movementMode:\"SNAP\"},cleanup:noop,actions:{moveUp:function(){return tryDispatchWhenDragging(moveUp)},moveRight:function(){return tryDispatchWhenDragging(moveRight)},moveDown:function(){return tryDispatchWhenDragging(moveDown)},\nmoveLeft:function(){return tryDispatchWhenDragging(moveLeft)}}})},abort:function(){_isActive({expected:\"PRE_DRAG\",phase:phase,isLockActive:isLockActive,shouldWarn:!0})&&lockAPI.release()}}}function useSensorMarshal(_ref4){var contextId=_ref4.contextId,store=_ref4.store,registry=_ref4.registry;_ref4=[].concat(_ref4.enableDefaultSensors?defaultSensors:[],_ref4.customSensors||[]);var lockAPI=React.useState(function(){return create()})[0],tryAbandonLock=useMemoOne.useCallback(function(previous,current){previous.isDragging&&\n!current.isDragging&&lockAPI.tryAbandon()},[lockAPI]);useIsomorphicLayoutEffect(function(){var previous=store.getState();return store.subscribe(function(){var current=store.getState();tryAbandonLock(previous,current);previous=current})},[lockAPI,store,tryAbandonLock]);useIsomorphicLayoutEffect(function(){return lockAPI.tryAbandon},[lockAPI.tryAbandon]);var canGetLock=useMemoOne.useCallback(function(draggableId){return canStart({lockAPI:lockAPI,registry:registry,store:store,draggableId:draggableId})},\n[lockAPI,registry,store]),tryGetLock=useMemoOne.useCallback(function(draggableId,forceStop,options){return tryStart({lockAPI:lockAPI,registry:registry,contextId:contextId,store:store,draggableId:draggableId,forceSensorStop:forceStop,sourceEvent:options&&options.sourceEvent?options.sourceEvent:null})},[contextId,lockAPI,registry,store]),findClosestDraggableId=useMemoOne.useCallback(function(event){event=(event=findClosestDragHandleFromEvent(contextId,event))?event.getAttribute(dragHandle.draggableId):\nnull;return event},[contextId]),findOptionsForDraggable=useMemoOne.useCallback(function(id){return(id=registry.draggable.findById(id))?id.options:null},[registry.draggable]),tryReleaseLock=useMemoOne.useCallback(lockAPI.tryAbandon,[lockAPI]),isLockClaimed=useMemoOne.useCallback(lockAPI.isClaimed,[lockAPI]),api=useMemoOne.useMemo(function(){return{canGetLock:canGetLock,tryGetLock:tryGetLock,findClosestDraggableId:findClosestDraggableId,findOptionsForDraggable:findOptionsForDraggable,tryReleaseLock:tryReleaseLock,\nisLockClaimed:isLockClaimed}},[canGetLock,tryGetLock,findClosestDraggableId,findOptionsForDraggable,tryReleaseLock,isLockClaimed]);useValidateSensorHooks(_ref4);for(var i=0;i<_ref4.length;i++)_ref4[i](api)}function getStore(lazyRef){lazyRef.current?void 0:invariant(!1,\"Could not find store from lazy ref\");return lazyRef.current}function App(props$jscomp$0){var contextId=props$jscomp$0.contextId,setCallbacks=props$jscomp$0.setCallbacks,sensors=props$jscomp$0.sensors,nonce=props$jscomp$0.nonce,liftInstruction=\nprops$jscomp$0.liftInstruction,lazyStoreRef=React.useRef(null);useStartupValidation();var lastPropsRef=usePrevious(props$jscomp$0),getResponders=useMemoOne.useCallback(function(){var props=lastPropsRef.current;return{onBeforeDragStart:props.onBeforeDragStart,onDragStart:props.onDragStart,onDragEnd:props.onDragEnd,onDragUpdate:props.onDragUpdate}},[lastPropsRef]),announce=useAnnouncer(contextId),liftInstructionId=useLiftInstruction(contextId,liftInstruction),styleMarshal=useStyleMarshal(contextId,\nnonce),lazyDispatch=useMemoOne.useCallback(function(action){getStore(lazyStoreRef).dispatch(action)},[]),marshalCallbacks=useMemoOne.useMemo(function(){return redux.bindActionCreators({publishWhileDragging:publishWhileDragging,updateDroppableScroll:updateDroppableScroll,updateDroppableIsEnabled:updateDroppableIsEnabled,updateDroppableIsCombineEnabled:updateDroppableIsCombineEnabled,collectionStarting:collectionStarting},lazyDispatch)},[lazyDispatch]),registry=useRegistry(),dimensionMarshal=useMemoOne.useMemo(function(){return createDimensionMarshal(registry,\nmarshalCallbacks)},[registry,marshalCallbacks]),autoScroller=useMemoOne.useMemo(function(){return createAutoScroller(_extends({scrollWindow:scrollWindow,scrollDroppable:dimensionMarshal.scrollDroppable},redux.bindActionCreators({move:move$jscomp$0},lazyDispatch)))},[dimensionMarshal.scrollDroppable,lazyDispatch]),focusMarshal=useFocusMarshal(contextId);nonce=useMemoOne.useMemo(function(){return redux.createStore(reducer,composeEnhancers(redux.applyMiddleware(style$jscomp$0(styleMarshal),dimensionMarshalStopper(dimensionMarshal),\nlift$1(dimensionMarshal),drop$1,dropAnimationFinish,dropAnimationFlushOnScroll,pendingDrop,autoScroll(autoScroller),scrollListener,focus(focusMarshal),responders(getResponders,announce))))},[announce,autoScroller,dimensionMarshal,focusMarshal,getResponders,styleMarshal]);lazyStoreRef.current&&lazyStoreRef.current!==nonce&&warning(\"unexpected store change\");lazyStoreRef.current=nonce;var tryResetStore=useMemoOne.useCallback(function(){var current=getStore(lazyStoreRef);\"IDLE\"!==current.getState().phase&&\ncurrent.dispatch({type:\"FLUSH\",payload:null})},[]),isDragging=useMemoOne.useCallback(function(){var state=getStore(lazyStoreRef).getState();return state.isDragging||\"DROP_ANIMATING\"===state.phase},[]);liftInstruction=useMemoOne.useMemo(function(){return{isDragging:isDragging,tryAbort:tryResetStore}},[isDragging,tryResetStore]);setCallbacks(liftInstruction);var getCanLift=useMemoOne.useCallback(function(id){return canStartDrag(getStore(lazyStoreRef).getState(),id)},[]),getIsMovementAllowed=useMemoOne.useCallback(function(){return isMovementAllowed(getStore(lazyStoreRef).getState())},\n[]);setCallbacks=useMemoOne.useMemo(function(){return{marshal:dimensionMarshal,focus:focusMarshal,contextId:contextId,canLift:getCanLift,isMovementAllowed:getIsMovementAllowed,liftInstructionId:liftInstructionId,registry:registry}},[contextId,dimensionMarshal,focusMarshal,getCanLift,getIsMovementAllowed,liftInstructionId,registry]);useSensorMarshal({contextId:contextId,store:nonce,registry:registry,customSensors:sensors,enableDefaultSensors:!1!==props$jscomp$0.enableDefaultSensors});React.useEffect(function(){return tryResetStore},\n[tryResetStore]);return React__default.createElement(AppContext.Provider,{value:setCallbacks},React__default.createElement(reactRedux.Provider,{context:StoreContext,store:nonce},props$jscomp$0.children))}function useRequiredContext(Context){(Context=React.useContext(Context))?void 0:invariant(!1,\"Could not find required context\");return Context}function useUniqueId(prefix){var countRef=React.useRef(count++);return prefix+\"::\"+countRef.current}function useDroppablePublisher(args){var whileDraggingRef=\nReact.useRef(null),appContext=useRequiredContext(AppContext),uniqueId=useUniqueId(\"droppable\"),registry=appContext.registry,marshal=appContext.marshal,previousRef=usePrevious(args),descriptor=useMemoOne.useMemo(function(){return{id:args.droppableId,type:args.type,mode:args.mode}},[args.droppableId,args.mode,args.type]),publishedDescriptorRef=React.useRef(descriptor),memoizedUpdateScroll=useMemoOne.useMemo(function(){return memoizeOne(function(x,y){whileDraggingRef.current?void 0:invariant(!1,\"Can only update scroll when dragging\");\nmarshal.updateDroppableScroll(descriptor.id,{x:x,y:y})})},[descriptor.id,marshal]),getClosestScroll=useMemoOne.useCallback(function(){var dragging=whileDraggingRef.current;return dragging&&dragging.env.closestScrollable?getScroll$1(dragging.env.closestScrollable):origin},[]),updateScroll=useMemoOne.useCallback(function(){var scroll=getClosestScroll();memoizedUpdateScroll(scroll.x,scroll.y)},[getClosestScroll,memoizedUpdateScroll]),scheduleScrollUpdate=useMemoOne.useMemo(function(){return rafSchd(updateScroll)},\n[updateScroll]),onClosestScroll=useMemoOne.useCallback(function(){var dragging=whileDraggingRef.current,closest=dragging&&dragging.env.closestScrollable||null;dragging&&closest?void 0:invariant(!1,\"Could not find scroll options while scrolling\");dragging.scrollOptions.shouldPublishImmediately?updateScroll():scheduleScrollUpdate()},[scheduleScrollUpdate,updateScroll]),getDimensionAndWatchScroll=useMemoOne.useCallback(function(windowScroll,options){whileDraggingRef.current?invariant(!1,\"Cannot collect a droppable while a drag is occurring\"):\nvoid 0;var previous=previousRef.current,ref=previous.getDroppableRef();ref?void 0:invariant(!1,\"Cannot collect without a droppable ref\");var env=getClosestScrollable(ref);var isFixedOnPage=getIsFixed(ref);env={closestScrollable:env,isFixedOnPage:isFixedOnPage};options={ref:ref,descriptor:descriptor,env:env,scrollOptions:options};whileDraggingRef.current=options;var direction=previous.direction,isDropDisabled=previous.isDropDisabled;isFixedOnPage=previous.isCombineEnabled;previous=!previous.ignoreContainerClipping;\nvar closestScrollable=env.closestScrollable;var client=cssBoxModel.getBox(ref);if(closestScrollable&&ref===closestScrollable){ref=client.paddingBox.top-closestScrollable.scrollTop;var left=client.paddingBox.left-closestScrollable.scrollLeft;ref=cssBoxModel.expand({top:ref,right:left+closestScrollable.scrollWidth,bottom:ref+closestScrollable.scrollHeight,left:left},client.border);client=cssBoxModel.createBox({borderBox:ref,margin:client.margin,border:client.border,padding:client.padding})}ref=cssBoxModel.withScroll(client,\nwindowScroll);if(closestScrollable){left=cssBoxModel.getBox(closestScrollable);var scrollSize={scrollHeight:closestScrollable.scrollHeight,scrollWidth:closestScrollable.scrollWidth};closestScrollable={client:left,page:cssBoxModel.withScroll(left,windowScroll),scroll:getScroll$1(closestScrollable),scrollSize:scrollSize,shouldClipSubject:previous}}else closestScrollable=null;windowScroll=!isDropDisabled;isDropDisabled=env.isFixedOnPage;previous=client;closestScrollable?(client=closestScrollable.scrollSize,\nleft=closestScrollable.client,scrollSize=getMaxScroll({scrollHeight:client.scrollHeight,scrollWidth:client.scrollWidth,height:left.paddingBox.height,width:left.paddingBox.width}),closestScrollable={pageMarginBox:closestScrollable.page.marginBox,frameClient:left,scrollSize:client,shouldClipSubject:closestScrollable.shouldClipSubject,scroll:{initial:closestScrollable.scroll,current:closestScrollable.scroll,max:scrollSize,diff:{value:origin,displacement:origin}}}):closestScrollable=null;direction=\"vertical\"===\ndirection?vertical:horizontal;client=getSubject({page:ref,withPlaceholder:null,axis:direction,frame:closestScrollable});isFixedOnPage={descriptor:descriptor,isCombineEnabled:isFixedOnPage,isFixedOnPage:isDropDisabled,axis:direction,isEnabled:windowScroll,client:previous,page:ref,frame:closestScrollable,subject:client};if(env=env.closestScrollable)env.setAttribute(scrollContainer.contextId,appContext.contextId),env.addEventListener(\"scroll\",onClosestScroll,options.scrollOptions.shouldPublishImmediately?\nimmediate:delayed),env&&getClosestScrollable(env.parentElement)&&warning(\"\\n    Droppable: unsupported nested scroll container detected.\\n    A Droppable can only have one scroll parent (which can be itself)\\n    Nested scroll containers are currently not supported.\\n\\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\\n  \");return isFixedOnPage},[appContext.contextId,descriptor,onClosestScroll,previousRef]),getScrollWhileDragging=useMemoOne.useCallback(function(){var dragging=\nwhileDraggingRef.current,closest=dragging&&dragging.env.closestScrollable||null;dragging&&closest?void 0:invariant(!1,\"Can only recollect Droppable client for Droppables that have a scroll container\");return getScroll$1(closest)},[]),dragStopped=useMemoOne.useCallback(function(){var dragging=whileDraggingRef.current;dragging?void 0:invariant(!1,\"Cannot stop drag when no active drag\");var closest=dragging&&dragging.env.closestScrollable||null;whileDraggingRef.current=null;closest&&(scheduleScrollUpdate.cancel(),\nclosest.removeAttribute(scrollContainer.contextId),closest.removeEventListener(\"scroll\",onClosestScroll,dragging.scrollOptions.shouldPublishImmediately?immediate:delayed))},[onClosestScroll,scheduleScrollUpdate]),scroll$jscomp$0=useMemoOne.useCallback(function(change){var dragging=whileDraggingRef.current;dragging?void 0:invariant(!1,\"Cannot scroll when there is no drag\");(dragging=dragging&&dragging.env.closestScrollable||null)?void 0:invariant(!1,\"Cannot scroll a droppable with no closest scrollable\");\ndragging.scrollTop+=change.y;dragging.scrollLeft+=change.x},[]),callbacks=useMemoOne.useMemo(function(){return{getDimensionAndWatchScroll:getDimensionAndWatchScroll,getScrollWhileDragging:getScrollWhileDragging,dragStopped:dragStopped,scroll:scroll$jscomp$0}},[dragStopped,getDimensionAndWatchScroll,getScrollWhileDragging,scroll$jscomp$0]),entry=useMemoOne.useMemo(function(){return{uniqueId:uniqueId,descriptor:descriptor,callbacks:callbacks}},[callbacks,descriptor,uniqueId]);useIsomorphicLayoutEffect(function(){publishedDescriptorRef.current=\nentry.descriptor;registry.droppable.register(entry);return function(){whileDraggingRef.current&&(warning(\"Unsupported: changing the droppableId or type of a Droppable during a drag\"),dragStopped());registry.droppable.unregister(entry)}},[callbacks,descriptor,dragStopped,entry,marshal,registry.droppable]);useIsomorphicLayoutEffect(function(){whileDraggingRef.current&&marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id,!args.isDropDisabled)},[args.isDropDisabled,marshal]);useIsomorphicLayoutEffect(function(){whileDraggingRef.current&&\nmarshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id,args.isCombineEnabled)},[args.isCombineEnabled,marshal])}function noop$2(){}function checkIsValidInnerRef(el){el&&isHtmlElement(el)?void 0:invariant(!1,\"\\n    provided.innerRef has not been provided with a HTMLElement.\\n\\n    You can find a guide on using the innerRef callback functions at:\\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\\n  \")}function runChecks(args,checks){checks.forEach(function(check){return check(args)})}\nfunction useValidation(args){useDevSetupWarning(function(){runChecks(args,shared);\"standard\"===args.props.mode&&runChecks(args,standard);\"virtual\"===args.props.mode&&runChecks(args,virtual)})}function useDraggablePublisher(args){var uniqueId=useUniqueId(\"draggable\"),descriptor=args.descriptor,registry=args.registry,getDraggableRef=args.getDraggableRef,canDragInteractiveElements=args.canDragInteractiveElements,shouldRespectForcePress=args.shouldRespectForcePress,isEnabled=args.isEnabled,options=useMemoOne.useMemo(function(){return{canDragInteractiveElements:canDragInteractiveElements,\nshouldRespectForcePress:shouldRespectForcePress,isEnabled:isEnabled}},[canDragInteractiveElements,isEnabled,shouldRespectForcePress]),getDimension=useMemoOne.useCallback(function(windowScroll$jscomp$0){var el=getDraggableRef();el?void 0:invariant(!1,\"Cannot get dimension when no ref is set\");var windowScroll=windowScroll$jscomp$0;void 0===windowScroll&&(windowScroll=origin);windowScroll$jscomp$0=window.getComputedStyle(el);var borderBox=el.getBoundingClientRect();borderBox=cssBoxModel.calculateBox(borderBox,\nwindowScroll$jscomp$0);windowScroll=cssBoxModel.withScroll(borderBox,windowScroll);el={client:borderBox,tagName:el.tagName.toLowerCase(),display:windowScroll$jscomp$0.display};return{descriptor:descriptor,placeholder:el,displaceBy:{x:borderBox.marginBox.width,y:borderBox.marginBox.height},client:borderBox,page:windowScroll}},[descriptor,getDraggableRef]),entry=useMemoOne.useMemo(function(){return{uniqueId:uniqueId,descriptor:descriptor,options:options,getDimension:getDimension}},[descriptor,getDimension,\noptions,uniqueId]),publishedRef=React.useRef(entry),isFirstPublishRef=React.useRef(!0);useIsomorphicLayoutEffect(function(){registry.draggable.register(publishedRef.current);return function(){return registry.draggable.unregister(publishedRef.current)}},[registry.draggable]);useIsomorphicLayoutEffect(function(){if(isFirstPublishRef.current)isFirstPublishRef.current=!1;else{var last=publishedRef.current;publishedRef.current=entry;registry.draggable.update(entry,last)}},[entry,registry.draggable])}function useValidation$1(props,\ncontextId,getRef){useDevSetupWarning(function(){var id=props.draggableId;id?void 0:invariant(!1,\"Draggable requires a draggableId\");\"string\"!==typeof id?invariant(!1,\"Draggable requires a [string] draggableId.\\n      Provided: [type: \"+typeof id+\"] (value: \"+id+\")\"):void 0;_Number$isInteger(props.index)?void 0:invariant(!1,\"Draggable[id: \"+id+\"]:  requires an integer index prop\");\"DRAGGING\"!==props.mapped.type&&(checkIsValidInnerRef(getRef()),props.isEnabled&&(findDragHandle(contextId,id)?void 0:\ninvariant(!1,\"Draggable[id: \"+id+\"]:  Unable to find drag handle\")))})}function useClonePropValidation(isClone){(function(){var initialRef=React.useRef(isClone);useDevSetupWarning(function(){isClone!==initialRef.current?invariant(!1,\"Draggable isClone prop value changed during component life\"):void 0},[isClone])})()}function preventHtml5Dnd(event){event.preventDefault()}function getDraggableSelector(){var memoizedOffset=memoizeOne(function(x,y){return{x:x,y:y}}),getMemoizedSnapshot=memoizeOne(function(mode,\nisClone,draggingOver,combineWith,dropping){return{isDragging:!0,isClone:isClone,isDropAnimating:!!dropping,dropAnimation:dropping,mode:mode,draggingOver:draggingOver,combineWith:combineWith,combineTargetFor:null}}),getMemoizedProps=memoizeOne(function(offset,mode,dimension,isClone,draggingOver,combineWith,forceShouldAnimate){return{mapped:{type:\"DRAGGING\",dropping:null,draggingOver:draggingOver,combineWith:combineWith,mode:mode,offset:offset,dimension:dimension,forceShouldAnimate:forceShouldAnimate,\nsnapshot:getMemoizedSnapshot(mode,isClone,draggingOver,combineWith,null)}}});return function(state,ownProps){if(state.isDragging){if(state.critical.draggable.id!==ownProps.draggableId)return null;var offset=state.current.client.offset,dimension=state.dimensions.draggables[ownProps.draggableId],draggingOver=whatIsDraggedOver(state.impact);var combineWith=state.impact;combineWith=combineWith.at&&\"COMBINE\"===combineWith.at.type?combineWith.at.combine.draggableId:null;var forceShouldAnimate=state.forceShouldAnimate;\nreturn getMemoizedProps(memoizedOffset(offset.x,offset.y),state.movementMode,dimension,ownProps.isClone,draggingOver,combineWith,forceShouldAnimate)}if(\"DROP_ANIMATING\"===state.phase){dimension=state.completed;if(dimension.result.draggableId!==ownProps.draggableId)return null;offset=ownProps.isClone;ownProps=state.dimensions.draggables[ownProps.draggableId];combineWith=dimension.result;dimension=combineWith.mode;draggingOver=whatIsDraggedOverFromResult(combineWith);combineWith=combineWith.combine?\ncombineWith.combine.draggableId:null;forceShouldAnimate={duration:state.dropDuration,curve:curves.drop,moveTo:state.newHomeClientOffset,opacity:combineWith?combine.opacity.drop:null,scale:combineWith?combine.scale.drop:null};return{mapped:{type:\"DRAGGING\",offset:state.newHomeClientOffset,dimension:ownProps,dropping:forceShouldAnimate,draggingOver:draggingOver,combineWith:combineWith,mode:dimension,forceShouldAnimate:null,snapshot:getMemoizedSnapshot(dimension,offset,draggingOver,combineWith,forceShouldAnimate)}}}return null}}\nfunction getSecondarySnapshot(combineTargetFor){return{isDragging:!1,isDropAnimating:!1,isClone:!1,dropAnimation:null,mode:null,draggingOver:null,combineTargetFor:combineTargetFor,combineWith:null}}function getSecondarySelector(){var memoizedOffset=memoizeOne(function(x,y){return{x:x,y:y}}),getMemoizedSnapshot=memoizeOne(getSecondarySnapshot),getMemoizedProps=memoizeOne(function(offset,combineTargetFor,shouldAnimateDisplacement){void 0===combineTargetFor&&(combineTargetFor=null);return{mapped:{type:\"SECONDARY\",\noffset:offset,combineTargetFor:combineTargetFor,shouldAnimateDisplacement:shouldAnimateDisplacement,snapshot:getMemoizedSnapshot(combineTargetFor)}}}),getProps=function(ownId,draggingId,impact,afterCritical){var visualDisplacement=impact.displaced.visible[ownId],isAfterCriticalInVirtualList=!(!afterCritical.inVirtualList||!afterCritical.effected[ownId]),combine=tryGetCombine(impact);draggingId=combine&&combine.draggableId===ownId?draggingId:null;if(!visualDisplacement){if(!isAfterCriticalInVirtualList)return draggingId?\ngetMemoizedProps(origin,draggingId,!0):null;if(impact.displaced.invisible[ownId])return null;visualDisplacement=negate(afterCritical.displacedBy.point);visualDisplacement=memoizedOffset(visualDisplacement.x,visualDisplacement.y);return getMemoizedProps(visualDisplacement,draggingId,!0)}if(isAfterCriticalInVirtualList)return draggingId?getMemoizedProps(origin,draggingId,!0):null;ownId=impact.displacedBy.point;ownId=memoizedOffset(ownId.x,ownId.y);return getMemoizedProps(ownId,draggingId,visualDisplacement.shouldAnimate)};\nreturn function(state,ownProps){return state.isDragging?state.critical.draggable.id===ownProps.draggableId?null:getProps(ownProps.draggableId,state.critical.draggable.id,state.impact,state.afterCritical):\"DROP_ANIMATING\"===state.phase?(state=state.completed,state.result.draggableId===ownProps.draggableId?null:getProps(ownProps.draggableId,state.result.draggableId,state.impact,state.afterCritical)):null}}function PrivateDraggable(props){return useRequiredContext(DroppableContext).isUsingCloneFor!==\nprops.draggableId||props.isClone?React__default.createElement(ConnectedDraggable,props):null}Object.defineProperty(exports,\"__esModule\",{value:!0});var React=require(\"module$node_modules$react$index\"),React__default=_interopDefault(React),useMemoOne=require(\"module$node_modules$use_memo_one$dist$use_memo_one_cjs\"),_inheritsLoose=_interopDefault(require(\"module$node_modules$$babel$runtime_corejs2$helpers$inheritsLoose\")),_extends=_interopDefault(require(\"module$node_modules$$babel$runtime_corejs2$helpers$extends\")),\nredux=require(\"module$node_modules$redux$lib$redux\"),reactRedux=require(\"module$node_modules$react_redux$lib$index\"),cssBoxModel=require(\"module$node_modules$css_box_model$dist$css_box_model_cjs\"),memoizeOne=_interopDefault(require(\"module$node_modules$memoize_one$dist$memoize_one_cjs\")),_Object$values=_interopDefault(require(\"module$node_modules$$babel$runtime_corejs2$core_js$object$values\")),_Object$keys=_interopDefault(require(\"module$node_modules$$babel$runtime_corejs2$core_js$object$keys\")),\nrafSchd=_interopDefault(require(\"module$node_modules$raf_schd$dist$raf_schd_cjs\")),_Date$now=_interopDefault(require(\"module$node_modules$$babel$runtime_corejs2$core_js$date$now\")),_Object$assign=_interopDefault(require(\"module$node_modules$$babel$runtime_corejs2$core_js$object$assign\")),ReactDOM=_interopDefault(require(\"module$node_modules$react_dom$index\")),_Number$isInteger=_interopDefault(require(\"module$node_modules$$babel$runtime_corejs2$core_js$number$is_integer\")),spacesAndTabs=/[ \\t]{2,}/g,\nlineStartWithSpaces=/^[ \\t]*/gm,warning=log.bind(null,\"warn\"),error=log.bind(null,\"error\");RbdInvariant.prototype.toString=function(){return this.message};var ErrorBoundary=function(_React$Component){function ErrorBoundary(){for(var _this,_len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];_this=_React$Component.call.apply(_React$Component,[this].concat(args))||this;_this.callbacks=null;_this.unbind=noop;_this.onWindowError=function(event){var callbacks=_this.getCallbacks();\ncallbacks.isDragging()&&(callbacks.tryAbort(),warning(\"\\n        An error was caught by our window 'error' event listener while a drag was occurring.\\n        The active drag has been aborted.\\n      \"));callbacks=event.error;callbacks instanceof RbdInvariant&&(event.preventDefault(),error(callbacks.message))};_this.getCallbacks=function(){if(!_this.callbacks)throw Error(\"Unable to find AppCallbacks in \\x3cErrorBoundary/\\x3e\");return _this.callbacks};_this.setCallbacks=function(callbacks){_this.callbacks=\ncallbacks};return _this}_inheritsLoose(ErrorBoundary,_React$Component);var _proto=ErrorBoundary.prototype;_proto.componentDidMount=function(){this.unbind=bindEvents(window,[{eventName:\"error\",fn:this.onWindowError}])};_proto.componentWillUnmount=function(){this.unbind()};_proto.componentDidCatch=function(err){if(err instanceof RbdInvariant)error(err.message),this.setState({});else throw err;};_proto.render=function(){return this.props.children(this.setCallbacks)};return ErrorBoundary}(React__default.Component),\nwithLocation=function(source,destination){var startPosition=source.index+1,endPosition=destination.index+1;return source.droppableId===destination.droppableId?\"\\n      You have moved the item from position \"+startPosition+\"\\n      to position \"+endPosition+\"\\n    \":\"\\n    You have moved the item from position \"+startPosition+\"\\n    in list \"+source.droppableId+\"\\n    to list \"+destination.droppableId+\"\\n    in position \"+endPosition+\"\\n  \"},withCombine=function(id,source,combine){return source.droppableId===\ncombine.droppableId?\"\\n      The item \"+id+\"\\n      has been combined with \"+combine.draggableId:\"\\n      The item \"+id+\"\\n      in list \"+source.droppableId+\"\\n      has been combined with \"+combine.draggableId+\"\\n      in list \"+combine.droppableId+\"\\n    \"},returnedToStart=function(source){return\"\\n  The item has returned to its starting position\\n  of \"+(source.index+1)+\"\\n\"},JSCompiler_object_inline_onDragStart_1611=function(start){return\"\\n  You have lifted an item in position \"+(start.source.index+\n1)+\".\\n  Use the arrow keys to move, space bar to drop, and escape to cancel.\\n\"},JSCompiler_object_inline_onDragUpdate_1612=function(update){var location=update.destination;return location?withLocation(update.source,location):(location=update.combine)?withCombine(update.draggableId,update.source,location):\"You are over an area that cannot be dropped on\"},JSCompiler_object_inline_onDragEnd_1613=function(result){if(\"CANCEL\"===result.reason)return\"\\n      Movement cancelled.\\n      \"+returnedToStart(result.source)+\n\"\\n    \";var location=result.destination,combine=result.combine;return location?\"\\n      You have dropped the item.\\n      \"+withLocation(result.source,location)+\"\\n    \":combine?\"\\n      You have dropped the item.\\n      \"+withCombine(result.draggableId,result.source,combine)+\"\\n    \":\"\\n    The item has been dropped while not over a drop area.\\n    \"+returnedToStart(result.source)+\"\\n  \"},origin={x:0,y:0},add=function(point1,point2){return{x:point1.x+point2.x,y:point1.y+point2.y}},subtract=function(point1,\npoint2){return{x:point1.x-point2.x,y:point1.y-point2.y}},isEqual=function(point1,point2){return point1.x===point2.x&&point1.y===point2.y},negate=function(point){return{x:0!==point.x?-point.x:0,y:0!==point.y?-point.y:0}},patch=function(line,value,otherValue){var _ref;void 0===otherValue&&(otherValue=0);return _ref={},_ref[line]=value,_ref[\"x\"===line?\"y\":\"x\"]=otherValue,_ref},distance=function(point1,point2){return Math.sqrt(Math.pow(point2.x-point1.x,2)+Math.pow(point2.y-point1.y,2))},closest=function(target,\npoints){return Math.min.apply(Math,points.map(function(point){return distance(target,point)}))},apply=function(fn){return function(point){return{x:fn(point.x),y:fn(point.y)}}},offsetByPosition=function(spacing,point){return{top:spacing.top+point.y,left:spacing.left+point.x,bottom:spacing.bottom+point.y,right:spacing.right+point.x}},getCorners=function(spacing){return[{x:spacing.left,y:spacing.top},{x:spacing.right,y:spacing.top},{x:spacing.left,y:spacing.bottom},{x:spacing.right,y:spacing.bottom}]},\ngetSubject=function(_ref){var page=_ref.page,withPlaceholder=_ref.withPlaceholder,axis=_ref.axis;_ref=_ref.frame;var scrolled=page.marginBox;scrolled=_ref?offsetByPosition(scrolled,_ref.scroll.diff.displacement):scrolled;if(withPlaceholder&&withPlaceholder.increasedBy){var _extends2;axis=_extends({},scrolled,(_extends2={},_extends2[axis.end]=scrolled[axis.end]+withPlaceholder.increasedBy[axis.line],_extends2))}else axis=scrolled;_extends2=axis;_ref&&_ref.shouldClipSubject?(_ref=_ref.pageMarginBox,\n_ref=cssBoxModel.getRect({top:Math.max(_extends2.top,_ref.top),right:Math.min(_extends2.right,_ref.right),bottom:Math.min(_extends2.bottom,_ref.bottom),left:Math.max(_extends2.left,_ref.left)}),_ref=0>=_ref.width||0>=_ref.height?null:_ref):_ref=cssBoxModel.getRect(_extends2);return{page:page,withPlaceholder:withPlaceholder,active:_ref}},scrollDroppable=function(droppable,newScroll){droppable.frame?void 0:invariant(!1);var scrollable=droppable.frame,scrollDiff=subtract(newScroll,scrollable.scroll.initial),\nscrollDisplacement=negate(scrollDiff);newScroll=_extends({},scrollable,{scroll:{initial:scrollable.scroll.initial,current:newScroll,diff:{value:scrollDiff,displacement:scrollDisplacement},max:scrollable.scroll.max}});scrollable=getSubject({page:droppable.subject.page,withPlaceholder:droppable.subject.withPlaceholder,axis:droppable.axis,frame:newScroll});return _extends({},droppable,{frame:newScroll,subject:scrollable})},toDroppableMap=memoizeOne(function(droppables){return droppables.reduce(function(previous,\ncurrent){previous[current.descriptor.id]=current;return previous},{})}),toDraggableMap=memoizeOne(function(draggables){return draggables.reduce(function(previous,current){previous[current.descriptor.id]=current;return previous},{})}),toDroppableList=memoizeOne(function(droppables){return _Object$values(droppables)}),toDraggableList=memoizeOne(function(draggables){return _Object$values(draggables)}),getDraggablesInsideDroppable=memoizeOne(function(droppableId,draggables){return toDraggableList(draggables).filter(function(draggable){return droppableId===\ndraggable.descriptor.droppableId}).sort(function(a,b){return a.descriptor.index-b.descriptor.index})}),forward={vertical:\"down\",horizontal:\"right\"},backward={vertical:\"up\",horizontal:\"left\"},removeDraggableFromList=memoizeOne(function(remove,list){return list.filter(function(item){return item.descriptor.id!==remove.descriptor.id})}),moveToNextCombine=function(_ref){function getImpact(target){return _extends({},previousImpact,{at:{type:\"COMBINE\",whenEntered:isMovingForward?forward:backward,combine:{draggableId:target,\ndroppableId:destination.descriptor.id}}})}var isMovingForward=_ref.isMovingForward,draggable=_ref.draggable,destination=_ref.destination,insideDestination=_ref.insideDestination,previousImpact=_ref.previousImpact;if(!destination.isCombineEnabled||!tryGetDestination(previousImpact))return null;_ref=previousImpact.displaced.all;var closestId=_ref.length?_ref[0]:null;if(isMovingForward)return closestId?getImpact(closestId):null;draggable=removeDraggableFromList(draggable,insideDestination);if(!closestId)return draggable.length?\ngetImpact(draggable[draggable.length-1].descriptor.id):null;insideDestination=findIndex(draggable,function(d){return d.descriptor.id===closestId});-1===insideDestination?invariant(!1,\"Could not find displaced item in set\"):void 0;--insideDestination;return 0>insideDestination?null:getImpact(draggable[insideDestination].descriptor.id)},isHomeOf=function(draggable,destination){return draggable.descriptor.droppableId===destination.descriptor.id},noDisplacedBy={point:origin,value:0},emptyGroups={invisible:{},\nvisible:{},all:[]},noImpact={displaced:emptyGroups,displacedBy:noDisplacedBy,at:null},isWithin=function(lowerBound,upperBound){return function(value){return lowerBound<=value&&value<=upperBound}},isPartiallyVisibleThroughFrame=function(frame){var isWithinVertical=isWithin(frame.top,frame.bottom),isWithinHorizontal=isWithin(frame.left,frame.right);return function(subject){if(isWithinVertical(subject.top)&&isWithinVertical(subject.bottom)&&isWithinHorizontal(subject.left)&&isWithinHorizontal(subject.right))return!0;\nvar isPartiallyVisibleVertically=isWithinVertical(subject.top)||isWithinVertical(subject.bottom),isPartiallyVisibleHorizontally=isWithinHorizontal(subject.left)||isWithinHorizontal(subject.right);if(isPartiallyVisibleVertically&&isPartiallyVisibleHorizontally)return!0;var isBiggerVertically=subject.top<frame.top&&subject.bottom>frame.bottom;subject=subject.left<frame.left&&subject.right>frame.right;return isBiggerVertically&&subject?!0:isBiggerVertically&&isPartiallyVisibleHorizontally||subject&&\nisPartiallyVisibleVertically}},isTotallyVisibleThroughFrame=function(frame){var isWithinVertical=isWithin(frame.top,frame.bottom),isWithinHorizontal=isWithin(frame.left,frame.right);return function(subject){return isWithinVertical(subject.top)&&isWithinVertical(subject.bottom)&&isWithinHorizontal(subject.left)&&isWithinHorizontal(subject.right)}},vertical={direction:\"vertical\",line:\"y\",crossAxisLine:\"x\",start:\"top\",end:\"bottom\",size:\"height\",crossAxisStart:\"left\",crossAxisEnd:\"right\",crossAxisSize:\"width\"},\nhorizontal={direction:\"horizontal\",line:\"x\",crossAxisLine:\"y\",start:\"left\",end:\"right\",size:\"width\",crossAxisStart:\"top\",crossAxisEnd:\"bottom\",crossAxisSize:\"height\"},isTotallyVisibleThroughFrameOnAxis=function(axis){return function(frame){var isWithinVertical=isWithin(frame.top,frame.bottom),isWithinHorizontal=isWithin(frame.left,frame.right);return function(subject){return axis===vertical?isWithinVertical(subject.top)&&isWithinVertical(subject.bottom):isWithinHorizontal(subject.left)&&isWithinHorizontal(subject.right)}}},\nisVisible=function(_ref){var toBeDisplaced=_ref.target,destination=_ref.destination,viewport=_ref.viewport,isVisibleThroughFrameFn=_ref.isVisibleThroughFrameFn;_ref=_ref.withDroppableDisplacement?offsetByPosition(toBeDisplaced,destination.frame?destination.frame.scroll.diff.displacement:origin):toBeDisplaced;destination=destination.subject.active?isVisibleThroughFrameFn(destination.subject.active)(_ref):!1;destination&&(destination=isVisibleThroughFrameFn(viewport)(_ref));return destination},isTotallyVisible=\nfunction(args){return isVisible(_extends({},args,{isVisibleThroughFrameFn:isTotallyVisibleThroughFrame}))},getCombinedItemDisplacement=function(_ref){var displaced=_ref.displaced,combineWith=_ref.combineWith,displacedBy=_ref.displacedBy;displaced=!(!displaced.visible[combineWith]&&!displaced.invisible[combineWith]);return _ref.afterCritical.effected[combineWith]?displaced?origin:negate(displacedBy.point):displaced?displacedBy.point:origin},getCrossAxisBorderBoxCenter=function(axis,target,isMoving){return target[axis.crossAxisStart]+\nisMoving.margin[axis.crossAxisStart]+isMoving.borderBox[axis.crossAxisSize]/2},goAfter=function(_ref){var axis=_ref.axis,moveRelativeTo=_ref.moveRelativeTo;_ref=_ref.isMoving;return patch(axis.line,moveRelativeTo.marginBox[axis.end]+(_ref.margin[axis.start]+_ref.borderBox[axis.size]/2),getCrossAxisBorderBoxCenter(axis,moveRelativeTo.marginBox,_ref))},goBefore=function(_ref2){var axis=_ref2.axis,moveRelativeTo=_ref2.moveRelativeTo;_ref2=_ref2.isMoving;return patch(axis.line,moveRelativeTo.marginBox[axis.start]-\n(_ref2.margin[axis.end]+_ref2.borderBox[axis.size]/2),getCrossAxisBorderBoxCenter(axis,moveRelativeTo.marginBox,_ref2))},whenReordering=function(_ref){var impact=_ref.impact,draggable=_ref.draggable,draggables=_ref.draggables,droppable=_ref.droppable,afterCritical=_ref.afterCritical,insideDestination=getDraggablesInsideDroppable(droppable.descriptor.id,draggables);_ref=draggable.page;var axis=droppable.axis;if(!insideDestination.length)return draggable=droppable.page,patch(axis.line,draggable.contentBox[axis.start]+\n(_ref.margin[axis.start]+_ref.borderBox[axis.size]/2),getCrossAxisBorderBoxCenter(axis,draggable.contentBox,_ref));droppable=impact.displacedBy;if(impact=impact.displaced.all[0]){draggable=draggables[impact];if(afterCritical.effected[impact])return goBefore({axis:axis,moveRelativeTo:draggable.page,isMoving:_ref});draggable=cssBoxModel.offset(draggable.page,droppable.point);return goBefore({axis:axis,moveRelativeTo:draggable,isMoving:_ref})}draggables=insideDestination[insideDestination.length-1];\nreturn draggables.descriptor.id===draggable.descriptor.id?_ref.borderBox.center:afterCritical.effected[draggables.descriptor.id]?(draggable=cssBoxModel.offset(draggables.page,negate(afterCritical.displacedBy.point)),goAfter({axis:axis,moveRelativeTo:draggable,isMoving:_ref})):goAfter({axis:axis,moveRelativeTo:draggables.page,isMoving:_ref})},withDroppableDisplacement=function(droppable,point){return(droppable=droppable.frame)?add(point,droppable.scroll.diff.displacement):point},getPageBorderBoxCenterFromImpact=\nfunction(args){var withoutDisplacement=args.impact;var draggable=args.draggable,droppable=args.droppable,draggables=args.draggables,afterCritical=args.afterCritical,original=draggable.page.borderBox.center,at=withoutDisplacement.at;droppable&&at?\"REORDER\"===at.type?withoutDisplacement=whenReordering({impact:withoutDisplacement,draggable:draggable,draggables:draggables,droppable:droppable,afterCritical:afterCritical}):((draggable=tryGetCombine(withoutDisplacement))?void 0:invariant(!1),draggable=draggable.draggableId,\ndraggables=draggables[draggable].page.borderBox.center,withoutDisplacement=getCombinedItemDisplacement({displaced:withoutDisplacement.displaced,afterCritical:afterCritical,combineWith:draggable,displacedBy:withoutDisplacement.displacedBy}),withoutDisplacement=add(draggables,withoutDisplacement)):withoutDisplacement=original;return(args=args.droppable)?withDroppableDisplacement(args,withoutDisplacement):withoutDisplacement},scrollViewport=function(viewport,newScroll){var diff=subtract(newScroll,viewport.scroll.initial),\ndisplacement=negate(diff);return{frame:cssBoxModel.getRect({top:newScroll.y,bottom:newScroll.y+viewport.frame.height,left:newScroll.x,right:newScroll.x+viewport.frame.width}),scroll:{initial:viewport.scroll.initial,max:viewport.scroll.max,current:newScroll,diff:{value:diff,displacement:displacement}}}},speculativelyIncrease=function(_ref){var impact=_ref.impact,viewport=_ref.viewport,destination=_ref.destination,draggables=_ref.draggables;_ref=_ref.maxScrollChange;var scrolledViewport=scrollViewport(viewport,\nadd(viewport.scroll.current,_ref)),scrolledDroppable=destination.frame?scrollDroppable(destination,add(destination.frame.scroll.current,_ref)):destination;_ref=impact.displaced;destination=getDisplacementGroups({afterDragging:getDraggables(_ref.all,draggables),destination:destination,displacedBy:impact.displacedBy,viewport:scrolledViewport.frame,last:_ref,forceShouldAnimate:!1});viewport=getDisplacementGroups({afterDragging:getDraggables(_ref.all,draggables),destination:scrolledDroppable,displacedBy:impact.displacedBy,\nviewport:viewport.frame,last:_ref,forceShouldAnimate:!1});var invisible={},visible={},groups=[_ref,destination,viewport];_ref.all.forEach(function(id){var displacement;a:{for(displacement=0;displacement<groups.length;displacement++){var displacement$jscomp$0=groups[displacement].visible[id];if(displacement$jscomp$0){displacement=displacement$jscomp$0;break a}}displacement=null}displacement?visible[id]=displacement:invisible[id]=!0});return _extends({},impact,{displaced:{all:_ref.all,invisible:invisible,\nvisible:visible}})},getClientFromPageBorderBoxCenter=function(_ref){var draggable=_ref.draggable;_ref=add(_ref.viewport.scroll.diff.displacement,_ref.pageBorderBoxCenter);_ref=subtract(_ref,draggable.page.borderBox.center);return add(draggable.client.borderBox.center,_ref)},isTotallyVisibleInNewLocation=function(_ref){var draggable=_ref.draggable,destination=_ref.destination,viewport=_ref.viewport,withDroppableDisplacement=_ref.withDroppableDisplacement,_ref$onlyOnMainAxis=_ref.onlyOnMainAxis;_ref$onlyOnMainAxis=\nvoid 0===_ref$onlyOnMainAxis?!1:_ref$onlyOnMainAxis;_ref=subtract(_ref.newPageBorderBoxCenter,draggable.page.borderBox.center);draggable={target:offsetByPosition(draggable.page.borderBox,_ref),destination:destination,withDroppableDisplacement:withDroppableDisplacement,viewport:viewport};return _ref$onlyOnMainAxis?isVisible(_extends({},draggable,{isVisibleThroughFrameFn:isTotallyVisibleThroughFrameOnAxis(draggable.destination.axis)})):isTotallyVisible(draggable)},moveToNextPlace=function(_ref){var isMovingForward=\n_ref.isMovingForward,draggable=_ref.draggable,destination=_ref.destination,draggables=_ref.draggables,previousImpact=_ref.previousImpact,viewport=_ref.viewport,previousPageBorderBoxCenter=_ref.previousPageBorderBoxCenter,previousClientSelection=_ref.previousClientSelection;_ref=_ref.afterCritical;if(!destination.isEnabled)return null;var insideDestination=getDraggablesInsideDroppable(destination.descriptor.id,draggables),isInHomeList=isHomeOf(draggable,destination),JSCompiler_temp;(JSCompiler_temp=\nmoveToNextCombine({isMovingForward:isMovingForward,draggable:draggable,destination:destination,insideDestination:insideDestination,previousImpact:previousImpact}))||((JSCompiler_temp=previousImpact.at)?void 0:invariant(!1,\"Cannot move in direction without previous impact location\"),\"REORDER\"===JSCompiler_temp.type?(JSCompiler_temp=JSCompiler_temp.destination,insideDestination.length?(JSCompiler_temp=JSCompiler_temp.index,isMovingForward=isMovingForward?JSCompiler_temp+1:JSCompiler_temp-1,JSCompiler_temp=\ninsideDestination[insideDestination.length-1].descriptor.index,isMovingForward=isMovingForward<insideDestination[0].descriptor.index||isMovingForward>(isInHomeList?JSCompiler_temp:JSCompiler_temp+1)?null:isMovingForward):isMovingForward=null,JSCompiler_temp=null==isMovingForward?null:calculateReorderImpact({draggable:draggable,insideDestination:insideDestination,destination:destination,viewport:viewport,last:previousImpact.displaced,displacedBy:previousImpact.displacedBy,index:isMovingForward})):\n(isInHomeList=JSCompiler_temp.combine,destination.isCombineEnabled?(isInHomeList=isInHomeList.draggableId,JSCompiler_temp=draggables[isInHomeList].descriptor.index,isMovingForward=_ref.effected[isInHomeList]?isMovingForward?JSCompiler_temp:JSCompiler_temp-1:isMovingForward?JSCompiler_temp+1:JSCompiler_temp):isMovingForward=null,JSCompiler_temp=null==isMovingForward?null:calculateReorderImpact({draggable:draggable,insideDestination:insideDestination,destination:destination,viewport:viewport,last:previousImpact.displaced,\ndisplacedBy:previousImpact.displacedBy,index:isMovingForward})));previousImpact=JSCompiler_temp;if(!previousImpact)return null;_ref=getPageBorderBoxCenterFromImpact({impact:previousImpact,draggable:draggable,droppable:destination,draggables:draggables,afterCritical:_ref});if(isTotallyVisibleInNewLocation({draggable:draggable,destination:destination,newPageBorderBoxCenter:_ref,viewport:viewport.frame,withDroppableDisplacement:!1,onlyOnMainAxis:!0}))return{clientSelection:getClientFromPageBorderBoxCenter({pageBorderBoxCenter:_ref,\ndraggable:draggable,viewport:viewport}),impact:previousImpact,scrollJumpRequest:null};draggable=subtract(_ref,previousPageBorderBoxCenter);destination=speculativelyIncrease({impact:previousImpact,viewport:viewport,destination:destination,draggables:draggables,maxScrollChange:draggable});return{clientSelection:previousClientSelection,impact:destination,scrollJumpRequest:draggable}},getKnownActive=function(droppable){(droppable=droppable.subject.active)?void 0:invariant(!1,\"Cannot get clipped area from droppable\");\nreturn droppable},getBestCrossAxisDroppable=function(_ref){var isMovingForward=_ref.isMovingForward,pageBorderBoxCenter=_ref.pageBorderBoxCenter,source=_ref.source,droppables=_ref.droppables,viewport=_ref.viewport,active=source.subject.active;if(!active)return null;var axis=source.axis,isBetweenSourceClipped=isWithin(active[axis.start],active[axis.end]);_ref=toDroppableList(droppables).filter(function(droppable){return droppable!==source}).filter(function(droppable){return droppable.isEnabled}).filter(function(droppable){return!!droppable.subject.active}).filter(function(droppable){return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))}).filter(function(droppable){droppable=\ngetKnownActive(droppable);return isMovingForward?active[axis.crossAxisEnd]<droppable[axis.crossAxisEnd]:droppable[axis.crossAxisStart]<active[axis.crossAxisStart]}).filter(function(droppable){droppable=getKnownActive(droppable);var isBetweenDestinationClipped=isWithin(droppable[axis.start],droppable[axis.end]);return isBetweenSourceClipped(droppable[axis.start])||isBetweenSourceClipped(droppable[axis.end])||isBetweenDestinationClipped(active[axis.start])||isBetweenDestinationClipped(active[axis.end])}).sort(function(a,\nb){a=getKnownActive(a)[axis.crossAxisStart];b=getKnownActive(b)[axis.crossAxisStart];return isMovingForward?a-b:b-a}).filter(function(droppable,index,array){return getKnownActive(droppable)[axis.crossAxisStart]===getKnownActive(array[0])[axis.crossAxisStart]});if(!_ref.length)return null;if(1===_ref.length)return _ref[0];droppables=_ref.filter(function(droppable){return isWithin(getKnownActive(droppable)[axis.start],getKnownActive(droppable)[axis.end])(pageBorderBoxCenter[axis.line])});return 1===\ndroppables.length?droppables[0]:1<droppables.length?droppables.sort(function(a,b){return getKnownActive(a)[axis.start]-getKnownActive(b)[axis.start]})[0]:_ref.sort(function(a,b){var first=closest(pageBorderBoxCenter,getCorners(getKnownActive(a))),second=closest(pageBorderBoxCenter,getCorners(getKnownActive(b)));return first!==second?first-second:getKnownActive(a)[axis.start]-getKnownActive(b)[axis.start]})[0]},getCurrentPageBorderBoxCenter=function(draggable,afterCritical){var original=draggable.page.borderBox.center;\nreturn afterCritical.effected[draggable.descriptor.id]?subtract(original,afterCritical.displacedBy.point):original},getClosestDraggable=function(_ref){var pageBorderBoxCenter=_ref.pageBorderBoxCenter,viewport=_ref.viewport,destination=_ref.destination,afterCritical=_ref.afterCritical;return _ref.insideDestination.filter(function(draggable){var original=draggable.page.borderBox;draggable=afterCritical.effected[draggable.descriptor.id]?offsetByPosition(original,negate(afterCritical.displacedBy.point)):\noriginal;return isTotallyVisible({target:draggable,destination:destination,viewport:viewport.frame,withDroppableDisplacement:!0})}).sort(function(a,b){var distanceToA=distance(pageBorderBoxCenter,withDroppableDisplacement(destination,getCurrentPageBorderBoxCenter(a,afterCritical))),distanceToB=distance(pageBorderBoxCenter,withDroppableDisplacement(destination,getCurrentPageBorderBoxCenter(b,afterCritical)));return distanceToA<distanceToB?-1:distanceToB<distanceToA?1:a.descriptor.index-b.descriptor.index})[0]||\nnull},getDisplacedBy=memoizeOne(function(axis,displaceBy){displaceBy=displaceBy[axis.line];return{value:displaceBy,point:patch(axis.line,displaceBy)}}),getRequiredGrowthForPlaceholder=function(droppable,placeholderSize,draggables){var axis=droppable.axis;if(\"virtual\"===droppable.descriptor.mode)return patch(axis.line,placeholderSize[axis.line]);var availableSpace=droppable.subject.page.contentBox[axis.size];droppable=getDraggablesInsideDroppable(droppable.descriptor.id,draggables).reduce(function(sum,\ndimension){return sum+dimension.client.marginBox[axis.size]},0)+placeholderSize[axis.line]-availableSpace;return 0>=droppable?null:patch(axis.line,droppable)},addPlaceholder=function(droppable,draggable,draggables){var frame=droppable.frame;isHomeOf(draggable,droppable)?invariant(!1,\"Should not add placeholder space to home list\"):void 0;droppable.subject.withPlaceholder?invariant(!1,\"Cannot add placeholder size to a subject when it already has one\"):void 0;draggable=getDisplacedBy(droppable.axis,\ndraggable.displaceBy).point;var requiredGrowth=getRequiredGrowthForPlaceholder(droppable,draggable,draggables);draggables={placeholderSize:draggable,increasedBy:requiredGrowth,oldFrameMaxScroll:droppable.frame?droppable.frame.scroll.max:null};if(!frame)return frame=getSubject({page:droppable.subject.page,withPlaceholder:draggables,axis:droppable.axis,frame:droppable.frame}),_extends({},droppable,{subject:frame});draggable=requiredGrowth?add(frame.scroll.max,requiredGrowth):frame.scroll.max;frame=\n_extends({},frame,{scroll:_extends({},frame.scroll,{max:draggable})});draggables=getSubject({page:droppable.subject.page,withPlaceholder:draggables,axis:droppable.axis,frame:frame});return _extends({},droppable,{subject:draggables,frame:frame})},whatIsDraggedOver=function(impact){return(impact=impact.at)?\"REORDER\"===impact.type?impact.destination.droppableId:impact.combine.droppableId:null},moveInDirection=function(_ref){var state=_ref.state;_ref=_ref.type;var isActuallyOver=state.dimensions.droppables;\nvar id=whatIsDraggedOver(state.impact);isActuallyOver=id?isActuallyOver[id]:null;id=state.dimensions.droppables[state.critical.droppable.id];var isOver=isActuallyOver||id;id=isOver.axis.direction;if((id=\"vertical\"===id&&(\"MOVE_UP\"===_ref||\"MOVE_DOWN\"===_ref)||\"horizontal\"===id&&(\"MOVE_LEFT\"===_ref||\"MOVE_RIGHT\"===_ref))&&!isActuallyOver)return null;var isMovingForward=\"MOVE_DOWN\"===_ref||\"MOVE_RIGHT\"===_ref;_ref=state.dimensions.draggables[state.critical.draggable.id];var previousPageBorderBoxCenter=\nstate.current.page.borderBoxCenter,_state$dimensions=state.dimensions;isActuallyOver=_state$dimensions.draggables;_state$dimensions=_state$dimensions.droppables;if(id)_ref=moveToNextPlace({isMovingForward:isMovingForward,previousPageBorderBoxCenter:previousPageBorderBoxCenter,draggable:_ref,destination:isOver,draggables:isActuallyOver,viewport:state.viewport,previousClientSelection:state.current.client.selection,previousImpact:state.impact,afterCritical:state.afterCritical});else if(id=state.viewport,\nstate=state.afterCritical,isOver=getBestCrossAxisDroppable({isMovingForward:isMovingForward,pageBorderBoxCenter:previousPageBorderBoxCenter,source:isOver,droppables:_state$dimensions,viewport:id})){isMovingForward=getDraggablesInsideDroppable(isOver.descriptor.id,isActuallyOver);if(_state$dimensions=getClosestDraggable({pageBorderBoxCenter:previousPageBorderBoxCenter,viewport:id,destination:isOver,insideDestination:isMovingForward,afterCritical:state})){previousPageBorderBoxCenter=previousPageBorderBoxCenter[isOver.axis.line]<=\n_state$dimensions.page.borderBox.center[isOver.axis.line];var relativeTo=_state$dimensions.descriptor.index;previousPageBorderBoxCenter=_state$dimensions.descriptor.id===_ref.descriptor.id||previousPageBorderBoxCenter?relativeTo:relativeTo+1;_state$dimensions=getDisplacedBy(isOver.axis,_ref.displaceBy);previousPageBorderBoxCenter=calculateReorderImpact({draggable:_ref,insideDestination:isMovingForward,destination:isOver,viewport:id,displacedBy:_state$dimensions,last:emptyGroups,index:previousPageBorderBoxCenter})}else isMovingForward.length?\npreviousPageBorderBoxCenter=null:(previousPageBorderBoxCenter={displaced:emptyGroups,displacedBy:noDisplacedBy,at:{type:\"REORDER\",destination:{droppableId:isOver.descriptor.id,index:0}}},isMovingForward=getPageBorderBoxCenterFromImpact({impact:previousPageBorderBoxCenter,draggable:_ref,droppable:isOver,draggables:isActuallyOver,afterCritical:state}),_state$dimensions=isHomeOf(_ref,isOver)?isOver:addPlaceholder(isOver,_ref,isActuallyOver),previousPageBorderBoxCenter=isTotallyVisibleInNewLocation({draggable:_ref,\ndestination:_state$dimensions,newPageBorderBoxCenter:isMovingForward,viewport:id.frame,withDroppableDisplacement:!1,onlyOnMainAxis:!0})?previousPageBorderBoxCenter:null);previousPageBorderBoxCenter?(isActuallyOver=getPageBorderBoxCenterFromImpact({impact:previousPageBorderBoxCenter,draggable:_ref,droppable:isOver,draggables:isActuallyOver,afterCritical:state}),_ref={clientSelection:getClientFromPageBorderBoxCenter({pageBorderBoxCenter:isActuallyOver,draggable:_ref,viewport:id}),impact:previousPageBorderBoxCenter,\nscrollJumpRequest:null}):_ref=null}else _ref=null;return _ref},isPositionInFrame=function(frame){var isWithinVertical=isWithin(frame.top,frame.bottom),isWithinHorizontal=isWithin(frame.left,frame.right);return function(point){return isWithinVertical(point.y)&&isWithinVertical(point.y)&&isWithinHorizontal(point.x)&&isWithinHorizontal(point.x)}},getDroppableOver$1=function(_ref){var target=_ref.target;return(_ref=find(toDroppableList(_ref.droppables),function(droppable){return droppable.isEnabled?(droppable=\ndroppable.subject.active)?isPositionInFrame(droppable)(target):!1:!1}))?_ref.descriptor.id:null},isUserMovingForward=function(axis,direction){return axis===vertical?\"down\"===direction.vertical:\"right\"===direction.horizontal},getReorderImpact=function(_ref2){var currentCenter=_ref2.pageBorderBoxCenterWithDroppableScrollChange,draggable=_ref2.draggable,destination=_ref2.destination,insideDestination=_ref2.insideDestination,last=_ref2.last,viewport=_ref2.viewport,afterCritical=_ref2.afterCritical,axis=\ndestination.axis,isMovingForward=isUserMovingForward(destination.axis,_ref2.userDirection);_ref2=getDisplacedBy(destination.axis,draggable.displaceBy);var targetCenter=currentCenter[axis.line],displacement=_ref2.value;currentCenter=removeDraggableFromList(draggable,insideDestination);currentCenter=find(currentCenter,function(child){var borderBox=child.page.borderBox,start=borderBox[axis.start];borderBox=borderBox[axis.end];child=!!afterCritical.effected[child.descriptor.id];return isMovingForward?\nchild?targetCenter<start:targetCenter<start+displacement:child?targetCenter<=borderBox-displacement:targetCenter<=borderBox});currentCenter=atIndex({draggable:draggable,closest:currentCenter,inHomeList:isHomeOf(draggable,destination)});return calculateReorderImpact({draggable:draggable,insideDestination:insideDestination,destination:destination,viewport:viewport,last:last,displacedBy:_ref2,index:currentCenter})},getCombineImpact=function(_ref2){var draggable=_ref2.draggable,currentCenter=_ref2.pageBorderBoxCenterWithDroppableScrollChange,\npreviousImpact=_ref2.previousImpact,destination=_ref2.destination,insideDestination=_ref2.insideDestination,userDirection=_ref2.userDirection,afterCritical=_ref2.afterCritical;if(!destination.isCombineEnabled)return null;var axis=destination.axis,displaced=previousImpact.displaced,canBeDisplacedBy=getDisplacedBy(destination.axis,draggable.displaceBy);var lastCombineImpact=previousImpact.at&&\"COMBINE\"===previousImpact.at.type?previousImpact.at:null;return(_ref2=find(removeDraggableFromList(draggable,\ninsideDestination),function(child){var id=child.descriptor.id,displaceBy=getCombinedItemDisplacement({displaced:displaced,afterCritical:afterCritical,combineWith:id,displacedBy:canBeDisplacedBy});var borderBox=child.page.borderBox;child=borderBox[axis.start]+displaceBy[axis.line];displaceBy=borderBox[axis.end]+displaceBy[axis.line];borderBox=.666*borderBox[axis.size];id=isUserMovingForward(axis,lastCombineImpact&&id===lastCombineImpact.combine.draggableId?lastCombineImpact.whenEntered:userDirection);\nvar targetCenter=currentCenter[axis.line];child=id?isWithin(child,child+borderBox)(targetCenter):isWithin(displaceBy-borderBox,displaceBy)(targetCenter);return child}))?calculateCombineImpact({combineWithId:_ref2.descriptor.id,destinationId:destination.descriptor.id,previousImpact:previousImpact,userDirection:userDirection}):null},getDragImpact=function(_ref){var pageBorderBoxCenter=_ref.pageBorderBoxCenter,draggable=_ref.draggable,draggables=_ref.draggables,droppables=_ref.droppables,previousImpact=\n_ref.previousImpact,viewport=_ref.viewport,userDirection=_ref.userDirection;_ref=_ref.afterCritical;var destinationId=getDroppableOver$1({target:pageBorderBoxCenter,droppables:droppables});if(!destinationId)return noImpact;droppables=droppables[destinationId];draggables=getDraggablesInsideDroppable(droppables.descriptor.id,draggables);pageBorderBoxCenter=(destinationId=droppables.frame)?add(pageBorderBoxCenter,destinationId.scroll.diff.value):pageBorderBoxCenter;return getCombineImpact({pageBorderBoxCenterWithDroppableScrollChange:pageBorderBoxCenter,\ndraggable:draggable,previousImpact:previousImpact,destination:droppables,insideDestination:draggables,userDirection:userDirection,afterCritical:_ref})||getReorderImpact({pageBorderBoxCenterWithDroppableScrollChange:pageBorderBoxCenter,draggable:draggable,destination:droppables,insideDestination:draggables,last:previousImpact.displaced,viewport:viewport,userDirection:userDirection,afterCritical:_ref})},patchDroppableMap=function(droppables,updated){var _extends2;return _extends({},droppables,(_extends2=\n{},_extends2[updated.descriptor.id]=updated,_extends2))},update$jscomp$0=function(_ref){var state=_ref.state,forcedImpact=_ref.impact,scrollJumpRequest=_ref.scrollJumpRequest,viewport=_ref.viewport||state.viewport,currentWindowScroll=viewport.scroll.current,dimensions=_ref.dimensions||state.dimensions;_ref=_ref.clientSelection||state.current.client.selection;var offset=subtract(_ref,state.initial.client.selection);_ref={offset:offset,selection:_ref,borderBoxCenter:add(state.initial.client.borderBoxCenter,\noffset)};var page={selection:add(_ref.selection,currentWindowScroll),borderBoxCenter:add(_ref.borderBoxCenter,currentWindowScroll)};currentWindowScroll={client:_ref,page:page};_ref=state.userDirection;var diff=subtract(currentWindowScroll.page.borderBoxCenter,state.current.page.borderBoxCenter);offset=diff.x;diff=diff.y;_ref={horizontal:0===offset?_ref.horizontal:0<offset?\"right\":\"left\",vertical:0===diff?_ref.vertical:0<diff?\"down\":\"up\"};if(\"COLLECTING\"===state.phase)return _extends({phase:\"COLLECTING\"},\nstate,{dimensions:dimensions,viewport:viewport,current:currentWindowScroll,userDirection:_ref});offset=dimensions.draggables[state.critical.draggable.id];forcedImpact=forcedImpact||getDragImpact({pageBorderBoxCenter:page.borderBoxCenter,draggable:offset,draggables:dimensions.draggables,droppables:dimensions.droppables,previousImpact:state.impact,viewport:viewport,userDirection:_ref,afterCritical:state.afterCritical});page=dimensions.draggables;diff=dimensions.droppables;var cleaned=whatIsDraggedOver(state.impact);\nvar now=whatIsDraggedOver(forcedImpact);if(cleaned&&cleaned!==now)if(cleaned=diff[cleaned],cleaned.subject.withPlaceholder){var added=cleaned.subject.withPlaceholder;added?void 0:invariant(!1,\"Cannot remove placeholder form subject when there was none\");(now=cleaned.frame)?((added=added.oldFrameMaxScroll)?void 0:invariant(!1,\"Expected droppable with frame to have old max frame scroll when removing placeholder\"),now=_extends({},now,{scroll:_extends({},now.scroll,{max:added})}),added=getSubject({page:cleaned.subject.page,\naxis:cleaned.axis,frame:now,withPlaceholder:null}),cleaned=_extends({},cleaned,{subject:added,frame:now})):(now=getSubject({page:cleaned.subject.page,axis:cleaned.axis,frame:null,withPlaceholder:null}),cleaned=_extends({},cleaned,{subject:now}));cleaned=patchDroppableMap(diff,cleaned)}else cleaned=diff;else cleaned=diff;(now=whatIsDraggedOver(forcedImpact))?(diff=diff[now],isHomeOf(offset,diff)||diff.subject.withPlaceholder?offset=cleaned:(offset=addPlaceholder(diff,offset,page),offset=patchDroppableMap(cleaned,\noffset))):offset=cleaned;return _extends({},state,{current:currentWindowScroll,userDirection:_ref,dimensions:{draggables:dimensions.draggables,droppables:offset},impact:forcedImpact,viewport:viewport,scrollJumpRequest:scrollJumpRequest||null,forceShouldAnimate:scrollJumpRequest?!1:null})},recompute=function(_ref){var impact=_ref.impact,viewport=_ref.viewport,destination=_ref.destination,forceShouldAnimate=_ref.forceShouldAnimate,last=impact.displaced;_ref=getDraggables$1(last.all,_ref.draggables);\nviewport=getDisplacementGroups({afterDragging:_ref,destination:destination,displacedBy:impact.displacedBy,viewport:viewport.frame,forceShouldAnimate:forceShouldAnimate,last:last});return _extends({},impact,{displaced:viewport})},getClientBorderBoxCenter=function(_ref){var draggable=_ref.draggable,viewport=_ref.viewport;_ref=getPageBorderBoxCenterFromImpact({impact:_ref.impact,draggable:draggable,draggables:_ref.draggables,droppable:_ref.droppable,afterCritical:_ref.afterCritical});return getClientFromPageBorderBoxCenter({pageBorderBoxCenter:_ref,\ndraggable:draggable,viewport:viewport})},refreshSnap=function(_ref){var state=_ref.state,forcedDimensions=_ref.dimensions;_ref=_ref.viewport;\"SNAP\"!==state.movementMode?invariant(!1):void 0;var needsVisibilityCheck=state.impact;_ref=_ref||state.viewport;forcedDimensions=forcedDimensions||state.dimensions;var draggables=forcedDimensions.draggables,droppables=forcedDimensions.droppables,draggable=draggables[state.critical.draggable.id],isOver=whatIsDraggedOver(needsVisibilityCheck);isOver?void 0:invariant(!1,\n\"Must be over a destination in SNAP movement mode\");droppables=droppables[isOver];needsVisibilityCheck=recompute({impact:needsVisibilityCheck,viewport:_ref,destination:droppables,draggables:draggables});draggables=getClientBorderBoxCenter({impact:needsVisibilityCheck,draggable:draggable,droppable:droppables,draggables:draggables,viewport:_ref,afterCritical:state.afterCritical});return update$jscomp$0({impact:needsVisibilityCheck,clientSelection:draggables,state:state,dimensions:forcedDimensions,viewport:_ref})},\ngetHomeLocation=function(descriptor){return{index:descriptor.index,droppableId:descriptor.droppableId}},getLiftEffect=function(_ref){var draggable=_ref.draggable,home=_ref.home,draggables=_ref.draggables;_ref=_ref.viewport;var displacedBy=getDisplacedBy(home.axis,draggable.displaceBy);draggables=getDraggablesInsideDroppable(home.descriptor.id,draggables);var rawIndex=draggables.indexOf(draggable);-1===rawIndex?invariant(!1,\"Expected draggable to be inside home list\"):void 0;draggables=draggables.slice(rawIndex+\n1);rawIndex=draggables.reduce(function(previous,item){previous[item.descriptor.id]=!0;return previous},{});rawIndex={inVirtualList:\"virtual\"===home.descriptor.mode,displacedBy:displacedBy,effected:rawIndex};return{impact:{displaced:getDisplacementGroups({afterDragging:draggables,destination:home,displacedBy:displacedBy,last:null,viewport:_ref.frame,forceShouldAnimate:!1}),displacedBy:displacedBy,at:{type:\"REORDER\",destination:getHomeLocation(draggable.descriptor)}},afterCritical:rawIndex}},adjustAdditionsForScrollChanges=\nfunction(_ref){var updatedDroppables=_ref.updatedDroppables,viewport=_ref.viewport,windowScrollChange=viewport.scroll.diff.value;return _ref.additions.map(function(draggable){var frame=updatedDroppables[draggable.descriptor.droppableId].frame;frame?void 0:invariant(!1,\"Expected Droppable to have a frame\");var totalChange=add(windowScrollChange,frame.scroll.diff.value);frame=viewport.scroll.initial;totalChange=cssBoxModel.offset(draggable.client,totalChange);frame=cssBoxModel.withScroll(totalChange,\nframe);return _extends({},draggable,{placeholder:_extends({},draggable.placeholder,{client:totalChange}),client:totalChange,page:frame})})},publishWhileDraggingInVirtual=function(_ref){var _extends2,_extends3,state=_ref.state;_ref=_ref.published;var withScrollChange=_ref.modified.map(function(update){return scrollDroppable(state.dimensions.droppables[update.droppableId],update.scroll)});withScrollChange=_extends({},state.dimensions.droppables,{},toDroppableMap(withScrollChange));var updatedAdditions=\ntoDraggableMap(adjustAdditionsForScrollChanges({additions:_ref.additions,updatedDroppables:withScrollChange,viewport:state.viewport})),draggables=_extends({},state.dimensions.draggables,{},updatedAdditions);_ref.removals.forEach(function(id){delete draggables[id]});_ref={droppables:withScrollChange,draggables:draggables};updatedAdditions=(withScrollChange=whatIsDraggedOver(state.impact))?_ref.droppables[withScrollChange]:null;var _getLiftEffect=getLiftEffect({draggable:_ref.draggables[state.critical.draggable.id],\nhome:_ref.droppables[state.critical.droppable.id],draggables:draggables,viewport:state.viewport});withScrollChange=_getLiftEffect.impact;_getLiftEffect=_getLiftEffect.afterCritical;updatedAdditions=getDragImpact({pageBorderBoxCenter:state.current.page.borderBoxCenter,draggable:_ref.draggables[state.critical.draggable.id],draggables:_ref.draggables,droppables:_ref.droppables,previousImpact:updatedAdditions&&updatedAdditions.isCombineEnabled?state.impact:withScrollChange,viewport:state.viewport,userDirection:state.userDirection,\nafterCritical:_getLiftEffect});_ref=_extends({phase:\"DRAGGING\"},state,(_extends2={},_extends2.phase=\"DRAGGING\",_extends2.impact=updatedAdditions,_extends2.onLiftImpact=withScrollChange,_extends2.dimensions=_ref,_extends2.afterCritical=_getLiftEffect,_extends2.forceShouldAnimate=!1,_extends2));return\"COLLECTING\"===state.phase?_ref:_extends({phase:\"DROP_PENDING\"},_ref,(_extends3={},_extends3.phase=\"DROP_PENDING\",_extends3.reason=state.reason,_extends3.isWaiting=!1,_extends3))},postDroppableChange=function(state,\nupdated,isEnabledChanging){var dimensions=state.dimensions;updated={draggables:dimensions.draggables,droppables:patchDroppableMap(dimensions.droppables,updated)};return\"SNAP\"!==state.movementMode||isEnabledChanging?update$jscomp$0({state:state,dimensions:updated}):refreshSnap({state:state,dimensions:updated})},idle={phase:\"IDLE\",completed:null,shouldFlush:!1},reducer=function(state,action){void 0===state&&(state=idle);if(\"FLUSH\"===action.type)return _extends({},idle,{shouldFlush:!0});if(\"INITIAL_PUBLISH\"===\naction.type){\"IDLE\"!==state.phase?invariant(!1,\"INITIAL_PUBLISH must come after a IDLE phase\"):void 0;var _action$payload=action.payload;state=_action$payload.critical;var viewport=_action$payload.viewport;action=_action$payload.dimensions;var movementMode=_action$payload.movementMode,draggable=action.draggables[state.draggable.id],home=action.droppables[state.droppable.id];_action$payload={selection:_action$payload.clientSelection,borderBoxCenter:draggable.client.borderBox.center,offset:origin};\n_action$payload={client:_action$payload,page:{selection:add(_action$payload.selection,viewport.scroll.initial),borderBoxCenter:add(_action$payload.selection,viewport.scroll.initial)}};var isWindowScrollAllowed=toDroppableList(action.droppables).every(function(item){return!item.isFixedOnPage});draggable=getLiftEffect({draggable:draggable,home:home,draggables:action.draggables,viewport:viewport});home=draggable.impact;return{phase:\"DRAGGING\",isDragging:!0,critical:state,movementMode:movementMode,dimensions:action,\ninitial:_action$payload,current:_action$payload,isWindowScrollAllowed:isWindowScrollAllowed,impact:home,afterCritical:draggable.afterCritical,onLiftImpact:home,viewport:viewport,userDirection:forward,scrollJumpRequest:null,forceShouldAnimate:null}}if(\"COLLECTION_STARTING\"===action.type){if(\"COLLECTING\"===state.phase||\"DROP_PENDING\"===state.phase)return state;\"DRAGGING\"!==state.phase?invariant(!1,\"Collection cannot start from phase \"+state.phase):void 0;return _extends({phase:\"COLLECTING\"},state,(movementMode=\n{},movementMode.phase=\"COLLECTING\",movementMode))}if(\"PUBLISH_WHILE_DRAGGING\"===action.type)return\"COLLECTING\"!==state.phase&&\"DROP_PENDING\"!==state.phase?invariant(!1,\"Unexpected \"+action.type+\" received in phase \"+state.phase):void 0,publishWhileDraggingInVirtual({state:state,published:action.payload});if(\"MOVE\"===action.type){if(\"DROP_PENDING\"===state.phase)return state;isMovementAllowed(state)?void 0:invariant(!1,action.type+\" not permitted in phase \"+state.phase);viewport=action.payload.client;\nreturn isEqual(viewport,state.current.client.selection)?state:update$jscomp$0({state:state,clientSelection:viewport,impact:\"SNAP\"===state.movementMode?state.impact:null})}if(\"UPDATE_DROPPABLE_SCROLL\"===action.type){if(\"DROP_PENDING\"===state.phase||\"COLLECTING\"===state.phase)return removeScrollJumpRequest(state);isMovementAllowed(state)?void 0:invariant(!1,action.type+\" not permitted in phase \"+state.phase);viewport=action.payload;action=state.dimensions.droppables[viewport.id];if(!action)return state;\nviewport=scrollDroppable(action,viewport.newScroll);return postDroppableChange(state,viewport,!1)}if(\"UPDATE_DROPPABLE_IS_ENABLED\"===action.type){if(\"DROP_PENDING\"===state.phase)return state;isMovementAllowed(state)?void 0:invariant(!1,\"Attempting to move in an unsupported phase \"+state.phase);action=action.payload;viewport=action.id;action=action.isEnabled;(movementMode=state.dimensions.droppables[viewport])?void 0:invariant(!1,\"Cannot find Droppable[id: \"+viewport+\"] to toggle its enabled state\");\nmovementMode.isEnabled===action?invariant(!1,\"Trying to set droppable isEnabled to \"+String(action)+\"\\n      but it is already \"+String(movementMode.isEnabled)):void 0;viewport=_extends({},movementMode,{isEnabled:action});return postDroppableChange(state,viewport,!0)}if(\"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\"===action.type){if(\"DROP_PENDING\"===state.phase)return state;isMovementAllowed(state)?void 0:invariant(!1,\"Attempting to move in an unsupported phase \"+state.phase);action=action.payload;viewport=\naction.id;action=action.isCombineEnabled;(movementMode=state.dimensions.droppables[viewport])?void 0:invariant(!1,\"Cannot find Droppable[id: \"+viewport+\"] to toggle its isCombineEnabled state\");movementMode.isCombineEnabled===action?invariant(!1,\"Trying to set droppable isCombineEnabled to \"+String(action)+\"\\n      but it is already \"+String(movementMode.isCombineEnabled)):void 0;viewport=_extends({},movementMode,{isCombineEnabled:action});return postDroppableChange(state,viewport,!0)}if(\"MOVE_BY_WINDOW_SCROLL\"===\naction.type){if(\"DROP_PENDING\"===state.phase||\"DROP_ANIMATING\"===state.phase)return state;isMovementAllowed(state)?void 0:invariant(!1,\"Cannot move by window in phase \"+state.phase);state.isWindowScrollAllowed?void 0:invariant(!1,\"Window scrolling is currently not supported for fixed lists\");viewport=action.payload.newScroll;if(isEqual(state.viewport.scroll.current,viewport))return removeScrollJumpRequest(state);viewport=scrollViewport(state.viewport,viewport);return\"SNAP\"===state.movementMode?refreshSnap({state:state,\nviewport:viewport}):update$jscomp$0({state:state,viewport:viewport})}if(\"UPDATE_VIEWPORT_MAX_SCROLL\"===action.type){if(!isMovementAllowed(state))return state;viewport=action.payload.maxScroll;if(isEqual(viewport,state.viewport.scroll.max))return state;viewport=_extends({},state.viewport,{scroll:_extends({},state.viewport.scroll,{max:viewport})});return _extends({phase:\"DRAGGING\"},state,{viewport:viewport})}if(\"MOVE_UP\"===action.type||\"MOVE_DOWN\"===action.type||\"MOVE_LEFT\"===action.type||\"MOVE_RIGHT\"===\naction.type){if(\"COLLECTING\"===state.phase||\"DROP_PENDING\"===state.phase)return state;\"DRAGGING\"!==state.phase?invariant(!1,action.type+\" received while not in DRAGGING phase\"):void 0;return(viewport=moveInDirection({state:state,type:action.type}))?update$jscomp$0({state:state,impact:viewport.impact,clientSelection:viewport.clientSelection,scrollJumpRequest:viewport.scrollJumpRequest}):state}return\"DROP_PENDING\"===action.type?(action=action.payload.reason,\"COLLECTING\"!==state.phase?invariant(!1,\"Can only move into the DROP_PENDING phase from the COLLECTING phase\"):\nvoid 0,_extends({phase:\"DROP_PENDING\"},state,(viewport={},viewport.phase=\"DROP_PENDING\",viewport.isWaiting=!0,viewport.reason=action,viewport))):\"DROP_ANIMATE\"===action.type?(movementMode=action.payload,viewport=movementMode.completed,action=movementMode.dropDuration,movementMode=movementMode.newHomeClientOffset,\"DRAGGING\"!==state.phase&&\"DROP_PENDING\"!==state.phase?invariant(!1,\"Cannot animate drop from phase \"+state.phase):void 0,{phase:\"DROP_ANIMATING\",completed:viewport,dropDuration:action,newHomeClientOffset:movementMode,\ndimensions:state.dimensions}):\"DROP_COMPLETE\"===action.type?{phase:\"IDLE\",completed:action.payload.completed,shouldFlush:!1}:state},publishWhileDragging=function(args){return{type:\"PUBLISH_WHILE_DRAGGING\",payload:args}},collectionStarting=function(){return{type:\"COLLECTION_STARTING\",payload:null}},updateDroppableScroll=function(args){return{type:\"UPDATE_DROPPABLE_SCROLL\",payload:args}},updateDroppableIsEnabled=function(args){return{type:\"UPDATE_DROPPABLE_IS_ENABLED\",payload:args}},updateDroppableIsCombineEnabled=\nfunction(args){return{type:\"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\",payload:args}},move$jscomp$0=function(args){return{type:\"MOVE\",payload:args}},moveUp=function(){return{type:\"MOVE_UP\",payload:null}},moveDown=function(){return{type:\"MOVE_DOWN\",payload:null}},moveRight=function(){return{type:\"MOVE_RIGHT\",payload:null}},moveLeft=function(){return{type:\"MOVE_LEFT\",payload:null}},completeDrop=function(args){return{type:\"DROP_COMPLETE\",payload:args}},dropAnimationFinished=function(){return{type:\"DROP_ANIMATION_FINISHED\",\npayload:null}},lift$1=function(marshal){return function(_ref){var getState=_ref.getState,dispatch=_ref.dispatch;return function(next){return function(action){if(\"LIFT\"!==action.type)next(action);else{var _action$payload=action.payload,id=_action$payload.id;action=_action$payload.clientSelection;_action$payload=_action$payload.movementMode;var initial=getState();\"DROP_ANIMATING\"===initial.phase&&dispatch(completeDrop({completed:initial.completed}));\"IDLE\"!==getState().phase?invariant(!1,\"Unexpected phase to start a drag\"):\nvoid 0;dispatch({type:\"FLUSH\",payload:null});var _marshal$startPublish=marshal.startPublishing({draggableId:id,scrollOptions:{shouldPublishImmediately:\"SNAP\"===_action$payload}});id=_marshal$startPublish.critical;initial=_marshal$startPublish.dimensions;_marshal$startPublish=_marshal$startPublish.viewport;var insideDestination=getDraggablesInsideDroppable(id.droppable.id,initial.draggables);checkIndexes(insideDestination);dispatch({type:\"INITIAL_PUBLISH\",payload:{critical:id,dimensions:initial,clientSelection:action,\nmovementMode:_action$payload,viewport:_marshal$startPublish}})}}}}},style$jscomp$0=function(marshal){return function(){return function(next){return function(action){\"INITIAL_PUBLISH\"===action.type&&marshal.dragging();\"DROP_ANIMATE\"===action.type&&marshal.dropping(action.payload.completed.result.reason);\"FLUSH\"!==action.type&&\"DROP_COMPLETE\"!==action.type||marshal.resting();next(action)}}}},curves={outOfTheWay:\"cubic-bezier(0.2, 0, 0, 1)\",drop:\"cubic-bezier(.2,1,.1,1)\"},combine={opacity:{drop:0,combining:.7},\nscale:{drop:.75}},outOfTheWayTiming=\"0.2s \"+curves.outOfTheWay,transitions={fluid:\"opacity \"+outOfTheWayTiming,snap:\"transform \"+outOfTheWayTiming+\", opacity \"+outOfTheWayTiming,drop:function(duration){duration=duration+\"s \"+curves.drop;return\"transform \"+duration+\", opacity \"+duration},outOfTheWay:\"transform \"+outOfTheWayTiming,placeholder:\"height \"+outOfTheWayTiming+\", width \"+outOfTheWayTiming+\", margin \"+outOfTheWayTiming},moveTo=function(offset){return isEqual(offset,origin)?null:\"translate(\"+\noffset.x+\"px, \"+offset.y+\"px)\"},transforms={moveTo:moveTo,drop:function(offset,isCombining){return(offset=moveTo(offset))?isCombining?offset+\" scale(\"+combine.scale.drop+\")\":offset:null}},dropTimeRange=.55-.33,drop$1=function(_ref){var getState=_ref.getState,dispatch=_ref.dispatch;return function(next){return function(action){if(\"DROP\"!==action.type)next(action);else{var state=getState();action=action.payload.reason;if(\"COLLECTING\"===state.phase)dispatch({type:\"DROP_PENDING\",payload:{reason:action}});\nelse if(\"IDLE\"!==state.phase){\"DROP_PENDING\"===state.phase&&state.isWaiting?invariant(!1,\"A DROP action occurred while DROP_PENDING and still waiting\"):void 0;\"DRAGGING\"!==state.phase&&\"DROP_PENDING\"!==state.phase?invariant(!1,\"Cannot drop in phase: \"+state.phase):void 0;var critical=state.critical,dimensions=state.dimensions,draggable=dimensions.draggables[state.critical.draggable.id];var JSCompiler_object_inline_impact_1572=state.dimensions.draggables;var JSCompiler_object_inline_didDropInsideDroppable_1573=\nstate.impact;var home=state.dimensions.droppables[state.critical.droppable.id],viewport=state.viewport,onLiftImpact=state.onLiftImpact;JSCompiler_object_inline_didDropInsideDroppable_1573.at&&\"DROP\"===action?(JSCompiler_object_inline_impact_1572=\"REORDER\"===JSCompiler_object_inline_didDropInsideDroppable_1573.at.type?JSCompiler_object_inline_didDropInsideDroppable_1573:_extends({},JSCompiler_object_inline_didDropInsideDroppable_1573,{displaced:emptyGroups}),JSCompiler_object_inline_didDropInsideDroppable_1573=\n!0):(JSCompiler_object_inline_impact_1572=recompute({draggables:JSCompiler_object_inline_impact_1572,impact:onLiftImpact,destination:home,viewport:viewport,forceShouldAnimate:!0}),JSCompiler_object_inline_didDropInsideDroppable_1573=!1);JSCompiler_object_inline_didDropInsideDroppable_1573=(home=JSCompiler_object_inline_didDropInsideDroppable_1573)?tryGetDestination(JSCompiler_object_inline_impact_1572):null;home=home?tryGetCombine(JSCompiler_object_inline_impact_1572):null;critical={draggableId:draggable.descriptor.id,\ntype:draggable.descriptor.type,source:{index:critical.draggable.index,droppableId:critical.droppable.id},reason:action,mode:state.movementMode,destination:JSCompiler_object_inline_didDropInsideDroppable_1573,combine:home};JSCompiler_object_inline_didDropInsideDroppable_1573=state.viewport;home=state.afterCritical;viewport=dimensions.draggables;dimensions=dimensions.droppables;onLiftImpact=whatIsDraggedOver(JSCompiler_object_inline_impact_1572);var home$jscomp$0=dimensions[draggable.descriptor.droppableId];\ndimensions=getClientBorderBoxCenter({impact:JSCompiler_object_inline_impact_1572,draggable:draggable,draggables:viewport,afterCritical:home,droppable:(onLiftImpact?dimensions[onLiftImpact]:null)||home$jscomp$0,viewport:JSCompiler_object_inline_didDropInsideDroppable_1573});draggable=subtract(dimensions,draggable.client.borderBox.center);dimensions={critical:state.critical,afterCritical:state.afterCritical,result:critical,impact:JSCompiler_object_inline_impact_1572};isEqual(state.current.client.offset,\ndraggable)&&!critical.combine?dispatch(completeDrop({completed:dimensions})):(state=distance(state.current.client.offset,draggable),0>=state?action=.33:1500<=state?action=.55:(state=.33+state/1500*dropTimeRange,action=Number((\"CANCEL\"===action?.6*state:state).toFixed(2))),dispatch({type:\"DROP_ANIMATE\",payload:{newHomeClientOffset:draggable,dropDuration:action,completed:dimensions}}))}}}}},scrollListener=function(store){var listener=getScrollListener({onWindowScroll:function(newScroll){store.dispatch({type:\"MOVE_BY_WINDOW_SCROLL\",\npayload:{newScroll:newScroll}})}});return function(next){return function(action){listener.isActive()||\"INITIAL_PUBLISH\"!==action.type||listener.start();!listener.isActive()||\"DROP_COMPLETE\"!==action.type&&\"DROP_ANIMATE\"!==action.type&&\"FLUSH\"!==action.type||listener.stop();next(action)}}},getExpiringAnnounce=function(announce){var wasCalled=!1,isExpired=!1,timeoutId=setTimeout(function(){isExpired=!0}),result=function(message){wasCalled?warning(\"Announcement already made. Not making a second announcement\"):\nisExpired?warning(\"\\n        Announcements cannot be made asynchronously.\\n        Default message has already been announced.\\n      \"):(wasCalled=!0,announce(message),clearTimeout(timeoutId))};result.wasCalled=function(){return wasCalled};return result},getAsyncMarshal=function(){var entries=[],execute=function(timerId){var index=findIndex(entries,function(item){return item.timerId===timerId});-1===index?invariant(!1,\"Could not find timer\"):void 0;entries.splice(index,1)[0].callback()};return{add:function(fn){var timerId=\nsetTimeout(function(){return execute(timerId)});entries.push({timerId:timerId,callback:fn})},flush:function(){if(entries.length){var shallow=[].concat(entries);entries.length=0;shallow.forEach(function(entry){clearTimeout(entry.timerId);entry.callback()})}}}},areLocationsEqual=function(first,second){return null==first&&null==second?!0:null==first||null==second?!1:first.droppableId===second.droppableId&&first.index===second.index},isCombineEqual=function(first,second){return null==first&&null==second?\n!0:null==first||null==second?!1:first.draggableId===second.draggableId&&first.droppableId===second.droppableId},isCriticalEqual=function(first,second){if(first===second)return!0;var isDroppableEqual=first.droppable.id===second.droppable.id&&first.droppable.type===second.droppable.type;return first.draggable.id===second.draggable.id&&first.draggable.droppableId===second.draggable.droppableId&&first.draggable.type===second.draggable.type&&first.draggable.index===second.draggable.index&&isDroppableEqual},\nwithTimings=function(key,fn){fn()},getDragStart=function(critical,mode){return{draggableId:critical.draggable.id,type:critical.droppable.type,source:{droppableId:critical.droppable.id,index:critical.draggable.index},mode:mode}},execute=function(responder,data,announce,getDefaultMessage){if(responder){var willExpire=getExpiringAnnounce(announce);responder(data,{announce:willExpire});willExpire.wasCalled()||announce(getDefaultMessage(data))}else announce(getDefaultMessage(data))},getPublisher=function(getResponders,\nannounce){var asyncMarshal=getAsyncMarshal(),dragging=null,drop=function(result){dragging?void 0:invariant(!1,\"Cannot fire onDragEnd when there is no matching onDragStart\");dragging=null;withTimings(\"onDragEnd\",function(){return execute(getResponders().onDragEnd,result,announce,JSCompiler_object_inline_onDragEnd_1613)})};return{beforeStart:function(critical,mode){dragging?invariant(!1,\"Cannot fire onBeforeDragStart as a drag start has already been published\"):void 0;withTimings(\"onBeforeDragStart\",\nfunction(){var fn=getResponders().onBeforeDragStart;fn&&fn(getDragStart(critical,mode))})},start:function(critical,mode){dragging?invariant(!1,\"Cannot fire onBeforeDragStart as a drag start has already been published\"):void 0;var data=getDragStart(critical,mode);dragging={mode:mode,lastCritical:critical,lastLocation:data.source,lastCombine:null};asyncMarshal.add(function(){withTimings(\"onDragStart\",function(){return execute(getResponders().onDragStart,data,announce,JSCompiler_object_inline_onDragStart_1611)})})},\nupdate:function(critical,impact){var location=tryGetDestination(impact);impact=tryGetCombine(impact);dragging?void 0:invariant(!1,\"Cannot fire onDragMove when onDragStart has not been called\");var hasCriticalChanged=!isCriticalEqual(critical,dragging.lastCritical);hasCriticalChanged&&(dragging.lastCritical=critical);var hasLocationChanged=!areLocationsEqual(dragging.lastLocation,location);hasLocationChanged&&(dragging.lastLocation=location);var hasGroupingChanged=!isCombineEqual(dragging.lastCombine,\nimpact);hasGroupingChanged&&(dragging.lastCombine=impact);if(hasCriticalChanged||hasLocationChanged||hasGroupingChanged){var data=_extends({},getDragStart(critical,dragging.mode),{combine:impact,destination:location});asyncMarshal.add(function(){withTimings(\"onDragUpdate\",function(){return execute(getResponders().onDragUpdate,data,announce,JSCompiler_object_inline_onDragUpdate_1612)})})}},flush:function(){dragging?void 0:invariant(!1,\"Can only flush responders while dragging\");asyncMarshal.flush()},\ndrop:drop,abort:function(){if(dragging){var result=_extends({},getDragStart(dragging.lastCritical,dragging.mode),{combine:null,destination:null,reason:\"CANCEL\"});drop(result)}}}},responders=function(getResponders,announce){var publisher=getPublisher(getResponders,announce);return function(store){return function(next){return function(action){if(\"INITIAL_PUBLISH\"===action.type){var critical=action.payload.critical;publisher.beforeStart(critical,action.payload.movementMode);next(action);publisher.start(critical,\naction.payload.movementMode)}else\"DROP_COMPLETE\"===action.type?(critical=action.payload.completed.result,publisher.flush(),next(action),publisher.drop(critical)):(next(action),\"FLUSH\"===action.type?publisher.abort():(action=store.getState(),\"DRAGGING\"===action.phase&&publisher.update(action.critical,action.impact)))}}}},dropAnimationFinish=function(store){return function(next){return function(action){\"DROP_ANIMATION_FINISHED\"!==action.type?next(action):(action=store.getState(),\"DROP_ANIMATING\"!==\naction.phase?invariant(!1,\"Cannot finish a drop animating when no drop is occurring\"):void 0,store.dispatch(completeDrop({completed:action.completed})))}}},dropAnimationFlushOnScroll=function(store){var unbind=null,frameId=null;return function(next){return function(action){if(\"FLUSH\"===action.type||\"DROP_COMPLETE\"===action.type||\"DROP_ANIMATION_FINISHED\"===action.type)frameId&&(cancelAnimationFrame(frameId),frameId=null),unbind&&(unbind(),unbind=null);next(action);if(\"DROP_ANIMATE\"===action.type){var binding=\n{eventName:\"scroll\",options:{capture:!0,passive:!1,once:!0},fn:function(){\"DROP_ANIMATING\"===store.getState().phase&&store.dispatch(dropAnimationFinished())}};frameId=requestAnimationFrame(function(){frameId=null;unbind=bindEvents(window,[binding])})}}}},dimensionMarshalStopper=function(marshal){return function(){return function(next){return function(action){\"DROP_COMPLETE\"!==action.type&&\"FLUSH\"!==action.type&&\"DROP_ANIMATE\"!==action.type||marshal.stopPublishing();next(action)}}}},focus=function(marshal){var isWatching=\n!1;return function(){return function(next){return function(action){\"INITIAL_PUBLISH\"===action.type?(isWatching=!0,marshal.tryRecordFocus(action.payload.critical.draggable.id),next(action),marshal.tryRestoreFocusRecorded()):(next(action),isWatching&&(\"FLUSH\"===action.type?(isWatching=!1,marshal.tryRestoreFocusRecorded()):\"DROP_COMPLETE\"===action.type&&(isWatching=!1,action=action.payload.completed.result,action.combine&&marshal.tryShiftRecord(action.draggableId,action.combine.draggableId),marshal.tryRestoreFocusRecorded())))}}}},\nautoScroll=function(autoScroller){return function(store){return function(next){return function(action){\"DROP_COMPLETE\"===action.type||\"DROP_ANIMATE\"===action.type||\"FLUSH\"===action.type?(autoScroller.stop(),next(action)):\"INITIAL_PUBLISH\"===action.type?(next(action),action=store.getState(),\"DRAGGING\"!==action.phase?invariant(!1,\"Expected phase to be DRAGGING after INITIAL_PUBLISH\"):void 0,autoScroller.start(action)):(next(action),autoScroller.scroll(store.getState()))}}}},pendingDrop=function(store){return function(next){return function(action){next(action);\n\"PUBLISH_WHILE_DRAGGING\"===action.type&&(action=store.getState(),\"DROP_PENDING\"===action.phase&&(action.isWaiting||store.dispatch({type:\"DROP\",payload:{reason:action.reason}})))}}},composeEnhancers=\"undefined\"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:redux.compose,clean$1=function(){return{additions:{},removals:{},modified:{}}},getMaxScroll=function(_ref){_ref=subtract({x:_ref.scrollWidth,y:_ref.scrollHeight},{x:_ref.width,y:_ref.height});\nreturn{x:Math.max(0,_ref.x),y:Math.max(0,_ref.y)}},getDocumentElement=function(){var doc=document.documentElement;doc?void 0:invariant(!1,\"Cannot find document.documentElement\");return doc},getMaxWindowScroll=function(){var doc=getDocumentElement();return getMaxScroll({scrollHeight:doc.scrollHeight,scrollWidth:doc.scrollWidth,width:doc.clientWidth,height:doc.clientHeight})},getViewport=function(){var scroll={x:window.pageXOffset,y:window.pageYOffset},maxScroll=getMaxWindowScroll(),top=scroll.y,left=\nscroll.x,doc=getDocumentElement();return{frame:cssBoxModel.getRect({top:top,left:left,right:left+doc.clientWidth,bottom:top+doc.clientHeight}),scroll:{initial:scroll,current:scroll,max:maxScroll,diff:{value:origin,displacement:origin}}}},getInitialPublish=function(_ref){var critical=_ref.critical,scrollOptions=_ref.scrollOptions,registry=_ref.registry;_ref=getViewport();var windowScroll=_ref.scroll.current,droppables=registry.droppable.getAllByType(critical.droppable.type).map(function(entry){return entry.callbacks.getDimensionAndWatchScroll(windowScroll,\nscrollOptions)});registry=registry.draggable.getAllByType(critical.draggable.type).map(function(entry){return entry.getDimension(windowScroll)});return{dimensions:{draggables:toDraggableMap(registry),droppables:toDroppableMap(droppables)},critical:critical,viewport:_ref}},createDimensionMarshal=function(registry,callbacks){var collection=null,publisher=createPublisher({callbacks:{publish:callbacks.publishWhileDragging,collectionStarting:callbacks.collectionStarting},registry:registry}),subscriber=\nfunction(event){collection?void 0:invariant(!1,\"Should only be subscribed when a collection is occurring\");var dragging=collection.critical.draggable;\"ADDITION\"===event.type&&shouldPublishUpdate(registry,dragging,event.value)&&publisher.add(event.value);\"REMOVAL\"===event.type&&shouldPublishUpdate(registry,dragging,event.value)&&publisher.remove(event.value)};return{updateDroppableIsEnabled:function(id,isEnabled){registry.droppable.exists(id)?void 0:invariant(!1,\"Cannot update is enabled flag of Droppable \"+\nid+\" as it is not registered\");collection&&callbacks.updateDroppableIsEnabled({id:id,isEnabled:isEnabled})},updateDroppableIsCombineEnabled:function(id,isCombineEnabled){collection&&(registry.droppable.exists(id)?void 0:invariant(!1,\"Cannot update isCombineEnabled flag of Droppable \"+id+\" as it is not registered\"),callbacks.updateDroppableIsCombineEnabled({id:id,isCombineEnabled:isCombineEnabled}))},scrollDroppable:function(id,change){collection&&registry.droppable.getById(id).callbacks.scroll(change)},\nupdateDroppableScroll:function(id,newScroll){collection&&(registry.droppable.exists(id)?void 0:invariant(!1,\"Cannot update the scroll on Droppable \"+id+\" as it is not registered\"),callbacks.updateDroppableScroll({id:id,newScroll:newScroll}))},startPublishing:function(request){collection?invariant(!1,\"Cannot start capturing critical dimensions as there is already a collection\"):void 0;var entry=registry.draggable.getById(request.draggableId),home=registry.droppable.getById(entry.descriptor.droppableId);\nentry={draggable:entry.descriptor,droppable:home.descriptor};home=registry.subscribe(subscriber);collection={critical:entry,unsubscribe:home};return getInitialPublish({critical:entry,registry:registry,scrollOptions:request.scrollOptions})},stopPublishing:function(){collection&&(publisher.stop(),registry.droppable.getAllByType(collection.critical.droppable.type).forEach(function(entry){return entry.callbacks.dragStopped()}),collection.unsubscribe(),collection=null)}}},canStartDrag=function(state,id){return\"IDLE\"===\nstate.phase?!0:\"DROP_ANIMATING\"!==state.phase||state.completed.result.draggableId===id?!1:\"DROP\"===state.completed.result.reason},scrollWindow=function(change){window.scrollBy(change.x,change.y)},getScrollableDroppables=memoizeOne(function(droppables){return toDroppableList(droppables).filter(function(droppable){return droppable.isEnabled&&droppable.frame?!0:!1})}),getScrollableDroppableOver=function(target,droppables){return find(getScrollableDroppables(droppables),function(droppable){droppable.frame?\nvoid 0:invariant(!1,\"Invalid result\");return isPositionInFrame(droppable.frame.pageMarginBox)(target)})},config={startFromPercentage:.25,maxScrollAtPercentage:.05,maxPixelScroll:28,ease:function(percentage){return Math.pow(percentage,2)},durationDampening:{stopDampeningAt:1200,accelerateAt:360}},getPercentage=function(_ref){var startOfRange=_ref.startOfRange,current=_ref.current;_ref=_ref.endOfRange-startOfRange;return 0===_ref?(warning(\"\\n      Detected distance range of 0 in the fluid auto scroller\\n      This is unexpected and would cause a divide by 0 issue.\\n      Not allowing an auto scroll\\n    \"),\n0):(current-startOfRange)/_ref},getValueFromDistance=function(distanceToEdge,thresholds){if(distanceToEdge>thresholds.startScrollingFrom)return 0;if(distanceToEdge<=thresholds.maxScrollValueAt)return config.maxPixelScroll;if(distanceToEdge===thresholds.startScrollingFrom)return 1;distanceToEdge=getPercentage({startOfRange:thresholds.maxScrollValueAt,endOfRange:thresholds.startScrollingFrom,current:distanceToEdge});distanceToEdge=config.maxPixelScroll*config.ease(1-distanceToEdge);return Math.ceil(distanceToEdge)},\naccelerateAt=config.durationDampening.accelerateAt,stopAt=config.durationDampening.stopDampeningAt,dampenValueByTime=function(proposedScroll,dragStartTime){dragStartTime=_Date$now()-dragStartTime;if(dragStartTime>=stopAt)return proposedScroll;if(dragStartTime<accelerateAt)return 1;dragStartTime=getPercentage({startOfRange:accelerateAt,endOfRange:stopAt,current:dragStartTime});proposedScroll*=config.ease(dragStartTime);return Math.ceil(proposedScroll)},getValue=function(_ref){var dragStartTime=_ref.dragStartTime,\nshouldUseTimeDampening=_ref.shouldUseTimeDampening;_ref=getValueFromDistance(_ref.distanceToEdge,_ref.thresholds);return 0===_ref?0:shouldUseTimeDampening?Math.max(dampenValueByTime(_ref,dragStartTime),1):_ref},getScrollOnAxis=function(_ref){var container=_ref.container,distanceToEdges=_ref.distanceToEdges,dragStartTime=_ref.dragStartTime,axis=_ref.axis;_ref=_ref.shouldUseTimeDampening;container={startScrollingFrom:container[axis.size]*config.startFromPercentage,maxScrollValueAt:container[axis.size]*\nconfig.maxScrollAtPercentage};return distanceToEdges[axis.end]<distanceToEdges[axis.start]?getValue({distanceToEdge:distanceToEdges[axis.end],thresholds:container,dragStartTime:dragStartTime,shouldUseTimeDampening:_ref}):-1*getValue({distanceToEdge:distanceToEdges[axis.start],thresholds:container,dragStartTime:dragStartTime,shouldUseTimeDampening:_ref})},clean$2=apply(function(value){return 0===value?0:value}),getScroll=function(_ref){var dragStartTime=_ref.dragStartTime,container=_ref.container,\nsubject=_ref.subject,center=_ref.center;_ref=_ref.shouldUseTimeDampening;var distanceToEdges={top:center.y-container.top,right:container.right-center.x,bottom:container.bottom-center.y,left:center.x-container.left};center=getScrollOnAxis({container:container,distanceToEdges:distanceToEdges,dragStartTime:dragStartTime,axis:vertical,shouldUseTimeDampening:_ref});dragStartTime=getScrollOnAxis({container:container,distanceToEdges:distanceToEdges,dragStartTime:dragStartTime,axis:horizontal,shouldUseTimeDampening:_ref});\ndragStartTime=clean$2({x:dragStartTime,y:center});if(isEqual(dragStartTime,origin))return null;_ref=subject.height>container.height;container=(container=subject.width>container.width)||_ref?container&&_ref?null:{x:container?0:dragStartTime.x,y:_ref?0:dragStartTime.y}:dragStartTime;return container?isEqual(container,origin)?null:container:null},smallestSigned=apply(function(value){return 0===value?0:0<value?1:-1}),getOverlap=function(){var getRemainder=function(target,max){return 0>target?target:target>\nmax?target-max:0};return function(_ref){var max=_ref.max;_ref=add(_ref.current,_ref.change);max={x:getRemainder(_ref.x,max.x),y:getRemainder(_ref.y,max.y)};return isEqual(max,origin)?null:max}}(),canPartiallyScroll=function(_ref2){var rawMax=_ref2.max,current=_ref2.current;rawMax={x:Math.max(current.x,rawMax.x),y:Math.max(current.y,rawMax.y)};_ref2=smallestSigned(_ref2.change);current=getOverlap({max:rawMax,current:current,change:_ref2});return!current||0!==_ref2.x&&0===current.x||0!==_ref2.y&&0===\ncurrent.y?!0:!1},canScrollWindow=function(viewport,change){return canPartiallyScroll({current:viewport.scroll.current,max:viewport.scroll.max,change:change})},canScrollDroppable=function(droppable,change){return(droppable=droppable.frame)?canPartiallyScroll({current:droppable.scroll.current,max:droppable.scroll.max,change:change}):!1},scroll$1=function(_ref){var state=_ref.state,dragStartTime=_ref.dragStartTime,shouldUseTimeDampening=_ref.shouldUseTimeDampening,scrollWindow=_ref.scrollWindow;_ref=\n_ref.scrollDroppable;var center=state.current.page.borderBoxCenter,subject=state.dimensions.draggables[state.critical.draggable.id].page.marginBox;if(state.isWindowScrollAllowed){var _change=state.viewport;var scroll=getScroll({dragStartTime:dragStartTime,container:_change.frame,subject:subject,center:center,shouldUseTimeDampening:shouldUseTimeDampening});if(_change=scroll&&canScrollWindow(_change,scroll)?scroll:null){scrollWindow(_change);return}}scrollWindow=whatIsDraggedOver(state.impact);state=\nstate.dimensions.droppables;scrollWindow?(state=state[scrollWindow],state=state.frame?state:null):state=getScrollableDroppableOver(center,state);state&&(scrollWindow=state,dragStartTime=(_change=scrollWindow.frame)?(dragStartTime=getScroll({dragStartTime:dragStartTime,container:_change.pageMarginBox,subject:subject,center:center,shouldUseTimeDampening:shouldUseTimeDampening}))&&canScrollDroppable(scrollWindow,dragStartTime)?dragStartTime:null:null,dragStartTime&&_ref(state.descriptor.id,dragStartTime))},\ncreateFluidScroller=function(_ref){var scrollDroppable=_ref.scrollDroppable,scheduleWindowScroll=rafSchd(_ref.scrollWindow),scheduleDroppableScroll=rafSchd(scrollDroppable),dragging=null,tryScroll=function(state){dragging?void 0:invariant(!1,\"Cannot fluid scroll if not dragging\");var _dragging=dragging;scroll$1({state:state,scrollWindow:scheduleWindowScroll,scrollDroppable:scheduleDroppableScroll,dragStartTime:_dragging.dragStartTime,shouldUseTimeDampening:_dragging.shouldUseTimeDampening})};return{start:function(state){dragging?\ninvariant(!1,\"Cannot start auto scrolling when already started\"):void 0;var dragStartTime=_Date$now(),wasScrollNeeded=!1,fakeScrollCallback=function(){wasScrollNeeded=!0};scroll$1({state:state,dragStartTime:0,shouldUseTimeDampening:!1,scrollWindow:fakeScrollCallback,scrollDroppable:fakeScrollCallback});dragging={dragStartTime:dragStartTime,shouldUseTimeDampening:wasScrollNeeded};wasScrollNeeded&&tryScroll(state)},stop:function(){dragging&&(scheduleWindowScroll.cancel(),scheduleDroppableScroll.cancel(),\ndragging=null)},scroll:tryScroll}},createJumpScroller=function(_ref){var move=_ref.move,scrollDroppable=_ref.scrollDroppable,scrollWindow=_ref.scrollWindow;return function(state){var request=state.scrollJumpRequest;if(request){var destination=whatIsDraggedOver(state.impact);destination?void 0:invariant(!1,\"Cannot perform a jump scroll when there is no destination\");destination=state.dimensions.droppables[destination];if(canScrollDroppable(destination,request)){var overlap;(overlap=(overlap=destination.frame)&&\ncanScrollDroppable(destination,request)?getOverlap({current:overlap.scroll.current,max:overlap.scroll.max,change:request}):null)?(overlap=subtract(request,overlap),scrollDroppable(destination.descriptor.id,overlap),request=subtract(request,overlap)):(scrollDroppable(destination.descriptor.id,request),request=null)}request&&(destination=state.viewport,state.isWindowScrollAllowed&&canScrollWindow(destination,request)&&((destination=canScrollWindow(destination,request)?getOverlap({current:destination.scroll.current,\nmax:destination.scroll.max,change:request}):null)?(destination=subtract(request,destination),scrollWindow(destination),request=subtract(request,destination)):(scrollWindow(request),request=null)),request&&(state=add(state.current.client.selection,request),move({client:state})))}}},createAutoScroller=function(_ref){var scrollDroppable=_ref.scrollDroppable,scrollWindow=_ref.scrollWindow;_ref=_ref.move;var fluidScroller=createFluidScroller({scrollWindow:scrollWindow,scrollDroppable:scrollDroppable}),\njumpScroll=createJumpScroller({move:_ref,scrollWindow:scrollWindow,scrollDroppable:scrollDroppable});return{scroll:function(state){\"DRAGGING\"===state.phase&&(\"FLUID\"===state.movementMode?fluidScroller.scroll(state):state.scrollJumpRequest&&jumpScroll(state))},start:fluidScroller.start,stop:fluidScroller.stop}},dragHandle={base:\"data-rbd-drag-handle\",draggableId:\"data-rbd-drag-handle-draggable-id\",contextId:\"data-rbd-drag-handle-context-id\"},draggable={base:\"data-rbd-draggable\",contextId:\"data-rbd-draggable-context-id\",\nid:\"data-rbd-draggable-id\"},JSCompiler_object_inline_contextId_2789=\"data-rbd-droppable-context-id\",scrollContainer={contextId:\"data-rbd-scroll-container-context-id\"},makeGetSelector=function(context){return function(attribute){return\"[\"+attribute+'\\x3d\"'+context+'\"]'}},getStyles=function(rules,property){return rules.map(function(rule){var value=rule.styles[property];return value?rule.selector+\" { \"+value+\" }\":\"\"}).join(\" \")},useIsomorphicLayoutEffect=\"undefined\"!==typeof window?React.useLayoutEffect:\nReact.useEffect,getHead=function(){var head=document.querySelector(\"head\");head?void 0:invariant(!1,\"Cannot find the head to append a style to\");return head},createStyleEl=function(nonce){var el=document.createElement(\"style\");nonce&&el.setAttribute(\"nonce\",nonce);el.type=\"text/css\";return el},StoreContext=React__default.createContext(null),getBodyElement=function(){var body=document.body;body?void 0:invariant(!1,\"Cannot find document.body\");return body},visuallyHidden={position:\"absolute\",width:\"1px\",\nheight:\"1px\",margin:\"-1px\",border:\"0\",padding:\"0\",overflow:\"hidden\",clip:\"rect(0 0 0 0)\",\"clip-path\":\"inset(100%)\"},AppContext=React__default.createContext(null),peerDependencies={react:\"^16.8.5\",\"react-dom\":\"^16.8.5\"},semver=/(\\d+)\\.(\\d+)\\.(\\d+)/,getVersion=function(value){var result=semver.exec(value);null==result?invariant(!1,\"Unable to parse React version \"+value):void 0;return{major:Number(result[1]),minor:Number(result[2]),patch:Number(result[3]),raw:value}},_preventedKeys,preventedKeys=(_preventedKeys=\n{},_preventedKeys[13]=!0,_preventedKeys[9]=!0,_preventedKeys),supportedEventName=function(){return\"undefined\"===typeof document?\"visibilitychange\":find([\"visibilitychange\",\"msvisibilitychange\",\"webkitvisibilitychange\",\"mozvisibilitychange\",\"ovisibilitychange\"],function(eventName){return\"on\"+eventName in document})||\"visibilitychange\"}(),idle$1={type:\"IDLE\"},_scrollJumpKeys,scrollJumpKeys=(_scrollJumpKeys={},_scrollJumpKeys[34]=!0,_scrollJumpKeys[33]=!0,_scrollJumpKeys[36]=!0,_scrollJumpKeys[35]=!0,\n_scrollJumpKeys),idle$2={type:\"IDLE\"},interactiveTagNames={input:!0,button:!0,textarea:!0,select:!0,option:!0,optgroup:!0,video:!0,audio:!0},supportedMatchesName=function(){return\"undefined\"===typeof document?\"matches\":find([\"matches\",\"msMatchesSelector\",\"webkitMatchesSelector\"],function(name){return name in Element.prototype})||\"matches\"}(),defaultSensors=[function(api){var phaseRef=React.useRef(idle$1),unbindEventsRef=React.useRef(noop),startCaptureBinding=useMemoOne.useMemo(function(){return{eventName:\"mousedown\",\nfn:function(event){if(!(event.defaultPrevented||0!==event.button||event.ctrlKey||event.metaKey||event.shiftKey||event.altKey)){var draggableId=api.findClosestDraggableId(event);draggableId&&(draggableId=api.tryGetLock(draggableId,stop,{sourceEvent:event}))&&(event.preventDefault(),event={x:event.clientX,y:event.clientY},unbindEventsRef.current(),startPendingDrag(draggableId,event))}}}},[api]),preventForcePressBinding=useMemoOne.useMemo(function(){return{eventName:\"webkitmouseforcewillbegin\",fn:function(event){if(!event.defaultPrevented){var id=\napi.findClosestDraggableId(event);if(id){var options=api.findOptionsForDraggable(id);options&&(options.shouldRespectForcePress||api.canGetLock(id)&&event.preventDefault())}}}}},[api]),listenForCapture=useMemoOne.useCallback(function(){unbindEventsRef.current=bindEvents(window,[preventForcePressBinding,startCaptureBinding],{passive:!1,capture:!0})},[preventForcePressBinding,startCaptureBinding]),stop=useMemoOne.useCallback(function(){\"IDLE\"!==phaseRef.current.type&&(phaseRef.current=idle$1,unbindEventsRef.current(),\nlistenForCapture())},[listenForCapture]),cancel=useMemoOne.useCallback(function(){var phase=phaseRef.current;stop();\"DRAGGING\"===phase.type&&phase.actions.cancel({shouldBlockNextClick:!0});\"PENDING\"===phase.type&&phase.actions.abort()},[stop]),bindCapturingEvents=useMemoOne.useCallback(function(){var bindings=getCaptureBindings({cancel:cancel,completed:stop,getPhase:function(){return phaseRef.current},setPhase:function(phase){phaseRef.current=phase}});unbindEventsRef.current=bindEvents(window,bindings,\n{capture:!0,passive:!1})},[cancel,stop]),startPendingDrag=useMemoOne.useCallback(function(actions,point){\"IDLE\"!==phaseRef.current.type?invariant(!1,\"Expected to move from IDLE to PENDING drag\"):void 0;phaseRef.current={type:\"PENDING\",point:point,actions:actions};bindCapturingEvents()},[bindCapturingEvents]);useIsomorphicLayoutEffect(function(){listenForCapture();return function(){unbindEventsRef.current()}},[listenForCapture])},function(api){var unbindEventsRef=React.useRef(noop$1),startCaptureBinding=\nuseMemoOne.useMemo(function(){return{eventName:\"keydown\",fn:function(event){function stop(){isCapturing?void 0:invariant(!1,\"Cannot stop capturing a keyboard drag when not capturing\");isCapturing=!1;unbindEventsRef.current();listenForCapture()}if(!event.defaultPrevented&&32===event.keyCode){var draggableId=api.findClosestDraggableId(event);if(draggableId&&(draggableId=api.tryGetLock(draggableId,stop,{sourceEvent:event}))){event.preventDefault();var isCapturing=!0;event=draggableId.snapLift();unbindEventsRef.current();\nunbindEventsRef.current=bindEvents(window,getDraggingBindings(event,stop),{capture:!0,passive:!1})}}}}},[api]),listenForCapture=useMemoOne.useCallback(function(){unbindEventsRef.current=bindEvents(window,[startCaptureBinding],{passive:!1,capture:!0})},[startCaptureBinding]);useIsomorphicLayoutEffect(function(){listenForCapture();return function(){unbindEventsRef.current()}},[listenForCapture])},function(api){var phaseRef=React.useRef(idle$2),unbindEventsRef=React.useRef(noop),getPhase=useMemoOne.useCallback(function(){return phaseRef.current},\n[]),setPhase=useMemoOne.useCallback(function(phase){phaseRef.current=phase},[]),startCaptureBinding=useMemoOne.useMemo(function(){return{eventName:\"touchstart\",fn:function(event){if(!event.defaultPrevented){var draggableId=api.findClosestDraggableId(event);draggableId&&(draggableId=api.tryGetLock(draggableId,stop,{sourceEvent:event}))&&(event=event.touches[0],event={x:event.clientX,y:event.clientY},unbindEventsRef.current(),startPendingDrag(draggableId,event))}}}},[api]),listenForCapture=useMemoOne.useCallback(function(){unbindEventsRef.current=\nbindEvents(window,[startCaptureBinding],{capture:!0,passive:!1})},[startCaptureBinding]),stop=useMemoOne.useCallback(function(){var current=phaseRef.current;\"IDLE\"!==current.type&&(\"PENDING\"===current.type&&clearTimeout(current.longPressTimerId),setPhase(idle$2),unbindEventsRef.current(),listenForCapture())},[listenForCapture,setPhase]),cancel=useMemoOne.useCallback(function(){var phase=phaseRef.current;stop();\"DRAGGING\"===phase.type&&phase.actions.cancel({shouldBlockNextClick:!0});\"PENDING\"===phase.type&&\nphase.actions.abort()},[stop]),bindCapturingEvents=useMemoOne.useCallback(function(){var options={capture:!0,passive:!1},args={cancel:cancel,completed:stop,getPhase:getPhase},unbindTarget=bindEvents(window,getHandleBindings(args),options),unbindWindow=bindEvents(window,getWindowBindings(args),options);unbindEventsRef.current=function(){unbindTarget();unbindWindow()}},[cancel,getPhase,stop]),startDragging=useMemoOne.useCallback(function(){var phase=getPhase();\"PENDING\"!==phase.type?invariant(!1,\"Cannot start dragging from phase \"+\nphase.type):void 0;phase=phase.actions.fluidLift(phase.point);setPhase({type:\"DRAGGING\",actions:phase,hasMoved:!1})},[getPhase,setPhase]),startPendingDrag=useMemoOne.useCallback(function(actions,point){\"IDLE\"!==getPhase().type?invariant(!1,\"Expected to move from IDLE to PENDING drag\"):void 0;var longPressTimerId=setTimeout(startDragging,120);setPhase({type:\"PENDING\",point:point,actions:actions,longPressTimerId:longPressTimerId});bindCapturingEvents()},[bindCapturingEvents,getPhase,setPhase,startDragging]);\nuseIsomorphicLayoutEffect(function(){listenForCapture();return function(){unbindEventsRef.current();var phase=getPhase();\"PENDING\"===phase.type&&(clearTimeout(phase.longPressTimerId),setPhase(idle$2))}},[getPhase,listenForCapture,setPhase]);useIsomorphicLayoutEffect(function(){return bindEvents(window,[{eventName:\"touchmove\",fn:function(){},options:{capture:!1,passive:!1}}])},[])}],instanceCount=0,isEqual$1=function(base){return function(value){return base===value}},isScroll=isEqual$1(\"scroll\"),isAuto=\nisEqual$1(\"auto\"),isVisible$1=isEqual$1(\"visible\"),isEither=function(overflow,fn){return fn(overflow.overflowX)||fn(overflow.overflowY)},isElementScrollable=function(el){el=window.getComputedStyle(el);el={overflowX:el.overflowX,overflowY:el.overflowY};return isEither(el,isScroll)||isEither(el,isAuto)},isBodyScrollable=function(){var body=getBodyElement(),html=document.documentElement;html?void 0:invariant(!1);if(!isElementScrollable(body))return!1;body=window.getComputedStyle(html);html=body.overflowY;\nif(isVisible$1(body.overflowX)&&isVisible$1(html))return!1;warning(\"\\n    We have detected that your \\x3cbody\\x3e element might be a scroll container.\\n    We have found no reliable way of detecting whether the \\x3cbody\\x3e element is a scroll container.\\n    Under most circumstances a \\x3cbody\\x3e scroll bar will be on the \\x3chtml\\x3e element (document.documentElement)\\n\\n    Because we cannot determine if the \\x3cbody\\x3e is a scroll container, and generally it is not one,\\n    we will be treating the \\x3cbody\\x3e as *not* a scroll container\\n\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\\n  \");\nreturn!1},getClosestScrollable=function getClosestScrollable(el){return null==el?null:el===document.body?isBodyScrollable()?el:null:el===document.documentElement?null:isElementScrollable(el)?el:getClosestScrollable(el.parentElement)},getScroll$1=function(el){return{x:el.scrollLeft,y:el.scrollTop}},getIsFixed=function getIsFixed(el){return el?\"fixed\"===window.getComputedStyle(el).position?!0:getIsFixed(el.parentElement):!1},immediate={passive:!1},delayed={passive:!0},count=0,empty={width:0,height:0,\nmargin:{top:0,right:0,bottom:0,left:0}},getStyle=function(_ref2){var placeholder=_ref2.placeholder,animate=_ref2.animate;_ref2=_ref2.isAnimatingOpenOnMount?empty:\"close\"===animate?empty:{height:placeholder.client.borderBox.height,width:placeholder.client.borderBox.width,margin:placeholder.client.margin};return{display:placeholder.display,boxSizing:\"border-box\",width:_ref2.width,height:_ref2.height,marginTop:_ref2.margin.top,marginRight:_ref2.margin.right,marginBottom:_ref2.margin.bottom,marginLeft:_ref2.margin.left,\nflexShrink:\"0\",flexGrow:\"0\",pointerEvents:\"none\",transition:\"none\"!==animate?transitions.placeholder:null}},Placeholder$1=React__default.memo(function(props){var animateOpenTimerRef=React.useRef(null),tryClearAnimateOpenTimer=useMemoOne.useCallback(function(){animateOpenTimerRef.current&&(clearTimeout(animateOpenTimerRef.current),animateOpenTimerRef.current=null)},[]),animate=props.animate,onTransitionEnd=props.onTransitionEnd,onClose=props.onClose,contextId=props.contextId,_useState=React.useState(\"open\"===\nprops.animate),isAnimatingOpenOnMount=_useState[0],setIsAnimatingOpenOnMount=_useState[1];React.useEffect(function(){if(!isAnimatingOpenOnMount)return noop$2;if(\"open\"!==animate)return tryClearAnimateOpenTimer(),setIsAnimatingOpenOnMount(!1),noop$2;if(animateOpenTimerRef.current)return noop$2;animateOpenTimerRef.current=setTimeout(function(){animateOpenTimerRef.current=null;setIsAnimatingOpenOnMount(!1)});return tryClearAnimateOpenTimer},[animate,isAnimatingOpenOnMount,tryClearAnimateOpenTimer]);\n_useState=useMemoOne.useCallback(function(event){\"height\"===event.propertyName&&(onTransitionEnd(),\"close\"===animate&&onClose())},[animate,onClose,onTransitionEnd]);var style=getStyle({isAnimatingOpenOnMount:isAnimatingOpenOnMount,animate:props.animate,placeholder:props.placeholder});return React__default.createElement(props.placeholder.tagName,{style:style,\"data-rbd-placeholder-context-id\":contextId,onTransitionEnd:_useState,ref:props.innerRef})}),DroppableContext=React__default.createContext(null),\nshared=[function(_ref){_ref=_ref.props;_ref.droppableId?void 0:invariant(!1,\"A Droppable requires a droppableId prop\");\"string\"!==typeof _ref.droppableId?invariant(!1,\"A Droppable requires a [string] droppableId. Provided: [\"+typeof _ref.droppableId+\"]\"):void 0},function(_ref2){_ref2=_ref2.props;\"boolean\"!==typeof _ref2.isDropDisabled?invariant(!1,\"isDropDisabled must be a boolean\"):void 0;\"boolean\"!==typeof _ref2.isCombineEnabled?invariant(!1,\"isCombineEnabled must be a boolean\"):void 0;\"boolean\"!==\ntypeof _ref2.ignoreContainerClipping?invariant(!1,\"ignoreContainerClipping must be a boolean\"):void 0},function(_ref3){_ref3=_ref3.getDroppableRef;checkIsValidInnerRef(_ref3())}],standard=[function(_ref4){var props=_ref4.props;_ref4=_ref4.getPlaceholderRef;props.placeholder&&(_ref4()||warning('\\n      Droppable setup issue [droppableId: \"'+props.droppableId+'\"]:\\n      DroppableProvided \\x3e placeholder could not be found.\\n\\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\\n    '))}],\nvirtual=[function(_ref5){_ref5.props.renderClone?void 0:invariant(!1,\"Must provide a clone render function (renderClone) for virtual lists\")},function(_ref6){_ref6=_ref6.getPlaceholderRef;_ref6()?invariant(!1,\"Expected virtual list to not have a placeholder\"):void 0}],AnimateInOut=function(_React$PureComponent){function AnimateInOut(){for(var _this,_len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];_this=_React$PureComponent.call.apply(_React$PureComponent,[this].concat(args))||\nthis;_this.state={isVisible:!!_this.props.on,data:_this.props.on,animate:_this.props.shouldAnimate&&_this.props.on?\"open\":\"none\"};_this.onClose=function(){\"close\"===_this.state.animate&&_this.setState({isVisible:!1})};return _this}_inheritsLoose(AnimateInOut,_React$PureComponent);AnimateInOut.getDerivedStateFromProps=function(props,state){return props.shouldAnimate?props.on?{isVisible:!0,data:props.on,animate:\"open\"}:state.isVisible?{isVisible:!0,data:state.data,animate:\"close\"}:{isVisible:!1,animate:\"close\",\ndata:null}:{isVisible:!!props.on,data:props.on,animate:\"none\"}};AnimateInOut.prototype.render=function(){return this.state.isVisible?this.props.children({onClose:this.onClose,data:this.state.data,animate:this.state.animate}):null};return AnimateInOut}(React__default.PureComponent),isStrictEqual=function(a,b){return a===b},whatIsDraggedOverFromResult=function(result){var combine=result.combine;return(result=result.destination)?result.droppableId:combine?combine.droppableId:null},atRest={mapped:{type:\"SECONDARY\",\noffset:origin,combineTargetFor:null,shouldAnimateDisplacement:!0,snapshot:getSecondarySnapshot(null)}},ConnectedDraggable=reactRedux.connect(function(){var draggingSelector=getDraggableSelector(),secondarySelector=getSecondarySelector();return function(state,ownProps){return draggingSelector(state,ownProps)||secondarySelector(state,ownProps)||atRest}},{dropAnimationFinished:dropAnimationFinished},null,{context:StoreContext,pure:!0,areStatePropsEqual:isStrictEqual})(function(props){var ref=React.useRef(null),\nsetRef=useMemoOne.useCallback(function(el){ref.current=el},[]),getRef=useMemoOne.useCallback(function(){return ref.current},[]),_useRequiredContext=useRequiredContext(AppContext),contextId=_useRequiredContext.contextId,liftInstructionId=_useRequiredContext.liftInstructionId,registry=_useRequiredContext.registry;_useRequiredContext=useRequiredContext(DroppableContext);var type=_useRequiredContext.type,droppableId=_useRequiredContext.droppableId,descriptor=useMemoOne.useMemo(function(){return{id:props.draggableId,\nindex:props.index,type:type,droppableId:droppableId}},[props.draggableId,props.index,type,droppableId]);_useRequiredContext=props.children;var draggableId=props.draggableId,isEnabled=props.isEnabled,shouldRespectForcePress=props.shouldRespectForcePress,canDragInteractiveElements=props.canDragInteractiveElements,isClone=props.isClone,mapped=props.mapped,dropAnimationFinishedAction=props.dropAnimationFinished;useValidation$1(props,contextId,getRef);useClonePropValidation(isClone);isClone||(isClone=\nuseMemoOne.useMemo(function(){return{descriptor:descriptor,registry:registry,getDraggableRef:getRef,canDragInteractiveElements:canDragInteractiveElements,shouldRespectForcePress:shouldRespectForcePress,isEnabled:isEnabled}},[descriptor,registry,getRef,canDragInteractiveElements,shouldRespectForcePress,isEnabled]),useDraggablePublisher(isClone));var dragHandleProps=useMemoOne.useMemo(function(){return isEnabled?{tabIndex:0,\"data-rbd-drag-handle-draggable-id\":draggableId,\"data-rbd-drag-handle-context-id\":contextId,\n\"aria-labelledby\":liftInstructionId,draggable:!1,onDragStart:preventHtml5Dnd}:null},[contextId,draggableId,isEnabled,liftInstructionId]),onMoveEnd=useMemoOne.useCallback(function(event){\"DRAGGING\"===mapped.type&&mapped.dropping&&\"transform\"===event.propertyName&&dropAnimationFinishedAction()},[dropAnimationFinishedAction,mapped]);isClone=useMemoOne.useMemo(function(){if(\"DRAGGING\"===mapped.type){var box=mapped.dimension.client,offset=mapped.offset,dropping=mapped.dropping;var JSCompiler_temp=!!mapped.combineWith;\nvar shouldAnimate=null!=mapped.forceShouldAnimate?mapped.forceShouldAnimate:\"SNAP\"===mapped.mode,isDropAnimating=!!dropping;offset=isDropAnimating?transforms.drop(offset,JSCompiler_temp):transforms.moveTo(offset);var JSCompiler_temp_const=box.marginBox.top,JSCompiler_temp_const$jscomp$0=box.marginBox.left,JSCompiler_temp_const$jscomp$1=box.borderBox.width;box=box.borderBox.height;dropping=dropping?transitions.drop(dropping.duration):shouldAnimate?transitions.snap:transitions.fluid;JSCompiler_temp=\n{position:\"fixed\",top:JSCompiler_temp_const,left:JSCompiler_temp_const$jscomp$0,boxSizing:\"border-box\",width:JSCompiler_temp_const$jscomp$1,height:box,transition:dropping,transform:offset,opacity:JSCompiler_temp?isDropAnimating?combine.opacity.drop:combine.opacity.combining:null,zIndex:isDropAnimating?4500:5E3,pointerEvents:\"none\"}}else JSCompiler_temp={transform:transforms.moveTo(mapped.offset),transition:mapped.shouldAnimateDisplacement?null:\"none\"};return{innerRef:setRef,draggableProps:{\"data-rbd-draggable-context-id\":contextId,\n\"data-rbd-draggable-id\":draggableId,style:JSCompiler_temp,onTransitionEnd:\"DRAGGING\"===mapped.type&&mapped.dropping?onMoveEnd:null},dragHandleProps:dragHandleProps}},[contextId,dragHandleProps,draggableId,mapped,onMoveEnd,setRef]);var rubric=useMemoOne.useMemo(function(){return{draggableId:descriptor.id,type:descriptor.type,source:{index:descriptor.index,droppableId:descriptor.droppableId}}},[descriptor.droppableId,descriptor.id,descriptor.index,descriptor.type]);return _useRequiredContext(isClone,\nmapped.snapshot,rubric)}),ConnectedDroppable=reactRedux.connect(function(){var idleWithAnimation={placeholder:null,shouldAnimatePlaceholder:!0,snapshot:{isDraggingOver:!1,draggingOverWith:null,draggingFromThisWith:null,isUsingPlaceholder:!1},useClone:null},idleWithoutAnimation=_extends({},idleWithAnimation,{shouldAnimatePlaceholder:!1}),getDraggableRubric=memoizeOne(function(descriptor){return{draggableId:descriptor.id,type:descriptor.type,source:{index:descriptor.index,droppableId:descriptor.droppableId}}}),\ngetMapProps=memoizeOne(function(id,isEnabled,isDraggingOverForConsumer,isDraggingOverForImpact,dragging,renderClone){var draggableId=dragging.descriptor.id;return dragging.descriptor.droppableId===id?(id=renderClone?{render:renderClone,dragging:getDraggableRubric(dragging.descriptor)}:null,{placeholder:dragging.placeholder,shouldAnimatePlaceholder:!1,snapshot:{isDraggingOver:isDraggingOverForConsumer,draggingOverWith:isDraggingOverForConsumer?draggableId:null,draggingFromThisWith:draggableId,isUsingPlaceholder:!0},\nuseClone:id}):isEnabled?isDraggingOverForImpact?{placeholder:dragging.placeholder,shouldAnimatePlaceholder:!0,snapshot:{isDraggingOver:isDraggingOverForConsumer,draggingOverWith:draggableId,draggingFromThisWith:null,isUsingPlaceholder:!0},useClone:null}:idleWithAnimation:idleWithoutAnimation});return function(state,ownProps){var id=ownProps.droppableId,type=ownProps.type,isEnabled=!ownProps.isDropDisabled;ownProps=ownProps.renderClone;if(state.isDragging){var critical=state.critical;if(type!==critical.droppable.type)return idleWithoutAnimation;\ntype=state.dimensions.draggables[critical.draggable.id];state=whatIsDraggedOver(state.impact)===id;return getMapProps(id,isEnabled,state,state,type,ownProps)}if(\"DROP_ANIMATING\"===state.phase){critical=state.completed;if(type!==critical.critical.droppable.type)return idleWithoutAnimation;state=state.dimensions.draggables[critical.critical.draggable.id];return getMapProps(id,isEnabled,whatIsDraggedOverFromResult(critical.result)===id,whatIsDraggedOver(critical.impact)===id,state,ownProps)}if(\"IDLE\"===\nstate.phase&&state.completed&&!state.shouldFlush){isEnabled=state.completed;if(type!==isEnabled.critical.droppable.type)return idleWithoutAnimation;ownProps=whatIsDraggedOver(isEnabled.impact)===id;state=!(!isEnabled.impact.at||\"COMBINE\"!==isEnabled.impact.at.type);if(ownProps)return state?idleWithAnimation:idleWithoutAnimation;if(isEnabled.critical.droppable.id===id)return idleWithAnimation}return idleWithoutAnimation}},{updateViewportMaxScroll:function(args){return{type:\"UPDATE_VIEWPORT_MAX_SCROLL\",\npayload:args}}},null,{context:StoreContext,pure:!0,areStatePropsEqual:isStrictEqual})(function(props){var appContext=React.useContext(AppContext);appContext?void 0:invariant(!1,\"Could not find app context\");var contextId=appContext.contextId,isMovementAllowed=appContext.isMovementAllowed,droppableRef=React.useRef(null),placeholderRef=React.useRef(null);appContext=props.children;var droppableId=props.droppableId,type=props.type,mode=props.mode,direction=props.direction,ignoreContainerClipping=props.ignoreContainerClipping,\nisDropDisabled=props.isDropDisabled,isCombineEnabled=props.isCombineEnabled,snapshot=props.snapshot,useClone=props.useClone,updateViewportMaxScroll=props.updateViewportMaxScroll,getContainerForClone=props.getContainerForClone,getDroppableRef=useMemoOne.useCallback(function(){return droppableRef.current},[]),setDroppableRef=useMemoOne.useCallback(function(value){droppableRef.current=value},[]),getPlaceholderRef=useMemoOne.useCallback(function(){return placeholderRef.current},[]),setPlaceholderRef=\nuseMemoOne.useCallback(function(value){placeholderRef.current=value},[]);useValidation({props:props,getDroppableRef:getDroppableRef,getPlaceholderRef:getPlaceholderRef});var onPlaceholderTransitionEnd=useMemoOne.useCallback(function(){isMovementAllowed()&&updateViewportMaxScroll({maxScroll:getMaxWindowScroll()})},[isMovementAllowed,updateViewportMaxScroll]);useDroppablePublisher({droppableId:droppableId,type:type,mode:mode,direction:direction,isDropDisabled:isDropDisabled,isCombineEnabled:isCombineEnabled,\nignoreContainerClipping:ignoreContainerClipping,getDroppableRef:getDroppableRef});var placeholder=React__default.createElement(AnimateInOut,{on:props.placeholder,shouldAnimate:props.shouldAnimatePlaceholder},function(_ref){return React__default.createElement(Placeholder$1,{placeholder:_ref.data,onClose:_ref.onClose,innerRef:setPlaceholderRef,animate:_ref.animate,contextId:contextId,onTransitionEnd:onPlaceholderTransitionEnd})});props=useMemoOne.useMemo(function(){return{innerRef:setDroppableRef,placeholder:placeholder,\ndroppableProps:{\"data-rbd-droppable-id\":droppableId,\"data-rbd-droppable-context-id\":contextId}}},[contextId,droppableId,placeholder,setDroppableRef]);var isUsingCloneFor=useClone?useClone.dragging.draggableId:null;mode=useMemoOne.useMemo(function(){return{droppableId:droppableId,type:type,isUsingCloneFor:isUsingCloneFor}},[droppableId,isUsingCloneFor,type]);return React__default.createElement(DroppableContext.Provider,{value:mode},appContext(props,snapshot),function(){if(!useClone)return null;var dragging=\nuseClone.dragging,render=useClone.render,node=React__default.createElement(PrivateDraggable,{draggableId:dragging.draggableId,index:dragging.source.index,isClone:!0,isEnabled:!0,shouldRespectForcePress:!1,canDragInteractiveElements:!0},function(draggableProvided,draggableSnapshot){return render(draggableProvided,draggableSnapshot,dragging)});return ReactDOM.createPortal(node,getContainerForClone())}())});ConnectedDroppable.defaultProps={mode:\"standard\",type:\"DEFAULT\",direction:\"vertical\",isDropDisabled:!1,\nisCombineEnabled:!1,ignoreContainerClipping:!1,renderClone:null,getContainerForClone:function(){document.body?void 0:invariant(!1,\"document.body is not ready\");return document.body}};exports.DragDropContext=function(props){var contextId=useMemoOne.useMemo(function(){return\"\"+instanceCount++},[]),liftInstruction=props.liftInstruction||\"Draggable item. Ensure your screen reader is not in browse mode and then press space bar to lift.\";return React__default.createElement(ErrorBoundary,null,function(setCallbacks){return React__default.createElement(App,\n{nonce:props.nonce,contextId:contextId,setCallbacks:setCallbacks,liftInstruction:liftInstruction,enableDefaultSensors:props.enableDefaultSensors,sensors:props.sensors,onBeforeDragStart:props.onBeforeDragStart,onDragStart:props.onDragStart,onDragUpdate:props.onDragUpdate,onDragEnd:props.onDragEnd},props.children)})};exports.Draggable=function(props){return React__default.createElement(PrivateDraggable,_extends({},props,{isClone:!1,isEnabled:\"boolean\"===typeof props.isDragDisabled?!props.isDragDisabled:\n!0,canDragInteractiveElements:!!props.disableInteractiveElementBlocking,shouldRespectForcePress:!!props.shouldRespectForcePress}))};exports.Droppable=ConnectedDroppable;exports.resetServerContext=function(){instanceCount=0}}","~:source","shadow$provide[\"module$node_modules$react_beautiful_dnd$dist$react_beautiful_dnd_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = require('react');\nvar React__default = _interopDefault(React);\nvar useMemoOne = require('use-memo-one');\nvar _inheritsLoose = _interopDefault(require('@babel/runtime-corejs2/helpers/inheritsLoose'));\nvar _extends = _interopDefault(require('@babel/runtime-corejs2/helpers/extends'));\nvar redux = require('redux');\nvar reactRedux = require('react-redux');\nvar cssBoxModel = require('css-box-model');\nvar memoizeOne = _interopDefault(require('memoize-one'));\nvar _Object$values = _interopDefault(require('@babel/runtime-corejs2/core-js/object/values'));\nvar _Object$keys = _interopDefault(require('@babel/runtime-corejs2/core-js/object/keys'));\nvar rafSchd = _interopDefault(require('raf-schd'));\nvar _Date$now = _interopDefault(require('@babel/runtime-corejs2/core-js/date/now'));\nvar _Object$assign = _interopDefault(require('@babel/runtime-corejs2/core-js/object/assign'));\nvar ReactDOM = _interopDefault(require('react-dom'));\nvar _Number$isInteger = _interopDefault(require('@babel/runtime-corejs2/core-js/number/is-integer'));\n\nvar isProduction = process.env.NODE_ENV === 'production';\nvar spacesAndTabs = /[ \\t]{2,}/g;\nvar lineStartWithSpaces = /^[ \\t]*/gm;\n\nvar clean = function clean(value) {\n  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\n};\n\nvar getDevMessage = function getDevMessage(message) {\n  return clean(\"\\n  %creact-beautiful-dnd\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77\\u200D This is a development only message. It will be removed in production builds.\\n\");\n};\n\nvar getFormattedMessage = function getFormattedMessage(message) {\n  return [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];\n};\nvar isDisabledFlag = '__react-beautiful-dnd-disable-dev-warnings';\nfunction log(type, message) {\n  var _console;\n\n  if (isProduction) {\n    return;\n  }\n\n  if (typeof window !== 'undefined' && window[isDisabledFlag]) {\n    return;\n  }\n\n  (_console = console)[type].apply(_console, getFormattedMessage(message));\n}\nvar warning = log.bind(null, 'warn');\nvar error = log.bind(null, 'error');\n\nfunction noop() {}\n\nfunction getOptions(shared, fromBinding) {\n  return _extends({}, shared, {}, fromBinding);\n}\n\nfunction bindEvents(el, bindings, sharedOptions) {\n  var unbindings = bindings.map(function (binding) {\n    var options = getOptions(sharedOptions, binding.options);\n    el.addEventListener(binding.eventName, binding.fn, options);\n    return function unbind() {\n      el.removeEventListener(binding.eventName, binding.fn, options);\n    };\n  });\n  return function unbindAll() {\n    unbindings.forEach(function (unbind) {\n      unbind();\n    });\n  };\n}\n\nvar isProduction$1 = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction RbdInvariant(message) {\n  this.message = message;\n}\n\nRbdInvariant.prototype.toString = function toString() {\n  return this.message;\n};\n\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction$1) {\n    throw new RbdInvariant(prefix);\n  } else {\n    throw new RbdInvariant(prefix + \": \" + (message || ''));\n  }\n}\n\nvar ErrorBoundary = function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.callbacks = null;\n    _this.unbind = noop;\n\n    _this.onWindowError = function (event) {\n      var callbacks = _this.getCallbacks();\n\n      if (callbacks.isDragging()) {\n        callbacks.tryAbort();\n        process.env.NODE_ENV !== \"production\" ? warning(\"\\n        An error was caught by our window 'error' event listener while a drag was occurring.\\n        The active drag has been aborted.\\n      \") : void 0;\n      }\n\n      var err = event.error;\n\n      if (err instanceof RbdInvariant) {\n        event.preventDefault();\n\n        if (process.env.NODE_ENV !== 'production') {\n          error(err.message);\n        }\n      }\n    };\n\n    _this.getCallbacks = function () {\n      if (!_this.callbacks) {\n        throw new Error('Unable to find AppCallbacks in <ErrorBoundary/>');\n      }\n\n      return _this.callbacks;\n    };\n\n    _this.setCallbacks = function (callbacks) {\n      _this.callbacks = callbacks;\n    };\n\n    return _this;\n  }\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.unbind = bindEvents(window, [{\n      eventName: 'error',\n      fn: this.onWindowError\n    }]);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.unbind();\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(err) {\n    if (err instanceof RbdInvariant) {\n      if (process.env.NODE_ENV !== 'production') {\n        error(err.message);\n      }\n\n      this.setState({});\n      return;\n    }\n\n    throw err;\n  };\n\n  _proto.render = function render() {\n    return this.props.children(this.setCallbacks);\n  };\n\n  return ErrorBoundary;\n}(React__default.Component);\n\nvar liftInstruction = \"Draggable item. Ensure your screen reader is not in browse mode and then press space bar to lift.\";\n\nvar position = function position(index) {\n  return index + 1;\n};\n\nvar onDragStart = function onDragStart(start) {\n  return \"\\n  You have lifted an item in position \" + position(start.source.index) + \".\\n  Use the arrow keys to move, space bar to drop, and escape to cancel.\\n\";\n};\n\nvar withLocation = function withLocation(source, destination) {\n  var isInHomeList = source.droppableId === destination.droppableId;\n  var startPosition = position(source.index);\n  var endPosition = position(destination.index);\n\n  if (isInHomeList) {\n    return \"\\n      You have moved the item from position \" + startPosition + \"\\n      to position \" + endPosition + \"\\n    \";\n  }\n\n  return \"\\n    You have moved the item from position \" + startPosition + \"\\n    in list \" + source.droppableId + \"\\n    to list \" + destination.droppableId + \"\\n    in position \" + endPosition + \"\\n  \";\n};\n\nvar withCombine = function withCombine(id, source, combine) {\n  var inHomeList = source.droppableId === combine.droppableId;\n\n  if (inHomeList) {\n    return \"\\n      The item \" + id + \"\\n      has been combined with \" + combine.draggableId;\n  }\n\n  return \"\\n      The item \" + id + \"\\n      in list \" + source.droppableId + \"\\n      has been combined with \" + combine.draggableId + \"\\n      in list \" + combine.droppableId + \"\\n    \";\n};\n\nvar onDragUpdate = function onDragUpdate(update) {\n  var location = update.destination;\n\n  if (location) {\n    return withLocation(update.source, location);\n  }\n\n  var combine = update.combine;\n\n  if (combine) {\n    return withCombine(update.draggableId, update.source, combine);\n  }\n\n  return 'You are over an area that cannot be dropped on';\n};\n\nvar returnedToStart = function returnedToStart(source) {\n  return \"\\n  The item has returned to its starting position\\n  of \" + position(source.index) + \"\\n\";\n};\n\nvar onDragEnd = function onDragEnd(result) {\n  if (result.reason === 'CANCEL') {\n    return \"\\n      Movement cancelled.\\n      \" + returnedToStart(result.source) + \"\\n    \";\n  }\n\n  var location = result.destination;\n  var combine = result.combine;\n\n  if (location) {\n    return \"\\n      You have dropped the item.\\n      \" + withLocation(result.source, location) + \"\\n    \";\n  }\n\n  if (combine) {\n    return \"\\n      You have dropped the item.\\n      \" + withCombine(result.draggableId, result.source, combine) + \"\\n    \";\n  }\n\n  return \"\\n    The item has been dropped while not over a drop area.\\n    \" + returnedToStart(result.source) + \"\\n  \";\n};\n\nvar preset = {\n  liftInstruction: liftInstruction,\n  onDragStart: onDragStart,\n  onDragUpdate: onDragUpdate,\n  onDragEnd: onDragEnd\n};\n\nvar origin = {\n  x: 0,\n  y: 0\n};\nvar add = function add(point1, point2) {\n  return {\n    x: point1.x + point2.x,\n    y: point1.y + point2.y\n  };\n};\nvar subtract = function subtract(point1, point2) {\n  return {\n    x: point1.x - point2.x,\n    y: point1.y - point2.y\n  };\n};\nvar isEqual = function isEqual(point1, point2) {\n  return point1.x === point2.x && point1.y === point2.y;\n};\nvar negate = function negate(point) {\n  return {\n    x: point.x !== 0 ? -point.x : 0,\n    y: point.y !== 0 ? -point.y : 0\n  };\n};\nvar patch = function patch(line, value, otherValue) {\n  var _ref;\n\n  if (otherValue === void 0) {\n    otherValue = 0;\n  }\n\n  return _ref = {}, _ref[line] = value, _ref[line === 'x' ? 'y' : 'x'] = otherValue, _ref;\n};\nvar distance = function distance(point1, point2) {\n  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n};\nvar closest = function closest(target, points) {\n  return Math.min.apply(Math, points.map(function (point) {\n    return distance(target, point);\n  }));\n};\nvar apply = function apply(fn) {\n  return function (point) {\n    return {\n      x: fn(point.x),\n      y: fn(point.y)\n    };\n  };\n};\n\nvar executeClip = (function (frame, subject) {\n  var result = cssBoxModel.getRect({\n    top: Math.max(subject.top, frame.top),\n    right: Math.min(subject.right, frame.right),\n    bottom: Math.min(subject.bottom, frame.bottom),\n    left: Math.max(subject.left, frame.left)\n  });\n\n  if (result.width <= 0 || result.height <= 0) {\n    return null;\n  }\n\n  return result;\n});\n\nvar offsetByPosition = function offsetByPosition(spacing, point) {\n  return {\n    top: spacing.top + point.y,\n    left: spacing.left + point.x,\n    bottom: spacing.bottom + point.y,\n    right: spacing.right + point.x\n  };\n};\nvar getCorners = function getCorners(spacing) {\n  return [{\n    x: spacing.left,\n    y: spacing.top\n  }, {\n    x: spacing.right,\n    y: spacing.top\n  }, {\n    x: spacing.left,\n    y: spacing.bottom\n  }, {\n    x: spacing.right,\n    y: spacing.bottom\n  }];\n};\nvar noSpacing = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n};\n\nvar scroll = function scroll(target, frame) {\n  if (!frame) {\n    return target;\n  }\n\n  return offsetByPosition(target, frame.scroll.diff.displacement);\n};\n\nvar increase = function increase(target, axis, withPlaceholder) {\n  if (withPlaceholder && withPlaceholder.increasedBy) {\n    var _extends2;\n\n    return _extends({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));\n  }\n\n  return target;\n};\n\nvar clip = function clip(target, frame) {\n  if (frame && frame.shouldClipSubject) {\n    return executeClip(frame.pageMarginBox, target);\n  }\n\n  return cssBoxModel.getRect(target);\n};\n\nvar getSubject = (function (_ref) {\n  var page = _ref.page,\n      withPlaceholder = _ref.withPlaceholder,\n      axis = _ref.axis,\n      frame = _ref.frame;\n  var scrolled = scroll(page.marginBox, frame);\n  var increased = increase(scrolled, axis, withPlaceholder);\n  var clipped = clip(increased, frame);\n  return {\n    page: page,\n    withPlaceholder: withPlaceholder,\n    active: clipped\n  };\n});\n\nvar scrollDroppable = (function (droppable, newScroll) {\n  !droppable.frame ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n  var scrollable = droppable.frame;\n  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n  var scrollDisplacement = negate(scrollDiff);\n\n  var frame = _extends({}, scrollable, {\n    scroll: {\n      initial: scrollable.scroll.initial,\n      current: newScroll,\n      diff: {\n        value: scrollDiff,\n        displacement: scrollDisplacement\n      },\n      max: scrollable.scroll.max\n    }\n  });\n\n  var subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: droppable.subject.withPlaceholder,\n    axis: droppable.axis,\n    frame: frame\n  });\n\n  var result = _extends({}, droppable, {\n    frame: frame,\n    subject: subject\n  });\n\n  return result;\n});\n\nfunction values(map) {\n  return _Object$values(map);\n}\nfunction findIndex(list, predicate) {\n  if (list.findIndex) {\n    return list.findIndex(predicate);\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (predicate(list[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n}\nfunction find(list, predicate) {\n  if (list.find) {\n    return list.find(predicate);\n  }\n\n  var index = findIndex(list, predicate);\n\n  if (index !== -1) {\n    return list[index];\n  }\n\n  return undefined;\n}\nfunction toArray(list) {\n  return Array.prototype.slice.call(list);\n}\n\nvar toDroppableMap = memoizeOne(function (droppables) {\n  return droppables.reduce(function (previous, current) {\n    previous[current.descriptor.id] = current;\n    return previous;\n  }, {});\n});\nvar toDraggableMap = memoizeOne(function (draggables) {\n  return draggables.reduce(function (previous, current) {\n    previous[current.descriptor.id] = current;\n    return previous;\n  }, {});\n});\nvar toDroppableList = memoizeOne(function (droppables) {\n  return values(droppables);\n});\nvar toDraggableList = memoizeOne(function (draggables) {\n  return values(draggables);\n});\n\nvar getDraggablesInsideDroppable = memoizeOne(function (droppableId, draggables) {\n  var result = toDraggableList(draggables).filter(function (draggable) {\n    return droppableId === draggable.descriptor.droppableId;\n  }).sort(function (a, b) {\n    return a.descriptor.index - b.descriptor.index;\n  });\n  return result;\n});\n\nvar forward = {\n  vertical: 'down',\n  horizontal: 'right'\n};\nvar backward = {\n  vertical: 'up',\n  horizontal: 'left'\n};\n\nfunction tryGetDestination(impact) {\n  if (impact.at && impact.at.type === 'REORDER') {\n    return impact.at.destination;\n  }\n\n  return null;\n}\nfunction tryGetCombine(impact) {\n  if (impact.at && impact.at.type === 'COMBINE') {\n    return impact.at.combine;\n  }\n\n  return null;\n}\n\nvar removeDraggableFromList = memoizeOne(function (remove, list) {\n  return list.filter(function (item) {\n    return item.descriptor.id !== remove.descriptor.id;\n  });\n});\n\nvar moveToNextCombine = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      previousImpact = _ref.previousImpact;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var location = tryGetDestination(previousImpact);\n\n  if (!location) {\n    return null;\n  }\n\n  function getImpact(target) {\n    var at = {\n      type: 'COMBINE',\n      whenEntered: isMovingForward ? forward : backward,\n      combine: {\n        draggableId: target,\n        droppableId: destination.descriptor.id\n      }\n    };\n    return _extends({}, previousImpact, {\n      at: at\n    });\n  }\n\n  var all = previousImpact.displaced.all;\n  var closestId = all.length ? all[0] : null;\n\n  if (isMovingForward) {\n    return closestId ? getImpact(closestId) : null;\n  }\n\n  var withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n\n  if (!closestId) {\n    if (!withoutDraggable.length) {\n      return null;\n    }\n\n    var last = withoutDraggable[withoutDraggable.length - 1];\n    return getImpact(last.descriptor.id);\n  }\n\n  var indexOfClosest = findIndex(withoutDraggable, function (d) {\n    return d.descriptor.id === closestId;\n  });\n  !(indexOfClosest !== -1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find displaced item in set') : invariant(false) : void 0;\n  var proposedIndex = indexOfClosest - 1;\n\n  if (proposedIndex < 0) {\n    return null;\n  }\n\n  var before = withoutDraggable[proposedIndex];\n  return getImpact(before.descriptor.id);\n});\n\nvar isHomeOf = (function (draggable, destination) {\n  return draggable.descriptor.droppableId === destination.descriptor.id;\n});\n\nvar noDisplacedBy = {\n  point: origin,\n  value: 0\n};\nvar emptyGroups = {\n  invisible: {},\n  visible: {},\n  all: []\n};\nvar noImpact = {\n  displaced: emptyGroups,\n  displacedBy: noDisplacedBy,\n  at: null\n};\n\nvar isWithin = (function (lowerBound, upperBound) {\n  return function (value) {\n    return lowerBound <= value && value <= upperBound;\n  };\n});\n\nvar isPartiallyVisibleThroughFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (subject) {\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n\n    if (isContained) {\n      return true;\n    }\n\n    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n\n    if (isPartiallyContained) {\n      return true;\n    }\n\n    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n\n    if (isTargetBiggerThanFrame) {\n      return true;\n    }\n\n    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n    return isTargetBiggerOnOneAxis;\n  };\n});\n\nvar isTotallyVisibleThroughFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (subject) {\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    return isContained;\n  };\n});\n\nvar vertical = {\n  direction: 'vertical',\n  line: 'y',\n  crossAxisLine: 'x',\n  start: 'top',\n  end: 'bottom',\n  size: 'height',\n  crossAxisStart: 'left',\n  crossAxisEnd: 'right',\n  crossAxisSize: 'width'\n};\nvar horizontal = {\n  direction: 'horizontal',\n  line: 'x',\n  crossAxisLine: 'y',\n  start: 'left',\n  end: 'right',\n  size: 'width',\n  crossAxisStart: 'top',\n  crossAxisEnd: 'bottom',\n  crossAxisSize: 'height'\n};\n\nvar isTotallyVisibleThroughFrameOnAxis = (function (axis) {\n  return function (frame) {\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function (subject) {\n      if (axis === vertical) {\n        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n      }\n\n      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    };\n  };\n});\n\nvar getDroppableDisplaced = function getDroppableDisplaced(target, destination) {\n  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n  return offsetByPosition(target, displacement);\n};\n\nvar isVisibleInDroppable = function isVisibleInDroppable(target, destination, isVisibleThroughFrameFn) {\n  if (!destination.subject.active) {\n    return false;\n  }\n\n  return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\n\nvar isVisibleInViewport = function isVisibleInViewport(target, viewport, isVisibleThroughFrameFn) {\n  return isVisibleThroughFrameFn(viewport)(target);\n};\n\nvar isVisible = function isVisible(_ref) {\n  var toBeDisplaced = _ref.target,\n      destination = _ref.destination,\n      viewport = _ref.viewport,\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\n      isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;\n  var displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\n\nvar isPartiallyVisible = function isPartiallyVisible(args) {\n  return isVisible(_extends({}, args, {\n    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n  }));\n};\nvar isTotallyVisible = function isTotallyVisible(args) {\n  return isVisible(_extends({}, args, {\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n  }));\n};\nvar isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis(args) {\n  return isVisible(_extends({}, args, {\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n  }));\n};\n\nvar getShouldAnimate = function getShouldAnimate(id, last, forceShouldAnimate) {\n  if (typeof forceShouldAnimate === 'boolean') {\n    return forceShouldAnimate;\n  }\n\n  if (!last) {\n    return true;\n  }\n\n  var invisible = last.invisible,\n      visible = last.visible;\n\n  if (invisible[id]) {\n    return false;\n  }\n\n  var previous = visible[id];\n  return previous ? previous.shouldAnimate : true;\n};\n\nfunction getTarget(draggable, displacedBy) {\n  var marginBox = draggable.page.marginBox;\n  var expandBy = {\n    top: displacedBy.point.y,\n    right: 0,\n    bottom: 0,\n    left: displacedBy.point.x\n  };\n  return cssBoxModel.getRect(cssBoxModel.expand(marginBox, expandBy));\n}\n\nfunction getDisplacementGroups(_ref) {\n  var afterDragging = _ref.afterDragging,\n      destination = _ref.destination,\n      displacedBy = _ref.displacedBy,\n      viewport = _ref.viewport,\n      forceShouldAnimate = _ref.forceShouldAnimate,\n      last = _ref.last;\n  return afterDragging.reduce(function process(groups, draggable) {\n    var target = getTarget(draggable, displacedBy);\n    var id = draggable.descriptor.id;\n    groups.all.push(id);\n    var isVisible = isPartiallyVisible({\n      target: target,\n      destination: destination,\n      viewport: viewport,\n      withDroppableDisplacement: true\n    });\n\n    if (!isVisible) {\n      groups.invisible[draggable.descriptor.id] = true;\n      return groups;\n    }\n\n    var shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n    var displacement = {\n      draggableId: id,\n      shouldAnimate: shouldAnimate\n    };\n    groups.visible[id] = displacement;\n    return groups;\n  }, {\n    all: [],\n    visible: {},\n    invisible: {}\n  });\n}\n\nfunction getIndexOfLastItem(draggables, options) {\n  if (!draggables.length) {\n    return 0;\n  }\n\n  var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\n\nfunction goAtEnd(_ref) {\n  var insideDestination = _ref.insideDestination,\n      inHomeList = _ref.inHomeList,\n      displacedBy = _ref.displacedBy,\n      destination = _ref.destination;\n  var newIndex = getIndexOfLastItem(insideDestination, {\n    inHomeList: inHomeList\n  });\n  return {\n    displaced: emptyGroups,\n    displacedBy: displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: newIndex\n      }\n    }\n  };\n}\n\nfunction calculateReorderImpact(_ref2) {\n  var draggable = _ref2.draggable,\n      insideDestination = _ref2.insideDestination,\n      destination = _ref2.destination,\n      viewport = _ref2.viewport,\n      displacedBy = _ref2.displacedBy,\n      last = _ref2.last,\n      index = _ref2.index,\n      forceShouldAnimate = _ref2.forceShouldAnimate;\n  var inHomeList = isHomeOf(draggable, destination);\n\n  if (index == null) {\n    return goAtEnd({\n      insideDestination: insideDestination,\n      inHomeList: inHomeList,\n      displacedBy: displacedBy,\n      destination: destination\n    });\n  }\n\n  var match = find(insideDestination, function (item) {\n    return item.descriptor.index === index;\n  });\n\n  if (!match) {\n    return goAtEnd({\n      insideDestination: insideDestination,\n      inHomeList: inHomeList,\n      displacedBy: displacedBy,\n      destination: destination\n    });\n  }\n\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  var sliceFrom = insideDestination.indexOf(match);\n  var impacted = withoutDragging.slice(sliceFrom);\n  var displaced = getDisplacementGroups({\n    afterDragging: impacted,\n    destination: destination,\n    displacedBy: displacedBy,\n    last: last,\n    viewport: viewport.frame,\n    forceShouldAnimate: forceShouldAnimate\n  });\n  return {\n    displaced: displaced,\n    displacedBy: displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: index\n      }\n    }\n  };\n}\n\nfunction didStartAfterCritical(draggableId, afterCritical) {\n  return Boolean(afterCritical.effected[draggableId]);\n}\n\nvar fromCombine = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      combine = _ref.combine,\n      afterCritical = _ref.afterCritical;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var combineId = combine.draggableId;\n  var combineWith = draggables[combineId];\n  var combineWithIndex = combineWith.descriptor.index;\n  var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n\n  if (didCombineWithStartAfterCritical) {\n    if (isMovingForward) {\n      return combineWithIndex;\n    }\n\n    return combineWithIndex - 1;\n  }\n\n  if (isMovingForward) {\n    return combineWithIndex + 1;\n  }\n\n  return combineWithIndex;\n});\n\nvar fromReorder = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      isInHomeList = _ref.isInHomeList,\n      insideDestination = _ref.insideDestination,\n      location = _ref.location;\n\n  if (!insideDestination.length) {\n    return null;\n  }\n\n  var currentIndex = location.index;\n  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n  var firstIndex = insideDestination[0].descriptor.index;\n  var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n  var upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n\n  if (proposedIndex < firstIndex) {\n    return null;\n  }\n\n  if (proposedIndex > upperBound) {\n    return null;\n  }\n\n  return proposedIndex;\n});\n\nvar moveToNextIndex = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      isInHomeList = _ref.isInHomeList,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var wasAt = previousImpact.at;\n  !wasAt ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot move in direction without previous impact location') : invariant(false) : void 0;\n\n  if (wasAt.type === 'REORDER') {\n    var _newIndex = fromReorder({\n      isMovingForward: isMovingForward,\n      isInHomeList: isInHomeList,\n      location: wasAt.destination,\n      insideDestination: insideDestination\n    });\n\n    if (_newIndex == null) {\n      return null;\n    }\n\n    return calculateReorderImpact({\n      draggable: draggable,\n      insideDestination: insideDestination,\n      destination: destination,\n      viewport: viewport,\n      last: previousImpact.displaced,\n      displacedBy: previousImpact.displacedBy,\n      index: _newIndex\n    });\n  }\n\n  var newIndex = fromCombine({\n    isMovingForward: isMovingForward,\n    destination: destination,\n    displaced: previousImpact.displaced,\n    draggables: draggables,\n    combine: wasAt.combine,\n    afterCritical: afterCritical\n  });\n\n  if (newIndex == null) {\n    return null;\n  }\n\n  return calculateReorderImpact({\n    draggable: draggable,\n    insideDestination: insideDestination,\n    destination: destination,\n    viewport: viewport,\n    last: previousImpact.displaced,\n    displacedBy: previousImpact.displacedBy,\n    index: newIndex\n  });\n});\n\nvar getCombinedItemDisplacement = (function (_ref) {\n  var displaced = _ref.displaced,\n      afterCritical = _ref.afterCritical,\n      combineWith = _ref.combineWith,\n      displacedBy = _ref.displacedBy;\n  var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n\n  if (didStartAfterCritical(combineWith, afterCritical)) {\n    return isDisplaced ? origin : negate(displacedBy.point);\n  }\n\n  return isDisplaced ? displacedBy.point : origin;\n});\n\nvar whenCombining = (function (_ref) {\n  var afterCritical = _ref.afterCritical,\n      impact = _ref.impact,\n      draggables = _ref.draggables;\n  var combine = tryGetCombine(impact);\n  !combine ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n  var combineWith = combine.draggableId;\n  var center = draggables[combineWith].page.borderBox.center;\n  var displaceBy = getCombinedItemDisplacement({\n    displaced: impact.displaced,\n    afterCritical: afterCritical,\n    combineWith: combineWith,\n    displacedBy: impact.displacedBy\n  });\n  return add(center, displaceBy);\n});\n\nvar distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter(axis, box) {\n  return box.margin[axis.start] + box.borderBox[axis.size] / 2;\n};\n\nvar distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter(axis, box) {\n  return box.margin[axis.end] + box.borderBox[axis.size] / 2;\n};\n\nvar getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter(axis, target, isMoving) {\n  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\n};\n\nvar goAfter = function goAfter(_ref) {\n  var axis = _ref.axis,\n      moveRelativeTo = _ref.moveRelativeTo,\n      isMoving = _ref.isMoving;\n  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goBefore = function goBefore(_ref2) {\n  var axis = _ref2.axis,\n      moveRelativeTo = _ref2.moveRelativeTo,\n      isMoving = _ref2.isMoving;\n  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goIntoStart = function goIntoStart(_ref3) {\n  var axis = _ref3.axis,\n      moveInto = _ref3.moveInto,\n      isMoving = _ref3.isMoving;\n  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\n};\n\nvar whenReordering = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      droppable = _ref.droppable,\n      afterCritical = _ref.afterCritical;\n  var insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  var draggablePage = draggable.page;\n  var axis = droppable.axis;\n\n  if (!insideDestination.length) {\n    return goIntoStart({\n      axis: axis,\n      moveInto: droppable.page,\n      isMoving: draggablePage\n    });\n  }\n\n  var displaced = impact.displaced,\n      displacedBy = impact.displacedBy;\n  var closestAfter = displaced.all[0];\n\n  if (closestAfter) {\n    var closest = draggables[closestAfter];\n\n    if (didStartAfterCritical(closestAfter, afterCritical)) {\n      return goBefore({\n        axis: axis,\n        moveRelativeTo: closest.page,\n        isMoving: draggablePage\n      });\n    }\n\n    var withDisplacement = cssBoxModel.offset(closest.page, displacedBy.point);\n    return goBefore({\n      axis: axis,\n      moveRelativeTo: withDisplacement,\n      isMoving: draggablePage\n    });\n  }\n\n  var last = insideDestination[insideDestination.length - 1];\n\n  if (last.descriptor.id === draggable.descriptor.id) {\n    return draggablePage.borderBox.center;\n  }\n\n  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n    var page = cssBoxModel.offset(last.page, negate(afterCritical.displacedBy.point));\n    return goAfter({\n      axis: axis,\n      moveRelativeTo: page,\n      isMoving: draggablePage\n    });\n  }\n\n  return goAfter({\n    axis: axis,\n    moveRelativeTo: last.page,\n    isMoving: draggablePage\n  });\n});\n\nvar withDroppableDisplacement = (function (droppable, point) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return point;\n  }\n\n  return add(point, frame.scroll.diff.displacement);\n});\n\nvar getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement(_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      afterCritical = _ref.afterCritical;\n  var original = draggable.page.borderBox.center;\n  var at = impact.at;\n\n  if (!droppable) {\n    return original;\n  }\n\n  if (!at) {\n    return original;\n  }\n\n  if (at.type === 'REORDER') {\n    return whenReordering({\n      impact: impact,\n      draggable: draggable,\n      draggables: draggables,\n      droppable: droppable,\n      afterCritical: afterCritical\n    });\n  }\n\n  return whenCombining({\n    impact: impact,\n    draggables: draggables,\n    afterCritical: afterCritical\n  });\n};\n\nvar getPageBorderBoxCenterFromImpact = (function (args) {\n  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n  var droppable = args.droppable;\n  var withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n  return withDisplacement;\n});\n\nvar scrollViewport = (function (viewport, newScroll) {\n  var diff = subtract(newScroll, viewport.scroll.initial);\n  var displacement = negate(diff);\n  var frame = cssBoxModel.getRect({\n    top: newScroll.y,\n    bottom: newScroll.y + viewport.frame.height,\n    left: newScroll.x,\n    right: newScroll.x + viewport.frame.width\n  });\n  var updated = {\n    frame: frame,\n    scroll: {\n      initial: viewport.scroll.initial,\n      max: viewport.scroll.max,\n      current: newScroll,\n      diff: {\n        value: diff,\n        displacement: displacement\n      }\n    }\n  };\n  return updated;\n});\n\nfunction getDraggables(ids, draggables) {\n  return ids.map(function (id) {\n    return draggables[id];\n  });\n}\n\nfunction tryGetVisible(id, groups) {\n  for (var i = 0; i < groups.length; i++) {\n    var displacement = groups[i].visible[id];\n\n    if (displacement) {\n      return displacement;\n    }\n  }\n\n  return null;\n}\n\nvar speculativelyIncrease = (function (_ref) {\n  var impact = _ref.impact,\n      viewport = _ref.viewport,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      maxScrollChange = _ref.maxScrollChange;\n  var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n  var last = impact.displaced;\n  var withViewportScroll = getDisplacementGroups({\n    afterDragging: getDraggables(last.all, draggables),\n    destination: destination,\n    displacedBy: impact.displacedBy,\n    viewport: scrolledViewport.frame,\n    last: last,\n    forceShouldAnimate: false\n  });\n  var withDroppableScroll = getDisplacementGroups({\n    afterDragging: getDraggables(last.all, draggables),\n    destination: scrolledDroppable,\n    displacedBy: impact.displacedBy,\n    viewport: viewport.frame,\n    last: last,\n    forceShouldAnimate: false\n  });\n  var invisible = {};\n  var visible = {};\n  var groups = [last, withViewportScroll, withDroppableScroll];\n  last.all.forEach(function (id) {\n    var displacement = tryGetVisible(id, groups);\n\n    if (displacement) {\n      visible[id] = displacement;\n      return;\n    }\n\n    invisible[id] = true;\n  });\n\n  var newImpact = _extends({}, impact, {\n    displaced: {\n      all: last.all,\n      invisible: invisible,\n      visible: visible\n    }\n  });\n\n  return newImpact;\n});\n\nvar withViewportDisplacement = (function (viewport, point) {\n  return add(viewport.scroll.diff.displacement, point);\n});\n\nvar getClientFromPageBorderBoxCenter = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggable = _ref.draggable,\n      viewport = _ref.viewport;\n  var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n  var offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n  return add(draggable.client.borderBox.center, offset);\n});\n\nvar isTotallyVisibleInNewLocation = (function (_ref) {\n  var draggable = _ref.draggable,\n      destination = _ref.destination,\n      newPageBorderBoxCenter = _ref.newPageBorderBoxCenter,\n      viewport = _ref.viewport,\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\n      _ref$onlyOnMainAxis = _ref.onlyOnMainAxis,\n      onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;\n  var changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n  var shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n  var args = {\n    target: shifted,\n    destination: destination,\n    withDroppableDisplacement: withDroppableDisplacement,\n    viewport: viewport\n  };\n  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n});\n\nvar moveToNextPlace = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      previousClientSelection = _ref.previousClientSelection,\n      afterCritical = _ref.afterCritical;\n\n  if (!destination.isEnabled) {\n    return null;\n  }\n\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var isInHomeList = isHomeOf(draggable, destination);\n  var impact = moveToNextCombine({\n    isMovingForward: isMovingForward,\n    draggable: draggable,\n    destination: destination,\n    insideDestination: insideDestination,\n    previousImpact: previousImpact\n  }) || moveToNextIndex({\n    isMovingForward: isMovingForward,\n    isInHomeList: isInHomeList,\n    draggable: draggable,\n    draggables: draggables,\n    destination: destination,\n    insideDestination: insideDestination,\n    previousImpact: previousImpact,\n    viewport: viewport,\n    afterCritical: afterCritical\n  });\n\n  if (!impact) {\n    return null;\n  }\n\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    afterCritical: afterCritical\n  });\n  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n    draggable: draggable,\n    destination: destination,\n    newPageBorderBoxCenter: pageBorderBoxCenter,\n    viewport: viewport.frame,\n    withDroppableDisplacement: false,\n    onlyOnMainAxis: true\n  });\n\n  if (isVisibleInNewLocation) {\n    var clientSelection = getClientFromPageBorderBoxCenter({\n      pageBorderBoxCenter: pageBorderBoxCenter,\n      draggable: draggable,\n      viewport: viewport\n    });\n    return {\n      clientSelection: clientSelection,\n      impact: impact,\n      scrollJumpRequest: null\n    };\n  }\n\n  var distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n  var cautious = speculativelyIncrease({\n    impact: impact,\n    viewport: viewport,\n    destination: destination,\n    draggables: draggables,\n    maxScrollChange: distance\n  });\n  return {\n    clientSelection: previousClientSelection,\n    impact: cautious,\n    scrollJumpRequest: distance\n  };\n});\n\nvar getKnownActive = function getKnownActive(droppable) {\n  var rect = droppable.subject.active;\n  !rect ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get clipped area from droppable') : invariant(false) : void 0;\n  return rect;\n};\n\nvar getBestCrossAxisDroppable = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      source = _ref.source,\n      droppables = _ref.droppables,\n      viewport = _ref.viewport;\n  var active = source.subject.active;\n\n  if (!active) {\n    return null;\n  }\n\n  var axis = source.axis;\n  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n  var candidates = toDroppableList(droppables).filter(function (droppable) {\n    return droppable !== source;\n  }).filter(function (droppable) {\n    return droppable.isEnabled;\n  }).filter(function (droppable) {\n    return Boolean(droppable.subject.active);\n  }).filter(function (droppable) {\n    return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable));\n  }).filter(function (droppable) {\n    var activeOfTarget = getKnownActive(droppable);\n\n    if (isMovingForward) {\n      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n    }\n\n    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n  }).filter(function (droppable) {\n    var activeOfTarget = getKnownActive(droppable);\n    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n  }).sort(function (a, b) {\n    var first = getKnownActive(a)[axis.crossAxisStart];\n    var second = getKnownActive(b)[axis.crossAxisStart];\n\n    if (isMovingForward) {\n      return first - second;\n    }\n\n    return second - first;\n  }).filter(function (droppable, index, array) {\n    return getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];\n  });\n\n  if (!candidates.length) {\n    return null;\n  }\n\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n\n  var contains = candidates.filter(function (droppable) {\n    var isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n    return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n  });\n\n  if (contains.length === 1) {\n    return contains[0];\n  }\n\n  if (contains.length > 1) {\n    return contains.sort(function (a, b) {\n      return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n  }\n\n  return candidates.sort(function (a, b) {\n    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n\n    if (first !== second) {\n      return first - second;\n    }\n\n    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n  })[0];\n});\n\nvar getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter(draggable, afterCritical) {\n  var original = draggable.page.borderBox.center;\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nvar getCurrentPageBorderBox = function getCurrentPageBorderBox(draggable, afterCritical) {\n  var original = draggable.page.borderBox;\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\n\nvar getClosestDraggable = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      viewport = _ref.viewport,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      afterCritical = _ref.afterCritical;\n  var sorted = insideDestination.filter(function (draggable) {\n    return isTotallyVisible({\n      target: getCurrentPageBorderBox(draggable, afterCritical),\n      destination: destination,\n      viewport: viewport.frame,\n      withDroppableDisplacement: true\n    });\n  }).sort(function (a, b) {\n    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n\n    if (distanceToA < distanceToB) {\n      return -1;\n    }\n\n    if (distanceToB < distanceToA) {\n      return 1;\n    }\n\n    return a.descriptor.index - b.descriptor.index;\n  });\n  return sorted[0] || null;\n});\n\nvar getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {\n  var displacement = displaceBy[axis.line];\n  return {\n    value: displacement,\n    point: patch(axis.line, displacement)\n  };\n});\n\nvar getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables) {\n  var axis = droppable.axis;\n\n  if (droppable.descriptor.mode === 'virtual') {\n    return patch(axis.line, placeholderSize[axis.line]);\n  }\n\n  var availableSpace = droppable.subject.page.contentBox[axis.size];\n  var insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  var spaceUsed = insideDroppable.reduce(function (sum, dimension) {\n    return sum + dimension.client.marginBox[axis.size];\n  }, 0);\n  var requiredSpace = spaceUsed + placeholderSize[axis.line];\n  var needsToGrowBy = requiredSpace - availableSpace;\n\n  if (needsToGrowBy <= 0) {\n    return null;\n  }\n\n  return patch(axis.line, needsToGrowBy);\n};\n\nvar withMaxScroll = function withMaxScroll(frame, max) {\n  return _extends({}, frame, {\n    scroll: _extends({}, frame.scroll, {\n      max: max\n    })\n  });\n};\n\nvar addPlaceholder = function addPlaceholder(droppable, draggable, draggables) {\n  var frame = droppable.frame;\n  !!isHomeOf(draggable, droppable) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not add placeholder space to home list') : invariant(false) : void 0;\n  !!droppable.subject.withPlaceholder ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot add placeholder size to a subject when it already has one') : invariant(false) : void 0;\n  var placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n  var added = {\n    placeholderSize: placeholderSize,\n    increasedBy: requiredGrowth,\n    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n  };\n\n  if (!frame) {\n    var _subject = getSubject({\n      page: droppable.subject.page,\n      withPlaceholder: added,\n      axis: droppable.axis,\n      frame: droppable.frame\n    });\n\n    return _extends({}, droppable, {\n      subject: _subject\n    });\n  }\n\n  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n  var newFrame = withMaxScroll(frame, maxScroll);\n  var subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: added,\n    axis: droppable.axis,\n    frame: newFrame\n  });\n  return _extends({}, droppable, {\n    subject: subject,\n    frame: newFrame\n  });\n};\nvar removePlaceholder = function removePlaceholder(droppable) {\n  var added = droppable.subject.withPlaceholder;\n  !added ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot remove placeholder form subject when there was none') : invariant(false) : void 0;\n  var frame = droppable.frame;\n\n  if (!frame) {\n    var _subject2 = getSubject({\n      page: droppable.subject.page,\n      axis: droppable.axis,\n      frame: null,\n      withPlaceholder: null\n    });\n\n    return _extends({}, droppable, {\n      subject: _subject2\n    });\n  }\n\n  var oldMaxScroll = added.oldFrameMaxScroll;\n  !oldMaxScroll ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected droppable with frame to have old max frame scroll when removing placeholder') : invariant(false) : void 0;\n  var newFrame = withMaxScroll(frame, oldMaxScroll);\n  var subject = getSubject({\n    page: droppable.subject.page,\n    axis: droppable.axis,\n    frame: newFrame,\n    withPlaceholder: null\n  });\n  return _extends({}, droppable, {\n    subject: subject,\n    frame: newFrame\n  });\n};\n\nvar moveToNewDroppable = (function (_ref) {\n  var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      moveRelativeTo = _ref.moveRelativeTo,\n      insideDestination = _ref.insideDestination,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n\n  if (!moveRelativeTo) {\n    if (insideDestination.length) {\n      return null;\n    }\n\n    var proposed = {\n      displaced: emptyGroups,\n      displacedBy: noDisplacedBy,\n      at: {\n        type: 'REORDER',\n        destination: {\n          droppableId: destination.descriptor.id,\n          index: 0\n        }\n      }\n    };\n    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n      impact: proposed,\n      draggable: draggable,\n      droppable: destination,\n      draggables: draggables,\n      afterCritical: afterCritical\n    });\n    var withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n      draggable: draggable,\n      destination: withPlaceholder,\n      newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n      viewport: viewport.frame,\n      withDroppableDisplacement: false,\n      onlyOnMainAxis: true\n    });\n    return isVisibleInNewLocation ? proposed : null;\n  }\n\n  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n\n  var proposedIndex = function () {\n    var relativeTo = moveRelativeTo.descriptor.index;\n\n    if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n      return relativeTo;\n    }\n\n    if (isGoingBeforeTarget) {\n      return relativeTo;\n    }\n\n    return relativeTo + 1;\n  }();\n\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  return calculateReorderImpact({\n    draggable: draggable,\n    insideDestination: insideDestination,\n    destination: destination,\n    viewport: viewport,\n    displacedBy: displacedBy,\n    last: emptyGroups,\n    index: proposedIndex\n  });\n});\n\nvar moveCrossAxis = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      draggable = _ref.draggable,\n      isOver = _ref.isOver,\n      draggables = _ref.draggables,\n      droppables = _ref.droppables,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var destination = getBestCrossAxisDroppable({\n    isMovingForward: isMovingForward,\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    source: isOver,\n    droppables: droppables,\n    viewport: viewport\n  });\n\n  if (!destination) {\n    return null;\n  }\n\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var moveRelativeTo = getClosestDraggable({\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    viewport: viewport,\n    destination: destination,\n    insideDestination: insideDestination,\n    afterCritical: afterCritical\n  });\n  var impact = moveToNewDroppable({\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    destination: destination,\n    draggable: draggable,\n    draggables: draggables,\n    moveRelativeTo: moveRelativeTo,\n    insideDestination: insideDestination,\n    viewport: viewport,\n    afterCritical: afterCritical\n  });\n\n  if (!impact) {\n    return null;\n  }\n\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    afterCritical: afterCritical\n  });\n  var clientSelection = getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    draggable: draggable,\n    viewport: viewport\n  });\n  return {\n    clientSelection: clientSelection,\n    impact: impact,\n    scrollJumpRequest: null\n  };\n});\n\nvar whatIsDraggedOver = (function (impact) {\n  var at = impact.at;\n\n  if (!at) {\n    return null;\n  }\n\n  if (at.type === 'REORDER') {\n    return at.destination.droppableId;\n  }\n\n  return at.combine.droppableId;\n});\n\nvar getDroppableOver = function getDroppableOver(impact, droppables) {\n  var id = whatIsDraggedOver(impact);\n  return id ? droppables[id] : null;\n};\n\nvar moveInDirection = (function (_ref) {\n  var state = _ref.state,\n      type = _ref.type;\n  var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);\n  var isMainAxisMovementAllowed = Boolean(isActuallyOver);\n  var home = state.dimensions.droppables[state.critical.droppable.id];\n  var isOver = isActuallyOver || home;\n  var direction = isOver.axis.direction;\n  var isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');\n\n  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n    return null;\n  }\n\n  var isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\n  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n  var _state$dimensions = state.dimensions,\n      draggables = _state$dimensions.draggables,\n      droppables = _state$dimensions.droppables;\n  return isMovingOnMainAxis ? moveToNextPlace({\n    isMovingForward: isMovingForward,\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    draggable: draggable,\n    destination: isOver,\n    draggables: draggables,\n    viewport: state.viewport,\n    previousClientSelection: state.current.client.selection,\n    previousImpact: state.impact,\n    afterCritical: state.afterCritical\n  }) : moveCrossAxis({\n    isMovingForward: isMovingForward,\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    draggable: draggable,\n    isOver: isOver,\n    draggables: draggables,\n    droppables: droppables,\n    viewport: state.viewport,\n    afterCritical: state.afterCritical\n  });\n});\n\nfunction isMovementAllowed(state) {\n  return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';\n}\n\nvar isPositionInFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (point) {\n    return isWithinVertical(point.y) && isWithinVertical(point.y) && isWithinHorizontal(point.x) && isWithinHorizontal(point.x);\n  };\n});\n\nvar getDroppableOver$1 = (function (_ref) {\n  var target = _ref.target,\n      droppables = _ref.droppables;\n  var maybe = find(toDroppableList(droppables), function (droppable) {\n    if (!droppable.isEnabled) {\n      return false;\n    }\n\n    var active = droppable.subject.active;\n\n    if (!active) {\n      return false;\n    }\n\n    return isPositionInFrame(active)(target);\n  });\n  return maybe ? maybe.descriptor.id : null;\n});\n\nvar withDroppableScroll = (function (droppable, point) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return point;\n  }\n\n  return add(point, frame.scroll.diff.value);\n});\n\nvar isUserMovingForward = (function (axis, direction) {\n  return axis === vertical ? direction.vertical === 'down' : direction.horizontal === 'right';\n});\n\nfunction atIndex(_ref) {\n  var draggable = _ref.draggable,\n      closest = _ref.closest,\n      inHomeList = _ref.inHomeList;\n\n  if (!closest) {\n    return null;\n  }\n\n  if (!inHomeList) {\n    return closest.descriptor.index;\n  }\n\n  if (closest.descriptor.index > draggable.descriptor.index) {\n    return closest.descriptor.index - 1;\n  }\n\n  return closest.descriptor.index;\n}\n\nvar getReorderImpact = (function (_ref2) {\n  var currentCenter = _ref2.pageBorderBoxCenterWithDroppableScrollChange,\n      draggable = _ref2.draggable,\n      destination = _ref2.destination,\n      insideDestination = _ref2.insideDestination,\n      last = _ref2.last,\n      viewport = _ref2.viewport,\n      userDirection = _ref2.userDirection,\n      afterCritical = _ref2.afterCritical;\n  var axis = destination.axis;\n  var isMovingForward = isUserMovingForward(destination.axis, userDirection);\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  var targetCenter = currentCenter[axis.line];\n  var displacement = displacedBy.value;\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  var closest = find(withoutDragging, function (child) {\n    var id = child.descriptor.id;\n    var borderBox = child.page.borderBox;\n    var start = borderBox[axis.start];\n    var end = borderBox[axis.end];\n    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n\n    if (isMovingForward) {\n      if (didStartAfterCritical$1) {\n        return targetCenter < start;\n      }\n\n      return targetCenter < start + displacement;\n    }\n\n    if (didStartAfterCritical$1) {\n      return targetCenter <= end - displacement;\n    }\n\n    return targetCenter <= end;\n  });\n  var newIndex = atIndex({\n    draggable: draggable,\n    closest: closest,\n    inHomeList: isHomeOf(draggable, destination)\n  });\n  return calculateReorderImpact({\n    draggable: draggable,\n    insideDestination: insideDestination,\n    destination: destination,\n    viewport: viewport,\n    last: last,\n    displacedBy: displacedBy,\n    index: newIndex\n  });\n});\n\nfunction getWhenEntered(id, current, lastCombineImpact) {\n  if (!lastCombineImpact) {\n    return current;\n  }\n\n  if (id !== lastCombineImpact.combine.draggableId) {\n    return current;\n  }\n\n  return lastCombineImpact.whenEntered;\n}\n\nfunction tryGetCombineImpact(impact) {\n  if (impact.at && impact.at.type === 'COMBINE') {\n    return impact.at;\n  }\n\n  return null;\n}\n\nfunction calculateCombineImpact(_ref) {\n  var combineWithId = _ref.combineWithId,\n      destinationId = _ref.destinationId,\n      userDirection = _ref.userDirection,\n      previousImpact = _ref.previousImpact;\n  var lastCombineImpact = tryGetCombineImpact(previousImpact);\n  var whenEntered = getWhenEntered(combineWithId, userDirection, lastCombineImpact);\n  var impact = {\n    displacedBy: previousImpact.displacedBy,\n    displaced: previousImpact.displaced,\n    at: {\n      type: 'COMBINE',\n      whenEntered: whenEntered,\n      combine: {\n        draggableId: combineWithId,\n        droppableId: destinationId\n      }\n    }\n  };\n  return impact;\n}\n\nfunction getWhenEntered$1(id, current, lastCombineImpact) {\n  if (!lastCombineImpact) {\n    return current;\n  }\n\n  if (id !== lastCombineImpact.combine.draggableId) {\n    return current;\n  }\n\n  return lastCombineImpact.whenEntered;\n}\n\nvar isCombiningWith = function isCombiningWith(_ref) {\n  var id = _ref.id,\n      currentCenter = _ref.currentCenter,\n      axis = _ref.axis,\n      borderBox = _ref.borderBox,\n      displaceBy = _ref.displaceBy,\n      currentUserDirection = _ref.currentUserDirection,\n      lastCombineImpact = _ref.lastCombineImpact;\n  var start = borderBox[axis.start] + displaceBy[axis.line];\n  var end = borderBox[axis.end] + displaceBy[axis.line];\n  var size = borderBox[axis.size];\n  var twoThirdsOfSize = size * 0.666;\n  var whenEntered = getWhenEntered$1(id, currentUserDirection, lastCombineImpact);\n  var isMovingForward = isUserMovingForward(axis, whenEntered);\n  var targetCenter = currentCenter[axis.line];\n\n  if (isMovingForward) {\n    return isWithin(start, start + twoThirdsOfSize)(targetCenter);\n  }\n\n  return isWithin(end - twoThirdsOfSize, end)(targetCenter);\n};\n\nfunction tryGetCombineImpact$1(impact) {\n  if (impact.at && impact.at.type === 'COMBINE') {\n    return impact.at;\n  }\n\n  return null;\n}\n\nvar getCombineImpact = (function (_ref2) {\n  var draggable = _ref2.draggable,\n      currentCenter = _ref2.pageBorderBoxCenterWithDroppableScrollChange,\n      previousImpact = _ref2.previousImpact,\n      destination = _ref2.destination,\n      insideDestination = _ref2.insideDestination,\n      userDirection = _ref2.userDirection,\n      afterCritical = _ref2.afterCritical;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var axis = destination.axis;\n  var displaced = previousImpact.displaced;\n  var canBeDisplacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  var lastCombineImpact = tryGetCombineImpact$1(previousImpact);\n  var combineWith = find(removeDraggableFromList(draggable, insideDestination), function (child) {\n    var id = child.descriptor.id;\n    var displaceBy = getCombinedItemDisplacement({\n      displaced: displaced,\n      afterCritical: afterCritical,\n      combineWith: id,\n      displacedBy: canBeDisplacedBy\n    });\n    return isCombiningWith({\n      id: id,\n      currentCenter: currentCenter,\n      axis: axis,\n      borderBox: child.page.borderBox,\n      displaceBy: displaceBy,\n      currentUserDirection: userDirection,\n      lastCombineImpact: lastCombineImpact\n    });\n  });\n\n  if (!combineWith) {\n    return null;\n  }\n\n  return calculateCombineImpact({\n    combineWithId: combineWith.descriptor.id,\n    destinationId: destination.descriptor.id,\n    previousImpact: previousImpact,\n    userDirection: userDirection\n  });\n});\n\nvar getDragImpact = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      droppables = _ref.droppables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      userDirection = _ref.userDirection,\n      afterCritical = _ref.afterCritical;\n  var destinationId = getDroppableOver$1({\n    target: pageBorderBoxCenter,\n    droppables: droppables\n  });\n\n  if (!destinationId) {\n    return noImpact;\n  }\n\n  var destination = droppables[destinationId];\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var pageBorderBoxCenterWithDroppableScrollChange = withDroppableScroll(destination, pageBorderBoxCenter);\n  return getCombineImpact({\n    pageBorderBoxCenterWithDroppableScrollChange: pageBorderBoxCenterWithDroppableScrollChange,\n    draggable: draggable,\n    previousImpact: previousImpact,\n    destination: destination,\n    insideDestination: insideDestination,\n    userDirection: userDirection,\n    afterCritical: afterCritical\n  }) || getReorderImpact({\n    pageBorderBoxCenterWithDroppableScrollChange: pageBorderBoxCenterWithDroppableScrollChange,\n    draggable: draggable,\n    destination: destination,\n    insideDestination: insideDestination,\n    last: previousImpact.displaced,\n    viewport: viewport,\n    userDirection: userDirection,\n    afterCritical: afterCritical\n  });\n});\n\nvar getVertical = function getVertical(previous, diff) {\n  if (diff === 0) {\n    return previous;\n  }\n\n  return diff > 0 ? 'down' : 'up';\n};\n\nvar getHorizontal = function getHorizontal(previous, diff) {\n  if (diff === 0) {\n    return previous;\n  }\n\n  return diff > 0 ? 'right' : 'left';\n};\n\nvar getUserDirection = (function (previous, oldPageBorderBoxCenter, newPageBorderBoxCenter) {\n  var diff = subtract(newPageBorderBoxCenter, oldPageBorderBoxCenter);\n  return {\n    horizontal: getHorizontal(previous.horizontal, diff.x),\n    vertical: getVertical(previous.vertical, diff.y)\n  };\n});\n\nvar patchDroppableMap = (function (droppables, updated) {\n  var _extends2;\n\n  return _extends({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));\n});\n\nvar clearUnusedPlaceholder = function clearUnusedPlaceholder(_ref) {\n  var previousImpact = _ref.previousImpact,\n      impact = _ref.impact,\n      droppables = _ref.droppables;\n  var last = whatIsDraggedOver(previousImpact);\n  var now = whatIsDraggedOver(impact);\n\n  if (!last) {\n    return droppables;\n  }\n\n  if (last === now) {\n    return droppables;\n  }\n\n  var lastDroppable = droppables[last];\n\n  if (!lastDroppable.subject.withPlaceholder) {\n    return droppables;\n  }\n\n  var updated = removePlaceholder(lastDroppable);\n  return patchDroppableMap(droppables, updated);\n};\n\nvar recomputePlaceholders = (function (_ref2) {\n  var draggable = _ref2.draggable,\n      draggables = _ref2.draggables,\n      droppables = _ref2.droppables,\n      previousImpact = _ref2.previousImpact,\n      impact = _ref2.impact;\n  var cleaned = clearUnusedPlaceholder({\n    previousImpact: previousImpact,\n    impact: impact,\n    droppables: droppables\n  });\n  var isOver = whatIsDraggedOver(impact);\n\n  if (!isOver) {\n    return cleaned;\n  }\n\n  var droppable = droppables[isOver];\n\n  if (isHomeOf(draggable, droppable)) {\n    return cleaned;\n  }\n\n  if (droppable.subject.withPlaceholder) {\n    return cleaned;\n  }\n\n  var patched = addPlaceholder(droppable, draggable, draggables);\n  return patchDroppableMap(cleaned, patched);\n});\n\nvar update = (function (_ref) {\n  var state = _ref.state,\n      forcedClientSelection = _ref.clientSelection,\n      forcedDimensions = _ref.dimensions,\n      forcedViewport = _ref.viewport,\n      forcedImpact = _ref.impact,\n      scrollJumpRequest = _ref.scrollJumpRequest;\n  var viewport = forcedViewport || state.viewport;\n  var currentWindowScroll = viewport.scroll.current;\n  var dimensions = forcedDimensions || state.dimensions;\n  var clientSelection = forcedClientSelection || state.current.client.selection;\n  var offset = subtract(clientSelection, state.initial.client.selection);\n  var client = {\n    offset: offset,\n    selection: clientSelection,\n    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n  };\n  var page = {\n    selection: add(client.selection, currentWindowScroll),\n    borderBoxCenter: add(client.borderBoxCenter, currentWindowScroll)\n  };\n  var current = {\n    client: client,\n    page: page\n  };\n  var userDirection = getUserDirection(state.userDirection, state.current.page.borderBoxCenter, current.page.borderBoxCenter);\n\n  if (state.phase === 'COLLECTING') {\n    return _extends({\n      phase: 'COLLECTING'\n    }, state, {\n      dimensions: dimensions,\n      viewport: viewport,\n      current: current,\n      userDirection: userDirection\n    });\n  }\n\n  var draggable = dimensions.draggables[state.critical.draggable.id];\n  var newImpact = forcedImpact || getDragImpact({\n    pageBorderBoxCenter: page.borderBoxCenter,\n    draggable: draggable,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact: state.impact,\n    viewport: viewport,\n    userDirection: userDirection,\n    afterCritical: state.afterCritical\n  });\n  var withUpdatedPlaceholders = recomputePlaceholders({\n    draggable: draggable,\n    impact: newImpact,\n    previousImpact: state.impact,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables\n  });\n\n  var result = _extends({}, state, {\n    current: current,\n    userDirection: userDirection,\n    dimensions: {\n      draggables: dimensions.draggables,\n      droppables: withUpdatedPlaceholders\n    },\n    impact: newImpact,\n    viewport: viewport,\n    scrollJumpRequest: scrollJumpRequest || null,\n    forceShouldAnimate: scrollJumpRequest ? false : null\n  });\n\n  return result;\n});\n\nfunction getDraggables$1(ids, draggables) {\n  return ids.map(function (id) {\n    return draggables[id];\n  });\n}\n\nvar recompute = (function (_ref) {\n  var impact = _ref.impact,\n      viewport = _ref.viewport,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      forceShouldAnimate = _ref.forceShouldAnimate;\n  var last = impact.displaced;\n  var afterDragging = getDraggables$1(last.all, draggables);\n  var displaced = getDisplacementGroups({\n    afterDragging: afterDragging,\n    destination: destination,\n    displacedBy: impact.displacedBy,\n    viewport: viewport.frame,\n    forceShouldAnimate: forceShouldAnimate,\n    last: last\n  });\n  return _extends({}, impact, {\n    displaced: displaced\n  });\n});\n\nvar getClientBorderBoxCenter = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    draggables: draggables,\n    droppable: droppable,\n    afterCritical: afterCritical\n  });\n  return getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    draggable: draggable,\n    viewport: viewport\n  });\n});\n\nvar refreshSnap = (function (_ref) {\n  var state = _ref.state,\n      forcedDimensions = _ref.dimensions,\n      forcedViewport = _ref.viewport;\n  !(state.movementMode === 'SNAP') ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n  var needsVisibilityCheck = state.impact;\n  var viewport = forcedViewport || state.viewport;\n  var dimensions = forcedDimensions || state.dimensions;\n  var draggables = dimensions.draggables,\n      droppables = dimensions.droppables;\n  var draggable = draggables[state.critical.draggable.id];\n  var isOver = whatIsDraggedOver(needsVisibilityCheck);\n  !isOver ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Must be over a destination in SNAP movement mode') : invariant(false) : void 0;\n  var destination = droppables[isOver];\n  var impact = recompute({\n    impact: needsVisibilityCheck,\n    viewport: viewport,\n    destination: destination,\n    draggables: draggables\n  });\n  var clientSelection = getClientBorderBoxCenter({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    viewport: viewport,\n    afterCritical: state.afterCritical\n  });\n  return update({\n    impact: impact,\n    clientSelection: clientSelection,\n    state: state,\n    dimensions: dimensions,\n    viewport: viewport\n  });\n});\n\nvar getHomeLocation = (function (descriptor) {\n  return {\n    index: descriptor.index,\n    droppableId: descriptor.droppableId\n  };\n});\n\nvar getLiftEffect = (function (_ref) {\n  var draggable = _ref.draggable,\n      home = _ref.home,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport;\n  var displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n  var insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n  var rawIndex = insideHome.indexOf(draggable);\n  !(rawIndex !== -1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected draggable to be inside home list') : invariant(false) : void 0;\n  var afterDragging = insideHome.slice(rawIndex + 1);\n  var effected = afterDragging.reduce(function (previous, item) {\n    previous[item.descriptor.id] = true;\n    return previous;\n  }, {});\n  var afterCritical = {\n    inVirtualList: home.descriptor.mode === 'virtual',\n    displacedBy: displacedBy,\n    effected: effected\n  };\n  var displaced = getDisplacementGroups({\n    afterDragging: afterDragging,\n    destination: home,\n    displacedBy: displacedBy,\n    last: null,\n    viewport: viewport.frame,\n    forceShouldAnimate: false\n  });\n  var impact = {\n    displaced: displaced,\n    displacedBy: displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: getHomeLocation(draggable.descriptor)\n    }\n  };\n  return {\n    impact: impact,\n    afterCritical: afterCritical\n  };\n});\n\nvar patchDimensionMap = (function (dimensions, updated) {\n  return {\n    draggables: dimensions.draggables,\n    droppables: patchDroppableMap(dimensions.droppables, updated)\n  };\n});\n\nvar records = {};\nvar isEnabled = false;\n\nvar isTimingsEnabled = function isTimingsEnabled() {\n  return isEnabled;\n};\nvar start = function start(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isTimingsEnabled()) {\n      return;\n    }\n\n    var now = performance.now();\n    records[key] = now;\n  }\n};\nvar finish = function finish(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isTimingsEnabled()) {\n      return;\n    }\n\n    var now = performance.now();\n    var previous = records[key];\n\n    if (!previous) {\n      console.warn('cannot finish timing as no previous time found', key);\n      return;\n    }\n\n    var result = now - previous;\n    var rounded = result.toFixed(2);\n\n    var style = function () {\n      if (result < 12) {\n        return {\n          textColor: 'green',\n          symbol: '‚úÖ'\n        };\n      }\n\n      if (result < 40) {\n        return {\n          textColor: 'orange',\n          symbol: '‚ö†Ô∏è'\n        };\n      }\n\n      return {\n        textColor: 'red',\n        symbol: '‚ùå'\n      };\n    }();\n\n    console.log(style.symbol + \" %cTiming %c\" + rounded + \" %cms %c\" + key, 'color: blue; font-weight: bold;', \"color: \" + style.textColor + \"; font-size: 1.1em;\", 'color: grey;', 'color: purple; font-weight: bold;');\n  }\n};\n\nvar offsetDraggable = (function (_ref) {\n  var draggable = _ref.draggable,\n      offset = _ref.offset,\n      initialWindowScroll = _ref.initialWindowScroll;\n  var client = cssBoxModel.offset(draggable.client, offset);\n  var page = cssBoxModel.withScroll(client, initialWindowScroll);\n\n  var moved = _extends({}, draggable, {\n    placeholder: _extends({}, draggable.placeholder, {\n      client: client\n    }),\n    client: client,\n    page: page\n  });\n\n  return moved;\n});\n\nvar getFrame = (function (droppable) {\n  var frame = droppable.frame;\n  !frame ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected Droppable to have a frame') : invariant(false) : void 0;\n  return frame;\n});\n\nvar adjustAdditionsForScrollChanges = (function (_ref) {\n  var additions = _ref.additions,\n      updatedDroppables = _ref.updatedDroppables,\n      viewport = _ref.viewport;\n  var windowScrollChange = viewport.scroll.diff.value;\n  return additions.map(function (draggable) {\n    var droppableId = draggable.descriptor.droppableId;\n    var modified = updatedDroppables[droppableId];\n    var frame = getFrame(modified);\n    var droppableScrollChange = frame.scroll.diff.value;\n    var totalChange = add(windowScrollChange, droppableScrollChange);\n    var moved = offsetDraggable({\n      draggable: draggable,\n      offset: totalChange,\n      initialWindowScroll: viewport.scroll.initial\n    });\n    return moved;\n  });\n});\n\nvar timingsKey = 'Processing dynamic changes';\nvar publishWhileDraggingInVirtual = (function (_ref) {\n  var _extends2, _extends3;\n\n  var state = _ref.state,\n      published = _ref.published;\n  start(timingsKey);\n  var withScrollChange = published.modified.map(function (update) {\n    var existing = state.dimensions.droppables[update.droppableId];\n    var scrolled = scrollDroppable(existing, update.scroll);\n    return scrolled;\n  });\n\n  var droppables = _extends({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));\n\n  var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n    additions: published.additions,\n    updatedDroppables: droppables,\n    viewport: state.viewport\n  }));\n\n  var draggables = _extends({}, state.dimensions.draggables, {}, updatedAdditions);\n\n  published.removals.forEach(function (id) {\n    delete draggables[id];\n  });\n  var dimensions = {\n    droppables: droppables,\n    draggables: draggables\n  };\n  var wasOverId = whatIsDraggedOver(state.impact);\n  var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n  var draggable = dimensions.draggables[state.critical.draggable.id];\n  var home = dimensions.droppables[state.critical.droppable.id];\n\n  var _getLiftEffect = getLiftEffect({\n    draggable: draggable,\n    home: home,\n    draggables: draggables,\n    viewport: state.viewport\n  }),\n      onLiftImpact = _getLiftEffect.impact,\n      afterCritical = _getLiftEffect.afterCritical;\n\n  var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n  var impact = getDragImpact({\n    pageBorderBoxCenter: state.current.page.borderBoxCenter,\n    draggable: dimensions.draggables[state.critical.draggable.id],\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact: previousImpact,\n    viewport: state.viewport,\n    userDirection: state.userDirection,\n    afterCritical: afterCritical\n  });\n  finish(timingsKey);\n\n  var draggingState = _extends({\n    phase: 'DRAGGING'\n  }, state, (_extends2 = {}, _extends2[\"phase\"] = 'DRAGGING', _extends2.impact = impact, _extends2.onLiftImpact = onLiftImpact, _extends2.dimensions = dimensions, _extends2.afterCritical = afterCritical, _extends2.forceShouldAnimate = false, _extends2));\n\n  if (state.phase === 'COLLECTING') {\n    return draggingState;\n  }\n\n  var dropPending = _extends({\n    phase: 'DROP_PENDING'\n  }, draggingState, (_extends3 = {}, _extends3[\"phase\"] = 'DROP_PENDING', _extends3.reason = state.reason, _extends3.isWaiting = false, _extends3));\n\n  return dropPending;\n});\n\nvar isSnapping = function isSnapping(state) {\n  return state.movementMode === 'SNAP';\n};\n\nvar postDroppableChange = function postDroppableChange(state, updated, isEnabledChanging) {\n  var dimensions = patchDimensionMap(state.dimensions, updated);\n\n  if (!isSnapping(state) || isEnabledChanging) {\n    return update({\n      state: state,\n      dimensions: dimensions\n    });\n  }\n\n  return refreshSnap({\n    state: state,\n    dimensions: dimensions\n  });\n};\n\nfunction removeScrollJumpRequest(state) {\n  if (state.isDragging && state.movementMode === 'SNAP') {\n    return _extends({\n      phase: 'DRAGGING'\n    }, state, {\n      scrollJumpRequest: null\n    });\n  }\n\n  return state;\n}\n\nvar idle = {\n  phase: 'IDLE',\n  completed: null,\n  shouldFlush: false\n};\nvar reducer = (function (state, action) {\n  if (state === void 0) {\n    state = idle;\n  }\n\n  if (action.type === 'FLUSH') {\n    return _extends({}, idle, {\n      shouldFlush: true\n    });\n  }\n\n  if (action.type === 'INITIAL_PUBLISH') {\n    !(state.phase === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INITIAL_PUBLISH must come after a IDLE phase') : invariant(false) : void 0;\n    var _action$payload = action.payload,\n        critical = _action$payload.critical,\n        clientSelection = _action$payload.clientSelection,\n        viewport = _action$payload.viewport,\n        dimensions = _action$payload.dimensions,\n        movementMode = _action$payload.movementMode;\n    var draggable = dimensions.draggables[critical.draggable.id];\n    var home = dimensions.droppables[critical.droppable.id];\n    var client = {\n      selection: clientSelection,\n      borderBoxCenter: draggable.client.borderBox.center,\n      offset: origin\n    };\n    var initial = {\n      client: client,\n      page: {\n        selection: add(client.selection, viewport.scroll.initial),\n        borderBoxCenter: add(client.selection, viewport.scroll.initial)\n      }\n    };\n    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function (item) {\n      return !item.isFixedOnPage;\n    });\n\n    var _getLiftEffect = getLiftEffect({\n      draggable: draggable,\n      home: home,\n      draggables: dimensions.draggables,\n      viewport: viewport\n    }),\n        impact = _getLiftEffect.impact,\n        afterCritical = _getLiftEffect.afterCritical;\n\n    var result = {\n      phase: 'DRAGGING',\n      isDragging: true,\n      critical: critical,\n      movementMode: movementMode,\n      dimensions: dimensions,\n      initial: initial,\n      current: initial,\n      isWindowScrollAllowed: isWindowScrollAllowed,\n      impact: impact,\n      afterCritical: afterCritical,\n      onLiftImpact: impact,\n      viewport: viewport,\n      userDirection: forward,\n      scrollJumpRequest: null,\n      forceShouldAnimate: null\n    };\n    return result;\n  }\n\n  if (action.type === 'COLLECTION_STARTING') {\n    var _extends2;\n\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Collection cannot start from phase \" + state.phase) : invariant(false) : void 0;\n\n    var _result = _extends({\n      phase: 'COLLECTING'\n    }, state, (_extends2 = {}, _extends2[\"phase\"] = 'COLLECTING', _extends2));\n\n    return _result;\n  }\n\n  if (action.type === 'PUBLISH_WHILE_DRAGGING') {\n    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Unexpected \" + action.type + \" received in phase \" + state.phase) : invariant(false) : void 0;\n    return publishWhileDraggingInVirtual({\n      state: state,\n      published: action.payload\n    });\n  }\n\n  if (action.type === 'MOVE') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : invariant(false) : void 0;\n    var _clientSelection = action.payload.client;\n\n    if (isEqual(_clientSelection, state.current.client.selection)) {\n      return state;\n    }\n\n    return update({\n      state: state,\n      clientSelection: _clientSelection,\n      impact: isSnapping(state) ? state.impact : null\n    });\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_SCROLL') {\n    if (state.phase === 'DROP_PENDING') {\n      return removeScrollJumpRequest(state);\n    }\n\n    if (state.phase === 'COLLECTING') {\n      return removeScrollJumpRequest(state);\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload2 = action.payload,\n        id = _action$payload2.id,\n        newScroll = _action$payload2.newScroll;\n    var target = state.dimensions.droppables[id];\n\n    if (!target) {\n      return state;\n    }\n\n    var scrolled = scrollDroppable(target, newScroll);\n    return postDroppableChange(state, scrolled, false);\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload3 = action.payload,\n        _id = _action$payload3.id,\n        isEnabled = _action$payload3.isEnabled;\n    var _target = state.dimensions.droppables[_id];\n    !_target ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find Droppable[id: \" + _id + \"] to toggle its enabled state\") : invariant(false) : void 0;\n    !(_target.isEnabled !== isEnabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Trying to set droppable isEnabled to \" + String(isEnabled) + \"\\n      but it is already \" + String(_target.isEnabled)) : invariant(false) : void 0;\n\n    var updated = _extends({}, _target, {\n      isEnabled: isEnabled\n    });\n\n    return postDroppableChange(state, updated, true);\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload4 = action.payload,\n        _id2 = _action$payload4.id,\n        isCombineEnabled = _action$payload4.isCombineEnabled;\n    var _target2 = state.dimensions.droppables[_id2];\n    !_target2 ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find Droppable[id: \" + _id2 + \"] to toggle its isCombineEnabled state\") : invariant(false) : void 0;\n    !(_target2.isCombineEnabled !== isCombineEnabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Trying to set droppable isCombineEnabled to \" + String(isCombineEnabled) + \"\\n      but it is already \" + String(_target2.isCombineEnabled)) : invariant(false) : void 0;\n\n    var _updated = _extends({}, _target2, {\n      isCombineEnabled: isCombineEnabled\n    });\n\n    return postDroppableChange(state, _updated, true);\n  }\n\n  if (action.type === 'MOVE_BY_WINDOW_SCROLL') {\n    if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot move by window in phase \" + state.phase) : invariant(false) : void 0;\n    !state.isWindowScrollAllowed ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Window scrolling is currently not supported for fixed lists') : invariant(false) : void 0;\n    var _newScroll = action.payload.newScroll;\n\n    if (isEqual(state.viewport.scroll.current, _newScroll)) {\n      return removeScrollJumpRequest(state);\n    }\n\n    var _viewport = scrollViewport(state.viewport, _newScroll);\n\n    if (isSnapping(state)) {\n      return refreshSnap({\n        state: state,\n        viewport: _viewport\n      });\n    }\n\n    return update({\n      state: state,\n      viewport: _viewport\n    });\n  }\n\n  if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {\n    if (!isMovementAllowed(state)) {\n      return state;\n    }\n\n    var maxScroll = action.payload.maxScroll;\n\n    if (isEqual(maxScroll, state.viewport.scroll.max)) {\n      return state;\n    }\n\n    var withMaxScroll = _extends({}, state.viewport, {\n      scroll: _extends({}, state.viewport.scroll, {\n        max: maxScroll\n      })\n    });\n\n    return _extends({\n      phase: 'DRAGGING'\n    }, state, {\n      viewport: withMaxScroll\n    });\n  }\n\n  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" received while not in DRAGGING phase\") : invariant(false) : void 0;\n\n    var _result2 = moveInDirection({\n      state: state,\n      type: action.type\n    });\n\n    if (!_result2) {\n      return state;\n    }\n\n    return update({\n      state: state,\n      impact: _result2.impact,\n      clientSelection: _result2.clientSelection,\n      scrollJumpRequest: _result2.scrollJumpRequest\n    });\n  }\n\n  if (action.type === 'DROP_PENDING') {\n    var _extends3;\n\n    var reason = action.payload.reason;\n    !(state.phase === 'COLLECTING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only move into the DROP_PENDING phase from the COLLECTING phase') : invariant(false) : void 0;\n\n    var newState = _extends({\n      phase: 'DROP_PENDING'\n    }, state, (_extends3 = {}, _extends3[\"phase\"] = 'DROP_PENDING', _extends3.isWaiting = true, _extends3.reason = reason, _extends3));\n\n    return newState;\n  }\n\n  if (action.type === 'DROP_ANIMATE') {\n    var _action$payload5 = action.payload,\n        completed = _action$payload5.completed,\n        dropDuration = _action$payload5.dropDuration,\n        newHomeClientOffset = _action$payload5.newHomeClientOffset;\n    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot animate drop from phase \" + state.phase) : invariant(false) : void 0;\n    var _result3 = {\n      phase: 'DROP_ANIMATING',\n      completed: completed,\n      dropDuration: dropDuration,\n      newHomeClientOffset: newHomeClientOffset,\n      dimensions: state.dimensions\n    };\n    return _result3;\n  }\n\n  if (action.type === 'DROP_COMPLETE') {\n    var _completed = action.payload.completed;\n    return {\n      phase: 'IDLE',\n      completed: _completed,\n      shouldFlush: false\n    };\n  }\n\n  return state;\n});\n\nvar lift = function lift(args) {\n  return {\n    type: 'LIFT',\n    payload: args\n  };\n};\nvar initialPublish = function initialPublish(args) {\n  return {\n    type: 'INITIAL_PUBLISH',\n    payload: args\n  };\n};\nvar publishWhileDragging = function publishWhileDragging(args) {\n  return {\n    type: 'PUBLISH_WHILE_DRAGGING',\n    payload: args\n  };\n};\nvar collectionStarting = function collectionStarting() {\n  return {\n    type: 'COLLECTION_STARTING',\n    payload: null\n  };\n};\nvar updateDroppableScroll = function updateDroppableScroll(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_SCROLL',\n    payload: args\n  };\n};\nvar updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_IS_ENABLED',\n    payload: args\n  };\n};\nvar updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',\n    payload: args\n  };\n};\nvar move = function move(args) {\n  return {\n    type: 'MOVE',\n    payload: args\n  };\n};\nvar moveByWindowScroll = function moveByWindowScroll(args) {\n  return {\n    type: 'MOVE_BY_WINDOW_SCROLL',\n    payload: args\n  };\n};\nvar updateViewportMaxScroll = function updateViewportMaxScroll(args) {\n  return {\n    type: 'UPDATE_VIEWPORT_MAX_SCROLL',\n    payload: args\n  };\n};\nvar moveUp = function moveUp() {\n  return {\n    type: 'MOVE_UP',\n    payload: null\n  };\n};\nvar moveDown = function moveDown() {\n  return {\n    type: 'MOVE_DOWN',\n    payload: null\n  };\n};\nvar moveRight = function moveRight() {\n  return {\n    type: 'MOVE_RIGHT',\n    payload: null\n  };\n};\nvar moveLeft = function moveLeft() {\n  return {\n    type: 'MOVE_LEFT',\n    payload: null\n  };\n};\nvar flush = function flush() {\n  return {\n    type: 'FLUSH',\n    payload: null\n  };\n};\nvar animateDrop = function animateDrop(args) {\n  return {\n    type: 'DROP_ANIMATE',\n    payload: args\n  };\n};\nvar completeDrop = function completeDrop(args) {\n  return {\n    type: 'DROP_COMPLETE',\n    payload: args\n  };\n};\nvar drop = function drop(args) {\n  return {\n    type: 'DROP',\n    payload: args\n  };\n};\nvar dropPending = function dropPending(args) {\n  return {\n    type: 'DROP_PENDING',\n    payload: args\n  };\n};\nvar dropAnimationFinished = function dropAnimationFinished() {\n  return {\n    type: 'DROP_ANIMATION_FINISHED',\n    payload: null\n  };\n};\n\nfunction checkIndexes(insideDestination) {\n  if (insideDestination.length <= 1) {\n    return;\n  }\n\n  var indexes = insideDestination.map(function (d) {\n    return d.descriptor.index;\n  });\n  var errors = {};\n\n  for (var i = 1; i < indexes.length; i++) {\n    var current = indexes[i];\n    var previous = indexes[i - 1];\n\n    if (current !== previous + 1) {\n      errors[current] = true;\n    }\n  }\n\n  if (!_Object$keys(errors).length) {\n    return;\n  }\n\n  var formatted = indexes.map(function (index) {\n    var hasError = Boolean(errors[index]);\n    return hasError ? \"[\\uD83D\\uDD25\" + index + \"]\" : \"\" + index;\n  }).join(', ');\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    Detected non-consecutive <Draggable /> indexes.\\n\\n    (This can cause unexpected bugs)\\n\\n    \" + formatted + \"\\n  \") : void 0;\n}\n\nfunction validateDimensions(critical, dimensions) {\n  if (process.env.NODE_ENV !== 'production') {\n    var insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n    checkIndexes(insideDestination);\n  }\n}\n\nvar lift$1 = (function (marshal) {\n  return function (_ref) {\n    var getState = _ref.getState,\n        dispatch = _ref.dispatch;\n    return function (next) {\n      return function (action) {\n        if (action.type !== 'LIFT') {\n          next(action);\n          return;\n        }\n\n        var _action$payload = action.payload,\n            id = _action$payload.id,\n            clientSelection = _action$payload.clientSelection,\n            movementMode = _action$payload.movementMode;\n        var initial = getState();\n\n        if (initial.phase === 'DROP_ANIMATING') {\n          dispatch(completeDrop({\n            completed: initial.completed\n          }));\n        }\n\n        !(getState().phase === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unexpected phase to start a drag') : invariant(false) : void 0;\n        dispatch(flush());\n        var scrollOptions = {\n          shouldPublishImmediately: movementMode === 'SNAP'\n        };\n        var request = {\n          draggableId: id,\n          scrollOptions: scrollOptions\n        };\n\n        var _marshal$startPublish = marshal.startPublishing(request),\n            critical = _marshal$startPublish.critical,\n            dimensions = _marshal$startPublish.dimensions,\n            viewport = _marshal$startPublish.viewport;\n\n        validateDimensions(critical, dimensions);\n        dispatch(initialPublish({\n          critical: critical,\n          dimensions: dimensions,\n          clientSelection: clientSelection,\n          movementMode: movementMode,\n          viewport: viewport\n        }));\n      };\n    };\n  };\n});\n\nvar style = (function (marshal) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          marshal.dragging();\n        }\n\n        if (action.type === 'DROP_ANIMATE') {\n          marshal.dropping(action.payload.completed.result.reason);\n        }\n\n        if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE') {\n          marshal.resting();\n        }\n\n        next(action);\n      };\n    };\n  };\n});\n\nvar curves = {\n  outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',\n  drop: 'cubic-bezier(.2,1,.1,1)'\n};\nvar combine = {\n  opacity: {\n    drop: 0,\n    combining: 0.7\n  },\n  scale: {\n    drop: 0.75\n  }\n};\nvar timings = {\n  outOfTheWay: 0.2,\n  minDropTime: 0.33,\n  maxDropTime: 0.55\n};\nvar outOfTheWayTiming = timings.outOfTheWay + \"s \" + curves.outOfTheWay;\nvar transitions = {\n  fluid: \"opacity \" + outOfTheWayTiming,\n  snap: \"transform \" + outOfTheWayTiming + \", opacity \" + outOfTheWayTiming,\n  drop: function drop(duration) {\n    var timing = duration + \"s \" + curves.drop;\n    return \"transform \" + timing + \", opacity \" + timing;\n  },\n  outOfTheWay: \"transform \" + outOfTheWayTiming,\n  placeholder: \"height \" + outOfTheWayTiming + \", width \" + outOfTheWayTiming + \", margin \" + outOfTheWayTiming\n};\n\nvar moveTo = function moveTo(offset) {\n  return isEqual(offset, origin) ? null : \"translate(\" + offset.x + \"px, \" + offset.y + \"px)\";\n};\n\nvar transforms = {\n  moveTo: moveTo,\n  drop: function drop(offset, isCombining) {\n    var translate = moveTo(offset);\n\n    if (!translate) {\n      return null;\n    }\n\n    if (!isCombining) {\n      return translate;\n    }\n\n    return translate + \" scale(\" + combine.scale.drop + \")\";\n  }\n};\n\nvar minDropTime = timings.minDropTime,\n    maxDropTime = timings.maxDropTime;\nvar dropTimeRange = maxDropTime - minDropTime;\nvar maxDropTimeAtDistance = 1500;\nvar cancelDropModifier = 0.6;\nvar getDropDuration = (function (_ref) {\n  var current = _ref.current,\n      destination = _ref.destination,\n      reason = _ref.reason;\n  var distance$1 = distance(current, destination);\n\n  if (distance$1 <= 0) {\n    return minDropTime;\n  }\n\n  if (distance$1 >= maxDropTimeAtDistance) {\n    return maxDropTime;\n  }\n\n  var percentage = distance$1 / maxDropTimeAtDistance;\n  var duration = minDropTime + dropTimeRange * percentage;\n  var withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;\n  return Number(withDuration.toFixed(2));\n});\n\nvar getNewHomeClientOffset = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      dimensions = _ref.dimensions,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var draggables = dimensions.draggables,\n      droppables = dimensions.droppables;\n  var droppableId = whatIsDraggedOver(impact);\n  var destination = droppableId ? droppables[droppableId] : null;\n  var home = droppables[draggable.descriptor.droppableId];\n  var newClientCenter = getClientBorderBoxCenter({\n    impact: impact,\n    draggable: draggable,\n    draggables: draggables,\n    afterCritical: afterCritical,\n    droppable: destination || home,\n    viewport: viewport\n  });\n  var offset = subtract(newClientCenter, draggable.client.borderBox.center);\n  return offset;\n});\n\nvar getDropImpact = (function (_ref) {\n  var draggables = _ref.draggables,\n      reason = _ref.reason,\n      lastImpact = _ref.lastImpact,\n      home = _ref.home,\n      viewport = _ref.viewport,\n      onLiftImpact = _ref.onLiftImpact;\n\n  if (!lastImpact.at || reason !== 'DROP') {\n    var recomputedHomeImpact = recompute({\n      draggables: draggables,\n      impact: onLiftImpact,\n      destination: home,\n      viewport: viewport,\n      forceShouldAnimate: true\n    });\n    return {\n      impact: recomputedHomeImpact,\n      didDropInsideDroppable: false\n    };\n  }\n\n  if (lastImpact.at.type === 'REORDER') {\n    return {\n      impact: lastImpact,\n      didDropInsideDroppable: true\n    };\n  }\n\n  var withoutMovement = _extends({}, lastImpact, {\n    displaced: emptyGroups\n  });\n\n  return {\n    impact: withoutMovement,\n    didDropInsideDroppable: true\n  };\n});\n\nvar drop$1 = (function (_ref) {\n  var getState = _ref.getState,\n      dispatch = _ref.dispatch;\n  return function (next) {\n    return function (action) {\n      if (action.type !== 'DROP') {\n        next(action);\n        return;\n      }\n\n      var state = getState();\n      var reason = action.payload.reason;\n\n      if (state.phase === 'COLLECTING') {\n        dispatch(dropPending({\n          reason: reason\n        }));\n        return;\n      }\n\n      if (state.phase === 'IDLE') {\n        return;\n      }\n\n      var isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;\n      !!isWaitingForDrop ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : invariant(false) : void 0;\n      !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot drop in phase: \" + state.phase) : invariant(false) : void 0;\n      var critical = state.critical;\n      var dimensions = state.dimensions;\n      var draggable = dimensions.draggables[state.critical.draggable.id];\n\n      var _getDropImpact = getDropImpact({\n        reason: reason,\n        lastImpact: state.impact,\n        afterCritical: state.afterCritical,\n        onLiftImpact: state.onLiftImpact,\n        home: state.dimensions.droppables[state.critical.droppable.id],\n        viewport: state.viewport,\n        draggables: state.dimensions.draggables\n      }),\n          impact = _getDropImpact.impact,\n          didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;\n\n      var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n      var combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n      var source = {\n        index: critical.draggable.index,\n        droppableId: critical.droppable.id\n      };\n      var result = {\n        draggableId: draggable.descriptor.id,\n        type: draggable.descriptor.type,\n        source: source,\n        reason: reason,\n        mode: state.movementMode,\n        destination: destination,\n        combine: combine\n      };\n      var newHomeClientOffset = getNewHomeClientOffset({\n        impact: impact,\n        draggable: draggable,\n        dimensions: dimensions,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n      });\n      var completed = {\n        critical: state.critical,\n        afterCritical: state.afterCritical,\n        result: result,\n        impact: impact\n      };\n      var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n\n      if (!isAnimationRequired) {\n        dispatch(completeDrop({\n          completed: completed\n        }));\n        return;\n      }\n\n      var dropDuration = getDropDuration({\n        current: state.current.client.offset,\n        destination: newHomeClientOffset,\n        reason: reason\n      });\n      var args = {\n        newHomeClientOffset: newHomeClientOffset,\n        dropDuration: dropDuration,\n        completed: completed\n      };\n      dispatch(animateDrop(args));\n    };\n  };\n});\n\nvar getWindowScroll = (function () {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset\n  };\n});\n\nfunction getWindowScrollBinding(update) {\n  return {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: function fn(event) {\n      if (event.target !== window && event.target !== window.document) {\n        return;\n      }\n\n      update();\n    }\n  };\n}\n\nfunction getScrollListener(_ref) {\n  var onWindowScroll = _ref.onWindowScroll;\n\n  function updateScroll() {\n    onWindowScroll(getWindowScroll());\n  }\n\n  var scheduled = rafSchd(updateScroll);\n  var binding = getWindowScrollBinding(scheduled);\n  var unbind = noop;\n\n  function isActive() {\n    return unbind !== noop;\n  }\n\n  function start() {\n    !!isActive() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start scroll listener when already active') : invariant(false) : void 0;\n    unbind = bindEvents(window, [binding]);\n  }\n\n  function stop() {\n    !isActive() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot stop scroll listener when not active') : invariant(false) : void 0;\n    scheduled.cancel();\n    unbind();\n    unbind = noop;\n  }\n\n  return {\n    start: start,\n    stop: stop,\n    isActive: isActive\n  };\n}\n\nvar shouldEnd = function shouldEnd(action) {\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';\n};\n\nvar scrollListener = (function (store) {\n  var listener = getScrollListener({\n    onWindowScroll: function onWindowScroll(newScroll) {\n      store.dispatch(moveByWindowScroll({\n        newScroll: newScroll\n      }));\n    }\n  });\n  return function (next) {\n    return function (action) {\n      if (!listener.isActive() && action.type === 'INITIAL_PUBLISH') {\n        listener.start();\n      }\n\n      if (listener.isActive() && shouldEnd(action)) {\n        listener.stop();\n      }\n\n      next(action);\n    };\n  };\n});\n\nvar getExpiringAnnounce = (function (announce) {\n  var wasCalled = false;\n  var isExpired = false;\n  var timeoutId = setTimeout(function () {\n    isExpired = true;\n  });\n\n  var result = function result(message) {\n    if (wasCalled) {\n      process.env.NODE_ENV !== \"production\" ? warning('Announcement already made. Not making a second announcement') : void 0;\n      return;\n    }\n\n    if (isExpired) {\n      process.env.NODE_ENV !== \"production\" ? warning(\"\\n        Announcements cannot be made asynchronously.\\n        Default message has already been announced.\\n      \") : void 0;\n      return;\n    }\n\n    wasCalled = true;\n    announce(message);\n    clearTimeout(timeoutId);\n  };\n\n  result.wasCalled = function () {\n    return wasCalled;\n  };\n\n  return result;\n});\n\nvar getAsyncMarshal = (function () {\n  var entries = [];\n\n  var execute = function execute(timerId) {\n    var index = findIndex(entries, function (item) {\n      return item.timerId === timerId;\n    });\n    !(index !== -1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find timer') : invariant(false) : void 0;\n\n    var _entries$splice = entries.splice(index, 1),\n        entry = _entries$splice[0];\n\n    entry.callback();\n  };\n\n  var add = function add(fn) {\n    var timerId = setTimeout(function () {\n      return execute(timerId);\n    });\n    var entry = {\n      timerId: timerId,\n      callback: fn\n    };\n    entries.push(entry);\n  };\n\n  var flush = function flush() {\n    if (!entries.length) {\n      return;\n    }\n\n    var shallow = [].concat(entries);\n    entries.length = 0;\n    shallow.forEach(function (entry) {\n      clearTimeout(entry.timerId);\n      entry.callback();\n    });\n  };\n\n  return {\n    add: add,\n    flush: flush\n  };\n});\n\nvar areLocationsEqual = function areLocationsEqual(first, second) {\n  if (first == null && second == null) {\n    return true;\n  }\n\n  if (first == null || second == null) {\n    return false;\n  }\n\n  return first.droppableId === second.droppableId && first.index === second.index;\n};\nvar isCombineEqual = function isCombineEqual(first, second) {\n  if (first == null && second == null) {\n    return true;\n  }\n\n  if (first == null || second == null) {\n    return false;\n  }\n\n  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nvar isCriticalEqual = function isCriticalEqual(first, second) {\n  if (first === second) {\n    return true;\n  }\n\n  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n  return isDraggableEqual && isDroppableEqual;\n};\n\nvar withTimings = function withTimings(key, fn) {\n  start(key);\n  fn();\n  finish(key);\n};\n\nvar getDragStart = function getDragStart(critical, mode) {\n  return {\n    draggableId: critical.draggable.id,\n    type: critical.droppable.type,\n    source: {\n      droppableId: critical.droppable.id,\n      index: critical.draggable.index\n    },\n    mode: mode\n  };\n};\n\nvar execute = function execute(responder, data, announce, getDefaultMessage) {\n  if (!responder) {\n    announce(getDefaultMessage(data));\n    return;\n  }\n\n  var willExpire = getExpiringAnnounce(announce);\n  var provided = {\n    announce: willExpire\n  };\n  responder(data, provided);\n\n  if (!willExpire.wasCalled()) {\n    announce(getDefaultMessage(data));\n  }\n};\n\nvar getPublisher = (function (getResponders, announce) {\n  var asyncMarshal = getAsyncMarshal();\n  var dragging = null;\n\n  var beforeStart = function beforeStart(critical, mode) {\n    !!dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\n    withTimings('onBeforeDragStart', function () {\n      var fn = getResponders().onBeforeDragStart;\n\n      if (fn) {\n        fn(getDragStart(critical, mode));\n      }\n    });\n  };\n\n  var start = function start(critical, mode) {\n    !!dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\n    var data = getDragStart(critical, mode);\n    dragging = {\n      mode: mode,\n      lastCritical: critical,\n      lastLocation: data.source,\n      lastCombine: null\n    };\n    asyncMarshal.add(function () {\n      withTimings('onDragStart', function () {\n        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);\n      });\n    });\n  };\n\n  var update = function update(critical, impact) {\n    var location = tryGetDestination(impact);\n    var combine = tryGetCombine(impact);\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : invariant(false) : void 0;\n    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n\n    if (hasCriticalChanged) {\n      dragging.lastCritical = critical;\n    }\n\n    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n\n    if (hasLocationChanged) {\n      dragging.lastLocation = location;\n    }\n\n    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n\n    if (hasGroupingChanged) {\n      dragging.lastCombine = combine;\n    }\n\n    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n      return;\n    }\n\n    var data = _extends({}, getDragStart(critical, dragging.mode), {\n      combine: combine,\n      destination: location\n    });\n\n    asyncMarshal.add(function () {\n      withTimings('onDragUpdate', function () {\n        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);\n      });\n    });\n  };\n\n  var flush = function flush() {\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only flush responders while dragging') : invariant(false) : void 0;\n    asyncMarshal.flush();\n  };\n\n  var drop = function drop(result) {\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onDragEnd when there is no matching onDragStart') : invariant(false) : void 0;\n    dragging = null;\n    withTimings('onDragEnd', function () {\n      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);\n    });\n  };\n\n  var abort = function abort() {\n    if (!dragging) {\n      return;\n    }\n\n    var result = _extends({}, getDragStart(dragging.lastCritical, dragging.mode), {\n      combine: null,\n      destination: null,\n      reason: 'CANCEL'\n    });\n\n    drop(result);\n  };\n\n  return {\n    beforeStart: beforeStart,\n    start: start,\n    update: update,\n    flush: flush,\n    drop: drop,\n    abort: abort\n  };\n});\n\nvar responders = (function (getResponders, announce) {\n  var publisher = getPublisher(getResponders, announce);\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          var critical = action.payload.critical;\n          publisher.beforeStart(critical, action.payload.movementMode);\n          next(action);\n          publisher.start(critical, action.payload.movementMode);\n          return;\n        }\n\n        if (action.type === 'DROP_COMPLETE') {\n          var result = action.payload.completed.result;\n          publisher.flush();\n          next(action);\n          publisher.drop(result);\n          return;\n        }\n\n        next(action);\n\n        if (action.type === 'FLUSH') {\n          publisher.abort();\n          return;\n        }\n\n        var state = store.getState();\n\n        if (state.phase === 'DRAGGING') {\n          publisher.update(state.critical, state.impact);\n        }\n      };\n    };\n  };\n});\n\nvar dropAnimationFinish = (function (store) {\n  return function (next) {\n    return function (action) {\n      if (action.type !== 'DROP_ANIMATION_FINISHED') {\n        next(action);\n        return;\n      }\n\n      var state = store.getState();\n      !(state.phase === 'DROP_ANIMATING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot finish a drop animating when no drop is occurring') : invariant(false) : void 0;\n      store.dispatch(completeDrop({\n        completed: state.completed\n      }));\n    };\n  };\n});\n\nvar dropAnimationFlushOnScroll = (function (store) {\n  var unbind = null;\n  var frameId = null;\n\n  function clear() {\n    if (frameId) {\n      cancelAnimationFrame(frameId);\n      frameId = null;\n    }\n\n    if (unbind) {\n      unbind();\n      unbind = null;\n    }\n  }\n\n  return function (next) {\n    return function (action) {\n      if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATION_FINISHED') {\n        clear();\n      }\n\n      next(action);\n\n      if (action.type !== 'DROP_ANIMATE') {\n        return;\n      }\n\n      var binding = {\n        eventName: 'scroll',\n        options: {\n          capture: true,\n          passive: false,\n          once: true\n        },\n        fn: function flushDropAnimation() {\n          var state = store.getState();\n\n          if (state.phase === 'DROP_ANIMATING') {\n            store.dispatch(dropAnimationFinished());\n          }\n        }\n      };\n      frameId = requestAnimationFrame(function () {\n        frameId = null;\n        unbind = bindEvents(window, [binding]);\n      });\n    };\n  };\n});\n\nvar dimensionMarshalStopper = (function (marshal) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' || action.type === 'DROP_ANIMATE') {\n          marshal.stopPublishing();\n        }\n\n        next(action);\n      };\n    };\n  };\n});\n\nvar focus = (function (marshal) {\n  var isWatching = false;\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          isWatching = true;\n          marshal.tryRecordFocus(action.payload.critical.draggable.id);\n          next(action);\n          marshal.tryRestoreFocusRecorded();\n          return;\n        }\n\n        next(action);\n\n        if (!isWatching) {\n          return;\n        }\n\n        if (action.type === 'FLUSH') {\n          isWatching = false;\n          marshal.tryRestoreFocusRecorded();\n          return;\n        }\n\n        if (action.type === 'DROP_COMPLETE') {\n          isWatching = false;\n          var result = action.payload.completed.result;\n\n          if (result.combine) {\n            marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n          }\n\n          marshal.tryRestoreFocusRecorded();\n        }\n      };\n    };\n  };\n});\n\nvar shouldStop = function shouldStop(action) {\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';\n};\n\nvar autoScroll = (function (autoScroller) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (shouldStop(action)) {\n          autoScroller.stop();\n          next(action);\n          return;\n        }\n\n        if (action.type === 'INITIAL_PUBLISH') {\n          next(action);\n          var state = store.getState();\n          !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected phase to be DRAGGING after INITIAL_PUBLISH') : invariant(false) : void 0;\n          autoScroller.start(state);\n          return;\n        }\n\n        next(action);\n        autoScroller.scroll(store.getState());\n      };\n    };\n  };\n});\n\nvar pendingDrop = (function (store) {\n  return function (next) {\n    return function (action) {\n      next(action);\n\n      if (action.type !== 'PUBLISH_WHILE_DRAGGING') {\n        return;\n      }\n\n      var postActionState = store.getState();\n\n      if (postActionState.phase !== 'DROP_PENDING') {\n        return;\n      }\n\n      if (postActionState.isWaiting) {\n        return;\n      }\n\n      store.dispatch(drop({\n        reason: postActionState.reason\n      }));\n    };\n  };\n});\n\nvar composeEnhancers = process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : redux.compose;\nvar createStore = (function (_ref) {\n  var dimensionMarshal = _ref.dimensionMarshal,\n      focusMarshal = _ref.focusMarshal,\n      styleMarshal = _ref.styleMarshal,\n      getResponders = _ref.getResponders,\n      announce = _ref.announce,\n      autoScroller = _ref.autoScroller;\n  return redux.createStore(reducer, composeEnhancers(redux.applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\n});\n\nvar clean$1 = function clean() {\n  return {\n    additions: {},\n    removals: {},\n    modified: {}\n  };\n};\n\nvar timingKey = 'Publish collection from DOM';\nfunction createPublisher(_ref) {\n  var registry = _ref.registry,\n      callbacks = _ref.callbacks;\n  var staging = clean$1();\n  var frameId = null;\n\n  var collect = function collect() {\n    if (frameId) {\n      return;\n    }\n\n    callbacks.collectionStarting();\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      start(timingKey);\n      var _staging = staging,\n          additions = _staging.additions,\n          removals = _staging.removals,\n          modified = _staging.modified;\n\n      var added = _Object$keys(additions).map(function (id) {\n        return registry.draggable.getById(id).getDimension(origin);\n      }).sort(function (a, b) {\n        return a.descriptor.index - b.descriptor.index;\n      });\n\n      var updated = _Object$keys(modified).map(function (id) {\n        var entry = registry.droppable.getById(id);\n        var scroll = entry.callbacks.getScrollWhileDragging();\n        return {\n          droppableId: id,\n          scroll: scroll\n        };\n      });\n\n      var result = {\n        additions: added,\n        removals: _Object$keys(removals),\n        modified: updated\n      };\n      staging = clean$1();\n      finish(timingKey);\n      callbacks.publish(result);\n    });\n  };\n\n  var add = function add(entry) {\n    var id = entry.descriptor.id;\n    staging.additions[id] = entry;\n    staging.modified[entry.descriptor.droppableId] = true;\n\n    if (staging.removals[id]) {\n      delete staging.removals[id];\n    }\n\n    collect();\n  };\n\n  var remove = function remove(entry) {\n    var descriptor = entry.descriptor;\n    staging.removals[descriptor.id] = true;\n    staging.modified[descriptor.droppableId] = true;\n\n    if (staging.additions[descriptor.id]) {\n      delete staging.additions[descriptor.id];\n    }\n\n    collect();\n  };\n\n  var stop = function stop() {\n    if (!frameId) {\n      return;\n    }\n\n    cancelAnimationFrame(frameId);\n    frameId = null;\n    staging = clean$1();\n  };\n\n  return {\n    add: add,\n    remove: remove,\n    stop: stop\n  };\n}\n\nvar getMaxScroll = (function (_ref) {\n  var scrollHeight = _ref.scrollHeight,\n      scrollWidth = _ref.scrollWidth,\n      height = _ref.height,\n      width = _ref.width;\n  var maxScroll = subtract({\n    x: scrollWidth,\n    y: scrollHeight\n  }, {\n    x: width,\n    y: height\n  });\n  var adjustedMaxScroll = {\n    x: Math.max(0, maxScroll.x),\n    y: Math.max(0, maxScroll.y)\n  };\n  return adjustedMaxScroll;\n});\n\nvar getDocumentElement = (function () {\n  var doc = document.documentElement;\n  !doc ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find document.documentElement') : invariant(false) : void 0;\n  return doc;\n});\n\nvar getMaxWindowScroll = (function () {\n  var doc = getDocumentElement();\n  var maxScroll = getMaxScroll({\n    scrollHeight: doc.scrollHeight,\n    scrollWidth: doc.scrollWidth,\n    width: doc.clientWidth,\n    height: doc.clientHeight\n  });\n  return maxScroll;\n});\n\nvar getViewport = (function () {\n  var scroll = getWindowScroll();\n  var maxScroll = getMaxWindowScroll();\n  var top = scroll.y;\n  var left = scroll.x;\n  var doc = getDocumentElement();\n  var width = doc.clientWidth;\n  var height = doc.clientHeight;\n  var right = left + width;\n  var bottom = top + height;\n  var frame = cssBoxModel.getRect({\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom\n  });\n  var viewport = {\n    frame: frame,\n    scroll: {\n      initial: scroll,\n      current: scroll,\n      max: maxScroll,\n      diff: {\n        value: origin,\n        displacement: origin\n      }\n    }\n  };\n  return viewport;\n});\n\nvar getInitialPublish = (function (_ref) {\n  var critical = _ref.critical,\n      scrollOptions = _ref.scrollOptions,\n      registry = _ref.registry;\n  var timingKey = 'Initial collection from DOM';\n  start(timingKey);\n  var viewport = getViewport();\n  var windowScroll = viewport.scroll.current;\n  var home = critical.droppable;\n  var droppables = registry.droppable.getAllByType(home.type).map(function (entry) {\n    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);\n  });\n  var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function (entry) {\n    return entry.getDimension(windowScroll);\n  });\n  var dimensions = {\n    draggables: toDraggableMap(draggables),\n    droppables: toDroppableMap(droppables)\n  };\n  finish(timingKey);\n  var result = {\n    dimensions: dimensions,\n    critical: critical,\n    viewport: viewport\n  };\n  return result;\n});\n\nfunction shouldPublishUpdate(registry, dragging, entry) {\n  if (entry.descriptor.id === dragging.id) {\n    return false;\n  }\n\n  if (entry.descriptor.type !== dragging.type) {\n    return false;\n  }\n\n  var home = registry.droppable.getById(entry.descriptor.droppableId);\n\n  if (home.descriptor.mode !== 'virtual') {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      You are attempting to add or remove a Draggable [id: \" + entry.descriptor.id + \"]\\n      while a drag is occurring. This is only supported for virtual lists.\\n\\n      See https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/patterns/virtual-lists.md\\n    \") : void 0;\n    return false;\n  }\n\n  return true;\n}\n\nvar createDimensionMarshal = (function (registry, callbacks) {\n  var collection = null;\n  var publisher = createPublisher({\n    callbacks: {\n      publish: callbacks.publishWhileDragging,\n      collectionStarting: callbacks.collectionStarting\n    },\n    registry: registry\n  });\n\n  var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update is enabled flag of Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (!collection) {\n      return;\n    }\n\n    callbacks.updateDroppableIsEnabled({\n      id: id,\n      isEnabled: isEnabled\n    });\n  };\n\n  var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(id, isCombineEnabled) {\n    if (!collection) {\n      return;\n    }\n\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update isCombineEnabled flag of Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n    callbacks.updateDroppableIsCombineEnabled({\n      id: id,\n      isCombineEnabled: isCombineEnabled\n    });\n  };\n\n  var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {\n    if (!collection) {\n      return;\n    }\n\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update the scroll on Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n    callbacks.updateDroppableScroll({\n      id: id,\n      newScroll: newScroll\n    });\n  };\n\n  var scrollDroppable = function scrollDroppable(id, change) {\n    if (!collection) {\n      return;\n    }\n\n    registry.droppable.getById(id).callbacks.scroll(change);\n  };\n\n  var stopPublishing = function stopPublishing() {\n    if (!collection) {\n      return;\n    }\n\n    publisher.stop();\n    var home = collection.critical.droppable;\n    registry.droppable.getAllByType(home.type).forEach(function (entry) {\n      return entry.callbacks.dragStopped();\n    });\n    collection.unsubscribe();\n    collection = null;\n  };\n\n  var subscriber = function subscriber(event) {\n    !collection ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should only be subscribed when a collection is occurring') : invariant(false) : void 0;\n    var dragging = collection.critical.draggable;\n\n    if (event.type === 'ADDITION') {\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\n        publisher.add(event.value);\n      }\n    }\n\n    if (event.type === 'REMOVAL') {\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\n        publisher.remove(event.value);\n      }\n    }\n  };\n\n  var startPublishing = function startPublishing(request) {\n    !!collection ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start capturing critical dimensions as there is already a collection') : invariant(false) : void 0;\n    var entry = registry.draggable.getById(request.draggableId);\n    var home = registry.droppable.getById(entry.descriptor.droppableId);\n    var critical = {\n      draggable: entry.descriptor,\n      droppable: home.descriptor\n    };\n    var unsubscribe = registry.subscribe(subscriber);\n    collection = {\n      critical: critical,\n      unsubscribe: unsubscribe\n    };\n    return getInitialPublish({\n      critical: critical,\n      registry: registry,\n      scrollOptions: request.scrollOptions\n    });\n  };\n\n  var marshal = {\n    updateDroppableIsEnabled: updateDroppableIsEnabled,\n    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n    scrollDroppable: scrollDroppable,\n    updateDroppableScroll: updateDroppableScroll,\n    startPublishing: startPublishing,\n    stopPublishing: stopPublishing\n  };\n  return marshal;\n});\n\nvar canStartDrag = (function (state, id) {\n  if (state.phase === 'IDLE') {\n    return true;\n  }\n\n  if (state.phase !== 'DROP_ANIMATING') {\n    return false;\n  }\n\n  if (state.completed.result.draggableId === id) {\n    return false;\n  }\n\n  return state.completed.result.reason === 'DROP';\n});\n\nvar scrollWindow = (function (change) {\n  window.scrollBy(change.x, change.y);\n});\n\nvar getScrollableDroppables = memoizeOne(function (droppables) {\n  return toDroppableList(droppables).filter(function (droppable) {\n    if (!droppable.isEnabled) {\n      return false;\n    }\n\n    if (!droppable.frame) {\n      return false;\n    }\n\n    return true;\n  });\n});\n\nvar getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {\n  var maybe = find(getScrollableDroppables(droppables), function (droppable) {\n    !droppable.frame ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid result') : invariant(false) : void 0;\n    return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n  });\n  return maybe;\n};\n\nvar getBestScrollableDroppable = (function (_ref) {\n  var center = _ref.center,\n      destination = _ref.destination,\n      droppables = _ref.droppables;\n\n  if (destination) {\n    var _dimension = droppables[destination];\n\n    if (!_dimension.frame) {\n      return null;\n    }\n\n    return _dimension;\n  }\n\n  var dimension = getScrollableDroppableOver(center, droppables);\n  return dimension;\n});\n\nvar config = {\n  startFromPercentage: 0.25,\n  maxScrollAtPercentage: 0.05,\n  maxPixelScroll: 28,\n  ease: function ease(percentage) {\n    return Math.pow(percentage, 2);\n  },\n  durationDampening: {\n    stopDampeningAt: 1200,\n    accelerateAt: 360\n  }\n};\n\nvar getDistanceThresholds = (function (container, axis) {\n  var startScrollingFrom = container[axis.size] * config.startFromPercentage;\n  var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;\n  var thresholds = {\n    startScrollingFrom: startScrollingFrom,\n    maxScrollValueAt: maxScrollValueAt\n  };\n  return thresholds;\n});\n\nvar getPercentage = (function (_ref) {\n  var startOfRange = _ref.startOfRange,\n      endOfRange = _ref.endOfRange,\n      current = _ref.current;\n  var range = endOfRange - startOfRange;\n\n  if (range === 0) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Detected distance range of 0 in the fluid auto scroller\\n      This is unexpected and would cause a divide by 0 issue.\\n      Not allowing an auto scroll\\n    \") : void 0;\n    return 0;\n  }\n\n  var currentInRange = current - startOfRange;\n  var percentage = currentInRange / range;\n  return percentage;\n});\n\nvar minScroll = 1;\n\nvar getValueFromDistance = (function (distanceToEdge, thresholds) {\n  if (distanceToEdge > thresholds.startScrollingFrom) {\n    return 0;\n  }\n\n  if (distanceToEdge <= thresholds.maxScrollValueAt) {\n    return config.maxPixelScroll;\n  }\n\n  if (distanceToEdge === thresholds.startScrollingFrom) {\n    return minScroll;\n  }\n\n  var percentageFromMaxScrollValueAt = getPercentage({\n    startOfRange: thresholds.maxScrollValueAt,\n    endOfRange: thresholds.startScrollingFrom,\n    current: distanceToEdge\n  });\n  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n  var scroll = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);\n  return Math.ceil(scroll);\n});\n\nvar accelerateAt = config.durationDampening.accelerateAt;\nvar stopAt = config.durationDampening.stopDampeningAt;\nvar dampenValueByTime = (function (proposedScroll, dragStartTime) {\n  var startOfRange = dragStartTime;\n  var endOfRange = stopAt;\n\n  var now = _Date$now();\n\n  var runTime = now - startOfRange;\n\n  if (runTime >= stopAt) {\n    return proposedScroll;\n  }\n\n  if (runTime < accelerateAt) {\n    return minScroll;\n  }\n\n  var betweenAccelerateAtAndStopAtPercentage = getPercentage({\n    startOfRange: accelerateAt,\n    endOfRange: endOfRange,\n    current: runTime\n  });\n  var scroll = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);\n  return Math.ceil(scroll);\n});\n\nvar getValue = (function (_ref) {\n  var distanceToEdge = _ref.distanceToEdge,\n      thresholds = _ref.thresholds,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var scroll = getValueFromDistance(distanceToEdge, thresholds);\n\n  if (scroll === 0) {\n    return 0;\n  }\n\n  if (!shouldUseTimeDampening) {\n    return scroll;\n  }\n\n  return Math.max(dampenValueByTime(scroll, dragStartTime), minScroll);\n});\n\nvar getScrollOnAxis = (function (_ref) {\n  var container = _ref.container,\n      distanceToEdges = _ref.distanceToEdges,\n      dragStartTime = _ref.dragStartTime,\n      axis = _ref.axis,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var thresholds = getDistanceThresholds(container, axis);\n  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n\n  if (isCloserToEnd) {\n    return getValue({\n      distanceToEdge: distanceToEdges[axis.end],\n      thresholds: thresholds,\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n  }\n\n  return -1 * getValue({\n    distanceToEdge: distanceToEdges[axis.start],\n    thresholds: thresholds,\n    dragStartTime: dragStartTime,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n});\n\nvar adjustForSizeLimits = (function (_ref) {\n  var container = _ref.container,\n      subject = _ref.subject,\n      proposedScroll = _ref.proposedScroll;\n  var isTooBigVertically = subject.height > container.height;\n  var isTooBigHorizontally = subject.width > container.width;\n\n  if (!isTooBigHorizontally && !isTooBigVertically) {\n    return proposedScroll;\n  }\n\n  if (isTooBigHorizontally && isTooBigVertically) {\n    return null;\n  }\n\n  return {\n    x: isTooBigHorizontally ? 0 : proposedScroll.x,\n    y: isTooBigVertically ? 0 : proposedScroll.y\n  };\n});\n\nvar clean$2 = apply(function (value) {\n  return value === 0 ? 0 : value;\n});\nvar getScroll = (function (_ref) {\n  var dragStartTime = _ref.dragStartTime,\n      container = _ref.container,\n      subject = _ref.subject,\n      center = _ref.center,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var distanceToEdges = {\n    top: center.y - container.top,\n    right: container.right - center.x,\n    bottom: container.bottom - center.y,\n    left: center.x - container.left\n  };\n  var y = getScrollOnAxis({\n    container: container,\n    distanceToEdges: distanceToEdges,\n    dragStartTime: dragStartTime,\n    axis: vertical,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  var x = getScrollOnAxis({\n    container: container,\n    distanceToEdges: distanceToEdges,\n    dragStartTime: dragStartTime,\n    axis: horizontal,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  var required = clean$2({\n    x: x,\n    y: y\n  });\n\n  if (isEqual(required, origin)) {\n    return null;\n  }\n\n  var limited = adjustForSizeLimits({\n    container: container,\n    subject: subject,\n    proposedScroll: required\n  });\n\n  if (!limited) {\n    return null;\n  }\n\n  return isEqual(limited, origin) ? null : limited;\n});\n\nvar smallestSigned = apply(function (value) {\n  if (value === 0) {\n    return 0;\n  }\n\n  return value > 0 ? 1 : -1;\n});\nvar getOverlap = function () {\n  var getRemainder = function getRemainder(target, max) {\n    if (target < 0) {\n      return target;\n    }\n\n    if (target > max) {\n      return target - max;\n    }\n\n    return 0;\n  };\n\n  return function (_ref) {\n    var current = _ref.current,\n        max = _ref.max,\n        change = _ref.change;\n    var targetScroll = add(current, change);\n    var overlap = {\n      x: getRemainder(targetScroll.x, max.x),\n      y: getRemainder(targetScroll.y, max.y)\n    };\n\n    if (isEqual(overlap, origin)) {\n      return null;\n    }\n\n    return overlap;\n  };\n}();\nvar canPartiallyScroll = function canPartiallyScroll(_ref2) {\n  var rawMax = _ref2.max,\n      current = _ref2.current,\n      change = _ref2.change;\n  var max = {\n    x: Math.max(current.x, rawMax.x),\n    y: Math.max(current.y, rawMax.y)\n  };\n  var smallestChange = smallestSigned(change);\n  var overlap = getOverlap({\n    max: max,\n    current: current,\n    change: smallestChange\n  });\n\n  if (!overlap) {\n    return true;\n  }\n\n  if (smallestChange.x !== 0 && overlap.x === 0) {\n    return true;\n  }\n\n  if (smallestChange.y !== 0 && overlap.y === 0) {\n    return true;\n  }\n\n  return false;\n};\nvar canScrollWindow = function canScrollWindow(viewport, change) {\n  return canPartiallyScroll({\n    current: viewport.scroll.current,\n    max: viewport.scroll.max,\n    change: change\n  });\n};\nvar getWindowOverlap = function getWindowOverlap(viewport, change) {\n  if (!canScrollWindow(viewport, change)) {\n    return null;\n  }\n\n  var max = viewport.scroll.max;\n  var current = viewport.scroll.current;\n  return getOverlap({\n    current: current,\n    max: max,\n    change: change\n  });\n};\nvar canScrollDroppable = function canScrollDroppable(droppable, change) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return false;\n  }\n\n  return canPartiallyScroll({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change: change\n  });\n};\nvar getDroppableOverlap = function getDroppableOverlap(droppable, change) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return null;\n  }\n\n  if (!canScrollDroppable(droppable, change)) {\n    return null;\n  }\n\n  return getOverlap({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change: change\n  });\n};\n\nvar getWindowScrollChange = (function (_ref) {\n  var viewport = _ref.viewport,\n      subject = _ref.subject,\n      center = _ref.center,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var scroll = getScroll({\n    dragStartTime: dragStartTime,\n    container: viewport.frame,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n});\n\nvar getDroppableScrollChange = (function (_ref) {\n  var droppable = _ref.droppable,\n      subject = _ref.subject,\n      center = _ref.center,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return null;\n  }\n\n  var scroll = getScroll({\n    dragStartTime: dragStartTime,\n    container: frame.pageMarginBox,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n});\n\nvar scroll$1 = (function (_ref) {\n  var state = _ref.state,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening,\n      scrollWindow = _ref.scrollWindow,\n      scrollDroppable = _ref.scrollDroppable;\n  var center = state.current.page.borderBoxCenter;\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\n  var subject = draggable.page.marginBox;\n\n  if (state.isWindowScrollAllowed) {\n    var viewport = state.viewport;\n\n    var _change = getWindowScrollChange({\n      dragStartTime: dragStartTime,\n      viewport: viewport,\n      subject: subject,\n      center: center,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n\n    if (_change) {\n      scrollWindow(_change);\n      return;\n    }\n  }\n\n  var droppable = getBestScrollableDroppable({\n    center: center,\n    destination: whatIsDraggedOver(state.impact),\n    droppables: state.dimensions.droppables\n  });\n\n  if (!droppable) {\n    return;\n  }\n\n  var change = getDroppableScrollChange({\n    dragStartTime: dragStartTime,\n    droppable: droppable,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n\n  if (change) {\n    scrollDroppable(droppable.descriptor.id, change);\n  }\n});\n\nvar createFluidScroller = (function (_ref) {\n  var scrollWindow = _ref.scrollWindow,\n      scrollDroppable = _ref.scrollDroppable;\n  var scheduleWindowScroll = rafSchd(scrollWindow);\n  var scheduleDroppableScroll = rafSchd(scrollDroppable);\n  var dragging = null;\n\n  var tryScroll = function tryScroll(state) {\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fluid scroll if not dragging') : invariant(false) : void 0;\n    var _dragging = dragging,\n        shouldUseTimeDampening = _dragging.shouldUseTimeDampening,\n        dragStartTime = _dragging.dragStartTime;\n    scroll$1({\n      state: state,\n      scrollWindow: scheduleWindowScroll,\n      scrollDroppable: scheduleDroppableScroll,\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n  };\n\n  var start$1 = function start$1(state) {\n    start('starting fluid scroller');\n    !!dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start auto scrolling when already started') : invariant(false) : void 0;\n\n    var dragStartTime = _Date$now();\n\n    var wasScrollNeeded = false;\n\n    var fakeScrollCallback = function fakeScrollCallback() {\n      wasScrollNeeded = true;\n    };\n\n    scroll$1({\n      state: state,\n      dragStartTime: 0,\n      shouldUseTimeDampening: false,\n      scrollWindow: fakeScrollCallback,\n      scrollDroppable: fakeScrollCallback\n    });\n    dragging = {\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: wasScrollNeeded\n    };\n    finish('starting fluid scroller');\n\n    if (wasScrollNeeded) {\n      tryScroll(state);\n    }\n  };\n\n  var stop = function stop() {\n    if (!dragging) {\n      return;\n    }\n\n    scheduleWindowScroll.cancel();\n    scheduleDroppableScroll.cancel();\n    dragging = null;\n  };\n\n  return {\n    start: start$1,\n    stop: stop,\n    scroll: tryScroll\n  };\n});\n\nvar createJumpScroller = (function (_ref) {\n  var move = _ref.move,\n      scrollDroppable = _ref.scrollDroppable,\n      scrollWindow = _ref.scrollWindow;\n\n  var moveByOffset = function moveByOffset(state, offset) {\n    var client = add(state.current.client.selection, offset);\n    move({\n      client: client\n    });\n  };\n\n  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {\n    if (!canScrollDroppable(droppable, change)) {\n      return change;\n    }\n\n    var overlap = getDroppableOverlap(droppable, change);\n\n    if (!overlap) {\n      scrollDroppable(droppable.descriptor.id, change);\n      return null;\n    }\n\n    var whatTheDroppableCanScroll = subtract(change, overlap);\n    scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n    var remainder = subtract(change, whatTheDroppableCanScroll);\n    return remainder;\n  };\n\n  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(isWindowScrollAllowed, viewport, change) {\n    if (!isWindowScrollAllowed) {\n      return change;\n    }\n\n    if (!canScrollWindow(viewport, change)) {\n      return change;\n    }\n\n    var overlap = getWindowOverlap(viewport, change);\n\n    if (!overlap) {\n      scrollWindow(change);\n      return null;\n    }\n\n    var whatTheWindowCanScroll = subtract(change, overlap);\n    scrollWindow(whatTheWindowCanScroll);\n    var remainder = subtract(change, whatTheWindowCanScroll);\n    return remainder;\n  };\n\n  var jumpScroller = function jumpScroller(state) {\n    var request = state.scrollJumpRequest;\n\n    if (!request) {\n      return;\n    }\n\n    var destination = whatIsDraggedOver(state.impact);\n    !destination ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : invariant(false) : void 0;\n    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n\n    if (!droppableRemainder) {\n      return;\n    }\n\n    var viewport = state.viewport;\n    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n\n    if (!windowRemainder) {\n      return;\n    }\n\n    moveByOffset(state, windowRemainder);\n  };\n\n  return jumpScroller;\n});\n\nvar createAutoScroller = (function (_ref) {\n  var scrollDroppable = _ref.scrollDroppable,\n      scrollWindow = _ref.scrollWindow,\n      move = _ref.move;\n  var fluidScroller = createFluidScroller({\n    scrollWindow: scrollWindow,\n    scrollDroppable: scrollDroppable\n  });\n  var jumpScroll = createJumpScroller({\n    move: move,\n    scrollWindow: scrollWindow,\n    scrollDroppable: scrollDroppable\n  });\n\n  var scroll = function scroll(state) {\n    if (state.phase !== 'DRAGGING') {\n      return;\n    }\n\n    if (state.movementMode === 'FLUID') {\n      fluidScroller.scroll(state);\n      return;\n    }\n\n    if (!state.scrollJumpRequest) {\n      return;\n    }\n\n    jumpScroll(state);\n  };\n\n  var scroller = {\n    scroll: scroll,\n    start: fluidScroller.start,\n    stop: fluidScroller.stop\n  };\n  return scroller;\n});\n\nvar prefix$1 = 'data-rbd';\nvar dragHandle = function () {\n  var base = prefix$1 + \"-drag-handle\";\n  return {\n    base: base,\n    draggableId: base + \"-draggable-id\",\n    contextId: base + \"-context-id\"\n  };\n}();\nvar draggable = function () {\n  var base = prefix$1 + \"-draggable\";\n  return {\n    base: base,\n    contextId: base + \"-context-id\",\n    id: base + \"-id\"\n  };\n}();\nvar droppable = function () {\n  var base = prefix$1 + \"-droppable\";\n  return {\n    base: base,\n    contextId: base + \"-context-id\",\n    id: base + \"-id\"\n  };\n}();\nvar scrollContainer = {\n  contextId: prefix$1 + \"-scroll-container-context-id\"\n};\n\nvar makeGetSelector = function makeGetSelector(context) {\n  return function (attribute) {\n    return \"[\" + attribute + \"=\\\"\" + context + \"\\\"]\";\n  };\n};\n\nvar getStyles = function getStyles(rules, property) {\n  return rules.map(function (rule) {\n    var value = rule.styles[property];\n\n    if (!value) {\n      return '';\n    }\n\n    return rule.selector + \" { \" + value + \" }\";\n  }).join(' ');\n};\n\nvar noPointerEvents = 'pointer-events: none;';\nvar getStyles$1 = (function (contextId) {\n  var getSelector = makeGetSelector(contextId);\n\n  var dragHandle$1 = function () {\n    var grabCursor = \"\\n      cursor: -webkit-grab;\\n      cursor: grab;\\n    \";\n    return {\n      selector: getSelector(dragHandle.contextId),\n      styles: {\n        always: \"\\n          -webkit-touch-callout: none;\\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\\n          touch-action: manipulation;\\n        \",\n        resting: grabCursor,\n        dragging: noPointerEvents,\n        dropAnimating: grabCursor\n      }\n    };\n  }();\n\n  var draggable$1 = function () {\n    var transition = \"\\n      transition: \" + transitions.outOfTheWay + \";\\n    \";\n    return {\n      selector: getSelector(draggable.contextId),\n      styles: {\n        dragging: transition,\n        dropAnimating: transition,\n        userCancel: transition\n      }\n    };\n  }();\n\n  var droppable$1 = {\n    selector: getSelector(droppable.contextId),\n    styles: {\n      always: \"overflow-anchor: none;\"\n    }\n  };\n  var body = {\n    selector: 'body',\n    styles: {\n      dragging: \"\\n        cursor: grabbing;\\n        cursor: -webkit-grabbing;\\n        user-select: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        overflow-anchor: none;\\n      \"\n    }\n  };\n  var rules = [draggable$1, dragHandle$1, droppable$1, body];\n  return {\n    always: getStyles(rules, 'always'),\n    resting: getStyles(rules, 'resting'),\n    dragging: getStyles(rules, 'dragging'),\n    dropAnimating: getStyles(rules, 'dropAnimating'),\n    userCancel: getStyles(rules, 'userCancel')\n  };\n});\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nvar getHead = function getHead() {\n  var head = document.querySelector('head');\n  !head ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find the head to append a style to') : invariant(false) : void 0;\n  return head;\n};\n\nvar createStyleEl = function createStyleEl(nonce) {\n  var el = document.createElement('style');\n\n  if (nonce) {\n    el.setAttribute('nonce', nonce);\n  }\n\n  el.type = 'text/css';\n  return el;\n};\n\nfunction useStyleMarshal(contextId, nonce) {\n  var styles = useMemoOne.useMemo(function () {\n    return getStyles$1(contextId);\n  }, [contextId]);\n  var alwaysRef = React.useRef(null);\n  var dynamicRef = React.useRef(null);\n  var setDynamicStyle = useMemoOne.useCallback(memoizeOne(function (proposed) {\n    var el = dynamicRef.current;\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;\n    el.textContent = proposed;\n  }), []);\n  var setAlwaysStyle = useMemoOne.useCallback(function (proposed) {\n    var el = alwaysRef.current;\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;\n    el.textContent = proposed;\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    !(!alwaysRef.current && !dynamicRef.current) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'style elements already mounted') : invariant(false) : void 0;\n    var always = createStyleEl(nonce);\n    var dynamic = createStyleEl(nonce);\n    alwaysRef.current = always;\n    dynamicRef.current = dynamic;\n    always.setAttribute(prefix$1 + \"-always\", contextId);\n    dynamic.setAttribute(prefix$1 + \"-dynamic\", contextId);\n    getHead().appendChild(always);\n    getHead().appendChild(dynamic);\n    setAlwaysStyle(styles.always);\n    setDynamicStyle(styles.resting);\n    return function () {\n      var remove = function remove(ref) {\n        var current = ref.current;\n        !current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot unmount ref as it is not set') : invariant(false) : void 0;\n        getHead().removeChild(current);\n        ref.current = null;\n      };\n\n      remove(alwaysRef);\n      remove(dynamicRef);\n    };\n  }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);\n  var dragging = useMemoOne.useCallback(function () {\n    return setDynamicStyle(styles.dragging);\n  }, [setDynamicStyle, styles.dragging]);\n  var dropping = useMemoOne.useCallback(function (reason) {\n    if (reason === 'DROP') {\n      setDynamicStyle(styles.dropAnimating);\n      return;\n    }\n\n    setDynamicStyle(styles.userCancel);\n  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);\n  var resting = useMemoOne.useCallback(function () {\n    if (!dynamicRef.current) {\n      return;\n    }\n\n    setDynamicStyle(styles.resting);\n  }, [setDynamicStyle, styles.resting]);\n  var marshal = useMemoOne.useMemo(function () {\n    return {\n      dragging: dragging,\n      dropping: dropping,\n      resting: resting\n    };\n  }, [dragging, dropping, resting]);\n  return marshal;\n}\n\nvar getWindowFromEl = (function (el) {\n  return el && el.ownerDocument ? el.ownerDocument.defaultView : window;\n});\n\nfunction isHtmlElement(el) {\n  return el instanceof getWindowFromEl(el).HTMLElement;\n}\n\nfunction findDragHandle(contextId, draggableId) {\n  var selector = \"[\" + dragHandle.contextId + \"=\\\"\" + contextId + \"\\\"]\";\n  var possible = toArray(document.querySelectorAll(selector));\n\n  if (!possible.length) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"Unable to find any drag handles in the context \\\"\" + contextId + \"\\\"\") : void 0;\n    return null;\n  }\n\n  var handle = find(possible, function (el) {\n    return el.getAttribute(dragHandle.draggableId) === draggableId;\n  });\n\n  if (!handle) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"Unable to find drag handle with id \\\"\" + draggableId + \"\\\" as no handle with a matching id was found\") : void 0;\n    return null;\n  }\n\n  if (!isHtmlElement(handle)) {\n    process.env.NODE_ENV !== \"production\" ? warning('drag handle needs to be a HTMLElement') : void 0;\n    return null;\n  }\n\n  return handle;\n}\n\nfunction useFocusMarshal(contextId) {\n  var entriesRef = React.useRef({});\n  var recordRef = React.useRef(null);\n  var restoreFocusFrameRef = React.useRef(null);\n  var isMountedRef = React.useRef(false);\n  var register = useMemoOne.useCallback(function register(id, focus) {\n    var entry = {\n      id: id,\n      focus: focus\n    };\n    entriesRef.current[id] = entry;\n    return function unregister() {\n      var entries = entriesRef.current;\n      var current = entries[id];\n\n      if (current !== entry) {\n        delete entries[id];\n      }\n    };\n  }, []);\n  var tryGiveFocus = useMemoOne.useCallback(function tryGiveFocus(tryGiveFocusTo) {\n    var handle = findDragHandle(contextId, tryGiveFocusTo);\n\n    if (handle && handle !== document.activeElement) {\n      handle.focus();\n    }\n  }, [contextId]);\n  var tryShiftRecord = useMemoOne.useCallback(function tryShiftRecord(previous, redirectTo) {\n    if (recordRef.current === previous) {\n      recordRef.current = redirectTo;\n    }\n  }, []);\n  var tryRestoreFocusRecorded = useMemoOne.useCallback(function tryRestoreFocusRecorded() {\n    if (restoreFocusFrameRef.current) {\n      return;\n    }\n\n    if (!isMountedRef.current) {\n      return;\n    }\n\n    restoreFocusFrameRef.current = requestAnimationFrame(function () {\n      restoreFocusFrameRef.current = null;\n      var record = recordRef.current;\n\n      if (record) {\n        tryGiveFocus(record);\n      }\n    });\n  }, [tryGiveFocus]);\n  var tryRecordFocus = useMemoOne.useCallback(function tryRecordFocus(id) {\n    recordRef.current = null;\n    var focused = document.activeElement;\n\n    if (!focused) {\n      return;\n    }\n\n    if (focused.getAttribute(dragHandle.draggableId) !== id) {\n      return;\n    }\n\n    recordRef.current = id;\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    isMountedRef.current = true;\n    return function clearFrameOnUnmount() {\n      isMountedRef.current = false;\n      var frameId = restoreFocusFrameRef.current;\n\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }, []);\n  var marshal = useMemoOne.useMemo(function () {\n    return {\n      register: register,\n      tryRecordFocus: tryRecordFocus,\n      tryRestoreFocusRecorded: tryRestoreFocusRecorded,\n      tryShiftRecord: tryShiftRecord\n    };\n  }, [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);\n  return marshal;\n}\n\nfunction createRegistry() {\n  var entries = {\n    draggables: {},\n    droppables: {}\n  };\n  var subscribers = [];\n\n  function subscribe(cb) {\n    subscribers.push(cb);\n    return function unsubscribe() {\n      var index = subscribers.indexOf(cb);\n\n      if (index === -1) {\n        return;\n      }\n\n      subscribers.splice(index, 1);\n    };\n  }\n\n  function notify(event) {\n    if (subscribers.length) {\n      subscribers.forEach(function (cb) {\n        return cb(event);\n      });\n    }\n  }\n\n  function findDraggableById(id) {\n    return entries.draggables[id] || null;\n  }\n\n  function getDraggableById(id) {\n    var entry = findDraggableById(id);\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find draggable entry with id [\" + id + \"]\") : invariant(false) : void 0;\n    return entry;\n  }\n\n  var draggableAPI = {\n    register: function register(entry) {\n      entries.draggables[entry.descriptor.id] = entry;\n      notify({\n        type: 'ADDITION',\n        value: entry\n      });\n    },\n    update: function update(entry, last) {\n      var current = entries.draggables[last.descriptor.id];\n\n      if (!current) {\n        return;\n      }\n\n      if (current.uniqueId !== entry.uniqueId) {\n        return;\n      }\n\n      delete entries.draggables[last.descriptor.id];\n      entries.draggables[entry.descriptor.id] = entry;\n    },\n    unregister: function unregister(entry) {\n      var draggableId = entry.descriptor.id;\n      var current = findDraggableById(draggableId);\n\n      if (!current) {\n        return;\n      }\n\n      if (entry.uniqueId !== current.uniqueId) {\n        return;\n      }\n\n      delete entries.draggables[draggableId];\n      notify({\n        type: 'REMOVAL',\n        value: entry\n      });\n    },\n    getById: getDraggableById,\n    findById: findDraggableById,\n    exists: function exists(id) {\n      return Boolean(findDraggableById(id));\n    },\n    getAllByType: function getAllByType(type) {\n      return values(entries.draggables).filter(function (entry) {\n        return entry.descriptor.type === type;\n      });\n    }\n  };\n\n  function findDroppableById(id) {\n    return entries.droppables[id] || null;\n  }\n\n  function getDroppableById(id) {\n    var entry = findDroppableById(id);\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find droppable entry with id [\" + id + \"]\") : invariant(false) : void 0;\n    return entry;\n  }\n\n  var droppableAPI = {\n    register: function register(entry) {\n      entries.droppables[entry.descriptor.id] = entry;\n    },\n    unregister: function unregister(entry) {\n      var current = findDroppableById(entry.descriptor.id);\n\n      if (!current) {\n        return;\n      }\n\n      if (entry.uniqueId !== current.uniqueId) {\n        return;\n      }\n\n      delete entries.droppables[entry.descriptor.id];\n    },\n    getById: getDroppableById,\n    findById: findDroppableById,\n    exists: function exists(id) {\n      return Boolean(findDroppableById(id));\n    },\n    getAllByType: function getAllByType(type) {\n      return values(entries.droppables).filter(function (entry) {\n        return entry.descriptor.type === type;\n      });\n    }\n  };\n\n  function clean() {\n    entries.draggables = {};\n    entries.droppables = {};\n    subscribers.length = 0;\n  }\n\n  return {\n    draggable: draggableAPI,\n    droppable: droppableAPI,\n    subscribe: subscribe,\n    clean: clean\n  };\n}\n\nfunction useRegistry() {\n  var registry = useMemoOne.useMemo(createRegistry, []);\n  React.useEffect(function () {\n    return function unmount() {\n      requestAnimationFrame(registry.clean);\n    };\n  }, [registry]);\n  return registry;\n}\n\nvar StoreContext = React__default.createContext(null);\n\nvar getBodyElement = (function () {\n  var body = document.body;\n  !body ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find document.body') : invariant(false) : void 0;\n  return body;\n});\n\nvar visuallyHidden = {\n  position: 'absolute',\n  width: '1px',\n  height: '1px',\n  margin: '-1px',\n  border: '0',\n  padding: '0',\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  'clip-path': 'inset(100%)'\n};\n\nvar getId = function getId(contextId) {\n  return \"rbd-announcement-\" + contextId;\n};\nfunction useAnnouncer(contextId) {\n  var id = useMemoOne.useMemo(function () {\n    return getId(contextId);\n  }, [contextId]);\n  var ref = React.useRef(null);\n  React.useEffect(function () {\n    !!ref.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Announcement node already mounted') : invariant(false) : void 0;\n    var el = document.createElement('div');\n    ref.current = el;\n    el.id = id;\n    el.setAttribute('aria-live', 'assertive');\n    el.setAttribute('role', 'log');\n    el.setAttribute('aria-atomic', 'true');\n\n    _Object$assign(el.style, visuallyHidden);\n\n    getBodyElement().appendChild(el);\n    return function () {\n      setTimeout(function remove() {\n        var toBeRemoved = ref.current;\n        !toBeRemoved ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot unmount announcement node') : invariant(false) : void 0;\n        getBodyElement().removeChild(toBeRemoved);\n        ref.current = null;\n      });\n    };\n  }, [id]);\n  var announce = useMemoOne.useCallback(function (message) {\n    var el = ref.current;\n\n    if (el) {\n      el.textContent = message;\n      return;\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      A screen reader message was trying to be announced but it was unable to do so.\\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\\n      Consider calling provided.announce() before the unmount so that the instruction will\\n      not be lost for users relying on a screen reader.\\n\\n      Message not passed to screen reader:\\n\\n      \\\"\" + message + \"\\\"\\n    \") : void 0;\n  }, []);\n  return announce;\n}\n\nvar getId$1 = function getId(contextId) {\n  return \"rbd-lift-instruction-\" + contextId;\n};\nfunction useLiftInstruction(contextId, liftInstruction) {\n  var id = useMemoOne.useMemo(function () {\n    return getId$1(contextId);\n  }, [contextId]);\n  React.useEffect(function mount() {\n    var el = document.createElement('div');\n    el.id = id;\n    el.textContent = liftInstruction;\n\n    _Object$assign(el.style, visuallyHidden);\n\n    getBodyElement().appendChild(el);\n    return function unmount() {\n      getBodyElement().removeChild(el);\n    };\n  }, [id, liftInstruction]);\n  return id;\n}\n\nvar AppContext = React__default.createContext(null);\n\nvar peerDependencies = {\n\treact: \"^16.8.5\",\n\t\"react-dom\": \"^16.8.5\"\n};\n\nvar semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\n\nvar getVersion = function getVersion(value) {\n  var result = semver.exec(value);\n  !(result != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Unable to parse React version \" + value) : invariant(false) : void 0;\n  var major = Number(result[1]);\n  var minor = Number(result[2]);\n  var patch = Number(result[3]);\n  return {\n    major: major,\n    minor: minor,\n    patch: patch,\n    raw: value\n  };\n};\n\nvar isSatisfied = function isSatisfied(expected, actual) {\n  if (actual.major > expected.major) {\n    return true;\n  }\n\n  if (actual.major < expected.major) {\n    return false;\n  }\n\n  if (actual.minor > expected.minor) {\n    return true;\n  }\n\n  if (actual.minor < expected.minor) {\n    return false;\n  }\n\n  return actual.patch >= expected.patch;\n};\n\nvar checkReactVersion = (function (peerDepValue, actualValue) {\n  var peerDep = getVersion(peerDepValue);\n  var actual = getVersion(actualValue);\n\n  if (isSatisfied(peerDep, actual)) {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    React version: [\" + actual.raw + \"]\\n    does not satisfy expected peer dependency version: [\" + peerDep.raw + \"]\\n\\n    This can result in run time bugs, and even fatal crashes\\n  \") : void 0;\n});\n\nvar suffix = \"\\n  We expect a html5 doctype: <!doctype html>\\n  This is to ensure consistent browser layout and measurement\\n\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\n\";\nvar checkDoctype = (function (doc) {\n  var doctype = doc.doctype;\n\n  if (!doctype) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      No <!doctype html> found.\\n\\n      \" + suffix + \"\\n    \") : void 0;\n    return;\n  }\n\n  if (doctype.name.toLowerCase() !== 'html') {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Unexpected <!doctype> found: (\" + doctype.name + \")\\n\\n      \" + suffix + \"\\n    \") : void 0;\n  }\n\n  if (doctype.publicId !== '') {\n    process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Unexpected <!doctype> publicId found: (\" + doctype.publicId + \")\\n      A html5 doctype does not have a publicId\\n\\n      \" + suffix + \"\\n    \") : void 0;\n  }\n});\n\nfunction useDev(useHook) {\n  if (process.env.NODE_ENV !== 'production') {\n    useHook();\n  }\n}\n\nfunction useDevSetupWarning(fn, inputs) {\n  useDev(function () {\n    React.useEffect(function () {\n      try {\n        fn();\n      } catch (e) {\n        error(\"\\n          A setup problem was encountered.\\n\\n          > \" + e.message + \"\\n        \");\n      }\n    }, inputs);\n  });\n}\n\nfunction useStartupValidation() {\n  useDevSetupWarning(function () {\n    checkReactVersion(peerDependencies.react, React__default.version);\n    checkDoctype(document);\n  }, []);\n}\n\nfunction usePrevious(current) {\n  var ref = React.useRef(current);\n  React.useEffect(function () {\n    ref.current = current;\n  });\n  return ref;\n}\n\nfunction create() {\n  var lock = null;\n\n  function isClaimed() {\n    return Boolean(lock);\n  }\n\n  function isActive(value) {\n    return value === lock;\n  }\n\n  function claim(abandon) {\n    !!lock ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot claim lock as it is already claimed') : invariant(false) : void 0;\n    var newLock = {\n      abandon: abandon\n    };\n    lock = newLock;\n    return newLock;\n  }\n\n  function release() {\n    !lock ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot release lock when there is no lock') : invariant(false) : void 0;\n    lock = null;\n  }\n\n  function tryAbandon() {\n    if (lock) {\n      lock.abandon();\n      release();\n    }\n  }\n\n  return {\n    isClaimed: isClaimed,\n    isActive: isActive,\n    claim: claim,\n    release: release,\n    tryAbandon: tryAbandon\n  };\n}\n\nvar tab = 9;\nvar enter = 13;\nvar escape = 27;\nvar space = 32;\nvar pageUp = 33;\nvar pageDown = 34;\nvar end = 35;\nvar home = 36;\nvar arrowLeft = 37;\nvar arrowUp = 38;\nvar arrowRight = 39;\nvar arrowDown = 40;\n\nvar _preventedKeys;\nvar preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);\nvar preventStandardKeyEvents = (function (event) {\n  if (preventedKeys[event.keyCode]) {\n    event.preventDefault();\n  }\n});\n\nvar supportedEventName = function () {\n  var base = 'visibilitychange';\n\n  if (typeof document === 'undefined') {\n    return base;\n  }\n\n  var candidates = [base, \"ms\" + base, \"webkit\" + base, \"moz\" + base, \"o\" + base];\n  var supported = find(candidates, function (eventName) {\n    return \"on\" + eventName in document;\n  });\n  return supported || base;\n}();\n\nvar primaryButton = 0;\nvar sloppyClickThreshold = 5;\n\nfunction isSloppyClickThresholdExceeded(original, current) {\n  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\n\nvar idle$1 = {\n  type: 'IDLE'\n};\n\nfunction getCaptureBindings(_ref) {\n  var cancel = _ref.cancel,\n      completed = _ref.completed,\n      getPhase = _ref.getPhase,\n      setPhase = _ref.setPhase;\n  return [{\n    eventName: 'mousemove',\n    fn: function fn(event) {\n      var button = event.button,\n          clientX = event.clientX,\n          clientY = event.clientY;\n\n      if (button !== primaryButton) {\n        return;\n      }\n\n      var point = {\n        x: clientX,\n        y: clientY\n      };\n      var phase = getPhase();\n\n      if (phase.type === 'DRAGGING') {\n        event.preventDefault();\n        phase.actions.move(point);\n        return;\n      }\n\n      !(phase.type === 'PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot be IDLE') : invariant(false) : void 0;\n      var pending = phase.point;\n\n      if (!isSloppyClickThresholdExceeded(pending, point)) {\n        return;\n      }\n\n      event.preventDefault();\n      var actions = phase.actions.fluidLift(point);\n      setPhase({\n        type: 'DRAGGING',\n        actions: actions\n      });\n    }\n  }, {\n    eventName: 'mouseup',\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n      phase.actions.drop({\n        shouldBlockNextClick: true\n      });\n      completed();\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: function fn(event) {\n      if (getPhase().type === 'DRAGGING') {\n        event.preventDefault();\n      }\n\n      cancel();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type === 'PENDING') {\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: function fn() {\n      if (getPhase().type === 'PENDING') {\n        cancel();\n      }\n    }\n  }, {\n    eventName: 'webkitmouseforcedown',\n    fn: function fn(event) {\n      var phase = getPhase();\n      !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unexpected phase') : invariant(false) : void 0;\n\n      if (phase.actions.shouldRespectForcePress()) {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction useMouseSensor(api) {\n  var phaseRef = React.useRef(idle$1);\n  var unbindEventsRef = React.useRef(noop);\n  var startCaptureBinding = useMemoOne.useMemo(function () {\n    return {\n      eventName: 'mousedown',\n      fn: function onMouseDown(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        if (event.button !== primaryButton) {\n          return;\n        }\n\n        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n          return;\n        }\n\n        var draggableId = api.findClosestDraggableId(event);\n\n        if (!draggableId) {\n          return;\n        }\n\n        var actions = api.tryGetLock(draggableId, stop, {\n          sourceEvent: event\n        });\n\n        if (!actions) {\n          return;\n        }\n\n        event.preventDefault();\n        var point = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        unbindEventsRef.current();\n        startPendingDrag(actions, point);\n      }\n    };\n  }, [api]);\n  var preventForcePressBinding = useMemoOne.useMemo(function () {\n    return {\n      eventName: 'webkitmouseforcewillbegin',\n      fn: function fn(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        var id = api.findClosestDraggableId(event);\n\n        if (!id) {\n          return;\n        }\n\n        var options = api.findOptionsForDraggable(id);\n\n        if (!options) {\n          return;\n        }\n\n        if (options.shouldRespectForcePress) {\n          return;\n        }\n\n        if (!api.canGetLock(id)) {\n          return;\n        }\n\n        event.preventDefault();\n      }\n    };\n  }, [api]);\n  var listenForCapture = useMemoOne.useCallback(function listenForCapture() {\n    var options = {\n      passive: false,\n      capture: true\n    };\n    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);\n  }, [preventForcePressBinding, startCaptureBinding]);\n  var stop = useMemoOne.useCallback(function () {\n    var current = phaseRef.current;\n\n    if (current.type === 'IDLE') {\n      return;\n    }\n\n    phaseRef.current = idle$1;\n    unbindEventsRef.current();\n    listenForCapture();\n  }, [listenForCapture]);\n  var cancel = useMemoOne.useCallback(function () {\n    var phase = phaseRef.current;\n    stop();\n\n    if (phase.type === 'DRAGGING') {\n      phase.actions.cancel({\n        shouldBlockNextClick: true\n      });\n    }\n\n    if (phase.type === 'PENDING') {\n      phase.actions.abort();\n    }\n  }, [stop]);\n  var bindCapturingEvents = useMemoOne.useCallback(function bindCapturingEvents() {\n    var options = {\n      capture: true,\n      passive: false\n    };\n    var bindings = getCaptureBindings({\n      cancel: cancel,\n      completed: stop,\n      getPhase: function getPhase() {\n        return phaseRef.current;\n      },\n      setPhase: function setPhase(phase) {\n        phaseRef.current = phase;\n      }\n    });\n    unbindEventsRef.current = bindEvents(window, bindings, options);\n  }, [cancel, stop]);\n  var startPendingDrag = useMemoOne.useCallback(function startPendingDrag(actions, point) {\n    !(phaseRef.current.type === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected to move from IDLE to PENDING drag') : invariant(false) : void 0;\n    phaseRef.current = {\n      type: 'PENDING',\n      point: point,\n      actions: actions\n    };\n    bindCapturingEvents();\n  }, [bindCapturingEvents]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n    };\n  }, [listenForCapture]);\n}\n\nvar _scrollJumpKeys;\n\nfunction noop$1() {}\n\nvar scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);\n\nfunction getDraggingBindings(actions, stop) {\n  function cancel() {\n    stop();\n    actions.cancel();\n  }\n\n  function drop() {\n    stop();\n    actions.drop();\n  }\n\n  return [{\n    eventName: 'keydown',\n    fn: function fn(event) {\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === space) {\n        event.preventDefault();\n        drop();\n        return;\n      }\n\n      if (event.keyCode === arrowDown) {\n        event.preventDefault();\n        actions.moveDown();\n        return;\n      }\n\n      if (event.keyCode === arrowUp) {\n        event.preventDefault();\n        actions.moveUp();\n        return;\n      }\n\n      if (event.keyCode === arrowRight) {\n        event.preventDefault();\n        actions.moveRight();\n        return;\n      }\n\n      if (event.keyCode === arrowLeft) {\n        event.preventDefault();\n        actions.moveLeft();\n        return;\n      }\n\n      if (scrollJumpKeys[event.keyCode]) {\n        event.preventDefault();\n        return;\n      }\n\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: cancel\n  }, {\n    eventName: 'mouseup',\n    fn: cancel\n  }, {\n    eventName: 'click',\n    fn: cancel\n  }, {\n    eventName: 'touchstart',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'wheel',\n    fn: cancel,\n    options: {\n      passive: true\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction useKeyboardSensor(api) {\n  var unbindEventsRef = React.useRef(noop$1);\n  var startCaptureBinding = useMemoOne.useMemo(function () {\n    return {\n      eventName: 'keydown',\n      fn: function onKeyDown(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        if (event.keyCode !== space) {\n          return;\n        }\n\n        var draggableId = api.findClosestDraggableId(event);\n\n        if (!draggableId) {\n          return;\n        }\n\n        var preDrag = api.tryGetLock(draggableId, stop, {\n          sourceEvent: event\n        });\n\n        if (!preDrag) {\n          return;\n        }\n\n        event.preventDefault();\n        var isCapturing = true;\n        var actions = preDrag.snapLift();\n        unbindEventsRef.current();\n\n        function stop() {\n          !isCapturing ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot stop capturing a keyboard drag when not capturing') : invariant(false) : void 0;\n          isCapturing = false;\n          unbindEventsRef.current();\n          listenForCapture();\n        }\n\n        unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n          capture: true,\n          passive: false\n        });\n      }\n    };\n  }, [api]);\n  var listenForCapture = useMemoOne.useCallback(function tryStartCapture() {\n    var options = {\n      passive: false,\n      capture: true\n    };\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\n  }, [startCaptureBinding]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n    };\n  }, [listenForCapture]);\n}\n\nvar idle$2 = {\n  type: 'IDLE'\n};\nvar timeForLongPress = 120;\nvar forcePressThreshold = 0.15;\n\nfunction getWindowBindings(_ref) {\n  var cancel = _ref.cancel,\n      getPhase = _ref.getPhase;\n  return [{\n    eventName: 'orientationchange',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'contextmenu',\n    fn: function fn(event) {\n      event.preventDefault();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: function fn(event) {\n      if (getPhase().type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === escape) {\n        event.preventDefault();\n      }\n\n      cancel();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction getHandleBindings(_ref2) {\n  var cancel = _ref2.cancel,\n      completed = _ref2.completed,\n      getPhase = _ref2.getPhase;\n  return [{\n    eventName: 'touchmove',\n    options: {\n      capture: false\n    },\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      phase.hasMoved = true;\n      var _event$touches$ = event.touches[0],\n          clientX = _event$touches$.clientX,\n          clientY = _event$touches$.clientY;\n      var point = {\n        x: clientX,\n        y: clientY\n      };\n      event.preventDefault();\n      phase.actions.move(point);\n    }\n  }, {\n    eventName: 'touchend',\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n      phase.actions.drop({\n        shouldBlockNextClick: true\n      });\n      completed();\n    }\n  }, {\n    eventName: 'touchcancel',\n    fn: function fn(event) {\n      if (getPhase().type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n      cancel();\n    }\n  }, {\n    eventName: 'touchforcechange',\n    fn: function fn(event) {\n      var phase = getPhase();\n      !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n      var touch = event.touches[0];\n\n      if (!touch) {\n        return;\n      }\n\n      var isForcePress = touch.force >= forcePressThreshold;\n\n      if (!isForcePress) {\n        return;\n      }\n\n      var shouldRespect = phase.actions.shouldRespectForcePress();\n\n      if (phase.type === 'PENDING') {\n        if (shouldRespect) {\n          cancel();\n        }\n\n        return;\n      }\n\n      if (shouldRespect) {\n        if (phase.hasMoved) {\n          event.preventDefault();\n          return;\n        }\n\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction useMouseSensor$1(api) {\n  var phaseRef = React.useRef(idle$2);\n  var unbindEventsRef = React.useRef(noop);\n  var getPhase = useMemoOne.useCallback(function getPhase() {\n    return phaseRef.current;\n  }, []);\n  var setPhase = useMemoOne.useCallback(function setPhase(phase) {\n    phaseRef.current = phase;\n  }, []);\n  var startCaptureBinding = useMemoOne.useMemo(function () {\n    return {\n      eventName: 'touchstart',\n      fn: function onTouchStart(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        var draggableId = api.findClosestDraggableId(event);\n\n        if (!draggableId) {\n          return;\n        }\n\n        var actions = api.tryGetLock(draggableId, stop, {\n          sourceEvent: event\n        });\n\n        if (!actions) {\n          return;\n        }\n\n        var touch = event.touches[0];\n        var clientX = touch.clientX,\n            clientY = touch.clientY;\n        var point = {\n          x: clientX,\n          y: clientY\n        };\n        unbindEventsRef.current();\n        startPendingDrag(actions, point);\n      }\n    };\n  }, [api]);\n  var listenForCapture = useMemoOne.useCallback(function listenForCapture() {\n    var options = {\n      capture: true,\n      passive: false\n    };\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\n  }, [startCaptureBinding]);\n  var stop = useMemoOne.useCallback(function () {\n    var current = phaseRef.current;\n\n    if (current.type === 'IDLE') {\n      return;\n    }\n\n    if (current.type === 'PENDING') {\n      clearTimeout(current.longPressTimerId);\n    }\n\n    setPhase(idle$2);\n    unbindEventsRef.current();\n    listenForCapture();\n  }, [listenForCapture, setPhase]);\n  var cancel = useMemoOne.useCallback(function () {\n    var phase = phaseRef.current;\n    stop();\n\n    if (phase.type === 'DRAGGING') {\n      phase.actions.cancel({\n        shouldBlockNextClick: true\n      });\n    }\n\n    if (phase.type === 'PENDING') {\n      phase.actions.abort();\n    }\n  }, [stop]);\n  var bindCapturingEvents = useMemoOne.useCallback(function bindCapturingEvents() {\n    var options = {\n      capture: true,\n      passive: false\n    };\n    var args = {\n      cancel: cancel,\n      completed: stop,\n      getPhase: getPhase\n    };\n    var unbindTarget = bindEvents(window, getHandleBindings(args), options);\n    var unbindWindow = bindEvents(window, getWindowBindings(args), options);\n\n    unbindEventsRef.current = function unbindAll() {\n      unbindTarget();\n      unbindWindow();\n    };\n  }, [cancel, getPhase, stop]);\n  var startDragging = useMemoOne.useCallback(function startDragging() {\n    var phase = getPhase();\n    !(phase.type === 'PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot start dragging from phase \" + phase.type) : invariant(false) : void 0;\n    var actions = phase.actions.fluidLift(phase.point);\n    setPhase({\n      type: 'DRAGGING',\n      actions: actions,\n      hasMoved: false\n    });\n  }, [getPhase, setPhase]);\n  var startPendingDrag = useMemoOne.useCallback(function startPendingDrag(actions, point) {\n    !(getPhase().type === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected to move from IDLE to PENDING drag') : invariant(false) : void 0;\n    var longPressTimerId = setTimeout(startDragging, timeForLongPress);\n    setPhase({\n      type: 'PENDING',\n      point: point,\n      actions: actions,\n      longPressTimerId: longPressTimerId\n    });\n    bindCapturingEvents();\n  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n      var phase = getPhase();\n\n      if (phase.type === 'PENDING') {\n        clearTimeout(phase.longPressTimerId);\n        setPhase(idle$2);\n      }\n    };\n  }, [getPhase, listenForCapture, setPhase]);\n  useIsomorphicLayoutEffect(function webkitHack() {\n    var unbind = bindEvents(window, [{\n      eventName: 'touchmove',\n      fn: function fn() {},\n      options: {\n        capture: false,\n        passive: false\n      }\n    }]);\n    return unbind;\n  }, []);\n}\n\nfunction useValidateSensorHooks(sensorHooks) {\n  useDev(function () {\n    var previousRef = usePrevious(sensorHooks);\n    useDevSetupWarning(function () {\n      !(previousRef.current.length === sensorHooks.length) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot change the amount of sensor hooks after mounting') : invariant(false) : void 0;\n    });\n  });\n}\n\nvar interactiveTagNames = {\n  input: true,\n  button: true,\n  textarea: true,\n  select: true,\n  option: true,\n  optgroup: true,\n  video: true,\n  audio: true\n};\n\nfunction isAnInteractiveElement(parent, current) {\n  if (current == null) {\n    return false;\n  }\n\n  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);\n\n  if (hasAnInteractiveTag) {\n    return true;\n  }\n\n  var attribute = current.getAttribute('contenteditable');\n\n  if (attribute === 'true' || attribute === '') {\n    return true;\n  }\n\n  if (current === parent) {\n    return false;\n  }\n\n  return isAnInteractiveElement(parent, current.parentElement);\n}\n\nfunction isEventInInteractiveElement(draggable, event) {\n  var target = event.target;\n\n  if (!isHtmlElement(target)) {\n    return false;\n  }\n\n  return isAnInteractiveElement(draggable, target);\n}\n\nvar getBorderBoxCenterPosition = (function (el) {\n  return cssBoxModel.getRect(el.getBoundingClientRect()).center;\n});\n\nfunction isElement(el) {\n  return el instanceof getWindowFromEl(el).Element;\n}\n\nvar supportedMatchesName = function () {\n  var base = 'matches';\n\n  if (typeof document === 'undefined') {\n    return base;\n  }\n\n  var candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];\n  var value = find(candidates, function (name) {\n    return name in Element.prototype;\n  });\n  return value || base;\n}();\n\nfunction closestPonyfill(el, selector) {\n  if (el == null) {\n    return null;\n  }\n\n  if (el[supportedMatchesName](selector)) {\n    return el;\n  }\n\n  return closestPonyfill(el.parentElement, selector);\n}\n\nfunction closest$1(el, selector) {\n  if (el.closest) {\n    return el.closest(selector);\n  }\n\n  return closestPonyfill(el, selector);\n}\n\nfunction getSelector(contextId) {\n  return \"[\" + dragHandle.contextId + \"=\\\"\" + contextId + \"\\\"]\";\n}\n\nfunction findClosestDragHandleFromEvent(contextId, event) {\n  var target = event.target;\n\n  if (!isElement(target)) {\n    process.env.NODE_ENV !== \"production\" ? warning('event.target must be a Element') : void 0;\n    return null;\n  }\n\n  var selector = getSelector(contextId);\n  var handle = closest$1(target, selector);\n\n  if (!handle) {\n    return null;\n  }\n\n  if (!isHtmlElement(handle)) {\n    process.env.NODE_ENV !== \"production\" ? warning('drag handle must be a HTMLElement') : void 0;\n    return null;\n  }\n\n  return handle;\n}\n\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n  var handle = findClosestDragHandleFromEvent(contextId, event);\n\n  if (!handle) {\n    return null;\n  }\n\n  return handle.getAttribute(dragHandle.draggableId);\n}\n\nfunction findDraggable(contextId, draggableId) {\n  var selector = \"[\" + draggable.contextId + \"=\\\"\" + contextId + \"\\\"]\";\n  var possible = toArray(document.querySelectorAll(selector));\n  var draggable$1 = find(possible, function (el) {\n    return el.getAttribute(draggable.id) === draggableId;\n  });\n\n  if (!draggable$1) {\n    return null;\n  }\n\n  if (!isHtmlElement(draggable$1)) {\n    process.env.NODE_ENV !== \"production\" ? warning('Draggable element is not a HTMLElement') : void 0;\n    return null;\n  }\n\n  return draggable$1;\n}\n\nfunction preventDefault(event) {\n  event.preventDefault();\n}\n\nfunction _isActive(_ref) {\n  var expected = _ref.expected,\n      phase = _ref.phase,\n      isLockActive = _ref.isLockActive,\n      shouldWarn = _ref.shouldWarn;\n\n  if (!isLockActive()) {\n    if (shouldWarn) {\n      process.env.NODE_ENV !== \"production\" ? warning(\"\\n        Cannot perform action.\\n        The sensor no longer has an action lock.\\n\\n        Tips:\\n\\n        - Throw away your action handlers when forceStop() is called\\n        - Check actions.isActive() if you really need to\\n      \") : void 0;\n    }\n\n    return false;\n  }\n\n  if (expected !== phase) {\n    if (shouldWarn) {\n      process.env.NODE_ENV !== \"production\" ? warning(\"\\n        Cannot perform action.\\n        The actions you used belong to an outdated phase\\n\\n        Current phase: \" + expected + \"\\n        You called an action from outdated phase: \" + phase + \"\\n\\n        Tips:\\n\\n        - Do not use preDragActions actions after calling preDragActions.lift()\\n      \") : void 0;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction canStart(_ref2) {\n  var lockAPI = _ref2.lockAPI,\n      store = _ref2.store,\n      registry = _ref2.registry,\n      draggableId = _ref2.draggableId;\n\n  if (lockAPI.isClaimed()) {\n    return false;\n  }\n\n  var entry = registry.draggable.findById(draggableId);\n\n  if (!entry) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"Unable to find draggable with id: \" + draggableId) : void 0;\n    return false;\n  }\n\n  if (!entry.options.isEnabled) {\n    return false;\n  }\n\n  if (!canStartDrag(store.getState(), draggableId)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction tryStart(_ref3) {\n  var lockAPI = _ref3.lockAPI,\n      contextId = _ref3.contextId,\n      store = _ref3.store,\n      registry = _ref3.registry,\n      draggableId = _ref3.draggableId,\n      forceSensorStop = _ref3.forceSensorStop,\n      sourceEvent = _ref3.sourceEvent;\n  var shouldStart = canStart({\n    lockAPI: lockAPI,\n    store: store,\n    registry: registry,\n    draggableId: draggableId\n  });\n\n  if (!shouldStart) {\n    return null;\n  }\n\n  var entry = registry.draggable.getById(draggableId);\n  var el = findDraggable(contextId, entry.descriptor.id);\n\n  if (!el) {\n    process.env.NODE_ENV !== \"production\" ? warning(\"Unable to find draggable element with id: \" + draggableId) : void 0;\n    return null;\n  }\n\n  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n    return null;\n  }\n\n  var lock = lockAPI.claim(forceSensorStop || noop);\n  var phase = 'PRE_DRAG';\n\n  function getShouldRespectForcePress() {\n    return entry.options.shouldRespectForcePress;\n  }\n\n  function isLockActive() {\n    return lockAPI.isActive(lock);\n  }\n\n  function tryDispatch(expected, getAction) {\n    if (_isActive({\n      expected: expected,\n      phase: phase,\n      isLockActive: isLockActive,\n      shouldWarn: true\n    })) {\n      store.dispatch(getAction());\n    }\n  }\n\n  var tryDispatchWhenDragging = tryDispatch.bind(this, 'DRAGGING');\n\n  function lift$1(args) {\n    function completed() {\n      lockAPI.release();\n      phase = 'COMPLETED';\n    }\n\n    if (phase !== 'PRE_DRAG') {\n      completed();\n      !(phase === 'PRE_DRAG') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot lift in phase \" + phase) : invariant(false) : void 0;\n    }\n\n    store.dispatch(lift(args.liftActionArgs));\n    phase = 'DRAGGING';\n\n    function finish(reason, options) {\n      if (options === void 0) {\n        options = {\n          shouldBlockNextClick: false\n        };\n      }\n\n      args.cleanup();\n\n      if (options.shouldBlockNextClick) {\n        var unbind = bindEvents(window, [{\n          eventName: 'click',\n          fn: preventDefault,\n          options: {\n            once: true,\n            passive: false,\n            capture: true\n          }\n        }]);\n        setTimeout(unbind);\n      }\n\n      completed();\n      store.dispatch(drop({\n        reason: reason\n      }));\n    }\n\n    return _extends({\n      isActive: function isActive() {\n        return _isActive({\n          expected: 'DRAGGING',\n          phase: phase,\n          isLockActive: isLockActive,\n          shouldWarn: false\n        });\n      },\n      shouldRespectForcePress: getShouldRespectForcePress,\n      drop: function drop(options) {\n        return finish('DROP', options);\n      },\n      cancel: function cancel(options) {\n        return finish('CANCEL', options);\n      }\n    }, args.actions);\n  }\n\n  function fluidLift(clientSelection) {\n    var move$1 = rafSchd(function (client) {\n      tryDispatchWhenDragging(function () {\n        return move({\n          client: client\n        });\n      });\n    });\n    var api = lift$1({\n      liftActionArgs: {\n        id: draggableId,\n        clientSelection: clientSelection,\n        movementMode: 'FLUID'\n      },\n      cleanup: function cleanup() {\n        return move$1.cancel();\n      },\n      actions: {\n        move: move$1\n      }\n    });\n    return _extends({}, api, {\n      move: move$1\n    });\n  }\n\n  function snapLift() {\n    var actions = {\n      moveUp: function moveUp$1() {\n        return tryDispatchWhenDragging(moveUp);\n      },\n      moveRight: function moveRight$1() {\n        return tryDispatchWhenDragging(moveRight);\n      },\n      moveDown: function moveDown$1() {\n        return tryDispatchWhenDragging(moveDown);\n      },\n      moveLeft: function moveLeft$1() {\n        return tryDispatchWhenDragging(moveLeft);\n      }\n    };\n    return lift$1({\n      liftActionArgs: {\n        id: draggableId,\n        clientSelection: getBorderBoxCenterPosition(el),\n        movementMode: 'SNAP'\n      },\n      cleanup: noop,\n      actions: actions\n    });\n  }\n\n  function abortPreDrag() {\n    var shouldRelease = _isActive({\n      expected: 'PRE_DRAG',\n      phase: phase,\n      isLockActive: isLockActive,\n      shouldWarn: true\n    });\n\n    if (shouldRelease) {\n      lockAPI.release();\n    }\n  }\n\n  var preDrag = {\n    isActive: function isActive() {\n      return _isActive({\n        expected: 'PRE_DRAG',\n        phase: phase,\n        isLockActive: isLockActive,\n        shouldWarn: false\n      });\n    },\n    shouldRespectForcePress: getShouldRespectForcePress,\n    fluidLift: fluidLift,\n    snapLift: snapLift,\n    abort: abortPreDrag\n  };\n  return preDrag;\n}\n\nvar defaultSensors = [useMouseSensor, useKeyboardSensor, useMouseSensor$1];\nfunction useSensorMarshal(_ref4) {\n  var contextId = _ref4.contextId,\n      store = _ref4.store,\n      registry = _ref4.registry,\n      customSensors = _ref4.customSensors,\n      enableDefaultSensors = _ref4.enableDefaultSensors;\n  var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);\n  var lockAPI = React.useState(function () {\n    return create();\n  })[0];\n  var tryAbandonLock = useMemoOne.useCallback(function tryAbandonLock(previous, current) {\n    if (previous.isDragging && !current.isDragging) {\n      lockAPI.tryAbandon();\n    }\n  }, [lockAPI]);\n  useIsomorphicLayoutEffect(function listenToStore() {\n    var previous = store.getState();\n    var unsubscribe = store.subscribe(function () {\n      var current = store.getState();\n      tryAbandonLock(previous, current);\n      previous = current;\n    });\n    return unsubscribe;\n  }, [lockAPI, store, tryAbandonLock]);\n  useIsomorphicLayoutEffect(function () {\n    return lockAPI.tryAbandon;\n  }, [lockAPI.tryAbandon]);\n  var canGetLock = useMemoOne.useCallback(function (draggableId) {\n    return canStart({\n      lockAPI: lockAPI,\n      registry: registry,\n      store: store,\n      draggableId: draggableId\n    });\n  }, [lockAPI, registry, store]);\n  var tryGetLock = useMemoOne.useCallback(function (draggableId, forceStop, options) {\n    return tryStart({\n      lockAPI: lockAPI,\n      registry: registry,\n      contextId: contextId,\n      store: store,\n      draggableId: draggableId,\n      forceSensorStop: forceStop,\n      sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n    });\n  }, [contextId, lockAPI, registry, store]);\n  var findClosestDraggableId = useMemoOne.useCallback(function (event) {\n    return tryGetClosestDraggableIdFromEvent(contextId, event);\n  }, [contextId]);\n  var findOptionsForDraggable = useMemoOne.useCallback(function (id) {\n    var entry = registry.draggable.findById(id);\n    return entry ? entry.options : null;\n  }, [registry.draggable]);\n  var tryReleaseLock = useMemoOne.useCallback(lockAPI.tryAbandon, [lockAPI]);\n  var isLockClaimed = useMemoOne.useCallback(lockAPI.isClaimed, [lockAPI]);\n  var api = useMemoOne.useMemo(function () {\n    return {\n      canGetLock: canGetLock,\n      tryGetLock: tryGetLock,\n      findClosestDraggableId: findClosestDraggableId,\n      findOptionsForDraggable: findOptionsForDraggable,\n      tryReleaseLock: tryReleaseLock,\n      isLockClaimed: isLockClaimed\n    };\n  }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);\n  useValidateSensorHooks(useSensors);\n\n  for (var i = 0; i < useSensors.length; i++) {\n    useSensors[i](api);\n  }\n}\n\nvar createResponders = function createResponders(props) {\n  return {\n    onBeforeDragStart: props.onBeforeDragStart,\n    onDragStart: props.onDragStart,\n    onDragEnd: props.onDragEnd,\n    onDragUpdate: props.onDragUpdate\n  };\n};\n\nfunction getStore(lazyRef) {\n  !lazyRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find store from lazy ref') : invariant(false) : void 0;\n  return lazyRef.current;\n}\n\nfunction App(props) {\n  var contextId = props.contextId,\n      setCallbacks = props.setCallbacks,\n      sensors = props.sensors,\n      nonce = props.nonce,\n      liftInstruction = props.liftInstruction;\n  var lazyStoreRef = React.useRef(null);\n  useStartupValidation();\n  var lastPropsRef = usePrevious(props);\n  var getResponders = useMemoOne.useCallback(function () {\n    return createResponders(lastPropsRef.current);\n  }, [lastPropsRef]);\n  var announce = useAnnouncer(contextId);\n  var liftInstructionId = useLiftInstruction(contextId, liftInstruction);\n  var styleMarshal = useStyleMarshal(contextId, nonce);\n  var lazyDispatch = useMemoOne.useCallback(function (action) {\n    getStore(lazyStoreRef).dispatch(action);\n  }, []);\n  var marshalCallbacks = useMemoOne.useMemo(function () {\n    return redux.bindActionCreators({\n      publishWhileDragging: publishWhileDragging,\n      updateDroppableScroll: updateDroppableScroll,\n      updateDroppableIsEnabled: updateDroppableIsEnabled,\n      updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n      collectionStarting: collectionStarting\n    }, lazyDispatch);\n  }, [lazyDispatch]);\n  var registry = useRegistry();\n  var dimensionMarshal = useMemoOne.useMemo(function () {\n    return createDimensionMarshal(registry, marshalCallbacks);\n  }, [registry, marshalCallbacks]);\n  var autoScroller = useMemoOne.useMemo(function () {\n    return createAutoScroller(_extends({\n      scrollWindow: scrollWindow,\n      scrollDroppable: dimensionMarshal.scrollDroppable\n    }, redux.bindActionCreators({\n      move: move\n    }, lazyDispatch)));\n  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);\n  var focusMarshal = useFocusMarshal(contextId);\n  var store = useMemoOne.useMemo(function () {\n    return createStore({\n      announce: announce,\n      autoScroller: autoScroller,\n      dimensionMarshal: dimensionMarshal,\n      focusMarshal: focusMarshal,\n      getResponders: getResponders,\n      styleMarshal: styleMarshal\n    });\n  }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n      process.env.NODE_ENV !== \"production\" ? warning('unexpected store change') : void 0;\n    }\n  }\n\n  lazyStoreRef.current = store;\n  var tryResetStore = useMemoOne.useCallback(function () {\n    var current = getStore(lazyStoreRef);\n    var state = current.getState();\n\n    if (state.phase !== 'IDLE') {\n      current.dispatch(flush());\n    }\n  }, []);\n  var isDragging = useMemoOne.useCallback(function () {\n    var state = getStore(lazyStoreRef).getState();\n    return state.isDragging || state.phase === 'DROP_ANIMATING';\n  }, []);\n  var appCallbacks = useMemoOne.useMemo(function () {\n    return {\n      isDragging: isDragging,\n      tryAbort: tryResetStore\n    };\n  }, [isDragging, tryResetStore]);\n  setCallbacks(appCallbacks);\n  var getCanLift = useMemoOne.useCallback(function (id) {\n    return canStartDrag(getStore(lazyStoreRef).getState(), id);\n  }, []);\n  var getIsMovementAllowed = useMemoOne.useCallback(function () {\n    return isMovementAllowed(getStore(lazyStoreRef).getState());\n  }, []);\n  var appContext = useMemoOne.useMemo(function () {\n    return {\n      marshal: dimensionMarshal,\n      focus: focusMarshal,\n      contextId: contextId,\n      canLift: getCanLift,\n      isMovementAllowed: getIsMovementAllowed,\n      liftInstructionId: liftInstructionId,\n      registry: registry\n    };\n  }, [contextId, dimensionMarshal, focusMarshal, getCanLift, getIsMovementAllowed, liftInstructionId, registry]);\n  useSensorMarshal({\n    contextId: contextId,\n    store: store,\n    registry: registry,\n    customSensors: sensors,\n    enableDefaultSensors: props.enableDefaultSensors !== false\n  });\n  React.useEffect(function () {\n    return tryResetStore;\n  }, [tryResetStore]);\n  return React__default.createElement(AppContext.Provider, {\n    value: appContext\n  }, React__default.createElement(reactRedux.Provider, {\n    context: StoreContext,\n    store: store\n  }, props.children));\n}\n\nvar instanceCount = 0;\nfunction resetServerContext() {\n  instanceCount = 0;\n}\nfunction DragDropContext(props) {\n  var contextId = useMemoOne.useMemo(function () {\n    return \"\" + instanceCount++;\n  }, []);\n  var liftInstruction = props.liftInstruction || preset.liftInstruction;\n  return React__default.createElement(ErrorBoundary, null, function (setCallbacks) {\n    return React__default.createElement(App, {\n      nonce: props.nonce,\n      contextId: contextId,\n      setCallbacks: setCallbacks,\n      liftInstruction: liftInstruction,\n      enableDefaultSensors: props.enableDefaultSensors,\n      sensors: props.sensors,\n      onBeforeDragStart: props.onBeforeDragStart,\n      onDragStart: props.onDragStart,\n      onDragUpdate: props.onDragUpdate,\n      onDragEnd: props.onDragEnd\n    }, props.children);\n  });\n}\n\nvar isEqual$1 = function isEqual(base) {\n  return function (value) {\n    return base === value;\n  };\n};\n\nvar isScroll = isEqual$1('scroll');\nvar isAuto = isEqual$1('auto');\nvar isVisible$1 = isEqual$1('visible');\n\nvar isEither = function isEither(overflow, fn) {\n  return fn(overflow.overflowX) || fn(overflow.overflowY);\n};\n\nvar isBoth = function isBoth(overflow, fn) {\n  return fn(overflow.overflowX) && fn(overflow.overflowY);\n};\n\nvar isElementScrollable = function isElementScrollable(el) {\n  var style = window.getComputedStyle(el);\n  var overflow = {\n    overflowX: style.overflowX,\n    overflowY: style.overflowY\n  };\n  return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\n\nvar isBodyScrollable = function isBodyScrollable() {\n  if (process.env.NODE_ENV === 'production') {\n    return false;\n  }\n\n  var body = getBodyElement();\n  var html = document.documentElement;\n  !html ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n\n  if (!isElementScrollable(body)) {\n    return false;\n  }\n\n  var htmlStyle = window.getComputedStyle(html);\n  var htmlOverflow = {\n    overflowX: htmlStyle.overflowX,\n    overflowY: htmlStyle.overflowY\n  };\n\n  if (isBoth(htmlOverflow, isVisible$1)) {\n    return false;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    We have detected that your <body> element might be a scroll container.\\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\\n\\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\\n    we will be treating the <body> as *not* a scroll container\\n\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\\n  \") : void 0;\n  return false;\n};\n\nvar getClosestScrollable = function getClosestScrollable(el) {\n  if (el == null) {\n    return null;\n  }\n\n  if (el === document.body) {\n    return isBodyScrollable() ? el : null;\n  }\n\n  if (el === document.documentElement) {\n    return null;\n  }\n\n  if (!isElementScrollable(el)) {\n    return getClosestScrollable(el.parentElement);\n  }\n\n  return el;\n};\n\nvar checkForNestedScrollContainers = (function (scrollable) {\n  if (!scrollable) {\n    return;\n  }\n\n  var anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n\n  if (!anotherScrollParent) {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n    Droppable: unsupported nested scroll container detected.\\n    A Droppable can only have one scroll parent (which can be itself)\\n    Nested scroll containers are currently not supported.\\n\\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\\n  \") : void 0;\n});\n\nvar getScroll$1 = (function (el) {\n  return {\n    x: el.scrollLeft,\n    y: el.scrollTop\n  };\n});\n\nvar getIsFixed = function getIsFixed(el) {\n  if (!el) {\n    return false;\n  }\n\n  var style = window.getComputedStyle(el);\n\n  if (style.position === 'fixed') {\n    return true;\n  }\n\n  return getIsFixed(el.parentElement);\n};\n\nvar getEnv = (function (start) {\n  var closestScrollable = getClosestScrollable(start);\n  var isFixedOnPage = getIsFixed(start);\n  return {\n    closestScrollable: closestScrollable,\n    isFixedOnPage: isFixedOnPage\n  };\n});\n\nvar getDroppableDimension = (function (_ref) {\n  var descriptor = _ref.descriptor,\n      isEnabled = _ref.isEnabled,\n      isCombineEnabled = _ref.isCombineEnabled,\n      isFixedOnPage = _ref.isFixedOnPage,\n      direction = _ref.direction,\n      client = _ref.client,\n      page = _ref.page,\n      closest = _ref.closest;\n\n  var frame = function () {\n    if (!closest) {\n      return null;\n    }\n\n    var scrollSize = closest.scrollSize,\n        frameClient = closest.client;\n    var maxScroll = getMaxScroll({\n      scrollHeight: scrollSize.scrollHeight,\n      scrollWidth: scrollSize.scrollWidth,\n      height: frameClient.paddingBox.height,\n      width: frameClient.paddingBox.width\n    });\n    return {\n      pageMarginBox: closest.page.marginBox,\n      frameClient: frameClient,\n      scrollSize: scrollSize,\n      shouldClipSubject: closest.shouldClipSubject,\n      scroll: {\n        initial: closest.scroll,\n        current: closest.scroll,\n        max: maxScroll,\n        diff: {\n          value: origin,\n          displacement: origin\n        }\n      }\n    };\n  }();\n\n  var axis = direction === 'vertical' ? vertical : horizontal;\n  var subject = getSubject({\n    page: page,\n    withPlaceholder: null,\n    axis: axis,\n    frame: frame\n  });\n  var dimension = {\n    descriptor: descriptor,\n    isCombineEnabled: isCombineEnabled,\n    isFixedOnPage: isFixedOnPage,\n    axis: axis,\n    isEnabled: isEnabled,\n    client: client,\n    page: page,\n    frame: frame,\n    subject: subject\n  };\n  return dimension;\n});\n\nvar getClient = function getClient(targetRef, closestScrollable) {\n  var base = cssBoxModel.getBox(targetRef);\n\n  if (!closestScrollable) {\n    return base;\n  }\n\n  if (targetRef !== closestScrollable) {\n    return base;\n  }\n\n  var top = base.paddingBox.top - closestScrollable.scrollTop;\n  var left = base.paddingBox.left - closestScrollable.scrollLeft;\n  var bottom = top + closestScrollable.scrollHeight;\n  var right = left + closestScrollable.scrollWidth;\n  var paddingBox = {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n  var borderBox = cssBoxModel.expand(paddingBox, base.border);\n  var client = cssBoxModel.createBox({\n    borderBox: borderBox,\n    margin: base.margin,\n    border: base.border,\n    padding: base.padding\n  });\n  return client;\n};\n\nvar getDimension = (function (_ref) {\n  var ref = _ref.ref,\n      descriptor = _ref.descriptor,\n      env = _ref.env,\n      windowScroll = _ref.windowScroll,\n      direction = _ref.direction,\n      isDropDisabled = _ref.isDropDisabled,\n      isCombineEnabled = _ref.isCombineEnabled,\n      shouldClipSubject = _ref.shouldClipSubject;\n  var closestScrollable = env.closestScrollable;\n  var client = getClient(ref, closestScrollable);\n  var page = cssBoxModel.withScroll(client, windowScroll);\n\n  var closest = function () {\n    if (!closestScrollable) {\n      return null;\n    }\n\n    var frameClient = cssBoxModel.getBox(closestScrollable);\n    var scrollSize = {\n      scrollHeight: closestScrollable.scrollHeight,\n      scrollWidth: closestScrollable.scrollWidth\n    };\n    return {\n      client: frameClient,\n      page: cssBoxModel.withScroll(frameClient, windowScroll),\n      scroll: getScroll$1(closestScrollable),\n      scrollSize: scrollSize,\n      shouldClipSubject: shouldClipSubject\n    };\n  }();\n\n  var dimension = getDroppableDimension({\n    descriptor: descriptor,\n    isEnabled: !isDropDisabled,\n    isCombineEnabled: isCombineEnabled,\n    isFixedOnPage: env.isFixedOnPage,\n    direction: direction,\n    client: client,\n    page: page,\n    closest: closest\n  });\n  return dimension;\n});\n\nvar immediate = {\n  passive: false\n};\nvar delayed = {\n  passive: true\n};\nvar getListenerOptions = (function (options) {\n  return options.shouldPublishImmediately ? immediate : delayed;\n});\n\nfunction useRequiredContext(Context) {\n  var result = React.useContext(Context);\n  !result ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find required context') : invariant(false) : void 0;\n  return result;\n}\n\nvar count = 0;\nfunction useUniqueId(prefix) {\n  var countRef = React.useRef(count++);\n  return prefix + \"::\" + countRef.current;\n}\n\nvar getClosestScrollableFromDrag = function getClosestScrollableFromDrag(dragging) {\n  return dragging && dragging.env.closestScrollable || null;\n};\n\nfunction useDroppablePublisher(args) {\n  var whileDraggingRef = React.useRef(null);\n  var appContext = useRequiredContext(AppContext);\n  var uniqueId = useUniqueId('droppable');\n  var registry = appContext.registry,\n      marshal = appContext.marshal;\n  var previousRef = usePrevious(args);\n  var descriptor = useMemoOne.useMemo(function () {\n    return {\n      id: args.droppableId,\n      type: args.type,\n      mode: args.mode\n    };\n  }, [args.droppableId, args.mode, args.type]);\n  var publishedDescriptorRef = React.useRef(descriptor);\n  var memoizedUpdateScroll = useMemoOne.useMemo(function () {\n    return memoizeOne(function (x, y) {\n      !whileDraggingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only update scroll when dragging') : invariant(false) : void 0;\n      var scroll = {\n        x: x,\n        y: y\n      };\n      marshal.updateDroppableScroll(descriptor.id, scroll);\n    });\n  }, [descriptor.id, marshal]);\n  var getClosestScroll = useMemoOne.useCallback(function () {\n    var dragging = whileDraggingRef.current;\n\n    if (!dragging || !dragging.env.closestScrollable) {\n      return origin;\n    }\n\n    return getScroll$1(dragging.env.closestScrollable);\n  }, []);\n  var updateScroll = useMemoOne.useCallback(function () {\n    var scroll = getClosestScroll();\n    memoizedUpdateScroll(scroll.x, scroll.y);\n  }, [getClosestScroll, memoizedUpdateScroll]);\n  var scheduleScrollUpdate = useMemoOne.useMemo(function () {\n    return rafSchd(updateScroll);\n  }, [updateScroll]);\n  var onClosestScroll = useMemoOne.useCallback(function () {\n    var dragging = whileDraggingRef.current;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find scroll options while scrolling') : invariant(false) : void 0;\n    var options = dragging.scrollOptions;\n\n    if (options.shouldPublishImmediately) {\n      updateScroll();\n      return;\n    }\n\n    scheduleScrollUpdate();\n  }, [scheduleScrollUpdate, updateScroll]);\n  var getDimensionAndWatchScroll = useMemoOne.useCallback(function (windowScroll, options) {\n    !!whileDraggingRef.current ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot collect a droppable while a drag is occurring') : invariant(false) : void 0;\n    var previous = previousRef.current;\n    var ref = previous.getDroppableRef();\n    !ref ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot collect without a droppable ref') : invariant(false) : void 0;\n    var env = getEnv(ref);\n    var dragging = {\n      ref: ref,\n      descriptor: descriptor,\n      env: env,\n      scrollOptions: options\n    };\n    whileDraggingRef.current = dragging;\n    var dimension = getDimension({\n      ref: ref,\n      descriptor: descriptor,\n      env: env,\n      windowScroll: windowScroll,\n      direction: previous.direction,\n      isDropDisabled: previous.isDropDisabled,\n      isCombineEnabled: previous.isCombineEnabled,\n      shouldClipSubject: !previous.ignoreContainerClipping\n    });\n    var scrollable = env.closestScrollable;\n\n    if (scrollable) {\n      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n      scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkForNestedScrollContainers(scrollable);\n      }\n    }\n\n    return dimension;\n  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);\n  var getScrollWhileDragging = useMemoOne.useCallback(function () {\n    var dragging = whileDraggingRef.current;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only recollect Droppable client for Droppables that have a scroll container') : invariant(false) : void 0;\n    return getScroll$1(closest);\n  }, []);\n  var dragStopped = useMemoOne.useCallback(function () {\n    var dragging = whileDraggingRef.current;\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot stop drag when no active drag') : invariant(false) : void 0;\n    var closest = getClosestScrollableFromDrag(dragging);\n    whileDraggingRef.current = null;\n\n    if (!closest) {\n      return;\n    }\n\n    scheduleScrollUpdate.cancel();\n    closest.removeAttribute(scrollContainer.contextId);\n    closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n  }, [onClosestScroll, scheduleScrollUpdate]);\n  var scroll = useMemoOne.useCallback(function (change) {\n    var dragging = whileDraggingRef.current;\n    !dragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot scroll when there is no drag') : invariant(false) : void 0;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !closest ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : invariant(false) : void 0;\n    closest.scrollTop += change.y;\n    closest.scrollLeft += change.x;\n  }, []);\n  var callbacks = useMemoOne.useMemo(function () {\n    return {\n      getDimensionAndWatchScroll: getDimensionAndWatchScroll,\n      getScrollWhileDragging: getScrollWhileDragging,\n      dragStopped: dragStopped,\n      scroll: scroll\n    };\n  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll]);\n  var entry = useMemoOne.useMemo(function () {\n    return {\n      uniqueId: uniqueId,\n      descriptor: descriptor,\n      callbacks: callbacks\n    };\n  }, [callbacks, descriptor, uniqueId]);\n  useIsomorphicLayoutEffect(function () {\n    publishedDescriptorRef.current = entry.descriptor;\n    registry.droppable.register(entry);\n    return function () {\n      if (whileDraggingRef.current) {\n        process.env.NODE_ENV !== \"production\" ? warning('Unsupported: changing the droppableId or type of a Droppable during a drag') : void 0;\n        dragStopped();\n      }\n\n      registry.droppable.unregister(entry);\n    };\n  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);\n  useIsomorphicLayoutEffect(function () {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n\n    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n  }, [args.isDropDisabled, marshal]);\n  useIsomorphicLayoutEffect(function () {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n\n    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n  }, [args.isCombineEnabled, marshal]);\n}\n\nfunction noop$2() {}\n\nvar empty = {\n  width: 0,\n  height: 0,\n  margin: noSpacing\n};\n\nvar getSize = function getSize(_ref) {\n  var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount,\n      placeholder = _ref.placeholder,\n      animate = _ref.animate;\n\n  if (isAnimatingOpenOnMount) {\n    return empty;\n  }\n\n  if (animate === 'close') {\n    return empty;\n  }\n\n  return {\n    height: placeholder.client.borderBox.height,\n    width: placeholder.client.borderBox.width,\n    margin: placeholder.client.margin\n  };\n};\n\nvar getStyle = function getStyle(_ref2) {\n  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount,\n      placeholder = _ref2.placeholder,\n      animate = _ref2.animate;\n  var size = getSize({\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n    placeholder: placeholder,\n    animate: animate\n  });\n  return {\n    display: placeholder.display,\n    boxSizing: 'border-box',\n    width: size.width,\n    height: size.height,\n    marginTop: size.margin.top,\n    marginRight: size.margin.right,\n    marginBottom: size.margin.bottom,\n    marginLeft: size.margin.left,\n    flexShrink: '0',\n    flexGrow: '0',\n    pointerEvents: 'none',\n    transition: animate !== 'none' ? transitions.placeholder : null\n  };\n};\n\nfunction Placeholder(props) {\n  var animateOpenTimerRef = React.useRef(null);\n  var tryClearAnimateOpenTimer = useMemoOne.useCallback(function () {\n    if (!animateOpenTimerRef.current) {\n      return;\n    }\n\n    clearTimeout(animateOpenTimerRef.current);\n    animateOpenTimerRef.current = null;\n  }, []);\n  var animate = props.animate,\n      onTransitionEnd = props.onTransitionEnd,\n      onClose = props.onClose,\n      contextId = props.contextId;\n\n  var _useState = React.useState(props.animate === 'open'),\n      isAnimatingOpenOnMount = _useState[0],\n      setIsAnimatingOpenOnMount = _useState[1];\n\n  React.useEffect(function () {\n    if (!isAnimatingOpenOnMount) {\n      return noop$2;\n    }\n\n    if (animate !== 'open') {\n      tryClearAnimateOpenTimer();\n      setIsAnimatingOpenOnMount(false);\n      return noop$2;\n    }\n\n    if (animateOpenTimerRef.current) {\n      return noop$2;\n    }\n\n    animateOpenTimerRef.current = setTimeout(function () {\n      animateOpenTimerRef.current = null;\n      setIsAnimatingOpenOnMount(false);\n    });\n    return tryClearAnimateOpenTimer;\n  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);\n  var onSizeChangeEnd = useMemoOne.useCallback(function (event) {\n    if (event.propertyName !== 'height') {\n      return;\n    }\n\n    onTransitionEnd();\n\n    if (animate === 'close') {\n      onClose();\n    }\n  }, [animate, onClose, onTransitionEnd]);\n  var style = getStyle({\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n    animate: props.animate,\n    placeholder: props.placeholder\n  });\n  return React__default.createElement(props.placeholder.tagName, {\n    style: style,\n    'data-rbd-placeholder-context-id': contextId,\n    onTransitionEnd: onSizeChangeEnd,\n    ref: props.innerRef\n  });\n}\n\nvar Placeholder$1 = React__default.memo(Placeholder);\n\nvar DroppableContext = React__default.createContext(null);\n\nfunction checkIsValidInnerRef(el) {\n  !(el && isHtmlElement(el)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"\\n    provided.innerRef has not been provided with a HTMLElement.\\n\\n    You can find a guide on using the innerRef callback functions at:\\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\\n  \") : invariant(false) : void 0;\n}\n\nfunction isBoolean(value) {\n  return typeof value === 'boolean';\n}\n\nfunction runChecks(args, checks) {\n  checks.forEach(function (check) {\n    return check(args);\n  });\n}\n\nvar shared = [function required(_ref) {\n  var props = _ref.props;\n  !props.droppableId ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'A Droppable requires a droppableId prop') : invariant(false) : void 0;\n  !(typeof props.droppableId === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"A Droppable requires a [string] droppableId. Provided: [\" + typeof props.droppableId + \"]\") : invariant(false) : void 0;\n}, function _boolean(_ref2) {\n  var props = _ref2.props;\n  !isBoolean(props.isDropDisabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isDropDisabled must be a boolean') : invariant(false) : void 0;\n  !isBoolean(props.isCombineEnabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isCombineEnabled must be a boolean') : invariant(false) : void 0;\n  !isBoolean(props.ignoreContainerClipping) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ignoreContainerClipping must be a boolean') : invariant(false) : void 0;\n}, function ref(_ref3) {\n  var getDroppableRef = _ref3.getDroppableRef;\n  checkIsValidInnerRef(getDroppableRef());\n}];\nvar standard = [function placeholder(_ref4) {\n  var props = _ref4.props,\n      getPlaceholderRef = _ref4.getPlaceholderRef;\n\n  if (!props.placeholder) {\n    return;\n  }\n\n  var ref = getPlaceholderRef();\n\n  if (ref) {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(\"\\n      Droppable setup issue [droppableId: \\\"\" + props.droppableId + \"\\\"]:\\n      DroppableProvided > placeholder could not be found.\\n\\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\\n    \") : void 0;\n}];\nvar virtual = [function hasClone(_ref5) {\n  var props = _ref5.props;\n  !props.renderClone ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Must provide a clone render function (renderClone) for virtual lists') : invariant(false) : void 0;\n}, function hasNoPlaceholder(_ref6) {\n  var getPlaceholderRef = _ref6.getPlaceholderRef;\n  !!getPlaceholderRef() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected virtual list to not have a placeholder') : invariant(false) : void 0;\n}];\nfunction useValidation(args) {\n  useDevSetupWarning(function () {\n    runChecks(args, shared);\n\n    if (args.props.mode === 'standard') {\n      runChecks(args, standard);\n    }\n\n    if (args.props.mode === 'virtual') {\n      runChecks(args, virtual);\n    }\n  });\n}\n\nvar AnimateInOut = function (_React$PureComponent) {\n  _inheritsLoose(AnimateInOut, _React$PureComponent);\n\n  function AnimateInOut() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\n    _this.state = {\n      isVisible: Boolean(_this.props.on),\n      data: _this.props.on,\n      animate: _this.props.shouldAnimate && _this.props.on ? 'open' : 'none'\n    };\n\n    _this.onClose = function () {\n      if (_this.state.animate !== 'close') {\n        return;\n      }\n\n      _this.setState({\n        isVisible: false\n      });\n    };\n\n    return _this;\n  }\n\n  AnimateInOut.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    if (!props.shouldAnimate) {\n      return {\n        isVisible: Boolean(props.on),\n        data: props.on,\n        animate: 'none'\n      };\n    }\n\n    if (props.on) {\n      return {\n        isVisible: true,\n        data: props.on,\n        animate: 'open'\n      };\n    }\n\n    if (state.isVisible) {\n      return {\n        isVisible: true,\n        data: state.data,\n        animate: 'close'\n      };\n    }\n\n    return {\n      isVisible: false,\n      animate: 'close',\n      data: null\n    };\n  };\n\n  var _proto = AnimateInOut.prototype;\n\n  _proto.render = function render() {\n    if (!this.state.isVisible) {\n      return null;\n    }\n\n    var provided = {\n      onClose: this.onClose,\n      data: this.state.data,\n      animate: this.state.animate\n    };\n    return this.props.children(provided);\n  };\n\n  return AnimateInOut;\n}(React__default.PureComponent);\n\nvar zIndexOptions = {\n  dragging: 5000,\n  dropAnimating: 4500\n};\n\nvar getDraggingTransition = function getDraggingTransition(shouldAnimateDragMovement, dropping) {\n  if (dropping) {\n    return transitions.drop(dropping.duration);\n  }\n\n  if (shouldAnimateDragMovement) {\n    return transitions.snap;\n  }\n\n  return transitions.fluid;\n};\n\nvar getDraggingOpacity = function getDraggingOpacity(isCombining, isDropAnimating) {\n  if (!isCombining) {\n    return null;\n  }\n\n  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\n\nvar getShouldDraggingAnimate = function getShouldDraggingAnimate(dragging) {\n  if (dragging.forceShouldAnimate != null) {\n    return dragging.forceShouldAnimate;\n  }\n\n  return dragging.mode === 'SNAP';\n};\n\nfunction getDraggingStyle(dragging) {\n  var dimension = dragging.dimension;\n  var box = dimension.client;\n  var offset = dragging.offset,\n      combineWith = dragging.combineWith,\n      dropping = dragging.dropping;\n  var isCombining = Boolean(combineWith);\n  var shouldAnimate = getShouldDraggingAnimate(dragging);\n  var isDropAnimating = Boolean(dropping);\n  var transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n  var style = {\n    position: 'fixed',\n    top: box.marginBox.top,\n    left: box.marginBox.left,\n    boxSizing: 'border-box',\n    width: box.borderBox.width,\n    height: box.borderBox.height,\n    transition: getDraggingTransition(shouldAnimate, dropping),\n    transform: transform,\n    opacity: getDraggingOpacity(isCombining, isDropAnimating),\n    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n    pointerEvents: 'none'\n  };\n  return style;\n}\n\nfunction getSecondaryStyle(secondary) {\n  return {\n    transform: transforms.moveTo(secondary.offset),\n    transition: secondary.shouldAnimateDisplacement ? null : 'none'\n  };\n}\n\nfunction getStyle$1(mapped) {\n  return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\n\nfunction getDimension$1(descriptor, el, windowScroll) {\n  if (windowScroll === void 0) {\n    windowScroll = origin;\n  }\n\n  var computedStyles = window.getComputedStyle(el);\n  var borderBox = el.getBoundingClientRect();\n  var client = cssBoxModel.calculateBox(borderBox, computedStyles);\n  var page = cssBoxModel.withScroll(client, windowScroll);\n  var placeholder = {\n    client: client,\n    tagName: el.tagName.toLowerCase(),\n    display: computedStyles.display\n  };\n  var displaceBy = {\n    x: client.marginBox.width,\n    y: client.marginBox.height\n  };\n  var dimension = {\n    descriptor: descriptor,\n    placeholder: placeholder,\n    displaceBy: displaceBy,\n    client: client,\n    page: page\n  };\n  return dimension;\n}\n\nfunction useDraggablePublisher(args) {\n  var uniqueId = useUniqueId('draggable');\n  var descriptor = args.descriptor,\n      registry = args.registry,\n      getDraggableRef = args.getDraggableRef,\n      canDragInteractiveElements = args.canDragInteractiveElements,\n      shouldRespectForcePress = args.shouldRespectForcePress,\n      isEnabled = args.isEnabled;\n  var options = useMemoOne.useMemo(function () {\n    return {\n      canDragInteractiveElements: canDragInteractiveElements,\n      shouldRespectForcePress: shouldRespectForcePress,\n      isEnabled: isEnabled\n    };\n  }, [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);\n  var getDimension = useMemoOne.useCallback(function (windowScroll) {\n    var el = getDraggableRef();\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get dimension when no ref is set') : invariant(false) : void 0;\n    return getDimension$1(descriptor, el, windowScroll);\n  }, [descriptor, getDraggableRef]);\n  var entry = useMemoOne.useMemo(function () {\n    return {\n      uniqueId: uniqueId,\n      descriptor: descriptor,\n      options: options,\n      getDimension: getDimension\n    };\n  }, [descriptor, getDimension, options, uniqueId]);\n  var publishedRef = React.useRef(entry);\n  var isFirstPublishRef = React.useRef(true);\n  useIsomorphicLayoutEffect(function () {\n    registry.draggable.register(publishedRef.current);\n    return function () {\n      return registry.draggable.unregister(publishedRef.current);\n    };\n  }, [registry.draggable]);\n  useIsomorphicLayoutEffect(function () {\n    if (isFirstPublishRef.current) {\n      isFirstPublishRef.current = false;\n      return;\n    }\n\n    var last = publishedRef.current;\n    publishedRef.current = entry;\n    registry.draggable.update(entry, last);\n  }, [entry, registry.draggable]);\n}\n\nfunction useValidation$1(props, contextId, getRef) {\n  useDevSetupWarning(function () {\n    function prefix(id) {\n      return \"Draggable[id: \" + id + \"]: \";\n    }\n\n    var id = props.draggableId;\n    !id ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Draggable requires a draggableId') : invariant(false) : void 0;\n    !(typeof id === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Draggable requires a [string] draggableId.\\n      Provided: [type: \" + typeof id + \"] (value: \" + id + \")\") : invariant(false) : void 0;\n    !_Number$isInteger(props.index) ? process.env.NODE_ENV !== \"production\" ? invariant(false, prefix(id) + \" requires an integer index prop\") : invariant(false) : void 0;\n\n    if (props.mapped.type === 'DRAGGING') {\n      return;\n    }\n\n    checkIsValidInnerRef(getRef());\n\n    if (props.isEnabled) {\n      !findDragHandle(contextId, id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, prefix(id) + \" Unable to find drag handle\") : invariant(false) : void 0;\n    }\n  });\n}\nfunction useClonePropValidation(isClone) {\n  useDev(function () {\n    var initialRef = React.useRef(isClone);\n    useDevSetupWarning(function () {\n      !(isClone === initialRef.current) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Draggable isClone prop value changed during component life') : invariant(false) : void 0;\n    }, [isClone]);\n  });\n}\n\nfunction preventHtml5Dnd(event) {\n  event.preventDefault();\n}\n\nfunction Draggable(props) {\n  var ref = React.useRef(null);\n  var setRef = useMemoOne.useCallback(function (el) {\n    ref.current = el;\n  }, []);\n  var getRef = useMemoOne.useCallback(function () {\n    return ref.current;\n  }, []);\n\n  var _useRequiredContext = useRequiredContext(AppContext),\n      contextId = _useRequiredContext.contextId,\n      liftInstructionId = _useRequiredContext.liftInstructionId,\n      registry = _useRequiredContext.registry;\n\n  var _useRequiredContext2 = useRequiredContext(DroppableContext),\n      type = _useRequiredContext2.type,\n      droppableId = _useRequiredContext2.droppableId;\n\n  var descriptor = useMemoOne.useMemo(function () {\n    return {\n      id: props.draggableId,\n      index: props.index,\n      type: type,\n      droppableId: droppableId\n    };\n  }, [props.draggableId, props.index, type, droppableId]);\n  var children = props.children,\n      draggableId = props.draggableId,\n      isEnabled = props.isEnabled,\n      shouldRespectForcePress = props.shouldRespectForcePress,\n      canDragInteractiveElements = props.canDragInteractiveElements,\n      isClone = props.isClone,\n      mapped = props.mapped,\n      dropAnimationFinishedAction = props.dropAnimationFinished;\n  useValidation$1(props, contextId, getRef);\n  useClonePropValidation(isClone);\n\n  if (!isClone) {\n    var forPublisher = useMemoOne.useMemo(function () {\n      return {\n        descriptor: descriptor,\n        registry: registry,\n        getDraggableRef: getRef,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress,\n        isEnabled: isEnabled\n      };\n    }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);\n    useDraggablePublisher(forPublisher);\n  }\n\n  var dragHandleProps = useMemoOne.useMemo(function () {\n    return isEnabled ? {\n      tabIndex: 0,\n      'data-rbd-drag-handle-draggable-id': draggableId,\n      'data-rbd-drag-handle-context-id': contextId,\n      'aria-labelledby': liftInstructionId,\n      draggable: false,\n      onDragStart: preventHtml5Dnd\n    } : null;\n  }, [contextId, draggableId, isEnabled, liftInstructionId]);\n  var onMoveEnd = useMemoOne.useCallback(function (event) {\n    if (mapped.type !== 'DRAGGING') {\n      return;\n    }\n\n    if (!mapped.dropping) {\n      return;\n    }\n\n    if (event.propertyName !== 'transform') {\n      return;\n    }\n\n    dropAnimationFinishedAction();\n  }, [dropAnimationFinishedAction, mapped]);\n  var provided = useMemoOne.useMemo(function () {\n    var style = getStyle$1(mapped);\n    var onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : null;\n    var result = {\n      innerRef: setRef,\n      draggableProps: {\n        'data-rbd-draggable-context-id': contextId,\n        'data-rbd-draggable-id': draggableId,\n        style: style,\n        onTransitionEnd: onTransitionEnd\n      },\n      dragHandleProps: dragHandleProps\n    };\n    return result;\n  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);\n  var rubric = useMemoOne.useMemo(function () {\n    return {\n      draggableId: descriptor.id,\n      type: descriptor.type,\n      source: {\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n      }\n    };\n  }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);\n  return children(provided, mapped.snapshot, rubric);\n}\n\nvar isStrictEqual = (function (a, b) {\n  return a === b;\n});\n\nvar whatIsDraggedOverFromResult = (function (result) {\n  var combine = result.combine,\n      destination = result.destination;\n\n  if (destination) {\n    return destination.droppableId;\n  }\n\n  if (combine) {\n    return combine.droppableId;\n  }\n\n  return null;\n});\n\nvar getCombineWithFromResult = function getCombineWithFromResult(result) {\n  return result.combine ? result.combine.draggableId : null;\n};\n\nvar getCombineWithFromImpact = function getCombineWithFromImpact(impact) {\n  return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;\n};\n\nfunction getDraggableSelector() {\n  var memoizedOffset = memoizeOne(function (x, y) {\n    return {\n      x: x,\n      y: y\n    };\n  });\n  var getMemoizedSnapshot = memoizeOne(function (mode, isClone, draggingOver, combineWith, dropping) {\n    return {\n      isDragging: true,\n      isClone: isClone,\n      isDropAnimating: Boolean(dropping),\n      dropAnimation: dropping,\n      mode: mode,\n      draggingOver: draggingOver,\n      combineWith: combineWith,\n      combineTargetFor: null\n    };\n  });\n  var getMemoizedProps = memoizeOne(function (offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {\n    return {\n      mapped: {\n        type: 'DRAGGING',\n        dropping: null,\n        draggingOver: draggingOver,\n        combineWith: combineWith,\n        mode: mode,\n        offset: offset,\n        dimension: dimension,\n        forceShouldAnimate: forceShouldAnimate,\n        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n      }\n    };\n  });\n\n  var selector = function selector(state, ownProps) {\n    if (state.isDragging) {\n      if (state.critical.draggable.id !== ownProps.draggableId) {\n        return null;\n      }\n\n      var offset = state.current.client.offset;\n      var dimension = state.dimensions.draggables[ownProps.draggableId];\n      var draggingOver = whatIsDraggedOver(state.impact);\n      var combineWith = getCombineWithFromImpact(state.impact);\n      var forceShouldAnimate = state.forceShouldAnimate;\n      return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (completed.result.draggableId !== ownProps.draggableId) {\n        return null;\n      }\n\n      var isClone = ownProps.isClone;\n      var _dimension = state.dimensions.draggables[ownProps.draggableId];\n      var result = completed.result;\n      var mode = result.mode;\n\n      var _draggingOver = whatIsDraggedOverFromResult(result);\n\n      var _combineWith = getCombineWithFromResult(result);\n\n      var duration = state.dropDuration;\n      var dropping = {\n        duration: duration,\n        curve: curves.drop,\n        moveTo: state.newHomeClientOffset,\n        opacity: _combineWith ? combine.opacity.drop : null,\n        scale: _combineWith ? combine.scale.drop : null\n      };\n      return {\n        mapped: {\n          type: 'DRAGGING',\n          offset: state.newHomeClientOffset,\n          dimension: _dimension,\n          dropping: dropping,\n          draggingOver: _draggingOver,\n          combineWith: _combineWith,\n          mode: mode,\n          forceShouldAnimate: null,\n          snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)\n        }\n      };\n    }\n\n    return null;\n  };\n\n  return selector;\n}\n\nfunction getSecondarySnapshot(combineTargetFor) {\n  return {\n    isDragging: false,\n    isDropAnimating: false,\n    isClone: false,\n    dropAnimation: null,\n    mode: null,\n    draggingOver: null,\n    combineTargetFor: combineTargetFor,\n    combineWith: null\n  };\n}\n\nvar atRest = {\n  mapped: {\n    type: 'SECONDARY',\n    offset: origin,\n    combineTargetFor: null,\n    shouldAnimateDisplacement: true,\n    snapshot: getSecondarySnapshot(null)\n  }\n};\n\nfunction getSecondarySelector() {\n  var memoizedOffset = memoizeOne(function (x, y) {\n    return {\n      x: x,\n      y: y\n    };\n  });\n  var getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);\n  var getMemoizedProps = memoizeOne(function (offset, combineTargetFor, shouldAnimateDisplacement) {\n    if (combineTargetFor === void 0) {\n      combineTargetFor = null;\n    }\n\n    return {\n      mapped: {\n        type: 'SECONDARY',\n        offset: offset,\n        combineTargetFor: combineTargetFor,\n        shouldAnimateDisplacement: shouldAnimateDisplacement,\n        snapshot: getMemoizedSnapshot(combineTargetFor)\n      }\n    };\n  });\n\n  var getFallback = function getFallback(combineTargetFor) {\n    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n  };\n\n  var getProps = function getProps(ownId, draggingId, impact, afterCritical) {\n    var visualDisplacement = impact.displaced.visible[ownId];\n    var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n    var combine = tryGetCombine(impact);\n    var combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n\n    if (!visualDisplacement) {\n      if (!isAfterCriticalInVirtualList) {\n        return getFallback(combineTargetFor);\n      }\n\n      if (impact.displaced.invisible[ownId]) {\n        return null;\n      }\n\n      var change = negate(afterCritical.displacedBy.point);\n\n      var _offset = memoizedOffset(change.x, change.y);\n\n      return getMemoizedProps(_offset, combineTargetFor, true);\n    }\n\n    if (isAfterCriticalInVirtualList) {\n      return getFallback(combineTargetFor);\n    }\n\n    var displaceBy = impact.displacedBy.point;\n    var offset = memoizedOffset(displaceBy.x, displaceBy.y);\n    return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n  };\n\n  var selector = function selector(state, ownProps) {\n    if (state.isDragging) {\n      if (state.critical.draggable.id === ownProps.draggableId) {\n        return null;\n      }\n\n      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (completed.result.draggableId === ownProps.draggableId) {\n        return null;\n      }\n\n      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n    }\n\n    return null;\n  };\n\n  return selector;\n}\n\nvar makeMapStateToProps = function makeMapStateToProps() {\n  var draggingSelector = getDraggableSelector();\n  var secondarySelector = getSecondarySelector();\n\n  var selector = function selector(state, ownProps) {\n    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n  };\n\n  return selector;\n};\nvar mapDispatchToProps = {\n  dropAnimationFinished: dropAnimationFinished\n};\nvar ConnectedDraggable = reactRedux.connect(makeMapStateToProps, mapDispatchToProps, null, {\n  context: StoreContext,\n  pure: true,\n  areStatePropsEqual: isStrictEqual\n})(Draggable);\n\nfunction PrivateDraggable(props) {\n  var droppableContext = useRequiredContext(DroppableContext);\n  var isUsingCloneFor = droppableContext.isUsingCloneFor;\n\n  if (isUsingCloneFor === props.draggableId && !props.isClone) {\n    return null;\n  }\n\n  return React__default.createElement(ConnectedDraggable, props);\n}\nfunction PublicDraggable(props) {\n  var isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;\n  var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n  var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n  return React__default.createElement(PrivateDraggable, _extends({}, props, {\n    isClone: false,\n    isEnabled: isEnabled,\n    canDragInteractiveElements: canDragInteractiveElements,\n    shouldRespectForcePress: shouldRespectForcePress\n  }));\n}\n\nfunction Droppable(props) {\n  var appContext = React.useContext(AppContext);\n  !appContext ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find app context') : invariant(false) : void 0;\n  var contextId = appContext.contextId,\n      isMovementAllowed = appContext.isMovementAllowed;\n  var droppableRef = React.useRef(null);\n  var placeholderRef = React.useRef(null);\n  var children = props.children,\n      droppableId = props.droppableId,\n      type = props.type,\n      mode = props.mode,\n      direction = props.direction,\n      ignoreContainerClipping = props.ignoreContainerClipping,\n      isDropDisabled = props.isDropDisabled,\n      isCombineEnabled = props.isCombineEnabled,\n      snapshot = props.snapshot,\n      useClone = props.useClone,\n      updateViewportMaxScroll = props.updateViewportMaxScroll,\n      getContainerForClone = props.getContainerForClone;\n  var getDroppableRef = useMemoOne.useCallback(function () {\n    return droppableRef.current;\n  }, []);\n  var setDroppableRef = useMemoOne.useCallback(function (value) {\n    droppableRef.current = value;\n  }, []);\n  var getPlaceholderRef = useMemoOne.useCallback(function () {\n    return placeholderRef.current;\n  }, []);\n  var setPlaceholderRef = useMemoOne.useCallback(function (value) {\n    placeholderRef.current = value;\n  }, []);\n  useValidation({\n    props: props,\n    getDroppableRef: getDroppableRef,\n    getPlaceholderRef: getPlaceholderRef\n  });\n  var onPlaceholderTransitionEnd = useMemoOne.useCallback(function () {\n    if (isMovementAllowed()) {\n      updateViewportMaxScroll({\n        maxScroll: getMaxWindowScroll()\n      });\n    }\n  }, [isMovementAllowed, updateViewportMaxScroll]);\n  useDroppablePublisher({\n    droppableId: droppableId,\n    type: type,\n    mode: mode,\n    direction: direction,\n    isDropDisabled: isDropDisabled,\n    isCombineEnabled: isCombineEnabled,\n    ignoreContainerClipping: ignoreContainerClipping,\n    getDroppableRef: getDroppableRef\n  });\n  var placeholder = React__default.createElement(AnimateInOut, {\n    on: props.placeholder,\n    shouldAnimate: props.shouldAnimatePlaceholder\n  }, function (_ref) {\n    var onClose = _ref.onClose,\n        data = _ref.data,\n        animate = _ref.animate;\n    return React__default.createElement(Placeholder$1, {\n      placeholder: data,\n      onClose: onClose,\n      innerRef: setPlaceholderRef,\n      animate: animate,\n      contextId: contextId,\n      onTransitionEnd: onPlaceholderTransitionEnd\n    });\n  });\n  var provided = useMemoOne.useMemo(function () {\n    return {\n      innerRef: setDroppableRef,\n      placeholder: placeholder,\n      droppableProps: {\n        'data-rbd-droppable-id': droppableId,\n        'data-rbd-droppable-context-id': contextId\n      }\n    };\n  }, [contextId, droppableId, placeholder, setDroppableRef]);\n  var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n  var droppableContext = useMemoOne.useMemo(function () {\n    return {\n      droppableId: droppableId,\n      type: type,\n      isUsingCloneFor: isUsingCloneFor\n    };\n  }, [droppableId, isUsingCloneFor, type]);\n\n  function getClone() {\n    if (!useClone) {\n      return null;\n    }\n\n    var dragging = useClone.dragging,\n        render = useClone.render;\n    var node = React__default.createElement(PrivateDraggable, {\n      draggableId: dragging.draggableId,\n      index: dragging.source.index,\n      isClone: true,\n      isEnabled: true,\n      shouldRespectForcePress: false,\n      canDragInteractiveElements: true\n    }, function (draggableProvided, draggableSnapshot) {\n      return render(draggableProvided, draggableSnapshot, dragging);\n    });\n    return ReactDOM.createPortal(node, getContainerForClone());\n  }\n\n  return React__default.createElement(DroppableContext.Provider, {\n    value: droppableContext\n  }, children(provided, snapshot), getClone());\n}\n\nvar isMatchingType = function isMatchingType(type, critical) {\n  return type === critical.droppable.type;\n};\n\nvar getDraggable = function getDraggable(critical, dimensions) {\n  return dimensions.draggables[critical.draggable.id];\n};\n\nvar makeMapStateToProps$1 = function makeMapStateToProps() {\n  var idleWithAnimation = {\n    placeholder: null,\n    shouldAnimatePlaceholder: true,\n    snapshot: {\n      isDraggingOver: false,\n      draggingOverWith: null,\n      draggingFromThisWith: null,\n      isUsingPlaceholder: false\n    },\n    useClone: null\n  };\n\n  var idleWithoutAnimation = _extends({}, idleWithAnimation, {\n    shouldAnimatePlaceholder: false\n  });\n\n  var getDraggableRubric = memoizeOne(function (descriptor) {\n    return {\n      draggableId: descriptor.id,\n      type: descriptor.type,\n      source: {\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n      }\n    };\n  });\n  var getMapProps = memoizeOne(function (id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {\n    var draggableId = dragging.descriptor.id;\n    var isHome = dragging.descriptor.droppableId === id;\n\n    if (isHome) {\n      var useClone = renderClone ? {\n        render: renderClone,\n        dragging: getDraggableRubric(dragging.descriptor)\n      } : null;\n      var _snapshot = {\n        isDraggingOver: isDraggingOverForConsumer,\n        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n        draggingFromThisWith: draggableId,\n        isUsingPlaceholder: true\n      };\n      return {\n        placeholder: dragging.placeholder,\n        shouldAnimatePlaceholder: false,\n        snapshot: _snapshot,\n        useClone: useClone\n      };\n    }\n\n    if (!isEnabled) {\n      return idleWithoutAnimation;\n    }\n\n    if (!isDraggingOverForImpact) {\n      return idleWithAnimation;\n    }\n\n    var snapshot = {\n      isDraggingOver: isDraggingOverForConsumer,\n      draggingOverWith: draggableId,\n      draggingFromThisWith: null,\n      isUsingPlaceholder: true\n    };\n    return {\n      placeholder: dragging.placeholder,\n      shouldAnimatePlaceholder: true,\n      snapshot: snapshot,\n      useClone: null\n    };\n  });\n\n  var selector = function selector(state, ownProps) {\n    var id = ownProps.droppableId;\n    var type = ownProps.type;\n    var isEnabled = !ownProps.isDropDisabled;\n    var renderClone = ownProps.renderClone;\n\n    if (state.isDragging) {\n      var critical = state.critical;\n\n      if (!isMatchingType(type, critical)) {\n        return idleWithoutAnimation;\n      }\n\n      var dragging = getDraggable(critical, state.dimensions);\n      var isDraggingOver = whatIsDraggedOver(state.impact) === id;\n      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (!isMatchingType(type, completed.critical)) {\n        return idleWithoutAnimation;\n      }\n\n      var _dragging = getDraggable(completed.critical, state.dimensions);\n\n      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);\n    }\n\n    if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {\n      var _completed = state.completed;\n\n      if (!isMatchingType(type, _completed.critical)) {\n        return idleWithoutAnimation;\n      }\n\n      var wasOver = whatIsDraggedOver(_completed.impact) === id;\n      var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === 'COMBINE');\n      var isHome = _completed.critical.droppable.id === id;\n\n      if (wasOver) {\n        return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n      }\n\n      if (isHome) {\n        return idleWithAnimation;\n      }\n\n      return idleWithoutAnimation;\n    }\n\n    return idleWithoutAnimation;\n  };\n\n  return selector;\n};\nvar mapDispatchToProps$1 = {\n  updateViewportMaxScroll: updateViewportMaxScroll\n};\n\nfunction getBody() {\n  !document.body ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'document.body is not ready') : invariant(false) : void 0;\n  return document.body;\n}\n\nvar defaultProps = {\n  mode: 'standard',\n  type: 'DEFAULT',\n  direction: 'vertical',\n  isDropDisabled: false,\n  isCombineEnabled: false,\n  ignoreContainerClipping: false,\n  renderClone: null,\n  getContainerForClone: getBody\n};\nvar ConnectedDroppable = reactRedux.connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n  context: StoreContext,\n  pure: true,\n  areStatePropsEqual: isStrictEqual\n})(Droppable);\nConnectedDroppable.defaultProps = defaultProps;\n\nexports.DragDropContext = DragDropContext;\nexports.Draggable = PublicDraggable;\nexports.Droppable = ConnectedDroppable;\nexports.resetServerContext = resetServerContext;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$redux$lib$redux","~$module$node_modules$$babel$runtime_corejs2$core_js$date$now","~$module$node_modules$memoize_one$dist$memoize_one_cjs","~$module$node_modules$raf_schd$dist$raf_schd_cjs","~$module$node_modules$css_box_model$dist$css_box_model_cjs","~$module$node_modules$react_redux$lib$index","~$module$node_modules$react_dom$index","~$module$node_modules$$babel$runtime_corejs2$core_js$number$is_integer","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$$babel$runtime_corejs2$core_js$object$keys","~$module$node_modules$$babel$runtime_corejs2$helpers$extends","~$module$node_modules$$babel$runtime_corejs2$helpers$inheritsLoose","~$module$node_modules$$babel$runtime_corejs2$core_js$object$values","~$module$node_modules$use_memo_one$dist$use_memo_one_cjs","~$module$node_modules$$babel$runtime_corejs2$core_js$object$assign"]],"~:properties",["^5",["abandon","release","resting","stop","contextId","scrollWidth","overflowX","callback","isVisibleThroughFrameFn","getDimensionAndWatchScroll","combineWithId","updateDroppableScroll","draggingFromThisWith","thresholds","message","isDropAnimating","updateDroppableIsEnabled","startPublishing","isUsingPlaceholder","getDraggableRef","unbind","pageBorderBoxCenterWithDroppableScrollChange","tryRecordFocus","shouldPublishImmediately","droppableProps","isActive","marginBottom","getScrollWhileDragging","crossAxisStart","snap","onLiftImpact","collectionStarting","cleanup","width","timerId","setPhase","combineWith","getDerivedStateFromProps","displaced","durationDampening","shouldUseTimeDampening","right","lastLocation","startScrollingFrom","passive","isWindowScrollAllowed","isDragging","uniqueId","top","isDraggingOver","getContainerForClone","curve","unregister","onWindowError","optgroup","destination","onClose","index","Draggable","once","offset","resetServerContext","cancel","callbacks","viewport","destinationId","isClaimed","height","margin","scale","combineTargetFor","tabIndex","distanceToEdges","overflowY","getCallbacks","marshal","draggingOverWith","shouldAnimate","major","stopPublishing","clip","dragging","wasCalled","closestScrollable","displaceBy","scrollLeft","ease","droppableId","scroll","tryAbort","findClosestDraggableId","placeholder","stopDampeningAt","textContent","borderBox","border","x","focus","startOfRange","placeholderSize","__esModule","isWaiting","removals","dragHandleProps","max","fluid","marginTop","outOfTheWay","padding","isAnimatingOpenOnMount","axis","isUsingCloneFor","option","combining","vertical","video","longPressTimerId","draggingOver","id","fn","flush","completed","dragStopped","transform","scrollSize","toString","shouldBlockNextClick","diff","snapshot","maxScroll","base","isMovementAllowed","lastCritical","update","withPlaceholder","innerRef","movementMode","increasedBy","droppable","withDroppableDisplacement","renderClone","getDimension","distanceToEdge","customSensors","mode","onBeforeDragStart","expected","getPhase","pageBorderBoxCenter","position","displacedBy","claim","scrollDroppable","dropAnimation","accelerateAt","getAllByType","getPlaceholderRef","eventName","crossAxisSize","findById","animate","dragStartTime","style","dropAnimationFinished","flexGrow","value","published","fluidLift","center","dimensions","areStatePropsEqual","drop","visible","moveDown","always","getDroppableRef","registry","previousClientSelection","shouldRespectForcePress","canGetLock","boxSizing","minor","enableDefaultSensors","context","pageMarginBox","tryGetLock","onWindowScroll","liftInstruction","userDirection","isMoving","direction","previousImpact","pure","liftInstructionId","announce","initial","select","crossAxisLine","afterDragging","moveRight","inHomeList","sensors","start","critical","impact","droppables","afterCritical","closest","onDragUpdate","remove","dropping","scrollWindow","DragDropContext","marginLeft","patch","draggableProps","moveUp","ignoreContainerClipping","draggables","on","subject","shouldAnimatePlaceholder","styles","current","publish","mapped","endOfRange","register","lastCombine","forceSensorStop","onDragEnd","draggable","length","shouldClipSubject","componentDidMount","input","props","line","defaultProps","hasMoved","duration","last","textarea","move","maxScrollAtPercentage","env","source","moveTo","audio","shouldWarn","type","overflow","home","beforeStart","dropAnimating","render","descriptor","y","horizontal","tagName","maxScrollChange","tryAbandon","state","shouldFlush","isVisible","ref","zIndex","modified","flexShrink","maxScrollValueAt","target","componentDidCatch","isMovingForward","isLockActive","scrollJumpRequest","sourceEvent","scrollOptions","reason","isCombineEnabled","isFixedOnPage","display","publishWhileDragging","capture","whenEntered","getById","updateDroppableIsCombineEnabled","add","onTransitionEnd","componentWillUnmount","clientSelection","bottom","isDropDisabled","tryShiftRecord","isClone","nonce","dropDuration","onlyOnMainAxis","onDragStart","all","selection","clean","abort","exists","isLockClaimed","size","effected","selector","previousPageBorderBoxCenter","active","newScroll","raw","startFromPercentage","page","frame","combine","payload","phase","updatedDroppables","canDragInteractiveElements","tryReleaseLock","client","borderBoxCenter","newHomeClientOffset","options","useClone","transition","react","scrollTop","dimension","subscribe","data","shouldAnimateDisplacement","scrollHeight","Droppable","draggableId","canLift","userCancel","displacement","frameClient","inVirtualList","store","lockAPI","crossAxisEnd","moveRelativeTo","oldFrameMaxScroll","opacity","end","moveLeft","forceShouldAnimate","at","point","liftActionArgs","left","pointerEvents","snapLift","container","change","actions","isEnabled","result","button","findOptionsForDraggable","invisible","setCallbacks","newPageBorderBoxCenter","updateViewportMaxScroll","additions","unsubscribe","insideDestination","marginRight","maxPixelScroll","tryRestoreFocusRecorded"]],"~:compiled-at",1577334979995,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_beautiful_dnd$dist$react_beautiful_dnd_cjs.js\",\n\"lineCount\":296,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.cjs.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_beautiful_dnd$dist$react_beautiful_dnd_cjs\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\\n\\nvar React = require('react');\\nvar React__default = _interopDefault(React);\\nvar useMemoOne = require('use-memo-one');\\nvar _inheritsLoose = _interopDefault(require('@babel/runtime-corejs2/helpers/inheritsLoose'));\\nvar _extends = _interopDefault(require('@babel/runtime-corejs2/helpers/extends'));\\nvar redux = require('redux');\\nvar reactRedux = require('react-redux');\\nvar cssBoxModel = require('css-box-model');\\nvar memoizeOne = _interopDefault(require('memoize-one'));\\nvar _Object$values = _interopDefault(require('@babel/runtime-corejs2/core-js/object/values'));\\nvar _Object$keys = _interopDefault(require('@babel/runtime-corejs2/core-js/object/keys'));\\nvar rafSchd = _interopDefault(require('raf-schd'));\\nvar _Date$now = _interopDefault(require('@babel/runtime-corejs2/core-js/date/now'));\\nvar _Object$assign = _interopDefault(require('@babel/runtime-corejs2/core-js/object/assign'));\\nvar ReactDOM = _interopDefault(require('react-dom'));\\nvar _Number$isInteger = _interopDefault(require('@babel/runtime-corejs2/core-js/number/is-integer'));\\n\\nvar isProduction = process.env.NODE_ENV === 'production';\\nvar spacesAndTabs = /[ \\\\t]{2,}/g;\\nvar lineStartWithSpaces = /^[ \\\\t]*/gm;\\n\\nvar clean = function clean(value) {\\n  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\\n};\\n\\nvar getDevMessage = function getDevMessage(message) {\\n  return clean(\\\"\\\\n  %creact-beautiful-dnd\\\\n\\\\n  %c\\\" + clean(message) + \\\"\\\\n\\\\n  %c\\\\uD83D\\\\uDC77\\\\u200D This is a development only message. It will be removed in production builds.\\\\n\\\");\\n};\\n\\nvar getFormattedMessage = function getFormattedMessage(message) {\\n  return [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];\\n};\\nvar isDisabledFlag = '__react-beautiful-dnd-disable-dev-warnings';\\nfunction log(type, message) {\\n  var _console;\\n\\n  if (isProduction) {\\n    return;\\n  }\\n\\n  if (typeof window !== 'undefined' && window[isDisabledFlag]) {\\n    return;\\n  }\\n\\n  (_console = console)[type].apply(_console, getFormattedMessage(message));\\n}\\nvar warning = log.bind(null, 'warn');\\nvar error = log.bind(null, 'error');\\n\\nfunction noop() {}\\n\\nfunction getOptions(shared, fromBinding) {\\n  return _extends({}, shared, {}, fromBinding);\\n}\\n\\nfunction bindEvents(el, bindings, sharedOptions) {\\n  var unbindings = bindings.map(function (binding) {\\n    var options = getOptions(sharedOptions, binding.options);\\n    el.addEventListener(binding.eventName, binding.fn, options);\\n    return function unbind() {\\n      el.removeEventListener(binding.eventName, binding.fn, options);\\n    };\\n  });\\n  return function unbindAll() {\\n    unbindings.forEach(function (unbind) {\\n      unbind();\\n    });\\n  };\\n}\\n\\nvar isProduction$1 = process.env.NODE_ENV === 'production';\\nvar prefix = 'Invariant failed';\\nfunction RbdInvariant(message) {\\n  this.message = message;\\n}\\n\\nRbdInvariant.prototype.toString = function toString() {\\n  return this.message;\\n};\\n\\nfunction invariant(condition, message) {\\n  if (condition) {\\n    return;\\n  }\\n\\n  if (isProduction$1) {\\n    throw new RbdInvariant(prefix);\\n  } else {\\n    throw new RbdInvariant(prefix + \\\": \\\" + (message || ''));\\n  }\\n}\\n\\nvar ErrorBoundary = function (_React$Component) {\\n  _inheritsLoose(ErrorBoundary, _React$Component);\\n\\n  function ErrorBoundary() {\\n    var _this;\\n\\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\\n    _this.callbacks = null;\\n    _this.unbind = noop;\\n\\n    _this.onWindowError = function (event) {\\n      var callbacks = _this.getCallbacks();\\n\\n      if (callbacks.isDragging()) {\\n        callbacks.tryAbort();\\n        process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n        An error was caught by our window 'error' event listener while a drag was occurring.\\\\n        The active drag has been aborted.\\\\n      \\\") : void 0;\\n      }\\n\\n      var err = event.error;\\n\\n      if (err instanceof RbdInvariant) {\\n        event.preventDefault();\\n\\n        if (process.env.NODE_ENV !== 'production') {\\n          error(err.message);\\n        }\\n      }\\n    };\\n\\n    _this.getCallbacks = function () {\\n      if (!_this.callbacks) {\\n        throw new Error('Unable to find AppCallbacks in <ErrorBoundary/>');\\n      }\\n\\n      return _this.callbacks;\\n    };\\n\\n    _this.setCallbacks = function (callbacks) {\\n      _this.callbacks = callbacks;\\n    };\\n\\n    return _this;\\n  }\\n\\n  var _proto = ErrorBoundary.prototype;\\n\\n  _proto.componentDidMount = function componentDidMount() {\\n    this.unbind = bindEvents(window, [{\\n      eventName: 'error',\\n      fn: this.onWindowError\\n    }]);\\n  };\\n\\n  _proto.componentWillUnmount = function componentWillUnmount() {\\n    this.unbind();\\n  };\\n\\n  _proto.componentDidCatch = function componentDidCatch(err) {\\n    if (err instanceof RbdInvariant) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        error(err.message);\\n      }\\n\\n      this.setState({});\\n      return;\\n    }\\n\\n    throw err;\\n  };\\n\\n  _proto.render = function render() {\\n    return this.props.children(this.setCallbacks);\\n  };\\n\\n  return ErrorBoundary;\\n}(React__default.Component);\\n\\nvar liftInstruction = \\\"Draggable item. Ensure your screen reader is not in browse mode and then press space bar to lift.\\\";\\n\\nvar position = function position(index) {\\n  return index + 1;\\n};\\n\\nvar onDragStart = function onDragStart(start) {\\n  return \\\"\\\\n  You have lifted an item in position \\\" + position(start.source.index) + \\\".\\\\n  Use the arrow keys to move, space bar to drop, and escape to cancel.\\\\n\\\";\\n};\\n\\nvar withLocation = function withLocation(source, destination) {\\n  var isInHomeList = source.droppableId === destination.droppableId;\\n  var startPosition = position(source.index);\\n  var endPosition = position(destination.index);\\n\\n  if (isInHomeList) {\\n    return \\\"\\\\n      You have moved the item from position \\\" + startPosition + \\\"\\\\n      to position \\\" + endPosition + \\\"\\\\n    \\\";\\n  }\\n\\n  return \\\"\\\\n    You have moved the item from position \\\" + startPosition + \\\"\\\\n    in list \\\" + source.droppableId + \\\"\\\\n    to list \\\" + destination.droppableId + \\\"\\\\n    in position \\\" + endPosition + \\\"\\\\n  \\\";\\n};\\n\\nvar withCombine = function withCombine(id, source, combine) {\\n  var inHomeList = source.droppableId === combine.droppableId;\\n\\n  if (inHomeList) {\\n    return \\\"\\\\n      The item \\\" + id + \\\"\\\\n      has been combined with \\\" + combine.draggableId;\\n  }\\n\\n  return \\\"\\\\n      The item \\\" + id + \\\"\\\\n      in list \\\" + source.droppableId + \\\"\\\\n      has been combined with \\\" + combine.draggableId + \\\"\\\\n      in list \\\" + combine.droppableId + \\\"\\\\n    \\\";\\n};\\n\\nvar onDragUpdate = function onDragUpdate(update) {\\n  var location = update.destination;\\n\\n  if (location) {\\n    return withLocation(update.source, location);\\n  }\\n\\n  var combine = update.combine;\\n\\n  if (combine) {\\n    return withCombine(update.draggableId, update.source, combine);\\n  }\\n\\n  return 'You are over an area that cannot be dropped on';\\n};\\n\\nvar returnedToStart = function returnedToStart(source) {\\n  return \\\"\\\\n  The item has returned to its starting position\\\\n  of \\\" + position(source.index) + \\\"\\\\n\\\";\\n};\\n\\nvar onDragEnd = function onDragEnd(result) {\\n  if (result.reason === 'CANCEL') {\\n    return \\\"\\\\n      Movement cancelled.\\\\n      \\\" + returnedToStart(result.source) + \\\"\\\\n    \\\";\\n  }\\n\\n  var location = result.destination;\\n  var combine = result.combine;\\n\\n  if (location) {\\n    return \\\"\\\\n      You have dropped the item.\\\\n      \\\" + withLocation(result.source, location) + \\\"\\\\n    \\\";\\n  }\\n\\n  if (combine) {\\n    return \\\"\\\\n      You have dropped the item.\\\\n      \\\" + withCombine(result.draggableId, result.source, combine) + \\\"\\\\n    \\\";\\n  }\\n\\n  return \\\"\\\\n    The item has been dropped while not over a drop area.\\\\n    \\\" + returnedToStart(result.source) + \\\"\\\\n  \\\";\\n};\\n\\nvar preset = {\\n  liftInstruction: liftInstruction,\\n  onDragStart: onDragStart,\\n  onDragUpdate: onDragUpdate,\\n  onDragEnd: onDragEnd\\n};\\n\\nvar origin = {\\n  x: 0,\\n  y: 0\\n};\\nvar add = function add(point1, point2) {\\n  return {\\n    x: point1.x + point2.x,\\n    y: point1.y + point2.y\\n  };\\n};\\nvar subtract = function subtract(point1, point2) {\\n  return {\\n    x: point1.x - point2.x,\\n    y: point1.y - point2.y\\n  };\\n};\\nvar isEqual = function isEqual(point1, point2) {\\n  return point1.x === point2.x && point1.y === point2.y;\\n};\\nvar negate = function negate(point) {\\n  return {\\n    x: point.x !== 0 ? -point.x : 0,\\n    y: point.y !== 0 ? -point.y : 0\\n  };\\n};\\nvar patch = function patch(line, value, otherValue) {\\n  var _ref;\\n\\n  if (otherValue === void 0) {\\n    otherValue = 0;\\n  }\\n\\n  return _ref = {}, _ref[line] = value, _ref[line === 'x' ? 'y' : 'x'] = otherValue, _ref;\\n};\\nvar distance = function distance(point1, point2) {\\n  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\\n};\\nvar closest = function closest(target, points) {\\n  return Math.min.apply(Math, points.map(function (point) {\\n    return distance(target, point);\\n  }));\\n};\\nvar apply = function apply(fn) {\\n  return function (point) {\\n    return {\\n      x: fn(point.x),\\n      y: fn(point.y)\\n    };\\n  };\\n};\\n\\nvar executeClip = (function (frame, subject) {\\n  var result = cssBoxModel.getRect({\\n    top: Math.max(subject.top, frame.top),\\n    right: Math.min(subject.right, frame.right),\\n    bottom: Math.min(subject.bottom, frame.bottom),\\n    left: Math.max(subject.left, frame.left)\\n  });\\n\\n  if (result.width <= 0 || result.height <= 0) {\\n    return null;\\n  }\\n\\n  return result;\\n});\\n\\nvar offsetByPosition = function offsetByPosition(spacing, point) {\\n  return {\\n    top: spacing.top + point.y,\\n    left: spacing.left + point.x,\\n    bottom: spacing.bottom + point.y,\\n    right: spacing.right + point.x\\n  };\\n};\\nvar getCorners = function getCorners(spacing) {\\n  return [{\\n    x: spacing.left,\\n    y: spacing.top\\n  }, {\\n    x: spacing.right,\\n    y: spacing.top\\n  }, {\\n    x: spacing.left,\\n    y: spacing.bottom\\n  }, {\\n    x: spacing.right,\\n    y: spacing.bottom\\n  }];\\n};\\nvar noSpacing = {\\n  top: 0,\\n  right: 0,\\n  bottom: 0,\\n  left: 0\\n};\\n\\nvar scroll = function scroll(target, frame) {\\n  if (!frame) {\\n    return target;\\n  }\\n\\n  return offsetByPosition(target, frame.scroll.diff.displacement);\\n};\\n\\nvar increase = function increase(target, axis, withPlaceholder) {\\n  if (withPlaceholder && withPlaceholder.increasedBy) {\\n    var _extends2;\\n\\n    return _extends({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));\\n  }\\n\\n  return target;\\n};\\n\\nvar clip = function clip(target, frame) {\\n  if (frame && frame.shouldClipSubject) {\\n    return executeClip(frame.pageMarginBox, target);\\n  }\\n\\n  return cssBoxModel.getRect(target);\\n};\\n\\nvar getSubject = (function (_ref) {\\n  var page = _ref.page,\\n      withPlaceholder = _ref.withPlaceholder,\\n      axis = _ref.axis,\\n      frame = _ref.frame;\\n  var scrolled = scroll(page.marginBox, frame);\\n  var increased = increase(scrolled, axis, withPlaceholder);\\n  var clipped = clip(increased, frame);\\n  return {\\n    page: page,\\n    withPlaceholder: withPlaceholder,\\n    active: clipped\\n  };\\n});\\n\\nvar scrollDroppable = (function (droppable, newScroll) {\\n  !droppable.frame ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false) : invariant(false) : void 0;\\n  var scrollable = droppable.frame;\\n  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);\\n  var scrollDisplacement = negate(scrollDiff);\\n\\n  var frame = _extends({}, scrollable, {\\n    scroll: {\\n      initial: scrollable.scroll.initial,\\n      current: newScroll,\\n      diff: {\\n        value: scrollDiff,\\n        displacement: scrollDisplacement\\n      },\\n      max: scrollable.scroll.max\\n    }\\n  });\\n\\n  var subject = getSubject({\\n    page: droppable.subject.page,\\n    withPlaceholder: droppable.subject.withPlaceholder,\\n    axis: droppable.axis,\\n    frame: frame\\n  });\\n\\n  var result = _extends({}, droppable, {\\n    frame: frame,\\n    subject: subject\\n  });\\n\\n  return result;\\n});\\n\\nfunction values(map) {\\n  return _Object$values(map);\\n}\\nfunction findIndex(list, predicate) {\\n  if (list.findIndex) {\\n    return list.findIndex(predicate);\\n  }\\n\\n  for (var i = 0; i < list.length; i++) {\\n    if (predicate(list[i])) {\\n      return i;\\n    }\\n  }\\n\\n  return -1;\\n}\\nfunction find(list, predicate) {\\n  if (list.find) {\\n    return list.find(predicate);\\n  }\\n\\n  var index = findIndex(list, predicate);\\n\\n  if (index !== -1) {\\n    return list[index];\\n  }\\n\\n  return undefined;\\n}\\nfunction toArray(list) {\\n  return Array.prototype.slice.call(list);\\n}\\n\\nvar toDroppableMap = memoizeOne(function (droppables) {\\n  return droppables.reduce(function (previous, current) {\\n    previous[current.descriptor.id] = current;\\n    return previous;\\n  }, {});\\n});\\nvar toDraggableMap = memoizeOne(function (draggables) {\\n  return draggables.reduce(function (previous, current) {\\n    previous[current.descriptor.id] = current;\\n    return previous;\\n  }, {});\\n});\\nvar toDroppableList = memoizeOne(function (droppables) {\\n  return values(droppables);\\n});\\nvar toDraggableList = memoizeOne(function (draggables) {\\n  return values(draggables);\\n});\\n\\nvar getDraggablesInsideDroppable = memoizeOne(function (droppableId, draggables) {\\n  var result = toDraggableList(draggables).filter(function (draggable) {\\n    return droppableId === draggable.descriptor.droppableId;\\n  }).sort(function (a, b) {\\n    return a.descriptor.index - b.descriptor.index;\\n  });\\n  return result;\\n});\\n\\nvar forward = {\\n  vertical: 'down',\\n  horizontal: 'right'\\n};\\nvar backward = {\\n  vertical: 'up',\\n  horizontal: 'left'\\n};\\n\\nfunction tryGetDestination(impact) {\\n  if (impact.at && impact.at.type === 'REORDER') {\\n    return impact.at.destination;\\n  }\\n\\n  return null;\\n}\\nfunction tryGetCombine(impact) {\\n  if (impact.at && impact.at.type === 'COMBINE') {\\n    return impact.at.combine;\\n  }\\n\\n  return null;\\n}\\n\\nvar removeDraggableFromList = memoizeOne(function (remove, list) {\\n  return list.filter(function (item) {\\n    return item.descriptor.id !== remove.descriptor.id;\\n  });\\n});\\n\\nvar moveToNextCombine = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      draggable = _ref.draggable,\\n      destination = _ref.destination,\\n      insideDestination = _ref.insideDestination,\\n      previousImpact = _ref.previousImpact;\\n\\n  if (!destination.isCombineEnabled) {\\n    return null;\\n  }\\n\\n  var location = tryGetDestination(previousImpact);\\n\\n  if (!location) {\\n    return null;\\n  }\\n\\n  function getImpact(target) {\\n    var at = {\\n      type: 'COMBINE',\\n      whenEntered: isMovingForward ? forward : backward,\\n      combine: {\\n        draggableId: target,\\n        droppableId: destination.descriptor.id\\n      }\\n    };\\n    return _extends({}, previousImpact, {\\n      at: at\\n    });\\n  }\\n\\n  var all = previousImpact.displaced.all;\\n  var closestId = all.length ? all[0] : null;\\n\\n  if (isMovingForward) {\\n    return closestId ? getImpact(closestId) : null;\\n  }\\n\\n  var withoutDraggable = removeDraggableFromList(draggable, insideDestination);\\n\\n  if (!closestId) {\\n    if (!withoutDraggable.length) {\\n      return null;\\n    }\\n\\n    var last = withoutDraggable[withoutDraggable.length - 1];\\n    return getImpact(last.descriptor.id);\\n  }\\n\\n  var indexOfClosest = findIndex(withoutDraggable, function (d) {\\n    return d.descriptor.id === closestId;\\n  });\\n  !(indexOfClosest !== -1) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find displaced item in set') : invariant(false) : void 0;\\n  var proposedIndex = indexOfClosest - 1;\\n\\n  if (proposedIndex < 0) {\\n    return null;\\n  }\\n\\n  var before = withoutDraggable[proposedIndex];\\n  return getImpact(before.descriptor.id);\\n});\\n\\nvar isHomeOf = (function (draggable, destination) {\\n  return draggable.descriptor.droppableId === destination.descriptor.id;\\n});\\n\\nvar noDisplacedBy = {\\n  point: origin,\\n  value: 0\\n};\\nvar emptyGroups = {\\n  invisible: {},\\n  visible: {},\\n  all: []\\n};\\nvar noImpact = {\\n  displaced: emptyGroups,\\n  displacedBy: noDisplacedBy,\\n  at: null\\n};\\n\\nvar isWithin = (function (lowerBound, upperBound) {\\n  return function (value) {\\n    return lowerBound <= value && value <= upperBound;\\n  };\\n});\\n\\nvar isPartiallyVisibleThroughFrame = (function (frame) {\\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\\n  return function (subject) {\\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\\n\\n    if (isContained) {\\n      return true;\\n    }\\n\\n    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\\n    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\\n    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\\n\\n    if (isPartiallyContained) {\\n      return true;\\n    }\\n\\n    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\\n    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\\n    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\\n\\n    if (isTargetBiggerThanFrame) {\\n      return true;\\n    }\\n\\n    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\\n    return isTargetBiggerOnOneAxis;\\n  };\\n});\\n\\nvar isTotallyVisibleThroughFrame = (function (frame) {\\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\\n  return function (subject) {\\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\\n    return isContained;\\n  };\\n});\\n\\nvar vertical = {\\n  direction: 'vertical',\\n  line: 'y',\\n  crossAxisLine: 'x',\\n  start: 'top',\\n  end: 'bottom',\\n  size: 'height',\\n  crossAxisStart: 'left',\\n  crossAxisEnd: 'right',\\n  crossAxisSize: 'width'\\n};\\nvar horizontal = {\\n  direction: 'horizontal',\\n  line: 'x',\\n  crossAxisLine: 'y',\\n  start: 'left',\\n  end: 'right',\\n  size: 'width',\\n  crossAxisStart: 'top',\\n  crossAxisEnd: 'bottom',\\n  crossAxisSize: 'height'\\n};\\n\\nvar isTotallyVisibleThroughFrameOnAxis = (function (axis) {\\n  return function (frame) {\\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\\n    return function (subject) {\\n      if (axis === vertical) {\\n        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\\n      }\\n\\n      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\\n    };\\n  };\\n});\\n\\nvar getDroppableDisplaced = function getDroppableDisplaced(target, destination) {\\n  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\\n  return offsetByPosition(target, displacement);\\n};\\n\\nvar isVisibleInDroppable = function isVisibleInDroppable(target, destination, isVisibleThroughFrameFn) {\\n  if (!destination.subject.active) {\\n    return false;\\n  }\\n\\n  return isVisibleThroughFrameFn(destination.subject.active)(target);\\n};\\n\\nvar isVisibleInViewport = function isVisibleInViewport(target, viewport, isVisibleThroughFrameFn) {\\n  return isVisibleThroughFrameFn(viewport)(target);\\n};\\n\\nvar isVisible = function isVisible(_ref) {\\n  var toBeDisplaced = _ref.target,\\n      destination = _ref.destination,\\n      viewport = _ref.viewport,\\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\\n      isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;\\n  var displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\\n  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\\n};\\n\\nvar isPartiallyVisible = function isPartiallyVisible(args) {\\n  return isVisible(_extends({}, args, {\\n    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\\n  }));\\n};\\nvar isTotallyVisible = function isTotallyVisible(args) {\\n  return isVisible(_extends({}, args, {\\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\\n  }));\\n};\\nvar isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis(args) {\\n  return isVisible(_extends({}, args, {\\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\\n  }));\\n};\\n\\nvar getShouldAnimate = function getShouldAnimate(id, last, forceShouldAnimate) {\\n  if (typeof forceShouldAnimate === 'boolean') {\\n    return forceShouldAnimate;\\n  }\\n\\n  if (!last) {\\n    return true;\\n  }\\n\\n  var invisible = last.invisible,\\n      visible = last.visible;\\n\\n  if (invisible[id]) {\\n    return false;\\n  }\\n\\n  var previous = visible[id];\\n  return previous ? previous.shouldAnimate : true;\\n};\\n\\nfunction getTarget(draggable, displacedBy) {\\n  var marginBox = draggable.page.marginBox;\\n  var expandBy = {\\n    top: displacedBy.point.y,\\n    right: 0,\\n    bottom: 0,\\n    left: displacedBy.point.x\\n  };\\n  return cssBoxModel.getRect(cssBoxModel.expand(marginBox, expandBy));\\n}\\n\\nfunction getDisplacementGroups(_ref) {\\n  var afterDragging = _ref.afterDragging,\\n      destination = _ref.destination,\\n      displacedBy = _ref.displacedBy,\\n      viewport = _ref.viewport,\\n      forceShouldAnimate = _ref.forceShouldAnimate,\\n      last = _ref.last;\\n  return afterDragging.reduce(function process(groups, draggable) {\\n    var target = getTarget(draggable, displacedBy);\\n    var id = draggable.descriptor.id;\\n    groups.all.push(id);\\n    var isVisible = isPartiallyVisible({\\n      target: target,\\n      destination: destination,\\n      viewport: viewport,\\n      withDroppableDisplacement: true\\n    });\\n\\n    if (!isVisible) {\\n      groups.invisible[draggable.descriptor.id] = true;\\n      return groups;\\n    }\\n\\n    var shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\\n    var displacement = {\\n      draggableId: id,\\n      shouldAnimate: shouldAnimate\\n    };\\n    groups.visible[id] = displacement;\\n    return groups;\\n  }, {\\n    all: [],\\n    visible: {},\\n    invisible: {}\\n  });\\n}\\n\\nfunction getIndexOfLastItem(draggables, options) {\\n  if (!draggables.length) {\\n    return 0;\\n  }\\n\\n  var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\\n  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\\n}\\n\\nfunction goAtEnd(_ref) {\\n  var insideDestination = _ref.insideDestination,\\n      inHomeList = _ref.inHomeList,\\n      displacedBy = _ref.displacedBy,\\n      destination = _ref.destination;\\n  var newIndex = getIndexOfLastItem(insideDestination, {\\n    inHomeList: inHomeList\\n  });\\n  return {\\n    displaced: emptyGroups,\\n    displacedBy: displacedBy,\\n    at: {\\n      type: 'REORDER',\\n      destination: {\\n        droppableId: destination.descriptor.id,\\n        index: newIndex\\n      }\\n    }\\n  };\\n}\\n\\nfunction calculateReorderImpact(_ref2) {\\n  var draggable = _ref2.draggable,\\n      insideDestination = _ref2.insideDestination,\\n      destination = _ref2.destination,\\n      viewport = _ref2.viewport,\\n      displacedBy = _ref2.displacedBy,\\n      last = _ref2.last,\\n      index = _ref2.index,\\n      forceShouldAnimate = _ref2.forceShouldAnimate;\\n  var inHomeList = isHomeOf(draggable, destination);\\n\\n  if (index == null) {\\n    return goAtEnd({\\n      insideDestination: insideDestination,\\n      inHomeList: inHomeList,\\n      displacedBy: displacedBy,\\n      destination: destination\\n    });\\n  }\\n\\n  var match = find(insideDestination, function (item) {\\n    return item.descriptor.index === index;\\n  });\\n\\n  if (!match) {\\n    return goAtEnd({\\n      insideDestination: insideDestination,\\n      inHomeList: inHomeList,\\n      displacedBy: displacedBy,\\n      destination: destination\\n    });\\n  }\\n\\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\\n  var sliceFrom = insideDestination.indexOf(match);\\n  var impacted = withoutDragging.slice(sliceFrom);\\n  var displaced = getDisplacementGroups({\\n    afterDragging: impacted,\\n    destination: destination,\\n    displacedBy: displacedBy,\\n    last: last,\\n    viewport: viewport.frame,\\n    forceShouldAnimate: forceShouldAnimate\\n  });\\n  return {\\n    displaced: displaced,\\n    displacedBy: displacedBy,\\n    at: {\\n      type: 'REORDER',\\n      destination: {\\n        droppableId: destination.descriptor.id,\\n        index: index\\n      }\\n    }\\n  };\\n}\\n\\nfunction didStartAfterCritical(draggableId, afterCritical) {\\n  return Boolean(afterCritical.effected[draggableId]);\\n}\\n\\nvar fromCombine = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      destination = _ref.destination,\\n      draggables = _ref.draggables,\\n      combine = _ref.combine,\\n      afterCritical = _ref.afterCritical;\\n\\n  if (!destination.isCombineEnabled) {\\n    return null;\\n  }\\n\\n  var combineId = combine.draggableId;\\n  var combineWith = draggables[combineId];\\n  var combineWithIndex = combineWith.descriptor.index;\\n  var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\\n\\n  if (didCombineWithStartAfterCritical) {\\n    if (isMovingForward) {\\n      return combineWithIndex;\\n    }\\n\\n    return combineWithIndex - 1;\\n  }\\n\\n  if (isMovingForward) {\\n    return combineWithIndex + 1;\\n  }\\n\\n  return combineWithIndex;\\n});\\n\\nvar fromReorder = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      isInHomeList = _ref.isInHomeList,\\n      insideDestination = _ref.insideDestination,\\n      location = _ref.location;\\n\\n  if (!insideDestination.length) {\\n    return null;\\n  }\\n\\n  var currentIndex = location.index;\\n  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\\n  var firstIndex = insideDestination[0].descriptor.index;\\n  var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\\n  var upperBound = isInHomeList ? lastIndex : lastIndex + 1;\\n\\n  if (proposedIndex < firstIndex) {\\n    return null;\\n  }\\n\\n  if (proposedIndex > upperBound) {\\n    return null;\\n  }\\n\\n  return proposedIndex;\\n});\\n\\nvar moveToNextIndex = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      isInHomeList = _ref.isInHomeList,\\n      draggable = _ref.draggable,\\n      draggables = _ref.draggables,\\n      destination = _ref.destination,\\n      insideDestination = _ref.insideDestination,\\n      previousImpact = _ref.previousImpact,\\n      viewport = _ref.viewport,\\n      afterCritical = _ref.afterCritical;\\n  var wasAt = previousImpact.at;\\n  !wasAt ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot move in direction without previous impact location') : invariant(false) : void 0;\\n\\n  if (wasAt.type === 'REORDER') {\\n    var _newIndex = fromReorder({\\n      isMovingForward: isMovingForward,\\n      isInHomeList: isInHomeList,\\n      location: wasAt.destination,\\n      insideDestination: insideDestination\\n    });\\n\\n    if (_newIndex == null) {\\n      return null;\\n    }\\n\\n    return calculateReorderImpact({\\n      draggable: draggable,\\n      insideDestination: insideDestination,\\n      destination: destination,\\n      viewport: viewport,\\n      last: previousImpact.displaced,\\n      displacedBy: previousImpact.displacedBy,\\n      index: _newIndex\\n    });\\n  }\\n\\n  var newIndex = fromCombine({\\n    isMovingForward: isMovingForward,\\n    destination: destination,\\n    displaced: previousImpact.displaced,\\n    draggables: draggables,\\n    combine: wasAt.combine,\\n    afterCritical: afterCritical\\n  });\\n\\n  if (newIndex == null) {\\n    return null;\\n  }\\n\\n  return calculateReorderImpact({\\n    draggable: draggable,\\n    insideDestination: insideDestination,\\n    destination: destination,\\n    viewport: viewport,\\n    last: previousImpact.displaced,\\n    displacedBy: previousImpact.displacedBy,\\n    index: newIndex\\n  });\\n});\\n\\nvar getCombinedItemDisplacement = (function (_ref) {\\n  var displaced = _ref.displaced,\\n      afterCritical = _ref.afterCritical,\\n      combineWith = _ref.combineWith,\\n      displacedBy = _ref.displacedBy;\\n  var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\\n\\n  if (didStartAfterCritical(combineWith, afterCritical)) {\\n    return isDisplaced ? origin : negate(displacedBy.point);\\n  }\\n\\n  return isDisplaced ? displacedBy.point : origin;\\n});\\n\\nvar whenCombining = (function (_ref) {\\n  var afterCritical = _ref.afterCritical,\\n      impact = _ref.impact,\\n      draggables = _ref.draggables;\\n  var combine = tryGetCombine(impact);\\n  !combine ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false) : invariant(false) : void 0;\\n  var combineWith = combine.draggableId;\\n  var center = draggables[combineWith].page.borderBox.center;\\n  var displaceBy = getCombinedItemDisplacement({\\n    displaced: impact.displaced,\\n    afterCritical: afterCritical,\\n    combineWith: combineWith,\\n    displacedBy: impact.displacedBy\\n  });\\n  return add(center, displaceBy);\\n});\\n\\nvar distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter(axis, box) {\\n  return box.margin[axis.start] + box.borderBox[axis.size] / 2;\\n};\\n\\nvar distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter(axis, box) {\\n  return box.margin[axis.end] + box.borderBox[axis.size] / 2;\\n};\\n\\nvar getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter(axis, target, isMoving) {\\n  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\\n};\\n\\nvar goAfter = function goAfter(_ref) {\\n  var axis = _ref.axis,\\n      moveRelativeTo = _ref.moveRelativeTo,\\n      isMoving = _ref.isMoving;\\n  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\\n};\\nvar goBefore = function goBefore(_ref2) {\\n  var axis = _ref2.axis,\\n      moveRelativeTo = _ref2.moveRelativeTo,\\n      isMoving = _ref2.isMoving;\\n  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\\n};\\nvar goIntoStart = function goIntoStart(_ref3) {\\n  var axis = _ref3.axis,\\n      moveInto = _ref3.moveInto,\\n      isMoving = _ref3.isMoving;\\n  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\\n};\\n\\nvar whenReordering = (function (_ref) {\\n  var impact = _ref.impact,\\n      draggable = _ref.draggable,\\n      draggables = _ref.draggables,\\n      droppable = _ref.droppable,\\n      afterCritical = _ref.afterCritical;\\n  var insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\\n  var draggablePage = draggable.page;\\n  var axis = droppable.axis;\\n\\n  if (!insideDestination.length) {\\n    return goIntoStart({\\n      axis: axis,\\n      moveInto: droppable.page,\\n      isMoving: draggablePage\\n    });\\n  }\\n\\n  var displaced = impact.displaced,\\n      displacedBy = impact.displacedBy;\\n  var closestAfter = displaced.all[0];\\n\\n  if (closestAfter) {\\n    var closest = draggables[closestAfter];\\n\\n    if (didStartAfterCritical(closestAfter, afterCritical)) {\\n      return goBefore({\\n        axis: axis,\\n        moveRelativeTo: closest.page,\\n        isMoving: draggablePage\\n      });\\n    }\\n\\n    var withDisplacement = cssBoxModel.offset(closest.page, displacedBy.point);\\n    return goBefore({\\n      axis: axis,\\n      moveRelativeTo: withDisplacement,\\n      isMoving: draggablePage\\n    });\\n  }\\n\\n  var last = insideDestination[insideDestination.length - 1];\\n\\n  if (last.descriptor.id === draggable.descriptor.id) {\\n    return draggablePage.borderBox.center;\\n  }\\n\\n  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\\n    var page = cssBoxModel.offset(last.page, negate(afterCritical.displacedBy.point));\\n    return goAfter({\\n      axis: axis,\\n      moveRelativeTo: page,\\n      isMoving: draggablePage\\n    });\\n  }\\n\\n  return goAfter({\\n    axis: axis,\\n    moveRelativeTo: last.page,\\n    isMoving: draggablePage\\n  });\\n});\\n\\nvar withDroppableDisplacement = (function (droppable, point) {\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    return point;\\n  }\\n\\n  return add(point, frame.scroll.diff.displacement);\\n});\\n\\nvar getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement(_ref) {\\n  var impact = _ref.impact,\\n      draggable = _ref.draggable,\\n      droppable = _ref.droppable,\\n      draggables = _ref.draggables,\\n      afterCritical = _ref.afterCritical;\\n  var original = draggable.page.borderBox.center;\\n  var at = impact.at;\\n\\n  if (!droppable) {\\n    return original;\\n  }\\n\\n  if (!at) {\\n    return original;\\n  }\\n\\n  if (at.type === 'REORDER') {\\n    return whenReordering({\\n      impact: impact,\\n      draggable: draggable,\\n      draggables: draggables,\\n      droppable: droppable,\\n      afterCritical: afterCritical\\n    });\\n  }\\n\\n  return whenCombining({\\n    impact: impact,\\n    draggables: draggables,\\n    afterCritical: afterCritical\\n  });\\n};\\n\\nvar getPageBorderBoxCenterFromImpact = (function (args) {\\n  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);\\n  var droppable = args.droppable;\\n  var withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\\n  return withDisplacement;\\n});\\n\\nvar scrollViewport = (function (viewport, newScroll) {\\n  var diff = subtract(newScroll, viewport.scroll.initial);\\n  var displacement = negate(diff);\\n  var frame = cssBoxModel.getRect({\\n    top: newScroll.y,\\n    bottom: newScroll.y + viewport.frame.height,\\n    left: newScroll.x,\\n    right: newScroll.x + viewport.frame.width\\n  });\\n  var updated = {\\n    frame: frame,\\n    scroll: {\\n      initial: viewport.scroll.initial,\\n      max: viewport.scroll.max,\\n      current: newScroll,\\n      diff: {\\n        value: diff,\\n        displacement: displacement\\n      }\\n    }\\n  };\\n  return updated;\\n});\\n\\nfunction getDraggables(ids, draggables) {\\n  return ids.map(function (id) {\\n    return draggables[id];\\n  });\\n}\\n\\nfunction tryGetVisible(id, groups) {\\n  for (var i = 0; i < groups.length; i++) {\\n    var displacement = groups[i].visible[id];\\n\\n    if (displacement) {\\n      return displacement;\\n    }\\n  }\\n\\n  return null;\\n}\\n\\nvar speculativelyIncrease = (function (_ref) {\\n  var impact = _ref.impact,\\n      viewport = _ref.viewport,\\n      destination = _ref.destination,\\n      draggables = _ref.draggables,\\n      maxScrollChange = _ref.maxScrollChange;\\n  var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\\n  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\\n  var last = impact.displaced;\\n  var withViewportScroll = getDisplacementGroups({\\n    afterDragging: getDraggables(last.all, draggables),\\n    destination: destination,\\n    displacedBy: impact.displacedBy,\\n    viewport: scrolledViewport.frame,\\n    last: last,\\n    forceShouldAnimate: false\\n  });\\n  var withDroppableScroll = getDisplacementGroups({\\n    afterDragging: getDraggables(last.all, draggables),\\n    destination: scrolledDroppable,\\n    displacedBy: impact.displacedBy,\\n    viewport: viewport.frame,\\n    last: last,\\n    forceShouldAnimate: false\\n  });\\n  var invisible = {};\\n  var visible = {};\\n  var groups = [last, withViewportScroll, withDroppableScroll];\\n  last.all.forEach(function (id) {\\n    var displacement = tryGetVisible(id, groups);\\n\\n    if (displacement) {\\n      visible[id] = displacement;\\n      return;\\n    }\\n\\n    invisible[id] = true;\\n  });\\n\\n  var newImpact = _extends({}, impact, {\\n    displaced: {\\n      all: last.all,\\n      invisible: invisible,\\n      visible: visible\\n    }\\n  });\\n\\n  return newImpact;\\n});\\n\\nvar withViewportDisplacement = (function (viewport, point) {\\n  return add(viewport.scroll.diff.displacement, point);\\n});\\n\\nvar getClientFromPageBorderBoxCenter = (function (_ref) {\\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\\n      draggable = _ref.draggable,\\n      viewport = _ref.viewport;\\n  var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\\n  var offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\\n  return add(draggable.client.borderBox.center, offset);\\n});\\n\\nvar isTotallyVisibleInNewLocation = (function (_ref) {\\n  var draggable = _ref.draggable,\\n      destination = _ref.destination,\\n      newPageBorderBoxCenter = _ref.newPageBorderBoxCenter,\\n      viewport = _ref.viewport,\\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\\n      _ref$onlyOnMainAxis = _ref.onlyOnMainAxis,\\n      onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;\\n  var changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\\n  var shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\\n  var args = {\\n    target: shifted,\\n    destination: destination,\\n    withDroppableDisplacement: withDroppableDisplacement,\\n    viewport: viewport\\n  };\\n  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\\n});\\n\\nvar moveToNextPlace = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      draggable = _ref.draggable,\\n      destination = _ref.destination,\\n      draggables = _ref.draggables,\\n      previousImpact = _ref.previousImpact,\\n      viewport = _ref.viewport,\\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\\n      previousClientSelection = _ref.previousClientSelection,\\n      afterCritical = _ref.afterCritical;\\n\\n  if (!destination.isEnabled) {\\n    return null;\\n  }\\n\\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\\n  var isInHomeList = isHomeOf(draggable, destination);\\n  var impact = moveToNextCombine({\\n    isMovingForward: isMovingForward,\\n    draggable: draggable,\\n    destination: destination,\\n    insideDestination: insideDestination,\\n    previousImpact: previousImpact\\n  }) || moveToNextIndex({\\n    isMovingForward: isMovingForward,\\n    isInHomeList: isInHomeList,\\n    draggable: draggable,\\n    draggables: draggables,\\n    destination: destination,\\n    insideDestination: insideDestination,\\n    previousImpact: previousImpact,\\n    viewport: viewport,\\n    afterCritical: afterCritical\\n  });\\n\\n  if (!impact) {\\n    return null;\\n  }\\n\\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\\n    impact: impact,\\n    draggable: draggable,\\n    droppable: destination,\\n    draggables: draggables,\\n    afterCritical: afterCritical\\n  });\\n  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\\n    draggable: draggable,\\n    destination: destination,\\n    newPageBorderBoxCenter: pageBorderBoxCenter,\\n    viewport: viewport.frame,\\n    withDroppableDisplacement: false,\\n    onlyOnMainAxis: true\\n  });\\n\\n  if (isVisibleInNewLocation) {\\n    var clientSelection = getClientFromPageBorderBoxCenter({\\n      pageBorderBoxCenter: pageBorderBoxCenter,\\n      draggable: draggable,\\n      viewport: viewport\\n    });\\n    return {\\n      clientSelection: clientSelection,\\n      impact: impact,\\n      scrollJumpRequest: null\\n    };\\n  }\\n\\n  var distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\\n  var cautious = speculativelyIncrease({\\n    impact: impact,\\n    viewport: viewport,\\n    destination: destination,\\n    draggables: draggables,\\n    maxScrollChange: distance\\n  });\\n  return {\\n    clientSelection: previousClientSelection,\\n    impact: cautious,\\n    scrollJumpRequest: distance\\n  };\\n});\\n\\nvar getKnownActive = function getKnownActive(droppable) {\\n  var rect = droppable.subject.active;\\n  !rect ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot get clipped area from droppable') : invariant(false) : void 0;\\n  return rect;\\n};\\n\\nvar getBestCrossAxisDroppable = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      pageBorderBoxCenter = _ref.pageBorderBoxCenter,\\n      source = _ref.source,\\n      droppables = _ref.droppables,\\n      viewport = _ref.viewport;\\n  var active = source.subject.active;\\n\\n  if (!active) {\\n    return null;\\n  }\\n\\n  var axis = source.axis;\\n  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\\n  var candidates = toDroppableList(droppables).filter(function (droppable) {\\n    return droppable !== source;\\n  }).filter(function (droppable) {\\n    return droppable.isEnabled;\\n  }).filter(function (droppable) {\\n    return Boolean(droppable.subject.active);\\n  }).filter(function (droppable) {\\n    return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable));\\n  }).filter(function (droppable) {\\n    var activeOfTarget = getKnownActive(droppable);\\n\\n    if (isMovingForward) {\\n      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\\n    }\\n\\n    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\\n  }).filter(function (droppable) {\\n    var activeOfTarget = getKnownActive(droppable);\\n    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\\n    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\\n  }).sort(function (a, b) {\\n    var first = getKnownActive(a)[axis.crossAxisStart];\\n    var second = getKnownActive(b)[axis.crossAxisStart];\\n\\n    if (isMovingForward) {\\n      return first - second;\\n    }\\n\\n    return second - first;\\n  }).filter(function (droppable, index, array) {\\n    return getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];\\n  });\\n\\n  if (!candidates.length) {\\n    return null;\\n  }\\n\\n  if (candidates.length === 1) {\\n    return candidates[0];\\n  }\\n\\n  var contains = candidates.filter(function (droppable) {\\n    var isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\\n    return isWithinDroppable(pageBorderBoxCenter[axis.line]);\\n  });\\n\\n  if (contains.length === 1) {\\n    return contains[0];\\n  }\\n\\n  if (contains.length > 1) {\\n    return contains.sort(function (a, b) {\\n      return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\\n    })[0];\\n  }\\n\\n  return candidates.sort(function (a, b) {\\n    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));\\n    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));\\n\\n    if (first !== second) {\\n      return first - second;\\n    }\\n\\n    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\\n  })[0];\\n});\\n\\nvar getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter(draggable, afterCritical) {\\n  var original = draggable.page.borderBox.center;\\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\\n};\\nvar getCurrentPageBorderBox = function getCurrentPageBorderBox(draggable, afterCritical) {\\n  var original = draggable.page.borderBox;\\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\\n};\\n\\nvar getClosestDraggable = (function (_ref) {\\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\\n      viewport = _ref.viewport,\\n      destination = _ref.destination,\\n      insideDestination = _ref.insideDestination,\\n      afterCritical = _ref.afterCritical;\\n  var sorted = insideDestination.filter(function (draggable) {\\n    return isTotallyVisible({\\n      target: getCurrentPageBorderBox(draggable, afterCritical),\\n      destination: destination,\\n      viewport: viewport.frame,\\n      withDroppableDisplacement: true\\n    });\\n  }).sort(function (a, b) {\\n    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\\n    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\\n\\n    if (distanceToA < distanceToB) {\\n      return -1;\\n    }\\n\\n    if (distanceToB < distanceToA) {\\n      return 1;\\n    }\\n\\n    return a.descriptor.index - b.descriptor.index;\\n  });\\n  return sorted[0] || null;\\n});\\n\\nvar getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {\\n  var displacement = displaceBy[axis.line];\\n  return {\\n    value: displacement,\\n    point: patch(axis.line, displacement)\\n  };\\n});\\n\\nvar getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables) {\\n  var axis = droppable.axis;\\n\\n  if (droppable.descriptor.mode === 'virtual') {\\n    return patch(axis.line, placeholderSize[axis.line]);\\n  }\\n\\n  var availableSpace = droppable.subject.page.contentBox[axis.size];\\n  var insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\\n  var spaceUsed = insideDroppable.reduce(function (sum, dimension) {\\n    return sum + dimension.client.marginBox[axis.size];\\n  }, 0);\\n  var requiredSpace = spaceUsed + placeholderSize[axis.line];\\n  var needsToGrowBy = requiredSpace - availableSpace;\\n\\n  if (needsToGrowBy <= 0) {\\n    return null;\\n  }\\n\\n  return patch(axis.line, needsToGrowBy);\\n};\\n\\nvar withMaxScroll = function withMaxScroll(frame, max) {\\n  return _extends({}, frame, {\\n    scroll: _extends({}, frame.scroll, {\\n      max: max\\n    })\\n  });\\n};\\n\\nvar addPlaceholder = function addPlaceholder(droppable, draggable, draggables) {\\n  var frame = droppable.frame;\\n  !!isHomeOf(draggable, droppable) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Should not add placeholder space to home list') : invariant(false) : void 0;\\n  !!droppable.subject.withPlaceholder ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot add placeholder size to a subject when it already has one') : invariant(false) : void 0;\\n  var placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\\n  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\\n  var added = {\\n    placeholderSize: placeholderSize,\\n    increasedBy: requiredGrowth,\\n    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\\n  };\\n\\n  if (!frame) {\\n    var _subject = getSubject({\\n      page: droppable.subject.page,\\n      withPlaceholder: added,\\n      axis: droppable.axis,\\n      frame: droppable.frame\\n    });\\n\\n    return _extends({}, droppable, {\\n      subject: _subject\\n    });\\n  }\\n\\n  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\\n  var newFrame = withMaxScroll(frame, maxScroll);\\n  var subject = getSubject({\\n    page: droppable.subject.page,\\n    withPlaceholder: added,\\n    axis: droppable.axis,\\n    frame: newFrame\\n  });\\n  return _extends({}, droppable, {\\n    subject: subject,\\n    frame: newFrame\\n  });\\n};\\nvar removePlaceholder = function removePlaceholder(droppable) {\\n  var added = droppable.subject.withPlaceholder;\\n  !added ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot remove placeholder form subject when there was none') : invariant(false) : void 0;\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    var _subject2 = getSubject({\\n      page: droppable.subject.page,\\n      axis: droppable.axis,\\n      frame: null,\\n      withPlaceholder: null\\n    });\\n\\n    return _extends({}, droppable, {\\n      subject: _subject2\\n    });\\n  }\\n\\n  var oldMaxScroll = added.oldFrameMaxScroll;\\n  !oldMaxScroll ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected droppable with frame to have old max frame scroll when removing placeholder') : invariant(false) : void 0;\\n  var newFrame = withMaxScroll(frame, oldMaxScroll);\\n  var subject = getSubject({\\n    page: droppable.subject.page,\\n    axis: droppable.axis,\\n    frame: newFrame,\\n    withPlaceholder: null\\n  });\\n  return _extends({}, droppable, {\\n    subject: subject,\\n    frame: newFrame\\n  });\\n};\\n\\nvar moveToNewDroppable = (function (_ref) {\\n  var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\\n      moveRelativeTo = _ref.moveRelativeTo,\\n      insideDestination = _ref.insideDestination,\\n      draggable = _ref.draggable,\\n      draggables = _ref.draggables,\\n      destination = _ref.destination,\\n      viewport = _ref.viewport,\\n      afterCritical = _ref.afterCritical;\\n\\n  if (!moveRelativeTo) {\\n    if (insideDestination.length) {\\n      return null;\\n    }\\n\\n    var proposed = {\\n      displaced: emptyGroups,\\n      displacedBy: noDisplacedBy,\\n      at: {\\n        type: 'REORDER',\\n        destination: {\\n          droppableId: destination.descriptor.id,\\n          index: 0\\n        }\\n      }\\n    };\\n    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\\n      impact: proposed,\\n      draggable: draggable,\\n      droppable: destination,\\n      draggables: draggables,\\n      afterCritical: afterCritical\\n    });\\n    var withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\\n    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\\n      draggable: draggable,\\n      destination: withPlaceholder,\\n      newPageBorderBoxCenter: proposedPageBorderBoxCenter,\\n      viewport: viewport.frame,\\n      withDroppableDisplacement: false,\\n      onlyOnMainAxis: true\\n    });\\n    return isVisibleInNewLocation ? proposed : null;\\n  }\\n\\n  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\\n\\n  var proposedIndex = function () {\\n    var relativeTo = moveRelativeTo.descriptor.index;\\n\\n    if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\\n      return relativeTo;\\n    }\\n\\n    if (isGoingBeforeTarget) {\\n      return relativeTo;\\n    }\\n\\n    return relativeTo + 1;\\n  }();\\n\\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\\n  return calculateReorderImpact({\\n    draggable: draggable,\\n    insideDestination: insideDestination,\\n    destination: destination,\\n    viewport: viewport,\\n    displacedBy: displacedBy,\\n    last: emptyGroups,\\n    index: proposedIndex\\n  });\\n});\\n\\nvar moveCrossAxis = (function (_ref) {\\n  var isMovingForward = _ref.isMovingForward,\\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\\n      draggable = _ref.draggable,\\n      isOver = _ref.isOver,\\n      draggables = _ref.draggables,\\n      droppables = _ref.droppables,\\n      viewport = _ref.viewport,\\n      afterCritical = _ref.afterCritical;\\n  var destination = getBestCrossAxisDroppable({\\n    isMovingForward: isMovingForward,\\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\\n    source: isOver,\\n    droppables: droppables,\\n    viewport: viewport\\n  });\\n\\n  if (!destination) {\\n    return null;\\n  }\\n\\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\\n  var moveRelativeTo = getClosestDraggable({\\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\\n    viewport: viewport,\\n    destination: destination,\\n    insideDestination: insideDestination,\\n    afterCritical: afterCritical\\n  });\\n  var impact = moveToNewDroppable({\\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\\n    destination: destination,\\n    draggable: draggable,\\n    draggables: draggables,\\n    moveRelativeTo: moveRelativeTo,\\n    insideDestination: insideDestination,\\n    viewport: viewport,\\n    afterCritical: afterCritical\\n  });\\n\\n  if (!impact) {\\n    return null;\\n  }\\n\\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\\n    impact: impact,\\n    draggable: draggable,\\n    droppable: destination,\\n    draggables: draggables,\\n    afterCritical: afterCritical\\n  });\\n  var clientSelection = getClientFromPageBorderBoxCenter({\\n    pageBorderBoxCenter: pageBorderBoxCenter,\\n    draggable: draggable,\\n    viewport: viewport\\n  });\\n  return {\\n    clientSelection: clientSelection,\\n    impact: impact,\\n    scrollJumpRequest: null\\n  };\\n});\\n\\nvar whatIsDraggedOver = (function (impact) {\\n  var at = impact.at;\\n\\n  if (!at) {\\n    return null;\\n  }\\n\\n  if (at.type === 'REORDER') {\\n    return at.destination.droppableId;\\n  }\\n\\n  return at.combine.droppableId;\\n});\\n\\nvar getDroppableOver = function getDroppableOver(impact, droppables) {\\n  var id = whatIsDraggedOver(impact);\\n  return id ? droppables[id] : null;\\n};\\n\\nvar moveInDirection = (function (_ref) {\\n  var state = _ref.state,\\n      type = _ref.type;\\n  var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);\\n  var isMainAxisMovementAllowed = Boolean(isActuallyOver);\\n  var home = state.dimensions.droppables[state.critical.droppable.id];\\n  var isOver = isActuallyOver || home;\\n  var direction = isOver.axis.direction;\\n  var isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');\\n\\n  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\\n    return null;\\n  }\\n\\n  var isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';\\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\\n  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\\n  var _state$dimensions = state.dimensions,\\n      draggables = _state$dimensions.draggables,\\n      droppables = _state$dimensions.droppables;\\n  return isMovingOnMainAxis ? moveToNextPlace({\\n    isMovingForward: isMovingForward,\\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\\n    draggable: draggable,\\n    destination: isOver,\\n    draggables: draggables,\\n    viewport: state.viewport,\\n    previousClientSelection: state.current.client.selection,\\n    previousImpact: state.impact,\\n    afterCritical: state.afterCritical\\n  }) : moveCrossAxis({\\n    isMovingForward: isMovingForward,\\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\\n    draggable: draggable,\\n    isOver: isOver,\\n    draggables: draggables,\\n    droppables: droppables,\\n    viewport: state.viewport,\\n    afterCritical: state.afterCritical\\n  });\\n});\\n\\nfunction isMovementAllowed(state) {\\n  return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';\\n}\\n\\nvar isPositionInFrame = (function (frame) {\\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\\n  return function (point) {\\n    return isWithinVertical(point.y) && isWithinVertical(point.y) && isWithinHorizontal(point.x) && isWithinHorizontal(point.x);\\n  };\\n});\\n\\nvar getDroppableOver$1 = (function (_ref) {\\n  var target = _ref.target,\\n      droppables = _ref.droppables;\\n  var maybe = find(toDroppableList(droppables), function (droppable) {\\n    if (!droppable.isEnabled) {\\n      return false;\\n    }\\n\\n    var active = droppable.subject.active;\\n\\n    if (!active) {\\n      return false;\\n    }\\n\\n    return isPositionInFrame(active)(target);\\n  });\\n  return maybe ? maybe.descriptor.id : null;\\n});\\n\\nvar withDroppableScroll = (function (droppable, point) {\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    return point;\\n  }\\n\\n  return add(point, frame.scroll.diff.value);\\n});\\n\\nvar isUserMovingForward = (function (axis, direction) {\\n  return axis === vertical ? direction.vertical === 'down' : direction.horizontal === 'right';\\n});\\n\\nfunction atIndex(_ref) {\\n  var draggable = _ref.draggable,\\n      closest = _ref.closest,\\n      inHomeList = _ref.inHomeList;\\n\\n  if (!closest) {\\n    return null;\\n  }\\n\\n  if (!inHomeList) {\\n    return closest.descriptor.index;\\n  }\\n\\n  if (closest.descriptor.index > draggable.descriptor.index) {\\n    return closest.descriptor.index - 1;\\n  }\\n\\n  return closest.descriptor.index;\\n}\\n\\nvar getReorderImpact = (function (_ref2) {\\n  var currentCenter = _ref2.pageBorderBoxCenterWithDroppableScrollChange,\\n      draggable = _ref2.draggable,\\n      destination = _ref2.destination,\\n      insideDestination = _ref2.insideDestination,\\n      last = _ref2.last,\\n      viewport = _ref2.viewport,\\n      userDirection = _ref2.userDirection,\\n      afterCritical = _ref2.afterCritical;\\n  var axis = destination.axis;\\n  var isMovingForward = isUserMovingForward(destination.axis, userDirection);\\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\\n  var targetCenter = currentCenter[axis.line];\\n  var displacement = displacedBy.value;\\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\\n  var closest = find(withoutDragging, function (child) {\\n    var id = child.descriptor.id;\\n    var borderBox = child.page.borderBox;\\n    var start = borderBox[axis.start];\\n    var end = borderBox[axis.end];\\n    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\\n\\n    if (isMovingForward) {\\n      if (didStartAfterCritical$1) {\\n        return targetCenter < start;\\n      }\\n\\n      return targetCenter < start + displacement;\\n    }\\n\\n    if (didStartAfterCritical$1) {\\n      return targetCenter <= end - displacement;\\n    }\\n\\n    return targetCenter <= end;\\n  });\\n  var newIndex = atIndex({\\n    draggable: draggable,\\n    closest: closest,\\n    inHomeList: isHomeOf(draggable, destination)\\n  });\\n  return calculateReorderImpact({\\n    draggable: draggable,\\n    insideDestination: insideDestination,\\n    destination: destination,\\n    viewport: viewport,\\n    last: last,\\n    displacedBy: displacedBy,\\n    index: newIndex\\n  });\\n});\\n\\nfunction getWhenEntered(id, current, lastCombineImpact) {\\n  if (!lastCombineImpact) {\\n    return current;\\n  }\\n\\n  if (id !== lastCombineImpact.combine.draggableId) {\\n    return current;\\n  }\\n\\n  return lastCombineImpact.whenEntered;\\n}\\n\\nfunction tryGetCombineImpact(impact) {\\n  if (impact.at && impact.at.type === 'COMBINE') {\\n    return impact.at;\\n  }\\n\\n  return null;\\n}\\n\\nfunction calculateCombineImpact(_ref) {\\n  var combineWithId = _ref.combineWithId,\\n      destinationId = _ref.destinationId,\\n      userDirection = _ref.userDirection,\\n      previousImpact = _ref.previousImpact;\\n  var lastCombineImpact = tryGetCombineImpact(previousImpact);\\n  var whenEntered = getWhenEntered(combineWithId, userDirection, lastCombineImpact);\\n  var impact = {\\n    displacedBy: previousImpact.displacedBy,\\n    displaced: previousImpact.displaced,\\n    at: {\\n      type: 'COMBINE',\\n      whenEntered: whenEntered,\\n      combine: {\\n        draggableId: combineWithId,\\n        droppableId: destinationId\\n      }\\n    }\\n  };\\n  return impact;\\n}\\n\\nfunction getWhenEntered$1(id, current, lastCombineImpact) {\\n  if (!lastCombineImpact) {\\n    return current;\\n  }\\n\\n  if (id !== lastCombineImpact.combine.draggableId) {\\n    return current;\\n  }\\n\\n  return lastCombineImpact.whenEntered;\\n}\\n\\nvar isCombiningWith = function isCombiningWith(_ref) {\\n  var id = _ref.id,\\n      currentCenter = _ref.currentCenter,\\n      axis = _ref.axis,\\n      borderBox = _ref.borderBox,\\n      displaceBy = _ref.displaceBy,\\n      currentUserDirection = _ref.currentUserDirection,\\n      lastCombineImpact = _ref.lastCombineImpact;\\n  var start = borderBox[axis.start] + displaceBy[axis.line];\\n  var end = borderBox[axis.end] + displaceBy[axis.line];\\n  var size = borderBox[axis.size];\\n  var twoThirdsOfSize = size * 0.666;\\n  var whenEntered = getWhenEntered$1(id, currentUserDirection, lastCombineImpact);\\n  var isMovingForward = isUserMovingForward(axis, whenEntered);\\n  var targetCenter = currentCenter[axis.line];\\n\\n  if (isMovingForward) {\\n    return isWithin(start, start + twoThirdsOfSize)(targetCenter);\\n  }\\n\\n  return isWithin(end - twoThirdsOfSize, end)(targetCenter);\\n};\\n\\nfunction tryGetCombineImpact$1(impact) {\\n  if (impact.at && impact.at.type === 'COMBINE') {\\n    return impact.at;\\n  }\\n\\n  return null;\\n}\\n\\nvar getCombineImpact = (function (_ref2) {\\n  var draggable = _ref2.draggable,\\n      currentCenter = _ref2.pageBorderBoxCenterWithDroppableScrollChange,\\n      previousImpact = _ref2.previousImpact,\\n      destination = _ref2.destination,\\n      insideDestination = _ref2.insideDestination,\\n      userDirection = _ref2.userDirection,\\n      afterCritical = _ref2.afterCritical;\\n\\n  if (!destination.isCombineEnabled) {\\n    return null;\\n  }\\n\\n  var axis = destination.axis;\\n  var displaced = previousImpact.displaced;\\n  var canBeDisplacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\\n  var lastCombineImpact = tryGetCombineImpact$1(previousImpact);\\n  var combineWith = find(removeDraggableFromList(draggable, insideDestination), function (child) {\\n    var id = child.descriptor.id;\\n    var displaceBy = getCombinedItemDisplacement({\\n      displaced: displaced,\\n      afterCritical: afterCritical,\\n      combineWith: id,\\n      displacedBy: canBeDisplacedBy\\n    });\\n    return isCombiningWith({\\n      id: id,\\n      currentCenter: currentCenter,\\n      axis: axis,\\n      borderBox: child.page.borderBox,\\n      displaceBy: displaceBy,\\n      currentUserDirection: userDirection,\\n      lastCombineImpact: lastCombineImpact\\n    });\\n  });\\n\\n  if (!combineWith) {\\n    return null;\\n  }\\n\\n  return calculateCombineImpact({\\n    combineWithId: combineWith.descriptor.id,\\n    destinationId: destination.descriptor.id,\\n    previousImpact: previousImpact,\\n    userDirection: userDirection\\n  });\\n});\\n\\nvar getDragImpact = (function (_ref) {\\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\\n      draggable = _ref.draggable,\\n      draggables = _ref.draggables,\\n      droppables = _ref.droppables,\\n      previousImpact = _ref.previousImpact,\\n      viewport = _ref.viewport,\\n      userDirection = _ref.userDirection,\\n      afterCritical = _ref.afterCritical;\\n  var destinationId = getDroppableOver$1({\\n    target: pageBorderBoxCenter,\\n    droppables: droppables\\n  });\\n\\n  if (!destinationId) {\\n    return noImpact;\\n  }\\n\\n  var destination = droppables[destinationId];\\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\\n  var pageBorderBoxCenterWithDroppableScrollChange = withDroppableScroll(destination, pageBorderBoxCenter);\\n  return getCombineImpact({\\n    pageBorderBoxCenterWithDroppableScrollChange: pageBorderBoxCenterWithDroppableScrollChange,\\n    draggable: draggable,\\n    previousImpact: previousImpact,\\n    destination: destination,\\n    insideDestination: insideDestination,\\n    userDirection: userDirection,\\n    afterCritical: afterCritical\\n  }) || getReorderImpact({\\n    pageBorderBoxCenterWithDroppableScrollChange: pageBorderBoxCenterWithDroppableScrollChange,\\n    draggable: draggable,\\n    destination: destination,\\n    insideDestination: insideDestination,\\n    last: previousImpact.displaced,\\n    viewport: viewport,\\n    userDirection: userDirection,\\n    afterCritical: afterCritical\\n  });\\n});\\n\\nvar getVertical = function getVertical(previous, diff) {\\n  if (diff === 0) {\\n    return previous;\\n  }\\n\\n  return diff > 0 ? 'down' : 'up';\\n};\\n\\nvar getHorizontal = function getHorizontal(previous, diff) {\\n  if (diff === 0) {\\n    return previous;\\n  }\\n\\n  return diff > 0 ? 'right' : 'left';\\n};\\n\\nvar getUserDirection = (function (previous, oldPageBorderBoxCenter, newPageBorderBoxCenter) {\\n  var diff = subtract(newPageBorderBoxCenter, oldPageBorderBoxCenter);\\n  return {\\n    horizontal: getHorizontal(previous.horizontal, diff.x),\\n    vertical: getVertical(previous.vertical, diff.y)\\n  };\\n});\\n\\nvar patchDroppableMap = (function (droppables, updated) {\\n  var _extends2;\\n\\n  return _extends({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));\\n});\\n\\nvar clearUnusedPlaceholder = function clearUnusedPlaceholder(_ref) {\\n  var previousImpact = _ref.previousImpact,\\n      impact = _ref.impact,\\n      droppables = _ref.droppables;\\n  var last = whatIsDraggedOver(previousImpact);\\n  var now = whatIsDraggedOver(impact);\\n\\n  if (!last) {\\n    return droppables;\\n  }\\n\\n  if (last === now) {\\n    return droppables;\\n  }\\n\\n  var lastDroppable = droppables[last];\\n\\n  if (!lastDroppable.subject.withPlaceholder) {\\n    return droppables;\\n  }\\n\\n  var updated = removePlaceholder(lastDroppable);\\n  return patchDroppableMap(droppables, updated);\\n};\\n\\nvar recomputePlaceholders = (function (_ref2) {\\n  var draggable = _ref2.draggable,\\n      draggables = _ref2.draggables,\\n      droppables = _ref2.droppables,\\n      previousImpact = _ref2.previousImpact,\\n      impact = _ref2.impact;\\n  var cleaned = clearUnusedPlaceholder({\\n    previousImpact: previousImpact,\\n    impact: impact,\\n    droppables: droppables\\n  });\\n  var isOver = whatIsDraggedOver(impact);\\n\\n  if (!isOver) {\\n    return cleaned;\\n  }\\n\\n  var droppable = droppables[isOver];\\n\\n  if (isHomeOf(draggable, droppable)) {\\n    return cleaned;\\n  }\\n\\n  if (droppable.subject.withPlaceholder) {\\n    return cleaned;\\n  }\\n\\n  var patched = addPlaceholder(droppable, draggable, draggables);\\n  return patchDroppableMap(cleaned, patched);\\n});\\n\\nvar update = (function (_ref) {\\n  var state = _ref.state,\\n      forcedClientSelection = _ref.clientSelection,\\n      forcedDimensions = _ref.dimensions,\\n      forcedViewport = _ref.viewport,\\n      forcedImpact = _ref.impact,\\n      scrollJumpRequest = _ref.scrollJumpRequest;\\n  var viewport = forcedViewport || state.viewport;\\n  var currentWindowScroll = viewport.scroll.current;\\n  var dimensions = forcedDimensions || state.dimensions;\\n  var clientSelection = forcedClientSelection || state.current.client.selection;\\n  var offset = subtract(clientSelection, state.initial.client.selection);\\n  var client = {\\n    offset: offset,\\n    selection: clientSelection,\\n    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\\n  };\\n  var page = {\\n    selection: add(client.selection, currentWindowScroll),\\n    borderBoxCenter: add(client.borderBoxCenter, currentWindowScroll)\\n  };\\n  var current = {\\n    client: client,\\n    page: page\\n  };\\n  var userDirection = getUserDirection(state.userDirection, state.current.page.borderBoxCenter, current.page.borderBoxCenter);\\n\\n  if (state.phase === 'COLLECTING') {\\n    return _extends({\\n      phase: 'COLLECTING'\\n    }, state, {\\n      dimensions: dimensions,\\n      viewport: viewport,\\n      current: current,\\n      userDirection: userDirection\\n    });\\n  }\\n\\n  var draggable = dimensions.draggables[state.critical.draggable.id];\\n  var newImpact = forcedImpact || getDragImpact({\\n    pageBorderBoxCenter: page.borderBoxCenter,\\n    draggable: draggable,\\n    draggables: dimensions.draggables,\\n    droppables: dimensions.droppables,\\n    previousImpact: state.impact,\\n    viewport: viewport,\\n    userDirection: userDirection,\\n    afterCritical: state.afterCritical\\n  });\\n  var withUpdatedPlaceholders = recomputePlaceholders({\\n    draggable: draggable,\\n    impact: newImpact,\\n    previousImpact: state.impact,\\n    draggables: dimensions.draggables,\\n    droppables: dimensions.droppables\\n  });\\n\\n  var result = _extends({}, state, {\\n    current: current,\\n    userDirection: userDirection,\\n    dimensions: {\\n      draggables: dimensions.draggables,\\n      droppables: withUpdatedPlaceholders\\n    },\\n    impact: newImpact,\\n    viewport: viewport,\\n    scrollJumpRequest: scrollJumpRequest || null,\\n    forceShouldAnimate: scrollJumpRequest ? false : null\\n  });\\n\\n  return result;\\n});\\n\\nfunction getDraggables$1(ids, draggables) {\\n  return ids.map(function (id) {\\n    return draggables[id];\\n  });\\n}\\n\\nvar recompute = (function (_ref) {\\n  var impact = _ref.impact,\\n      viewport = _ref.viewport,\\n      draggables = _ref.draggables,\\n      destination = _ref.destination,\\n      forceShouldAnimate = _ref.forceShouldAnimate;\\n  var last = impact.displaced;\\n  var afterDragging = getDraggables$1(last.all, draggables);\\n  var displaced = getDisplacementGroups({\\n    afterDragging: afterDragging,\\n    destination: destination,\\n    displacedBy: impact.displacedBy,\\n    viewport: viewport.frame,\\n    forceShouldAnimate: forceShouldAnimate,\\n    last: last\\n  });\\n  return _extends({}, impact, {\\n    displaced: displaced\\n  });\\n});\\n\\nvar getClientBorderBoxCenter = (function (_ref) {\\n  var impact = _ref.impact,\\n      draggable = _ref.draggable,\\n      droppable = _ref.droppable,\\n      draggables = _ref.draggables,\\n      viewport = _ref.viewport,\\n      afterCritical = _ref.afterCritical;\\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\\n    impact: impact,\\n    draggable: draggable,\\n    draggables: draggables,\\n    droppable: droppable,\\n    afterCritical: afterCritical\\n  });\\n  return getClientFromPageBorderBoxCenter({\\n    pageBorderBoxCenter: pageBorderBoxCenter,\\n    draggable: draggable,\\n    viewport: viewport\\n  });\\n});\\n\\nvar refreshSnap = (function (_ref) {\\n  var state = _ref.state,\\n      forcedDimensions = _ref.dimensions,\\n      forcedViewport = _ref.viewport;\\n  !(state.movementMode === 'SNAP') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false) : invariant(false) : void 0;\\n  var needsVisibilityCheck = state.impact;\\n  var viewport = forcedViewport || state.viewport;\\n  var dimensions = forcedDimensions || state.dimensions;\\n  var draggables = dimensions.draggables,\\n      droppables = dimensions.droppables;\\n  var draggable = draggables[state.critical.draggable.id];\\n  var isOver = whatIsDraggedOver(needsVisibilityCheck);\\n  !isOver ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Must be over a destination in SNAP movement mode') : invariant(false) : void 0;\\n  var destination = droppables[isOver];\\n  var impact = recompute({\\n    impact: needsVisibilityCheck,\\n    viewport: viewport,\\n    destination: destination,\\n    draggables: draggables\\n  });\\n  var clientSelection = getClientBorderBoxCenter({\\n    impact: impact,\\n    draggable: draggable,\\n    droppable: destination,\\n    draggables: draggables,\\n    viewport: viewport,\\n    afterCritical: state.afterCritical\\n  });\\n  return update({\\n    impact: impact,\\n    clientSelection: clientSelection,\\n    state: state,\\n    dimensions: dimensions,\\n    viewport: viewport\\n  });\\n});\\n\\nvar getHomeLocation = (function (descriptor) {\\n  return {\\n    index: descriptor.index,\\n    droppableId: descriptor.droppableId\\n  };\\n});\\n\\nvar getLiftEffect = (function (_ref) {\\n  var draggable = _ref.draggable,\\n      home = _ref.home,\\n      draggables = _ref.draggables,\\n      viewport = _ref.viewport;\\n  var displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\\n  var insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\\n  var rawIndex = insideHome.indexOf(draggable);\\n  !(rawIndex !== -1) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected draggable to be inside home list') : invariant(false) : void 0;\\n  var afterDragging = insideHome.slice(rawIndex + 1);\\n  var effected = afterDragging.reduce(function (previous, item) {\\n    previous[item.descriptor.id] = true;\\n    return previous;\\n  }, {});\\n  var afterCritical = {\\n    inVirtualList: home.descriptor.mode === 'virtual',\\n    displacedBy: displacedBy,\\n    effected: effected\\n  };\\n  var displaced = getDisplacementGroups({\\n    afterDragging: afterDragging,\\n    destination: home,\\n    displacedBy: displacedBy,\\n    last: null,\\n    viewport: viewport.frame,\\n    forceShouldAnimate: false\\n  });\\n  var impact = {\\n    displaced: displaced,\\n    displacedBy: displacedBy,\\n    at: {\\n      type: 'REORDER',\\n      destination: getHomeLocation(draggable.descriptor)\\n    }\\n  };\\n  return {\\n    impact: impact,\\n    afterCritical: afterCritical\\n  };\\n});\\n\\nvar patchDimensionMap = (function (dimensions, updated) {\\n  return {\\n    draggables: dimensions.draggables,\\n    droppables: patchDroppableMap(dimensions.droppables, updated)\\n  };\\n});\\n\\nvar records = {};\\nvar isEnabled = false;\\n\\nvar isTimingsEnabled = function isTimingsEnabled() {\\n  return isEnabled;\\n};\\nvar start = function start(key) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (!isTimingsEnabled()) {\\n      return;\\n    }\\n\\n    var now = performance.now();\\n    records[key] = now;\\n  }\\n};\\nvar finish = function finish(key) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (!isTimingsEnabled()) {\\n      return;\\n    }\\n\\n    var now = performance.now();\\n    var previous = records[key];\\n\\n    if (!previous) {\\n      console.warn('cannot finish timing as no previous time found', key);\\n      return;\\n    }\\n\\n    var result = now - previous;\\n    var rounded = result.toFixed(2);\\n\\n    var style = function () {\\n      if (result < 12) {\\n        return {\\n          textColor: 'green',\\n          symbol: '\\u2705'\\n        };\\n      }\\n\\n      if (result < 40) {\\n        return {\\n          textColor: 'orange',\\n          symbol: '\\u26a0\\ufe0f'\\n        };\\n      }\\n\\n      return {\\n        textColor: 'red',\\n        symbol: '\\u274c'\\n      };\\n    }();\\n\\n    console.log(style.symbol + \\\" %cTiming %c\\\" + rounded + \\\" %cms %c\\\" + key, 'color: blue; font-weight: bold;', \\\"color: \\\" + style.textColor + \\\"; font-size: 1.1em;\\\", 'color: grey;', 'color: purple; font-weight: bold;');\\n  }\\n};\\n\\nvar offsetDraggable = (function (_ref) {\\n  var draggable = _ref.draggable,\\n      offset = _ref.offset,\\n      initialWindowScroll = _ref.initialWindowScroll;\\n  var client = cssBoxModel.offset(draggable.client, offset);\\n  var page = cssBoxModel.withScroll(client, initialWindowScroll);\\n\\n  var moved = _extends({}, draggable, {\\n    placeholder: _extends({}, draggable.placeholder, {\\n      client: client\\n    }),\\n    client: client,\\n    page: page\\n  });\\n\\n  return moved;\\n});\\n\\nvar getFrame = (function (droppable) {\\n  var frame = droppable.frame;\\n  !frame ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected Droppable to have a frame') : invariant(false) : void 0;\\n  return frame;\\n});\\n\\nvar adjustAdditionsForScrollChanges = (function (_ref) {\\n  var additions = _ref.additions,\\n      updatedDroppables = _ref.updatedDroppables,\\n      viewport = _ref.viewport;\\n  var windowScrollChange = viewport.scroll.diff.value;\\n  return additions.map(function (draggable) {\\n    var droppableId = draggable.descriptor.droppableId;\\n    var modified = updatedDroppables[droppableId];\\n    var frame = getFrame(modified);\\n    var droppableScrollChange = frame.scroll.diff.value;\\n    var totalChange = add(windowScrollChange, droppableScrollChange);\\n    var moved = offsetDraggable({\\n      draggable: draggable,\\n      offset: totalChange,\\n      initialWindowScroll: viewport.scroll.initial\\n    });\\n    return moved;\\n  });\\n});\\n\\nvar timingsKey = 'Processing dynamic changes';\\nvar publishWhileDraggingInVirtual = (function (_ref) {\\n  var _extends2, _extends3;\\n\\n  var state = _ref.state,\\n      published = _ref.published;\\n  start(timingsKey);\\n  var withScrollChange = published.modified.map(function (update) {\\n    var existing = state.dimensions.droppables[update.droppableId];\\n    var scrolled = scrollDroppable(existing, update.scroll);\\n    return scrolled;\\n  });\\n\\n  var droppables = _extends({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));\\n\\n  var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\\n    additions: published.additions,\\n    updatedDroppables: droppables,\\n    viewport: state.viewport\\n  }));\\n\\n  var draggables = _extends({}, state.dimensions.draggables, {}, updatedAdditions);\\n\\n  published.removals.forEach(function (id) {\\n    delete draggables[id];\\n  });\\n  var dimensions = {\\n    droppables: droppables,\\n    draggables: draggables\\n  };\\n  var wasOverId = whatIsDraggedOver(state.impact);\\n  var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\\n  var draggable = dimensions.draggables[state.critical.draggable.id];\\n  var home = dimensions.droppables[state.critical.droppable.id];\\n\\n  var _getLiftEffect = getLiftEffect({\\n    draggable: draggable,\\n    home: home,\\n    draggables: draggables,\\n    viewport: state.viewport\\n  }),\\n      onLiftImpact = _getLiftEffect.impact,\\n      afterCritical = _getLiftEffect.afterCritical;\\n\\n  var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\\n  var impact = getDragImpact({\\n    pageBorderBoxCenter: state.current.page.borderBoxCenter,\\n    draggable: dimensions.draggables[state.critical.draggable.id],\\n    draggables: dimensions.draggables,\\n    droppables: dimensions.droppables,\\n    previousImpact: previousImpact,\\n    viewport: state.viewport,\\n    userDirection: state.userDirection,\\n    afterCritical: afterCritical\\n  });\\n  finish(timingsKey);\\n\\n  var draggingState = _extends({\\n    phase: 'DRAGGING'\\n  }, state, (_extends2 = {}, _extends2[\\\"phase\\\"] = 'DRAGGING', _extends2.impact = impact, _extends2.onLiftImpact = onLiftImpact, _extends2.dimensions = dimensions, _extends2.afterCritical = afterCritical, _extends2.forceShouldAnimate = false, _extends2));\\n\\n  if (state.phase === 'COLLECTING') {\\n    return draggingState;\\n  }\\n\\n  var dropPending = _extends({\\n    phase: 'DROP_PENDING'\\n  }, draggingState, (_extends3 = {}, _extends3[\\\"phase\\\"] = 'DROP_PENDING', _extends3.reason = state.reason, _extends3.isWaiting = false, _extends3));\\n\\n  return dropPending;\\n});\\n\\nvar isSnapping = function isSnapping(state) {\\n  return state.movementMode === 'SNAP';\\n};\\n\\nvar postDroppableChange = function postDroppableChange(state, updated, isEnabledChanging) {\\n  var dimensions = patchDimensionMap(state.dimensions, updated);\\n\\n  if (!isSnapping(state) || isEnabledChanging) {\\n    return update({\\n      state: state,\\n      dimensions: dimensions\\n    });\\n  }\\n\\n  return refreshSnap({\\n    state: state,\\n    dimensions: dimensions\\n  });\\n};\\n\\nfunction removeScrollJumpRequest(state) {\\n  if (state.isDragging && state.movementMode === 'SNAP') {\\n    return _extends({\\n      phase: 'DRAGGING'\\n    }, state, {\\n      scrollJumpRequest: null\\n    });\\n  }\\n\\n  return state;\\n}\\n\\nvar idle = {\\n  phase: 'IDLE',\\n  completed: null,\\n  shouldFlush: false\\n};\\nvar reducer = (function (state, action) {\\n  if (state === void 0) {\\n    state = idle;\\n  }\\n\\n  if (action.type === 'FLUSH') {\\n    return _extends({}, idle, {\\n      shouldFlush: true\\n    });\\n  }\\n\\n  if (action.type === 'INITIAL_PUBLISH') {\\n    !(state.phase === 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'INITIAL_PUBLISH must come after a IDLE phase') : invariant(false) : void 0;\\n    var _action$payload = action.payload,\\n        critical = _action$payload.critical,\\n        clientSelection = _action$payload.clientSelection,\\n        viewport = _action$payload.viewport,\\n        dimensions = _action$payload.dimensions,\\n        movementMode = _action$payload.movementMode;\\n    var draggable = dimensions.draggables[critical.draggable.id];\\n    var home = dimensions.droppables[critical.droppable.id];\\n    var client = {\\n      selection: clientSelection,\\n      borderBoxCenter: draggable.client.borderBox.center,\\n      offset: origin\\n    };\\n    var initial = {\\n      client: client,\\n      page: {\\n        selection: add(client.selection, viewport.scroll.initial),\\n        borderBoxCenter: add(client.selection, viewport.scroll.initial)\\n      }\\n    };\\n    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function (item) {\\n      return !item.isFixedOnPage;\\n    });\\n\\n    var _getLiftEffect = getLiftEffect({\\n      draggable: draggable,\\n      home: home,\\n      draggables: dimensions.draggables,\\n      viewport: viewport\\n    }),\\n        impact = _getLiftEffect.impact,\\n        afterCritical = _getLiftEffect.afterCritical;\\n\\n    var result = {\\n      phase: 'DRAGGING',\\n      isDragging: true,\\n      critical: critical,\\n      movementMode: movementMode,\\n      dimensions: dimensions,\\n      initial: initial,\\n      current: initial,\\n      isWindowScrollAllowed: isWindowScrollAllowed,\\n      impact: impact,\\n      afterCritical: afterCritical,\\n      onLiftImpact: impact,\\n      viewport: viewport,\\n      userDirection: forward,\\n      scrollJumpRequest: null,\\n      forceShouldAnimate: null\\n    };\\n    return result;\\n  }\\n\\n  if (action.type === 'COLLECTION_STARTING') {\\n    var _extends2;\\n\\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\\n      return state;\\n    }\\n\\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Collection cannot start from phase \\\" + state.phase) : invariant(false) : void 0;\\n\\n    var _result = _extends({\\n      phase: 'COLLECTING'\\n    }, state, (_extends2 = {}, _extends2[\\\"phase\\\"] = 'COLLECTING', _extends2));\\n\\n    return _result;\\n  }\\n\\n  if (action.type === 'PUBLISH_WHILE_DRAGGING') {\\n    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Unexpected \\\" + action.type + \\\" received in phase \\\" + state.phase) : invariant(false) : void 0;\\n    return publishWhileDraggingInVirtual({\\n      state: state,\\n      published: action.payload\\n    });\\n  }\\n\\n  if (action.type === 'MOVE') {\\n    if (state.phase === 'DROP_PENDING') {\\n      return state;\\n    }\\n\\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, action.type + \\\" not permitted in phase \\\" + state.phase) : invariant(false) : void 0;\\n    var _clientSelection = action.payload.client;\\n\\n    if (isEqual(_clientSelection, state.current.client.selection)) {\\n      return state;\\n    }\\n\\n    return update({\\n      state: state,\\n      clientSelection: _clientSelection,\\n      impact: isSnapping(state) ? state.impact : null\\n    });\\n  }\\n\\n  if (action.type === 'UPDATE_DROPPABLE_SCROLL') {\\n    if (state.phase === 'DROP_PENDING') {\\n      return removeScrollJumpRequest(state);\\n    }\\n\\n    if (state.phase === 'COLLECTING') {\\n      return removeScrollJumpRequest(state);\\n    }\\n\\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, action.type + \\\" not permitted in phase \\\" + state.phase) : invariant(false) : void 0;\\n    var _action$payload2 = action.payload,\\n        id = _action$payload2.id,\\n        newScroll = _action$payload2.newScroll;\\n    var target = state.dimensions.droppables[id];\\n\\n    if (!target) {\\n      return state;\\n    }\\n\\n    var scrolled = scrollDroppable(target, newScroll);\\n    return postDroppableChange(state, scrolled, false);\\n  }\\n\\n  if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {\\n    if (state.phase === 'DROP_PENDING') {\\n      return state;\\n    }\\n\\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Attempting to move in an unsupported phase \\\" + state.phase) : invariant(false) : void 0;\\n    var _action$payload3 = action.payload,\\n        _id = _action$payload3.id,\\n        isEnabled = _action$payload3.isEnabled;\\n    var _target = state.dimensions.droppables[_id];\\n    !_target ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot find Droppable[id: \\\" + _id + \\\"] to toggle its enabled state\\\") : invariant(false) : void 0;\\n    !(_target.isEnabled !== isEnabled) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Trying to set droppable isEnabled to \\\" + String(isEnabled) + \\\"\\\\n      but it is already \\\" + String(_target.isEnabled)) : invariant(false) : void 0;\\n\\n    var updated = _extends({}, _target, {\\n      isEnabled: isEnabled\\n    });\\n\\n    return postDroppableChange(state, updated, true);\\n  }\\n\\n  if (action.type === 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED') {\\n    if (state.phase === 'DROP_PENDING') {\\n      return state;\\n    }\\n\\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Attempting to move in an unsupported phase \\\" + state.phase) : invariant(false) : void 0;\\n    var _action$payload4 = action.payload,\\n        _id2 = _action$payload4.id,\\n        isCombineEnabled = _action$payload4.isCombineEnabled;\\n    var _target2 = state.dimensions.droppables[_id2];\\n    !_target2 ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot find Droppable[id: \\\" + _id2 + \\\"] to toggle its isCombineEnabled state\\\") : invariant(false) : void 0;\\n    !(_target2.isCombineEnabled !== isCombineEnabled) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Trying to set droppable isCombineEnabled to \\\" + String(isCombineEnabled) + \\\"\\\\n      but it is already \\\" + String(_target2.isCombineEnabled)) : invariant(false) : void 0;\\n\\n    var _updated = _extends({}, _target2, {\\n      isCombineEnabled: isCombineEnabled\\n    });\\n\\n    return postDroppableChange(state, _updated, true);\\n  }\\n\\n  if (action.type === 'MOVE_BY_WINDOW_SCROLL') {\\n    if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {\\n      return state;\\n    }\\n\\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot move by window in phase \\\" + state.phase) : invariant(false) : void 0;\\n    !state.isWindowScrollAllowed ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Window scrolling is currently not supported for fixed lists') : invariant(false) : void 0;\\n    var _newScroll = action.payload.newScroll;\\n\\n    if (isEqual(state.viewport.scroll.current, _newScroll)) {\\n      return removeScrollJumpRequest(state);\\n    }\\n\\n    var _viewport = scrollViewport(state.viewport, _newScroll);\\n\\n    if (isSnapping(state)) {\\n      return refreshSnap({\\n        state: state,\\n        viewport: _viewport\\n      });\\n    }\\n\\n    return update({\\n      state: state,\\n      viewport: _viewport\\n    });\\n  }\\n\\n  if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {\\n    if (!isMovementAllowed(state)) {\\n      return state;\\n    }\\n\\n    var maxScroll = action.payload.maxScroll;\\n\\n    if (isEqual(maxScroll, state.viewport.scroll.max)) {\\n      return state;\\n    }\\n\\n    var withMaxScroll = _extends({}, state.viewport, {\\n      scroll: _extends({}, state.viewport.scroll, {\\n        max: maxScroll\\n      })\\n    });\\n\\n    return _extends({\\n      phase: 'DRAGGING'\\n    }, state, {\\n      viewport: withMaxScroll\\n    });\\n  }\\n\\n  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {\\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\\n      return state;\\n    }\\n\\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, action.type + \\\" received while not in DRAGGING phase\\\") : invariant(false) : void 0;\\n\\n    var _result2 = moveInDirection({\\n      state: state,\\n      type: action.type\\n    });\\n\\n    if (!_result2) {\\n      return state;\\n    }\\n\\n    return update({\\n      state: state,\\n      impact: _result2.impact,\\n      clientSelection: _result2.clientSelection,\\n      scrollJumpRequest: _result2.scrollJumpRequest\\n    });\\n  }\\n\\n  if (action.type === 'DROP_PENDING') {\\n    var _extends3;\\n\\n    var reason = action.payload.reason;\\n    !(state.phase === 'COLLECTING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Can only move into the DROP_PENDING phase from the COLLECTING phase') : invariant(false) : void 0;\\n\\n    var newState = _extends({\\n      phase: 'DROP_PENDING'\\n    }, state, (_extends3 = {}, _extends3[\\\"phase\\\"] = 'DROP_PENDING', _extends3.isWaiting = true, _extends3.reason = reason, _extends3));\\n\\n    return newState;\\n  }\\n\\n  if (action.type === 'DROP_ANIMATE') {\\n    var _action$payload5 = action.payload,\\n        completed = _action$payload5.completed,\\n        dropDuration = _action$payload5.dropDuration,\\n        newHomeClientOffset = _action$payload5.newHomeClientOffset;\\n    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot animate drop from phase \\\" + state.phase) : invariant(false) : void 0;\\n    var _result3 = {\\n      phase: 'DROP_ANIMATING',\\n      completed: completed,\\n      dropDuration: dropDuration,\\n      newHomeClientOffset: newHomeClientOffset,\\n      dimensions: state.dimensions\\n    };\\n    return _result3;\\n  }\\n\\n  if (action.type === 'DROP_COMPLETE') {\\n    var _completed = action.payload.completed;\\n    return {\\n      phase: 'IDLE',\\n      completed: _completed,\\n      shouldFlush: false\\n    };\\n  }\\n\\n  return state;\\n});\\n\\nvar lift = function lift(args) {\\n  return {\\n    type: 'LIFT',\\n    payload: args\\n  };\\n};\\nvar initialPublish = function initialPublish(args) {\\n  return {\\n    type: 'INITIAL_PUBLISH',\\n    payload: args\\n  };\\n};\\nvar publishWhileDragging = function publishWhileDragging(args) {\\n  return {\\n    type: 'PUBLISH_WHILE_DRAGGING',\\n    payload: args\\n  };\\n};\\nvar collectionStarting = function collectionStarting() {\\n  return {\\n    type: 'COLLECTION_STARTING',\\n    payload: null\\n  };\\n};\\nvar updateDroppableScroll = function updateDroppableScroll(args) {\\n  return {\\n    type: 'UPDATE_DROPPABLE_SCROLL',\\n    payload: args\\n  };\\n};\\nvar updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {\\n  return {\\n    type: 'UPDATE_DROPPABLE_IS_ENABLED',\\n    payload: args\\n  };\\n};\\nvar updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(args) {\\n  return {\\n    type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',\\n    payload: args\\n  };\\n};\\nvar move = function move(args) {\\n  return {\\n    type: 'MOVE',\\n    payload: args\\n  };\\n};\\nvar moveByWindowScroll = function moveByWindowScroll(args) {\\n  return {\\n    type: 'MOVE_BY_WINDOW_SCROLL',\\n    payload: args\\n  };\\n};\\nvar updateViewportMaxScroll = function updateViewportMaxScroll(args) {\\n  return {\\n    type: 'UPDATE_VIEWPORT_MAX_SCROLL',\\n    payload: args\\n  };\\n};\\nvar moveUp = function moveUp() {\\n  return {\\n    type: 'MOVE_UP',\\n    payload: null\\n  };\\n};\\nvar moveDown = function moveDown() {\\n  return {\\n    type: 'MOVE_DOWN',\\n    payload: null\\n  };\\n};\\nvar moveRight = function moveRight() {\\n  return {\\n    type: 'MOVE_RIGHT',\\n    payload: null\\n  };\\n};\\nvar moveLeft = function moveLeft() {\\n  return {\\n    type: 'MOVE_LEFT',\\n    payload: null\\n  };\\n};\\nvar flush = function flush() {\\n  return {\\n    type: 'FLUSH',\\n    payload: null\\n  };\\n};\\nvar animateDrop = function animateDrop(args) {\\n  return {\\n    type: 'DROP_ANIMATE',\\n    payload: args\\n  };\\n};\\nvar completeDrop = function completeDrop(args) {\\n  return {\\n    type: 'DROP_COMPLETE',\\n    payload: args\\n  };\\n};\\nvar drop = function drop(args) {\\n  return {\\n    type: 'DROP',\\n    payload: args\\n  };\\n};\\nvar dropPending = function dropPending(args) {\\n  return {\\n    type: 'DROP_PENDING',\\n    payload: args\\n  };\\n};\\nvar dropAnimationFinished = function dropAnimationFinished() {\\n  return {\\n    type: 'DROP_ANIMATION_FINISHED',\\n    payload: null\\n  };\\n};\\n\\nfunction checkIndexes(insideDestination) {\\n  if (insideDestination.length <= 1) {\\n    return;\\n  }\\n\\n  var indexes = insideDestination.map(function (d) {\\n    return d.descriptor.index;\\n  });\\n  var errors = {};\\n\\n  for (var i = 1; i < indexes.length; i++) {\\n    var current = indexes[i];\\n    var previous = indexes[i - 1];\\n\\n    if (current !== previous + 1) {\\n      errors[current] = true;\\n    }\\n  }\\n\\n  if (!_Object$keys(errors).length) {\\n    return;\\n  }\\n\\n  var formatted = indexes.map(function (index) {\\n    var hasError = Boolean(errors[index]);\\n    return hasError ? \\\"[\\\\uD83D\\\\uDD25\\\" + index + \\\"]\\\" : \\\"\\\" + index;\\n  }).join(', ');\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n    Detected non-consecutive <Draggable /> indexes.\\\\n\\\\n    (This can cause unexpected bugs)\\\\n\\\\n    \\\" + formatted + \\\"\\\\n  \\\") : void 0;\\n}\\n\\nfunction validateDimensions(critical, dimensions) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    var insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\\n    checkIndexes(insideDestination);\\n  }\\n}\\n\\nvar lift$1 = (function (marshal) {\\n  return function (_ref) {\\n    var getState = _ref.getState,\\n        dispatch = _ref.dispatch;\\n    return function (next) {\\n      return function (action) {\\n        if (action.type !== 'LIFT') {\\n          next(action);\\n          return;\\n        }\\n\\n        var _action$payload = action.payload,\\n            id = _action$payload.id,\\n            clientSelection = _action$payload.clientSelection,\\n            movementMode = _action$payload.movementMode;\\n        var initial = getState();\\n\\n        if (initial.phase === 'DROP_ANIMATING') {\\n          dispatch(completeDrop({\\n            completed: initial.completed\\n          }));\\n        }\\n\\n        !(getState().phase === 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Unexpected phase to start a drag') : invariant(false) : void 0;\\n        dispatch(flush());\\n        var scrollOptions = {\\n          shouldPublishImmediately: movementMode === 'SNAP'\\n        };\\n        var request = {\\n          draggableId: id,\\n          scrollOptions: scrollOptions\\n        };\\n\\n        var _marshal$startPublish = marshal.startPublishing(request),\\n            critical = _marshal$startPublish.critical,\\n            dimensions = _marshal$startPublish.dimensions,\\n            viewport = _marshal$startPublish.viewport;\\n\\n        validateDimensions(critical, dimensions);\\n        dispatch(initialPublish({\\n          critical: critical,\\n          dimensions: dimensions,\\n          clientSelection: clientSelection,\\n          movementMode: movementMode,\\n          viewport: viewport\\n        }));\\n      };\\n    };\\n  };\\n});\\n\\nvar style = (function (marshal) {\\n  return function () {\\n    return function (next) {\\n      return function (action) {\\n        if (action.type === 'INITIAL_PUBLISH') {\\n          marshal.dragging();\\n        }\\n\\n        if (action.type === 'DROP_ANIMATE') {\\n          marshal.dropping(action.payload.completed.result.reason);\\n        }\\n\\n        if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE') {\\n          marshal.resting();\\n        }\\n\\n        next(action);\\n      };\\n    };\\n  };\\n});\\n\\nvar curves = {\\n  outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',\\n  drop: 'cubic-bezier(.2,1,.1,1)'\\n};\\nvar combine = {\\n  opacity: {\\n    drop: 0,\\n    combining: 0.7\\n  },\\n  scale: {\\n    drop: 0.75\\n  }\\n};\\nvar timings = {\\n  outOfTheWay: 0.2,\\n  minDropTime: 0.33,\\n  maxDropTime: 0.55\\n};\\nvar outOfTheWayTiming = timings.outOfTheWay + \\\"s \\\" + curves.outOfTheWay;\\nvar transitions = {\\n  fluid: \\\"opacity \\\" + outOfTheWayTiming,\\n  snap: \\\"transform \\\" + outOfTheWayTiming + \\\", opacity \\\" + outOfTheWayTiming,\\n  drop: function drop(duration) {\\n    var timing = duration + \\\"s \\\" + curves.drop;\\n    return \\\"transform \\\" + timing + \\\", opacity \\\" + timing;\\n  },\\n  outOfTheWay: \\\"transform \\\" + outOfTheWayTiming,\\n  placeholder: \\\"height \\\" + outOfTheWayTiming + \\\", width \\\" + outOfTheWayTiming + \\\", margin \\\" + outOfTheWayTiming\\n};\\n\\nvar moveTo = function moveTo(offset) {\\n  return isEqual(offset, origin) ? null : \\\"translate(\\\" + offset.x + \\\"px, \\\" + offset.y + \\\"px)\\\";\\n};\\n\\nvar transforms = {\\n  moveTo: moveTo,\\n  drop: function drop(offset, isCombining) {\\n    var translate = moveTo(offset);\\n\\n    if (!translate) {\\n      return null;\\n    }\\n\\n    if (!isCombining) {\\n      return translate;\\n    }\\n\\n    return translate + \\\" scale(\\\" + combine.scale.drop + \\\")\\\";\\n  }\\n};\\n\\nvar minDropTime = timings.minDropTime,\\n    maxDropTime = timings.maxDropTime;\\nvar dropTimeRange = maxDropTime - minDropTime;\\nvar maxDropTimeAtDistance = 1500;\\nvar cancelDropModifier = 0.6;\\nvar getDropDuration = (function (_ref) {\\n  var current = _ref.current,\\n      destination = _ref.destination,\\n      reason = _ref.reason;\\n  var distance$1 = distance(current, destination);\\n\\n  if (distance$1 <= 0) {\\n    return minDropTime;\\n  }\\n\\n  if (distance$1 >= maxDropTimeAtDistance) {\\n    return maxDropTime;\\n  }\\n\\n  var percentage = distance$1 / maxDropTimeAtDistance;\\n  var duration = minDropTime + dropTimeRange * percentage;\\n  var withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;\\n  return Number(withDuration.toFixed(2));\\n});\\n\\nvar getNewHomeClientOffset = (function (_ref) {\\n  var impact = _ref.impact,\\n      draggable = _ref.draggable,\\n      dimensions = _ref.dimensions,\\n      viewport = _ref.viewport,\\n      afterCritical = _ref.afterCritical;\\n  var draggables = dimensions.draggables,\\n      droppables = dimensions.droppables;\\n  var droppableId = whatIsDraggedOver(impact);\\n  var destination = droppableId ? droppables[droppableId] : null;\\n  var home = droppables[draggable.descriptor.droppableId];\\n  var newClientCenter = getClientBorderBoxCenter({\\n    impact: impact,\\n    draggable: draggable,\\n    draggables: draggables,\\n    afterCritical: afterCritical,\\n    droppable: destination || home,\\n    viewport: viewport\\n  });\\n  var offset = subtract(newClientCenter, draggable.client.borderBox.center);\\n  return offset;\\n});\\n\\nvar getDropImpact = (function (_ref) {\\n  var draggables = _ref.draggables,\\n      reason = _ref.reason,\\n      lastImpact = _ref.lastImpact,\\n      home = _ref.home,\\n      viewport = _ref.viewport,\\n      onLiftImpact = _ref.onLiftImpact;\\n\\n  if (!lastImpact.at || reason !== 'DROP') {\\n    var recomputedHomeImpact = recompute({\\n      draggables: draggables,\\n      impact: onLiftImpact,\\n      destination: home,\\n      viewport: viewport,\\n      forceShouldAnimate: true\\n    });\\n    return {\\n      impact: recomputedHomeImpact,\\n      didDropInsideDroppable: false\\n    };\\n  }\\n\\n  if (lastImpact.at.type === 'REORDER') {\\n    return {\\n      impact: lastImpact,\\n      didDropInsideDroppable: true\\n    };\\n  }\\n\\n  var withoutMovement = _extends({}, lastImpact, {\\n    displaced: emptyGroups\\n  });\\n\\n  return {\\n    impact: withoutMovement,\\n    didDropInsideDroppable: true\\n  };\\n});\\n\\nvar drop$1 = (function (_ref) {\\n  var getState = _ref.getState,\\n      dispatch = _ref.dispatch;\\n  return function (next) {\\n    return function (action) {\\n      if (action.type !== 'DROP') {\\n        next(action);\\n        return;\\n      }\\n\\n      var state = getState();\\n      var reason = action.payload.reason;\\n\\n      if (state.phase === 'COLLECTING') {\\n        dispatch(dropPending({\\n          reason: reason\\n        }));\\n        return;\\n      }\\n\\n      if (state.phase === 'IDLE') {\\n        return;\\n      }\\n\\n      var isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;\\n      !!isWaitingForDrop ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : invariant(false) : void 0;\\n      !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot drop in phase: \\\" + state.phase) : invariant(false) : void 0;\\n      var critical = state.critical;\\n      var dimensions = state.dimensions;\\n      var draggable = dimensions.draggables[state.critical.draggable.id];\\n\\n      var _getDropImpact = getDropImpact({\\n        reason: reason,\\n        lastImpact: state.impact,\\n        afterCritical: state.afterCritical,\\n        onLiftImpact: state.onLiftImpact,\\n        home: state.dimensions.droppables[state.critical.droppable.id],\\n        viewport: state.viewport,\\n        draggables: state.dimensions.draggables\\n      }),\\n          impact = _getDropImpact.impact,\\n          didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;\\n\\n      var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\\n      var combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\\n      var source = {\\n        index: critical.draggable.index,\\n        droppableId: critical.droppable.id\\n      };\\n      var result = {\\n        draggableId: draggable.descriptor.id,\\n        type: draggable.descriptor.type,\\n        source: source,\\n        reason: reason,\\n        mode: state.movementMode,\\n        destination: destination,\\n        combine: combine\\n      };\\n      var newHomeClientOffset = getNewHomeClientOffset({\\n        impact: impact,\\n        draggable: draggable,\\n        dimensions: dimensions,\\n        viewport: state.viewport,\\n        afterCritical: state.afterCritical\\n      });\\n      var completed = {\\n        critical: state.critical,\\n        afterCritical: state.afterCritical,\\n        result: result,\\n        impact: impact\\n      };\\n      var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\\n\\n      if (!isAnimationRequired) {\\n        dispatch(completeDrop({\\n          completed: completed\\n        }));\\n        return;\\n      }\\n\\n      var dropDuration = getDropDuration({\\n        current: state.current.client.offset,\\n        destination: newHomeClientOffset,\\n        reason: reason\\n      });\\n      var args = {\\n        newHomeClientOffset: newHomeClientOffset,\\n        dropDuration: dropDuration,\\n        completed: completed\\n      };\\n      dispatch(animateDrop(args));\\n    };\\n  };\\n});\\n\\nvar getWindowScroll = (function () {\\n  return {\\n    x: window.pageXOffset,\\n    y: window.pageYOffset\\n  };\\n});\\n\\nfunction getWindowScrollBinding(update) {\\n  return {\\n    eventName: 'scroll',\\n    options: {\\n      passive: true,\\n      capture: false\\n    },\\n    fn: function fn(event) {\\n      if (event.target !== window && event.target !== window.document) {\\n        return;\\n      }\\n\\n      update();\\n    }\\n  };\\n}\\n\\nfunction getScrollListener(_ref) {\\n  var onWindowScroll = _ref.onWindowScroll;\\n\\n  function updateScroll() {\\n    onWindowScroll(getWindowScroll());\\n  }\\n\\n  var scheduled = rafSchd(updateScroll);\\n  var binding = getWindowScrollBinding(scheduled);\\n  var unbind = noop;\\n\\n  function isActive() {\\n    return unbind !== noop;\\n  }\\n\\n  function start() {\\n    !!isActive() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot start scroll listener when already active') : invariant(false) : void 0;\\n    unbind = bindEvents(window, [binding]);\\n  }\\n\\n  function stop() {\\n    !isActive() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot stop scroll listener when not active') : invariant(false) : void 0;\\n    scheduled.cancel();\\n    unbind();\\n    unbind = noop;\\n  }\\n\\n  return {\\n    start: start,\\n    stop: stop,\\n    isActive: isActive\\n  };\\n}\\n\\nvar shouldEnd = function shouldEnd(action) {\\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';\\n};\\n\\nvar scrollListener = (function (store) {\\n  var listener = getScrollListener({\\n    onWindowScroll: function onWindowScroll(newScroll) {\\n      store.dispatch(moveByWindowScroll({\\n        newScroll: newScroll\\n      }));\\n    }\\n  });\\n  return function (next) {\\n    return function (action) {\\n      if (!listener.isActive() && action.type === 'INITIAL_PUBLISH') {\\n        listener.start();\\n      }\\n\\n      if (listener.isActive() && shouldEnd(action)) {\\n        listener.stop();\\n      }\\n\\n      next(action);\\n    };\\n  };\\n});\\n\\nvar getExpiringAnnounce = (function (announce) {\\n  var wasCalled = false;\\n  var isExpired = false;\\n  var timeoutId = setTimeout(function () {\\n    isExpired = true;\\n  });\\n\\n  var result = function result(message) {\\n    if (wasCalled) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning('Announcement already made. Not making a second announcement') : void 0;\\n      return;\\n    }\\n\\n    if (isExpired) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n        Announcements cannot be made asynchronously.\\\\n        Default message has already been announced.\\\\n      \\\") : void 0;\\n      return;\\n    }\\n\\n    wasCalled = true;\\n    announce(message);\\n    clearTimeout(timeoutId);\\n  };\\n\\n  result.wasCalled = function () {\\n    return wasCalled;\\n  };\\n\\n  return result;\\n});\\n\\nvar getAsyncMarshal = (function () {\\n  var entries = [];\\n\\n  var execute = function execute(timerId) {\\n    var index = findIndex(entries, function (item) {\\n      return item.timerId === timerId;\\n    });\\n    !(index !== -1) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find timer') : invariant(false) : void 0;\\n\\n    var _entries$splice = entries.splice(index, 1),\\n        entry = _entries$splice[0];\\n\\n    entry.callback();\\n  };\\n\\n  var add = function add(fn) {\\n    var timerId = setTimeout(function () {\\n      return execute(timerId);\\n    });\\n    var entry = {\\n      timerId: timerId,\\n      callback: fn\\n    };\\n    entries.push(entry);\\n  };\\n\\n  var flush = function flush() {\\n    if (!entries.length) {\\n      return;\\n    }\\n\\n    var shallow = [].concat(entries);\\n    entries.length = 0;\\n    shallow.forEach(function (entry) {\\n      clearTimeout(entry.timerId);\\n      entry.callback();\\n    });\\n  };\\n\\n  return {\\n    add: add,\\n    flush: flush\\n  };\\n});\\n\\nvar areLocationsEqual = function areLocationsEqual(first, second) {\\n  if (first == null && second == null) {\\n    return true;\\n  }\\n\\n  if (first == null || second == null) {\\n    return false;\\n  }\\n\\n  return first.droppableId === second.droppableId && first.index === second.index;\\n};\\nvar isCombineEqual = function isCombineEqual(first, second) {\\n  if (first == null && second == null) {\\n    return true;\\n  }\\n\\n  if (first == null || second == null) {\\n    return false;\\n  }\\n\\n  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\\n};\\nvar isCriticalEqual = function isCriticalEqual(first, second) {\\n  if (first === second) {\\n    return true;\\n  }\\n\\n  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\\n  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\\n  return isDraggableEqual && isDroppableEqual;\\n};\\n\\nvar withTimings = function withTimings(key, fn) {\\n  start(key);\\n  fn();\\n  finish(key);\\n};\\n\\nvar getDragStart = function getDragStart(critical, mode) {\\n  return {\\n    draggableId: critical.draggable.id,\\n    type: critical.droppable.type,\\n    source: {\\n      droppableId: critical.droppable.id,\\n      index: critical.draggable.index\\n    },\\n    mode: mode\\n  };\\n};\\n\\nvar execute = function execute(responder, data, announce, getDefaultMessage) {\\n  if (!responder) {\\n    announce(getDefaultMessage(data));\\n    return;\\n  }\\n\\n  var willExpire = getExpiringAnnounce(announce);\\n  var provided = {\\n    announce: willExpire\\n  };\\n  responder(data, provided);\\n\\n  if (!willExpire.wasCalled()) {\\n    announce(getDefaultMessage(data));\\n  }\\n};\\n\\nvar getPublisher = (function (getResponders, announce) {\\n  var asyncMarshal = getAsyncMarshal();\\n  var dragging = null;\\n\\n  var beforeStart = function beforeStart(critical, mode) {\\n    !!dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\\n    withTimings('onBeforeDragStart', function () {\\n      var fn = getResponders().onBeforeDragStart;\\n\\n      if (fn) {\\n        fn(getDragStart(critical, mode));\\n      }\\n    });\\n  };\\n\\n  var start = function start(critical, mode) {\\n    !!dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\\n    var data = getDragStart(critical, mode);\\n    dragging = {\\n      mode: mode,\\n      lastCritical: critical,\\n      lastLocation: data.source,\\n      lastCombine: null\\n    };\\n    asyncMarshal.add(function () {\\n      withTimings('onDragStart', function () {\\n        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);\\n      });\\n    });\\n  };\\n\\n  var update = function update(critical, impact) {\\n    var location = tryGetDestination(impact);\\n    var combine = tryGetCombine(impact);\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : invariant(false) : void 0;\\n    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\\n\\n    if (hasCriticalChanged) {\\n      dragging.lastCritical = critical;\\n    }\\n\\n    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\\n\\n    if (hasLocationChanged) {\\n      dragging.lastLocation = location;\\n    }\\n\\n    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\\n\\n    if (hasGroupingChanged) {\\n      dragging.lastCombine = combine;\\n    }\\n\\n    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\\n      return;\\n    }\\n\\n    var data = _extends({}, getDragStart(critical, dragging.mode), {\\n      combine: combine,\\n      destination: location\\n    });\\n\\n    asyncMarshal.add(function () {\\n      withTimings('onDragUpdate', function () {\\n        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);\\n      });\\n    });\\n  };\\n\\n  var flush = function flush() {\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Can only flush responders while dragging') : invariant(false) : void 0;\\n    asyncMarshal.flush();\\n  };\\n\\n  var drop = function drop(result) {\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot fire onDragEnd when there is no matching onDragStart') : invariant(false) : void 0;\\n    dragging = null;\\n    withTimings('onDragEnd', function () {\\n      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);\\n    });\\n  };\\n\\n  var abort = function abort() {\\n    if (!dragging) {\\n      return;\\n    }\\n\\n    var result = _extends({}, getDragStart(dragging.lastCritical, dragging.mode), {\\n      combine: null,\\n      destination: null,\\n      reason: 'CANCEL'\\n    });\\n\\n    drop(result);\\n  };\\n\\n  return {\\n    beforeStart: beforeStart,\\n    start: start,\\n    update: update,\\n    flush: flush,\\n    drop: drop,\\n    abort: abort\\n  };\\n});\\n\\nvar responders = (function (getResponders, announce) {\\n  var publisher = getPublisher(getResponders, announce);\\n  return function (store) {\\n    return function (next) {\\n      return function (action) {\\n        if (action.type === 'INITIAL_PUBLISH') {\\n          var critical = action.payload.critical;\\n          publisher.beforeStart(critical, action.payload.movementMode);\\n          next(action);\\n          publisher.start(critical, action.payload.movementMode);\\n          return;\\n        }\\n\\n        if (action.type === 'DROP_COMPLETE') {\\n          var result = action.payload.completed.result;\\n          publisher.flush();\\n          next(action);\\n          publisher.drop(result);\\n          return;\\n        }\\n\\n        next(action);\\n\\n        if (action.type === 'FLUSH') {\\n          publisher.abort();\\n          return;\\n        }\\n\\n        var state = store.getState();\\n\\n        if (state.phase === 'DRAGGING') {\\n          publisher.update(state.critical, state.impact);\\n        }\\n      };\\n    };\\n  };\\n});\\n\\nvar dropAnimationFinish = (function (store) {\\n  return function (next) {\\n    return function (action) {\\n      if (action.type !== 'DROP_ANIMATION_FINISHED') {\\n        next(action);\\n        return;\\n      }\\n\\n      var state = store.getState();\\n      !(state.phase === 'DROP_ANIMATING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot finish a drop animating when no drop is occurring') : invariant(false) : void 0;\\n      store.dispatch(completeDrop({\\n        completed: state.completed\\n      }));\\n    };\\n  };\\n});\\n\\nvar dropAnimationFlushOnScroll = (function (store) {\\n  var unbind = null;\\n  var frameId = null;\\n\\n  function clear() {\\n    if (frameId) {\\n      cancelAnimationFrame(frameId);\\n      frameId = null;\\n    }\\n\\n    if (unbind) {\\n      unbind();\\n      unbind = null;\\n    }\\n  }\\n\\n  return function (next) {\\n    return function (action) {\\n      if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATION_FINISHED') {\\n        clear();\\n      }\\n\\n      next(action);\\n\\n      if (action.type !== 'DROP_ANIMATE') {\\n        return;\\n      }\\n\\n      var binding = {\\n        eventName: 'scroll',\\n        options: {\\n          capture: true,\\n          passive: false,\\n          once: true\\n        },\\n        fn: function flushDropAnimation() {\\n          var state = store.getState();\\n\\n          if (state.phase === 'DROP_ANIMATING') {\\n            store.dispatch(dropAnimationFinished());\\n          }\\n        }\\n      };\\n      frameId = requestAnimationFrame(function () {\\n        frameId = null;\\n        unbind = bindEvents(window, [binding]);\\n      });\\n    };\\n  };\\n});\\n\\nvar dimensionMarshalStopper = (function (marshal) {\\n  return function () {\\n    return function (next) {\\n      return function (action) {\\n        if (action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' || action.type === 'DROP_ANIMATE') {\\n          marshal.stopPublishing();\\n        }\\n\\n        next(action);\\n      };\\n    };\\n  };\\n});\\n\\nvar focus = (function (marshal) {\\n  var isWatching = false;\\n  return function () {\\n    return function (next) {\\n      return function (action) {\\n        if (action.type === 'INITIAL_PUBLISH') {\\n          isWatching = true;\\n          marshal.tryRecordFocus(action.payload.critical.draggable.id);\\n          next(action);\\n          marshal.tryRestoreFocusRecorded();\\n          return;\\n        }\\n\\n        next(action);\\n\\n        if (!isWatching) {\\n          return;\\n        }\\n\\n        if (action.type === 'FLUSH') {\\n          isWatching = false;\\n          marshal.tryRestoreFocusRecorded();\\n          return;\\n        }\\n\\n        if (action.type === 'DROP_COMPLETE') {\\n          isWatching = false;\\n          var result = action.payload.completed.result;\\n\\n          if (result.combine) {\\n            marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\\n          }\\n\\n          marshal.tryRestoreFocusRecorded();\\n        }\\n      };\\n    };\\n  };\\n});\\n\\nvar shouldStop = function shouldStop(action) {\\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';\\n};\\n\\nvar autoScroll = (function (autoScroller) {\\n  return function (store) {\\n    return function (next) {\\n      return function (action) {\\n        if (shouldStop(action)) {\\n          autoScroller.stop();\\n          next(action);\\n          return;\\n        }\\n\\n        if (action.type === 'INITIAL_PUBLISH') {\\n          next(action);\\n          var state = store.getState();\\n          !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected phase to be DRAGGING after INITIAL_PUBLISH') : invariant(false) : void 0;\\n          autoScroller.start(state);\\n          return;\\n        }\\n\\n        next(action);\\n        autoScroller.scroll(store.getState());\\n      };\\n    };\\n  };\\n});\\n\\nvar pendingDrop = (function (store) {\\n  return function (next) {\\n    return function (action) {\\n      next(action);\\n\\n      if (action.type !== 'PUBLISH_WHILE_DRAGGING') {\\n        return;\\n      }\\n\\n      var postActionState = store.getState();\\n\\n      if (postActionState.phase !== 'DROP_PENDING') {\\n        return;\\n      }\\n\\n      if (postActionState.isWaiting) {\\n        return;\\n      }\\n\\n      store.dispatch(drop({\\n        reason: postActionState.reason\\n      }));\\n    };\\n  };\\n});\\n\\nvar composeEnhancers = process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : redux.compose;\\nvar createStore = (function (_ref) {\\n  var dimensionMarshal = _ref.dimensionMarshal,\\n      focusMarshal = _ref.focusMarshal,\\n      styleMarshal = _ref.styleMarshal,\\n      getResponders = _ref.getResponders,\\n      announce = _ref.announce,\\n      autoScroller = _ref.autoScroller;\\n  return redux.createStore(reducer, composeEnhancers(redux.applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\\n});\\n\\nvar clean$1 = function clean() {\\n  return {\\n    additions: {},\\n    removals: {},\\n    modified: {}\\n  };\\n};\\n\\nvar timingKey = 'Publish collection from DOM';\\nfunction createPublisher(_ref) {\\n  var registry = _ref.registry,\\n      callbacks = _ref.callbacks;\\n  var staging = clean$1();\\n  var frameId = null;\\n\\n  var collect = function collect() {\\n    if (frameId) {\\n      return;\\n    }\\n\\n    callbacks.collectionStarting();\\n    frameId = requestAnimationFrame(function () {\\n      frameId = null;\\n      start(timingKey);\\n      var _staging = staging,\\n          additions = _staging.additions,\\n          removals = _staging.removals,\\n          modified = _staging.modified;\\n\\n      var added = _Object$keys(additions).map(function (id) {\\n        return registry.draggable.getById(id).getDimension(origin);\\n      }).sort(function (a, b) {\\n        return a.descriptor.index - b.descriptor.index;\\n      });\\n\\n      var updated = _Object$keys(modified).map(function (id) {\\n        var entry = registry.droppable.getById(id);\\n        var scroll = entry.callbacks.getScrollWhileDragging();\\n        return {\\n          droppableId: id,\\n          scroll: scroll\\n        };\\n      });\\n\\n      var result = {\\n        additions: added,\\n        removals: _Object$keys(removals),\\n        modified: updated\\n      };\\n      staging = clean$1();\\n      finish(timingKey);\\n      callbacks.publish(result);\\n    });\\n  };\\n\\n  var add = function add(entry) {\\n    var id = entry.descriptor.id;\\n    staging.additions[id] = entry;\\n    staging.modified[entry.descriptor.droppableId] = true;\\n\\n    if (staging.removals[id]) {\\n      delete staging.removals[id];\\n    }\\n\\n    collect();\\n  };\\n\\n  var remove = function remove(entry) {\\n    var descriptor = entry.descriptor;\\n    staging.removals[descriptor.id] = true;\\n    staging.modified[descriptor.droppableId] = true;\\n\\n    if (staging.additions[descriptor.id]) {\\n      delete staging.additions[descriptor.id];\\n    }\\n\\n    collect();\\n  };\\n\\n  var stop = function stop() {\\n    if (!frameId) {\\n      return;\\n    }\\n\\n    cancelAnimationFrame(frameId);\\n    frameId = null;\\n    staging = clean$1();\\n  };\\n\\n  return {\\n    add: add,\\n    remove: remove,\\n    stop: stop\\n  };\\n}\\n\\nvar getMaxScroll = (function (_ref) {\\n  var scrollHeight = _ref.scrollHeight,\\n      scrollWidth = _ref.scrollWidth,\\n      height = _ref.height,\\n      width = _ref.width;\\n  var maxScroll = subtract({\\n    x: scrollWidth,\\n    y: scrollHeight\\n  }, {\\n    x: width,\\n    y: height\\n  });\\n  var adjustedMaxScroll = {\\n    x: Math.max(0, maxScroll.x),\\n    y: Math.max(0, maxScroll.y)\\n  };\\n  return adjustedMaxScroll;\\n});\\n\\nvar getDocumentElement = (function () {\\n  var doc = document.documentElement;\\n  !doc ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot find document.documentElement') : invariant(false) : void 0;\\n  return doc;\\n});\\n\\nvar getMaxWindowScroll = (function () {\\n  var doc = getDocumentElement();\\n  var maxScroll = getMaxScroll({\\n    scrollHeight: doc.scrollHeight,\\n    scrollWidth: doc.scrollWidth,\\n    width: doc.clientWidth,\\n    height: doc.clientHeight\\n  });\\n  return maxScroll;\\n});\\n\\nvar getViewport = (function () {\\n  var scroll = getWindowScroll();\\n  var maxScroll = getMaxWindowScroll();\\n  var top = scroll.y;\\n  var left = scroll.x;\\n  var doc = getDocumentElement();\\n  var width = doc.clientWidth;\\n  var height = doc.clientHeight;\\n  var right = left + width;\\n  var bottom = top + height;\\n  var frame = cssBoxModel.getRect({\\n    top: top,\\n    left: left,\\n    right: right,\\n    bottom: bottom\\n  });\\n  var viewport = {\\n    frame: frame,\\n    scroll: {\\n      initial: scroll,\\n      current: scroll,\\n      max: maxScroll,\\n      diff: {\\n        value: origin,\\n        displacement: origin\\n      }\\n    }\\n  };\\n  return viewport;\\n});\\n\\nvar getInitialPublish = (function (_ref) {\\n  var critical = _ref.critical,\\n      scrollOptions = _ref.scrollOptions,\\n      registry = _ref.registry;\\n  var timingKey = 'Initial collection from DOM';\\n  start(timingKey);\\n  var viewport = getViewport();\\n  var windowScroll = viewport.scroll.current;\\n  var home = critical.droppable;\\n  var droppables = registry.droppable.getAllByType(home.type).map(function (entry) {\\n    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);\\n  });\\n  var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function (entry) {\\n    return entry.getDimension(windowScroll);\\n  });\\n  var dimensions = {\\n    draggables: toDraggableMap(draggables),\\n    droppables: toDroppableMap(droppables)\\n  };\\n  finish(timingKey);\\n  var result = {\\n    dimensions: dimensions,\\n    critical: critical,\\n    viewport: viewport\\n  };\\n  return result;\\n});\\n\\nfunction shouldPublishUpdate(registry, dragging, entry) {\\n  if (entry.descriptor.id === dragging.id) {\\n    return false;\\n  }\\n\\n  if (entry.descriptor.type !== dragging.type) {\\n    return false;\\n  }\\n\\n  var home = registry.droppable.getById(entry.descriptor.droppableId);\\n\\n  if (home.descriptor.mode !== 'virtual') {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      You are attempting to add or remove a Draggable [id: \\\" + entry.descriptor.id + \\\"]\\\\n      while a drag is occurring. This is only supported for virtual lists.\\\\n\\\\n      See https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/patterns/virtual-lists.md\\\\n    \\\") : void 0;\\n    return false;\\n  }\\n\\n  return true;\\n}\\n\\nvar createDimensionMarshal = (function (registry, callbacks) {\\n  var collection = null;\\n  var publisher = createPublisher({\\n    callbacks: {\\n      publish: callbacks.publishWhileDragging,\\n      collectionStarting: callbacks.collectionStarting\\n    },\\n    registry: registry\\n  });\\n\\n  var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {\\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot update is enabled flag of Droppable \\\" + id + \\\" as it is not registered\\\") : invariant(false) : void 0;\\n\\n    if (!collection) {\\n      return;\\n    }\\n\\n    callbacks.updateDroppableIsEnabled({\\n      id: id,\\n      isEnabled: isEnabled\\n    });\\n  };\\n\\n  var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(id, isCombineEnabled) {\\n    if (!collection) {\\n      return;\\n    }\\n\\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot update isCombineEnabled flag of Droppable \\\" + id + \\\" as it is not registered\\\") : invariant(false) : void 0;\\n    callbacks.updateDroppableIsCombineEnabled({\\n      id: id,\\n      isCombineEnabled: isCombineEnabled\\n    });\\n  };\\n\\n  var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {\\n    if (!collection) {\\n      return;\\n    }\\n\\n    !registry.droppable.exists(id) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot update the scroll on Droppable \\\" + id + \\\" as it is not registered\\\") : invariant(false) : void 0;\\n    callbacks.updateDroppableScroll({\\n      id: id,\\n      newScroll: newScroll\\n    });\\n  };\\n\\n  var scrollDroppable = function scrollDroppable(id, change) {\\n    if (!collection) {\\n      return;\\n    }\\n\\n    registry.droppable.getById(id).callbacks.scroll(change);\\n  };\\n\\n  var stopPublishing = function stopPublishing() {\\n    if (!collection) {\\n      return;\\n    }\\n\\n    publisher.stop();\\n    var home = collection.critical.droppable;\\n    registry.droppable.getAllByType(home.type).forEach(function (entry) {\\n      return entry.callbacks.dragStopped();\\n    });\\n    collection.unsubscribe();\\n    collection = null;\\n  };\\n\\n  var subscriber = function subscriber(event) {\\n    !collection ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Should only be subscribed when a collection is occurring') : invariant(false) : void 0;\\n    var dragging = collection.critical.draggable;\\n\\n    if (event.type === 'ADDITION') {\\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\\n        publisher.add(event.value);\\n      }\\n    }\\n\\n    if (event.type === 'REMOVAL') {\\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\\n        publisher.remove(event.value);\\n      }\\n    }\\n  };\\n\\n  var startPublishing = function startPublishing(request) {\\n    !!collection ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot start capturing critical dimensions as there is already a collection') : invariant(false) : void 0;\\n    var entry = registry.draggable.getById(request.draggableId);\\n    var home = registry.droppable.getById(entry.descriptor.droppableId);\\n    var critical = {\\n      draggable: entry.descriptor,\\n      droppable: home.descriptor\\n    };\\n    var unsubscribe = registry.subscribe(subscriber);\\n    collection = {\\n      critical: critical,\\n      unsubscribe: unsubscribe\\n    };\\n    return getInitialPublish({\\n      critical: critical,\\n      registry: registry,\\n      scrollOptions: request.scrollOptions\\n    });\\n  };\\n\\n  var marshal = {\\n    updateDroppableIsEnabled: updateDroppableIsEnabled,\\n    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\\n    scrollDroppable: scrollDroppable,\\n    updateDroppableScroll: updateDroppableScroll,\\n    startPublishing: startPublishing,\\n    stopPublishing: stopPublishing\\n  };\\n  return marshal;\\n});\\n\\nvar canStartDrag = (function (state, id) {\\n  if (state.phase === 'IDLE') {\\n    return true;\\n  }\\n\\n  if (state.phase !== 'DROP_ANIMATING') {\\n    return false;\\n  }\\n\\n  if (state.completed.result.draggableId === id) {\\n    return false;\\n  }\\n\\n  return state.completed.result.reason === 'DROP';\\n});\\n\\nvar scrollWindow = (function (change) {\\n  window.scrollBy(change.x, change.y);\\n});\\n\\nvar getScrollableDroppables = memoizeOne(function (droppables) {\\n  return toDroppableList(droppables).filter(function (droppable) {\\n    if (!droppable.isEnabled) {\\n      return false;\\n    }\\n\\n    if (!droppable.frame) {\\n      return false;\\n    }\\n\\n    return true;\\n  });\\n});\\n\\nvar getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {\\n  var maybe = find(getScrollableDroppables(droppables), function (droppable) {\\n    !droppable.frame ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Invalid result') : invariant(false) : void 0;\\n    return isPositionInFrame(droppable.frame.pageMarginBox)(target);\\n  });\\n  return maybe;\\n};\\n\\nvar getBestScrollableDroppable = (function (_ref) {\\n  var center = _ref.center,\\n      destination = _ref.destination,\\n      droppables = _ref.droppables;\\n\\n  if (destination) {\\n    var _dimension = droppables[destination];\\n\\n    if (!_dimension.frame) {\\n      return null;\\n    }\\n\\n    return _dimension;\\n  }\\n\\n  var dimension = getScrollableDroppableOver(center, droppables);\\n  return dimension;\\n});\\n\\nvar config = {\\n  startFromPercentage: 0.25,\\n  maxScrollAtPercentage: 0.05,\\n  maxPixelScroll: 28,\\n  ease: function ease(percentage) {\\n    return Math.pow(percentage, 2);\\n  },\\n  durationDampening: {\\n    stopDampeningAt: 1200,\\n    accelerateAt: 360\\n  }\\n};\\n\\nvar getDistanceThresholds = (function (container, axis) {\\n  var startScrollingFrom = container[axis.size] * config.startFromPercentage;\\n  var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;\\n  var thresholds = {\\n    startScrollingFrom: startScrollingFrom,\\n    maxScrollValueAt: maxScrollValueAt\\n  };\\n  return thresholds;\\n});\\n\\nvar getPercentage = (function (_ref) {\\n  var startOfRange = _ref.startOfRange,\\n      endOfRange = _ref.endOfRange,\\n      current = _ref.current;\\n  var range = endOfRange - startOfRange;\\n\\n  if (range === 0) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      Detected distance range of 0 in the fluid auto scroller\\\\n      This is unexpected and would cause a divide by 0 issue.\\\\n      Not allowing an auto scroll\\\\n    \\\") : void 0;\\n    return 0;\\n  }\\n\\n  var currentInRange = current - startOfRange;\\n  var percentage = currentInRange / range;\\n  return percentage;\\n});\\n\\nvar minScroll = 1;\\n\\nvar getValueFromDistance = (function (distanceToEdge, thresholds) {\\n  if (distanceToEdge > thresholds.startScrollingFrom) {\\n    return 0;\\n  }\\n\\n  if (distanceToEdge <= thresholds.maxScrollValueAt) {\\n    return config.maxPixelScroll;\\n  }\\n\\n  if (distanceToEdge === thresholds.startScrollingFrom) {\\n    return minScroll;\\n  }\\n\\n  var percentageFromMaxScrollValueAt = getPercentage({\\n    startOfRange: thresholds.maxScrollValueAt,\\n    endOfRange: thresholds.startScrollingFrom,\\n    current: distanceToEdge\\n  });\\n  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\\n  var scroll = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);\\n  return Math.ceil(scroll);\\n});\\n\\nvar accelerateAt = config.durationDampening.accelerateAt;\\nvar stopAt = config.durationDampening.stopDampeningAt;\\nvar dampenValueByTime = (function (proposedScroll, dragStartTime) {\\n  var startOfRange = dragStartTime;\\n  var endOfRange = stopAt;\\n\\n  var now = _Date$now();\\n\\n  var runTime = now - startOfRange;\\n\\n  if (runTime >= stopAt) {\\n    return proposedScroll;\\n  }\\n\\n  if (runTime < accelerateAt) {\\n    return minScroll;\\n  }\\n\\n  var betweenAccelerateAtAndStopAtPercentage = getPercentage({\\n    startOfRange: accelerateAt,\\n    endOfRange: endOfRange,\\n    current: runTime\\n  });\\n  var scroll = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);\\n  return Math.ceil(scroll);\\n});\\n\\nvar getValue = (function (_ref) {\\n  var distanceToEdge = _ref.distanceToEdge,\\n      thresholds = _ref.thresholds,\\n      dragStartTime = _ref.dragStartTime,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\\n  var scroll = getValueFromDistance(distanceToEdge, thresholds);\\n\\n  if (scroll === 0) {\\n    return 0;\\n  }\\n\\n  if (!shouldUseTimeDampening) {\\n    return scroll;\\n  }\\n\\n  return Math.max(dampenValueByTime(scroll, dragStartTime), minScroll);\\n});\\n\\nvar getScrollOnAxis = (function (_ref) {\\n  var container = _ref.container,\\n      distanceToEdges = _ref.distanceToEdges,\\n      dragStartTime = _ref.dragStartTime,\\n      axis = _ref.axis,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\\n  var thresholds = getDistanceThresholds(container, axis);\\n  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\\n\\n  if (isCloserToEnd) {\\n    return getValue({\\n      distanceToEdge: distanceToEdges[axis.end],\\n      thresholds: thresholds,\\n      dragStartTime: dragStartTime,\\n      shouldUseTimeDampening: shouldUseTimeDampening\\n    });\\n  }\\n\\n  return -1 * getValue({\\n    distanceToEdge: distanceToEdges[axis.start],\\n    thresholds: thresholds,\\n    dragStartTime: dragStartTime,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n});\\n\\nvar adjustForSizeLimits = (function (_ref) {\\n  var container = _ref.container,\\n      subject = _ref.subject,\\n      proposedScroll = _ref.proposedScroll;\\n  var isTooBigVertically = subject.height > container.height;\\n  var isTooBigHorizontally = subject.width > container.width;\\n\\n  if (!isTooBigHorizontally && !isTooBigVertically) {\\n    return proposedScroll;\\n  }\\n\\n  if (isTooBigHorizontally && isTooBigVertically) {\\n    return null;\\n  }\\n\\n  return {\\n    x: isTooBigHorizontally ? 0 : proposedScroll.x,\\n    y: isTooBigVertically ? 0 : proposedScroll.y\\n  };\\n});\\n\\nvar clean$2 = apply(function (value) {\\n  return value === 0 ? 0 : value;\\n});\\nvar getScroll = (function (_ref) {\\n  var dragStartTime = _ref.dragStartTime,\\n      container = _ref.container,\\n      subject = _ref.subject,\\n      center = _ref.center,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\\n  var distanceToEdges = {\\n    top: center.y - container.top,\\n    right: container.right - center.x,\\n    bottom: container.bottom - center.y,\\n    left: center.x - container.left\\n  };\\n  var y = getScrollOnAxis({\\n    container: container,\\n    distanceToEdges: distanceToEdges,\\n    dragStartTime: dragStartTime,\\n    axis: vertical,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n  var x = getScrollOnAxis({\\n    container: container,\\n    distanceToEdges: distanceToEdges,\\n    dragStartTime: dragStartTime,\\n    axis: horizontal,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n  var required = clean$2({\\n    x: x,\\n    y: y\\n  });\\n\\n  if (isEqual(required, origin)) {\\n    return null;\\n  }\\n\\n  var limited = adjustForSizeLimits({\\n    container: container,\\n    subject: subject,\\n    proposedScroll: required\\n  });\\n\\n  if (!limited) {\\n    return null;\\n  }\\n\\n  return isEqual(limited, origin) ? null : limited;\\n});\\n\\nvar smallestSigned = apply(function (value) {\\n  if (value === 0) {\\n    return 0;\\n  }\\n\\n  return value > 0 ? 1 : -1;\\n});\\nvar getOverlap = function () {\\n  var getRemainder = function getRemainder(target, max) {\\n    if (target < 0) {\\n      return target;\\n    }\\n\\n    if (target > max) {\\n      return target - max;\\n    }\\n\\n    return 0;\\n  };\\n\\n  return function (_ref) {\\n    var current = _ref.current,\\n        max = _ref.max,\\n        change = _ref.change;\\n    var targetScroll = add(current, change);\\n    var overlap = {\\n      x: getRemainder(targetScroll.x, max.x),\\n      y: getRemainder(targetScroll.y, max.y)\\n    };\\n\\n    if (isEqual(overlap, origin)) {\\n      return null;\\n    }\\n\\n    return overlap;\\n  };\\n}();\\nvar canPartiallyScroll = function canPartiallyScroll(_ref2) {\\n  var rawMax = _ref2.max,\\n      current = _ref2.current,\\n      change = _ref2.change;\\n  var max = {\\n    x: Math.max(current.x, rawMax.x),\\n    y: Math.max(current.y, rawMax.y)\\n  };\\n  var smallestChange = smallestSigned(change);\\n  var overlap = getOverlap({\\n    max: max,\\n    current: current,\\n    change: smallestChange\\n  });\\n\\n  if (!overlap) {\\n    return true;\\n  }\\n\\n  if (smallestChange.x !== 0 && overlap.x === 0) {\\n    return true;\\n  }\\n\\n  if (smallestChange.y !== 0 && overlap.y === 0) {\\n    return true;\\n  }\\n\\n  return false;\\n};\\nvar canScrollWindow = function canScrollWindow(viewport, change) {\\n  return canPartiallyScroll({\\n    current: viewport.scroll.current,\\n    max: viewport.scroll.max,\\n    change: change\\n  });\\n};\\nvar getWindowOverlap = function getWindowOverlap(viewport, change) {\\n  if (!canScrollWindow(viewport, change)) {\\n    return null;\\n  }\\n\\n  var max = viewport.scroll.max;\\n  var current = viewport.scroll.current;\\n  return getOverlap({\\n    current: current,\\n    max: max,\\n    change: change\\n  });\\n};\\nvar canScrollDroppable = function canScrollDroppable(droppable, change) {\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    return false;\\n  }\\n\\n  return canPartiallyScroll({\\n    current: frame.scroll.current,\\n    max: frame.scroll.max,\\n    change: change\\n  });\\n};\\nvar getDroppableOverlap = function getDroppableOverlap(droppable, change) {\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    return null;\\n  }\\n\\n  if (!canScrollDroppable(droppable, change)) {\\n    return null;\\n  }\\n\\n  return getOverlap({\\n    current: frame.scroll.current,\\n    max: frame.scroll.max,\\n    change: change\\n  });\\n};\\n\\nvar getWindowScrollChange = (function (_ref) {\\n  var viewport = _ref.viewport,\\n      subject = _ref.subject,\\n      center = _ref.center,\\n      dragStartTime = _ref.dragStartTime,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\\n  var scroll = getScroll({\\n    dragStartTime: dragStartTime,\\n    container: viewport.frame,\\n    subject: subject,\\n    center: center,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n  return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\\n});\\n\\nvar getDroppableScrollChange = (function (_ref) {\\n  var droppable = _ref.droppable,\\n      subject = _ref.subject,\\n      center = _ref.center,\\n      dragStartTime = _ref.dragStartTime,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\\n  var frame = droppable.frame;\\n\\n  if (!frame) {\\n    return null;\\n  }\\n\\n  var scroll = getScroll({\\n    dragStartTime: dragStartTime,\\n    container: frame.pageMarginBox,\\n    subject: subject,\\n    center: center,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n  return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\\n});\\n\\nvar scroll$1 = (function (_ref) {\\n  var state = _ref.state,\\n      dragStartTime = _ref.dragStartTime,\\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening,\\n      scrollWindow = _ref.scrollWindow,\\n      scrollDroppable = _ref.scrollDroppable;\\n  var center = state.current.page.borderBoxCenter;\\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\\n  var subject = draggable.page.marginBox;\\n\\n  if (state.isWindowScrollAllowed) {\\n    var viewport = state.viewport;\\n\\n    var _change = getWindowScrollChange({\\n      dragStartTime: dragStartTime,\\n      viewport: viewport,\\n      subject: subject,\\n      center: center,\\n      shouldUseTimeDampening: shouldUseTimeDampening\\n    });\\n\\n    if (_change) {\\n      scrollWindow(_change);\\n      return;\\n    }\\n  }\\n\\n  var droppable = getBestScrollableDroppable({\\n    center: center,\\n    destination: whatIsDraggedOver(state.impact),\\n    droppables: state.dimensions.droppables\\n  });\\n\\n  if (!droppable) {\\n    return;\\n  }\\n\\n  var change = getDroppableScrollChange({\\n    dragStartTime: dragStartTime,\\n    droppable: droppable,\\n    subject: subject,\\n    center: center,\\n    shouldUseTimeDampening: shouldUseTimeDampening\\n  });\\n\\n  if (change) {\\n    scrollDroppable(droppable.descriptor.id, change);\\n  }\\n});\\n\\nvar createFluidScroller = (function (_ref) {\\n  var scrollWindow = _ref.scrollWindow,\\n      scrollDroppable = _ref.scrollDroppable;\\n  var scheduleWindowScroll = rafSchd(scrollWindow);\\n  var scheduleDroppableScroll = rafSchd(scrollDroppable);\\n  var dragging = null;\\n\\n  var tryScroll = function tryScroll(state) {\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot fluid scroll if not dragging') : invariant(false) : void 0;\\n    var _dragging = dragging,\\n        shouldUseTimeDampening = _dragging.shouldUseTimeDampening,\\n        dragStartTime = _dragging.dragStartTime;\\n    scroll$1({\\n      state: state,\\n      scrollWindow: scheduleWindowScroll,\\n      scrollDroppable: scheduleDroppableScroll,\\n      dragStartTime: dragStartTime,\\n      shouldUseTimeDampening: shouldUseTimeDampening\\n    });\\n  };\\n\\n  var start$1 = function start$1(state) {\\n    start('starting fluid scroller');\\n    !!dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot start auto scrolling when already started') : invariant(false) : void 0;\\n\\n    var dragStartTime = _Date$now();\\n\\n    var wasScrollNeeded = false;\\n\\n    var fakeScrollCallback = function fakeScrollCallback() {\\n      wasScrollNeeded = true;\\n    };\\n\\n    scroll$1({\\n      state: state,\\n      dragStartTime: 0,\\n      shouldUseTimeDampening: false,\\n      scrollWindow: fakeScrollCallback,\\n      scrollDroppable: fakeScrollCallback\\n    });\\n    dragging = {\\n      dragStartTime: dragStartTime,\\n      shouldUseTimeDampening: wasScrollNeeded\\n    };\\n    finish('starting fluid scroller');\\n\\n    if (wasScrollNeeded) {\\n      tryScroll(state);\\n    }\\n  };\\n\\n  var stop = function stop() {\\n    if (!dragging) {\\n      return;\\n    }\\n\\n    scheduleWindowScroll.cancel();\\n    scheduleDroppableScroll.cancel();\\n    dragging = null;\\n  };\\n\\n  return {\\n    start: start$1,\\n    stop: stop,\\n    scroll: tryScroll\\n  };\\n});\\n\\nvar createJumpScroller = (function (_ref) {\\n  var move = _ref.move,\\n      scrollDroppable = _ref.scrollDroppable,\\n      scrollWindow = _ref.scrollWindow;\\n\\n  var moveByOffset = function moveByOffset(state, offset) {\\n    var client = add(state.current.client.selection, offset);\\n    move({\\n      client: client\\n    });\\n  };\\n\\n  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {\\n    if (!canScrollDroppable(droppable, change)) {\\n      return change;\\n    }\\n\\n    var overlap = getDroppableOverlap(droppable, change);\\n\\n    if (!overlap) {\\n      scrollDroppable(droppable.descriptor.id, change);\\n      return null;\\n    }\\n\\n    var whatTheDroppableCanScroll = subtract(change, overlap);\\n    scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\\n    var remainder = subtract(change, whatTheDroppableCanScroll);\\n    return remainder;\\n  };\\n\\n  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(isWindowScrollAllowed, viewport, change) {\\n    if (!isWindowScrollAllowed) {\\n      return change;\\n    }\\n\\n    if (!canScrollWindow(viewport, change)) {\\n      return change;\\n    }\\n\\n    var overlap = getWindowOverlap(viewport, change);\\n\\n    if (!overlap) {\\n      scrollWindow(change);\\n      return null;\\n    }\\n\\n    var whatTheWindowCanScroll = subtract(change, overlap);\\n    scrollWindow(whatTheWindowCanScroll);\\n    var remainder = subtract(change, whatTheWindowCanScroll);\\n    return remainder;\\n  };\\n\\n  var jumpScroller = function jumpScroller(state) {\\n    var request = state.scrollJumpRequest;\\n\\n    if (!request) {\\n      return;\\n    }\\n\\n    var destination = whatIsDraggedOver(state.impact);\\n    !destination ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : invariant(false) : void 0;\\n    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\\n\\n    if (!droppableRemainder) {\\n      return;\\n    }\\n\\n    var viewport = state.viewport;\\n    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\\n\\n    if (!windowRemainder) {\\n      return;\\n    }\\n\\n    moveByOffset(state, windowRemainder);\\n  };\\n\\n  return jumpScroller;\\n});\\n\\nvar createAutoScroller = (function (_ref) {\\n  var scrollDroppable = _ref.scrollDroppable,\\n      scrollWindow = _ref.scrollWindow,\\n      move = _ref.move;\\n  var fluidScroller = createFluidScroller({\\n    scrollWindow: scrollWindow,\\n    scrollDroppable: scrollDroppable\\n  });\\n  var jumpScroll = createJumpScroller({\\n    move: move,\\n    scrollWindow: scrollWindow,\\n    scrollDroppable: scrollDroppable\\n  });\\n\\n  var scroll = function scroll(state) {\\n    if (state.phase !== 'DRAGGING') {\\n      return;\\n    }\\n\\n    if (state.movementMode === 'FLUID') {\\n      fluidScroller.scroll(state);\\n      return;\\n    }\\n\\n    if (!state.scrollJumpRequest) {\\n      return;\\n    }\\n\\n    jumpScroll(state);\\n  };\\n\\n  var scroller = {\\n    scroll: scroll,\\n    start: fluidScroller.start,\\n    stop: fluidScroller.stop\\n  };\\n  return scroller;\\n});\\n\\nvar prefix$1 = 'data-rbd';\\nvar dragHandle = function () {\\n  var base = prefix$1 + \\\"-drag-handle\\\";\\n  return {\\n    base: base,\\n    draggableId: base + \\\"-draggable-id\\\",\\n    contextId: base + \\\"-context-id\\\"\\n  };\\n}();\\nvar draggable = function () {\\n  var base = prefix$1 + \\\"-draggable\\\";\\n  return {\\n    base: base,\\n    contextId: base + \\\"-context-id\\\",\\n    id: base + \\\"-id\\\"\\n  };\\n}();\\nvar droppable = function () {\\n  var base = prefix$1 + \\\"-droppable\\\";\\n  return {\\n    base: base,\\n    contextId: base + \\\"-context-id\\\",\\n    id: base + \\\"-id\\\"\\n  };\\n}();\\nvar scrollContainer = {\\n  contextId: prefix$1 + \\\"-scroll-container-context-id\\\"\\n};\\n\\nvar makeGetSelector = function makeGetSelector(context) {\\n  return function (attribute) {\\n    return \\\"[\\\" + attribute + \\\"=\\\\\\\"\\\" + context + \\\"\\\\\\\"]\\\";\\n  };\\n};\\n\\nvar getStyles = function getStyles(rules, property) {\\n  return rules.map(function (rule) {\\n    var value = rule.styles[property];\\n\\n    if (!value) {\\n      return '';\\n    }\\n\\n    return rule.selector + \\\" { \\\" + value + \\\" }\\\";\\n  }).join(' ');\\n};\\n\\nvar noPointerEvents = 'pointer-events: none;';\\nvar getStyles$1 = (function (contextId) {\\n  var getSelector = makeGetSelector(contextId);\\n\\n  var dragHandle$1 = function () {\\n    var grabCursor = \\\"\\\\n      cursor: -webkit-grab;\\\\n      cursor: grab;\\\\n    \\\";\\n    return {\\n      selector: getSelector(dragHandle.contextId),\\n      styles: {\\n        always: \\\"\\\\n          -webkit-touch-callout: none;\\\\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\\\\n          touch-action: manipulation;\\\\n        \\\",\\n        resting: grabCursor,\\n        dragging: noPointerEvents,\\n        dropAnimating: grabCursor\\n      }\\n    };\\n  }();\\n\\n  var draggable$1 = function () {\\n    var transition = \\\"\\\\n      transition: \\\" + transitions.outOfTheWay + \\\";\\\\n    \\\";\\n    return {\\n      selector: getSelector(draggable.contextId),\\n      styles: {\\n        dragging: transition,\\n        dropAnimating: transition,\\n        userCancel: transition\\n      }\\n    };\\n  }();\\n\\n  var droppable$1 = {\\n    selector: getSelector(droppable.contextId),\\n    styles: {\\n      always: \\\"overflow-anchor: none;\\\"\\n    }\\n  };\\n  var body = {\\n    selector: 'body',\\n    styles: {\\n      dragging: \\\"\\\\n        cursor: grabbing;\\\\n        cursor: -webkit-grabbing;\\\\n        user-select: none;\\\\n        -webkit-user-select: none;\\\\n        -moz-user-select: none;\\\\n        -ms-user-select: none;\\\\n        overflow-anchor: none;\\\\n      \\\"\\n    }\\n  };\\n  var rules = [draggable$1, dragHandle$1, droppable$1, body];\\n  return {\\n    always: getStyles(rules, 'always'),\\n    resting: getStyles(rules, 'resting'),\\n    dragging: getStyles(rules, 'dragging'),\\n    dropAnimating: getStyles(rules, 'dropAnimating'),\\n    userCancel: getStyles(rules, 'userCancel')\\n  };\\n});\\n\\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\\n\\nvar getHead = function getHead() {\\n  var head = document.querySelector('head');\\n  !head ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot find the head to append a style to') : invariant(false) : void 0;\\n  return head;\\n};\\n\\nvar createStyleEl = function createStyleEl(nonce) {\\n  var el = document.createElement('style');\\n\\n  if (nonce) {\\n    el.setAttribute('nonce', nonce);\\n  }\\n\\n  el.type = 'text/css';\\n  return el;\\n};\\n\\nfunction useStyleMarshal(contextId, nonce) {\\n  var styles = useMemoOne.useMemo(function () {\\n    return getStyles$1(contextId);\\n  }, [contextId]);\\n  var alwaysRef = React.useRef(null);\\n  var dynamicRef = React.useRef(null);\\n  var setDynamicStyle = useMemoOne.useCallback(memoizeOne(function (proposed) {\\n    var el = dynamicRef.current;\\n    !el ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;\\n    el.textContent = proposed;\\n  }), []);\\n  var setAlwaysStyle = useMemoOne.useCallback(function (proposed) {\\n    var el = alwaysRef.current;\\n    !el ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;\\n    el.textContent = proposed;\\n  }, []);\\n  useIsomorphicLayoutEffect(function () {\\n    !(!alwaysRef.current && !dynamicRef.current) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'style elements already mounted') : invariant(false) : void 0;\\n    var always = createStyleEl(nonce);\\n    var dynamic = createStyleEl(nonce);\\n    alwaysRef.current = always;\\n    dynamicRef.current = dynamic;\\n    always.setAttribute(prefix$1 + \\\"-always\\\", contextId);\\n    dynamic.setAttribute(prefix$1 + \\\"-dynamic\\\", contextId);\\n    getHead().appendChild(always);\\n    getHead().appendChild(dynamic);\\n    setAlwaysStyle(styles.always);\\n    setDynamicStyle(styles.resting);\\n    return function () {\\n      var remove = function remove(ref) {\\n        var current = ref.current;\\n        !current ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot unmount ref as it is not set') : invariant(false) : void 0;\\n        getHead().removeChild(current);\\n        ref.current = null;\\n      };\\n\\n      remove(alwaysRef);\\n      remove(dynamicRef);\\n    };\\n  }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);\\n  var dragging = useMemoOne.useCallback(function () {\\n    return setDynamicStyle(styles.dragging);\\n  }, [setDynamicStyle, styles.dragging]);\\n  var dropping = useMemoOne.useCallback(function (reason) {\\n    if (reason === 'DROP') {\\n      setDynamicStyle(styles.dropAnimating);\\n      return;\\n    }\\n\\n    setDynamicStyle(styles.userCancel);\\n  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);\\n  var resting = useMemoOne.useCallback(function () {\\n    if (!dynamicRef.current) {\\n      return;\\n    }\\n\\n    setDynamicStyle(styles.resting);\\n  }, [setDynamicStyle, styles.resting]);\\n  var marshal = useMemoOne.useMemo(function () {\\n    return {\\n      dragging: dragging,\\n      dropping: dropping,\\n      resting: resting\\n    };\\n  }, [dragging, dropping, resting]);\\n  return marshal;\\n}\\n\\nvar getWindowFromEl = (function (el) {\\n  return el && el.ownerDocument ? el.ownerDocument.defaultView : window;\\n});\\n\\nfunction isHtmlElement(el) {\\n  return el instanceof getWindowFromEl(el).HTMLElement;\\n}\\n\\nfunction findDragHandle(contextId, draggableId) {\\n  var selector = \\\"[\\\" + dragHandle.contextId + \\\"=\\\\\\\"\\\" + contextId + \\\"\\\\\\\"]\\\";\\n  var possible = toArray(document.querySelectorAll(selector));\\n\\n  if (!possible.length) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"Unable to find any drag handles in the context \\\\\\\"\\\" + contextId + \\\"\\\\\\\"\\\") : void 0;\\n    return null;\\n  }\\n\\n  var handle = find(possible, function (el) {\\n    return el.getAttribute(dragHandle.draggableId) === draggableId;\\n  });\\n\\n  if (!handle) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"Unable to find drag handle with id \\\\\\\"\\\" + draggableId + \\\"\\\\\\\" as no handle with a matching id was found\\\") : void 0;\\n    return null;\\n  }\\n\\n  if (!isHtmlElement(handle)) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning('drag handle needs to be a HTMLElement') : void 0;\\n    return null;\\n  }\\n\\n  return handle;\\n}\\n\\nfunction useFocusMarshal(contextId) {\\n  var entriesRef = React.useRef({});\\n  var recordRef = React.useRef(null);\\n  var restoreFocusFrameRef = React.useRef(null);\\n  var isMountedRef = React.useRef(false);\\n  var register = useMemoOne.useCallback(function register(id, focus) {\\n    var entry = {\\n      id: id,\\n      focus: focus\\n    };\\n    entriesRef.current[id] = entry;\\n    return function unregister() {\\n      var entries = entriesRef.current;\\n      var current = entries[id];\\n\\n      if (current !== entry) {\\n        delete entries[id];\\n      }\\n    };\\n  }, []);\\n  var tryGiveFocus = useMemoOne.useCallback(function tryGiveFocus(tryGiveFocusTo) {\\n    var handle = findDragHandle(contextId, tryGiveFocusTo);\\n\\n    if (handle && handle !== document.activeElement) {\\n      handle.focus();\\n    }\\n  }, [contextId]);\\n  var tryShiftRecord = useMemoOne.useCallback(function tryShiftRecord(previous, redirectTo) {\\n    if (recordRef.current === previous) {\\n      recordRef.current = redirectTo;\\n    }\\n  }, []);\\n  var tryRestoreFocusRecorded = useMemoOne.useCallback(function tryRestoreFocusRecorded() {\\n    if (restoreFocusFrameRef.current) {\\n      return;\\n    }\\n\\n    if (!isMountedRef.current) {\\n      return;\\n    }\\n\\n    restoreFocusFrameRef.current = requestAnimationFrame(function () {\\n      restoreFocusFrameRef.current = null;\\n      var record = recordRef.current;\\n\\n      if (record) {\\n        tryGiveFocus(record);\\n      }\\n    });\\n  }, [tryGiveFocus]);\\n  var tryRecordFocus = useMemoOne.useCallback(function tryRecordFocus(id) {\\n    recordRef.current = null;\\n    var focused = document.activeElement;\\n\\n    if (!focused) {\\n      return;\\n    }\\n\\n    if (focused.getAttribute(dragHandle.draggableId) !== id) {\\n      return;\\n    }\\n\\n    recordRef.current = id;\\n  }, []);\\n  useIsomorphicLayoutEffect(function () {\\n    isMountedRef.current = true;\\n    return function clearFrameOnUnmount() {\\n      isMountedRef.current = false;\\n      var frameId = restoreFocusFrameRef.current;\\n\\n      if (frameId) {\\n        cancelAnimationFrame(frameId);\\n      }\\n    };\\n  }, []);\\n  var marshal = useMemoOne.useMemo(function () {\\n    return {\\n      register: register,\\n      tryRecordFocus: tryRecordFocus,\\n      tryRestoreFocusRecorded: tryRestoreFocusRecorded,\\n      tryShiftRecord: tryShiftRecord\\n    };\\n  }, [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);\\n  return marshal;\\n}\\n\\nfunction createRegistry() {\\n  var entries = {\\n    draggables: {},\\n    droppables: {}\\n  };\\n  var subscribers = [];\\n\\n  function subscribe(cb) {\\n    subscribers.push(cb);\\n    return function unsubscribe() {\\n      var index = subscribers.indexOf(cb);\\n\\n      if (index === -1) {\\n        return;\\n      }\\n\\n      subscribers.splice(index, 1);\\n    };\\n  }\\n\\n  function notify(event) {\\n    if (subscribers.length) {\\n      subscribers.forEach(function (cb) {\\n        return cb(event);\\n      });\\n    }\\n  }\\n\\n  function findDraggableById(id) {\\n    return entries.draggables[id] || null;\\n  }\\n\\n  function getDraggableById(id) {\\n    var entry = findDraggableById(id);\\n    !entry ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot find draggable entry with id [\\\" + id + \\\"]\\\") : invariant(false) : void 0;\\n    return entry;\\n  }\\n\\n  var draggableAPI = {\\n    register: function register(entry) {\\n      entries.draggables[entry.descriptor.id] = entry;\\n      notify({\\n        type: 'ADDITION',\\n        value: entry\\n      });\\n    },\\n    update: function update(entry, last) {\\n      var current = entries.draggables[last.descriptor.id];\\n\\n      if (!current) {\\n        return;\\n      }\\n\\n      if (current.uniqueId !== entry.uniqueId) {\\n        return;\\n      }\\n\\n      delete entries.draggables[last.descriptor.id];\\n      entries.draggables[entry.descriptor.id] = entry;\\n    },\\n    unregister: function unregister(entry) {\\n      var draggableId = entry.descriptor.id;\\n      var current = findDraggableById(draggableId);\\n\\n      if (!current) {\\n        return;\\n      }\\n\\n      if (entry.uniqueId !== current.uniqueId) {\\n        return;\\n      }\\n\\n      delete entries.draggables[draggableId];\\n      notify({\\n        type: 'REMOVAL',\\n        value: entry\\n      });\\n    },\\n    getById: getDraggableById,\\n    findById: findDraggableById,\\n    exists: function exists(id) {\\n      return Boolean(findDraggableById(id));\\n    },\\n    getAllByType: function getAllByType(type) {\\n      return values(entries.draggables).filter(function (entry) {\\n        return entry.descriptor.type === type;\\n      });\\n    }\\n  };\\n\\n  function findDroppableById(id) {\\n    return entries.droppables[id] || null;\\n  }\\n\\n  function getDroppableById(id) {\\n    var entry = findDroppableById(id);\\n    !entry ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot find droppable entry with id [\\\" + id + \\\"]\\\") : invariant(false) : void 0;\\n    return entry;\\n  }\\n\\n  var droppableAPI = {\\n    register: function register(entry) {\\n      entries.droppables[entry.descriptor.id] = entry;\\n    },\\n    unregister: function unregister(entry) {\\n      var current = findDroppableById(entry.descriptor.id);\\n\\n      if (!current) {\\n        return;\\n      }\\n\\n      if (entry.uniqueId !== current.uniqueId) {\\n        return;\\n      }\\n\\n      delete entries.droppables[entry.descriptor.id];\\n    },\\n    getById: getDroppableById,\\n    findById: findDroppableById,\\n    exists: function exists(id) {\\n      return Boolean(findDroppableById(id));\\n    },\\n    getAllByType: function getAllByType(type) {\\n      return values(entries.droppables).filter(function (entry) {\\n        return entry.descriptor.type === type;\\n      });\\n    }\\n  };\\n\\n  function clean() {\\n    entries.draggables = {};\\n    entries.droppables = {};\\n    subscribers.length = 0;\\n  }\\n\\n  return {\\n    draggable: draggableAPI,\\n    droppable: droppableAPI,\\n    subscribe: subscribe,\\n    clean: clean\\n  };\\n}\\n\\nfunction useRegistry() {\\n  var registry = useMemoOne.useMemo(createRegistry, []);\\n  React.useEffect(function () {\\n    return function unmount() {\\n      requestAnimationFrame(registry.clean);\\n    };\\n  }, [registry]);\\n  return registry;\\n}\\n\\nvar StoreContext = React__default.createContext(null);\\n\\nvar getBodyElement = (function () {\\n  var body = document.body;\\n  !body ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot find document.body') : invariant(false) : void 0;\\n  return body;\\n});\\n\\nvar visuallyHidden = {\\n  position: 'absolute',\\n  width: '1px',\\n  height: '1px',\\n  margin: '-1px',\\n  border: '0',\\n  padding: '0',\\n  overflow: 'hidden',\\n  clip: 'rect(0 0 0 0)',\\n  'clip-path': 'inset(100%)'\\n};\\n\\nvar getId = function getId(contextId) {\\n  return \\\"rbd-announcement-\\\" + contextId;\\n};\\nfunction useAnnouncer(contextId) {\\n  var id = useMemoOne.useMemo(function () {\\n    return getId(contextId);\\n  }, [contextId]);\\n  var ref = React.useRef(null);\\n  React.useEffect(function () {\\n    !!ref.current ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Announcement node already mounted') : invariant(false) : void 0;\\n    var el = document.createElement('div');\\n    ref.current = el;\\n    el.id = id;\\n    el.setAttribute('aria-live', 'assertive');\\n    el.setAttribute('role', 'log');\\n    el.setAttribute('aria-atomic', 'true');\\n\\n    _Object$assign(el.style, visuallyHidden);\\n\\n    getBodyElement().appendChild(el);\\n    return function () {\\n      setTimeout(function remove() {\\n        var toBeRemoved = ref.current;\\n        !toBeRemoved ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot unmount announcement node') : invariant(false) : void 0;\\n        getBodyElement().removeChild(toBeRemoved);\\n        ref.current = null;\\n      });\\n    };\\n  }, [id]);\\n  var announce = useMemoOne.useCallback(function (message) {\\n    var el = ref.current;\\n\\n    if (el) {\\n      el.textContent = message;\\n      return;\\n    }\\n\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      A screen reader message was trying to be announced but it was unable to do so.\\\\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\\\\n      Consider calling provided.announce() before the unmount so that the instruction will\\\\n      not be lost for users relying on a screen reader.\\\\n\\\\n      Message not passed to screen reader:\\\\n\\\\n      \\\\\\\"\\\" + message + \\\"\\\\\\\"\\\\n    \\\") : void 0;\\n  }, []);\\n  return announce;\\n}\\n\\nvar getId$1 = function getId(contextId) {\\n  return \\\"rbd-lift-instruction-\\\" + contextId;\\n};\\nfunction useLiftInstruction(contextId, liftInstruction) {\\n  var id = useMemoOne.useMemo(function () {\\n    return getId$1(contextId);\\n  }, [contextId]);\\n  React.useEffect(function mount() {\\n    var el = document.createElement('div');\\n    el.id = id;\\n    el.textContent = liftInstruction;\\n\\n    _Object$assign(el.style, visuallyHidden);\\n\\n    getBodyElement().appendChild(el);\\n    return function unmount() {\\n      getBodyElement().removeChild(el);\\n    };\\n  }, [id, liftInstruction]);\\n  return id;\\n}\\n\\nvar AppContext = React__default.createContext(null);\\n\\nvar peerDependencies = {\\n\\treact: \\\"^16.8.5\\\",\\n\\t\\\"react-dom\\\": \\\"^16.8.5\\\"\\n};\\n\\nvar semver = /(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)/;\\n\\nvar getVersion = function getVersion(value) {\\n  var result = semver.exec(value);\\n  !(result != null) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Unable to parse React version \\\" + value) : invariant(false) : void 0;\\n  var major = Number(result[1]);\\n  var minor = Number(result[2]);\\n  var patch = Number(result[3]);\\n  return {\\n    major: major,\\n    minor: minor,\\n    patch: patch,\\n    raw: value\\n  };\\n};\\n\\nvar isSatisfied = function isSatisfied(expected, actual) {\\n  if (actual.major > expected.major) {\\n    return true;\\n  }\\n\\n  if (actual.major < expected.major) {\\n    return false;\\n  }\\n\\n  if (actual.minor > expected.minor) {\\n    return true;\\n  }\\n\\n  if (actual.minor < expected.minor) {\\n    return false;\\n  }\\n\\n  return actual.patch >= expected.patch;\\n};\\n\\nvar checkReactVersion = (function (peerDepValue, actualValue) {\\n  var peerDep = getVersion(peerDepValue);\\n  var actual = getVersion(actualValue);\\n\\n  if (isSatisfied(peerDep, actual)) {\\n    return;\\n  }\\n\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n    React version: [\\\" + actual.raw + \\\"]\\\\n    does not satisfy expected peer dependency version: [\\\" + peerDep.raw + \\\"]\\\\n\\\\n    This can result in run time bugs, and even fatal crashes\\\\n  \\\") : void 0;\\n});\\n\\nvar suffix = \\\"\\\\n  We expect a html5 doctype: <!doctype html>\\\\n  This is to ensure consistent browser layout and measurement\\\\n\\\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\\\n\\\";\\nvar checkDoctype = (function (doc) {\\n  var doctype = doc.doctype;\\n\\n  if (!doctype) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      No <!doctype html> found.\\\\n\\\\n      \\\" + suffix + \\\"\\\\n    \\\") : void 0;\\n    return;\\n  }\\n\\n  if (doctype.name.toLowerCase() !== 'html') {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      Unexpected <!doctype> found: (\\\" + doctype.name + \\\")\\\\n\\\\n      \\\" + suffix + \\\"\\\\n    \\\") : void 0;\\n  }\\n\\n  if (doctype.publicId !== '') {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      Unexpected <!doctype> publicId found: (\\\" + doctype.publicId + \\\")\\\\n      A html5 doctype does not have a publicId\\\\n\\\\n      \\\" + suffix + \\\"\\\\n    \\\") : void 0;\\n  }\\n});\\n\\nfunction useDev(useHook) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    useHook();\\n  }\\n}\\n\\nfunction useDevSetupWarning(fn, inputs) {\\n  useDev(function () {\\n    React.useEffect(function () {\\n      try {\\n        fn();\\n      } catch (e) {\\n        error(\\\"\\\\n          A setup problem was encountered.\\\\n\\\\n          > \\\" + e.message + \\\"\\\\n        \\\");\\n      }\\n    }, inputs);\\n  });\\n}\\n\\nfunction useStartupValidation() {\\n  useDevSetupWarning(function () {\\n    checkReactVersion(peerDependencies.react, React__default.version);\\n    checkDoctype(document);\\n  }, []);\\n}\\n\\nfunction usePrevious(current) {\\n  var ref = React.useRef(current);\\n  React.useEffect(function () {\\n    ref.current = current;\\n  });\\n  return ref;\\n}\\n\\nfunction create() {\\n  var lock = null;\\n\\n  function isClaimed() {\\n    return Boolean(lock);\\n  }\\n\\n  function isActive(value) {\\n    return value === lock;\\n  }\\n\\n  function claim(abandon) {\\n    !!lock ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot claim lock as it is already claimed') : invariant(false) : void 0;\\n    var newLock = {\\n      abandon: abandon\\n    };\\n    lock = newLock;\\n    return newLock;\\n  }\\n\\n  function release() {\\n    !lock ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot release lock when there is no lock') : invariant(false) : void 0;\\n    lock = null;\\n  }\\n\\n  function tryAbandon() {\\n    if (lock) {\\n      lock.abandon();\\n      release();\\n    }\\n  }\\n\\n  return {\\n    isClaimed: isClaimed,\\n    isActive: isActive,\\n    claim: claim,\\n    release: release,\\n    tryAbandon: tryAbandon\\n  };\\n}\\n\\nvar tab = 9;\\nvar enter = 13;\\nvar escape = 27;\\nvar space = 32;\\nvar pageUp = 33;\\nvar pageDown = 34;\\nvar end = 35;\\nvar home = 36;\\nvar arrowLeft = 37;\\nvar arrowUp = 38;\\nvar arrowRight = 39;\\nvar arrowDown = 40;\\n\\nvar _preventedKeys;\\nvar preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);\\nvar preventStandardKeyEvents = (function (event) {\\n  if (preventedKeys[event.keyCode]) {\\n    event.preventDefault();\\n  }\\n});\\n\\nvar supportedEventName = function () {\\n  var base = 'visibilitychange';\\n\\n  if (typeof document === 'undefined') {\\n    return base;\\n  }\\n\\n  var candidates = [base, \\\"ms\\\" + base, \\\"webkit\\\" + base, \\\"moz\\\" + base, \\\"o\\\" + base];\\n  var supported = find(candidates, function (eventName) {\\n    return \\\"on\\\" + eventName in document;\\n  });\\n  return supported || base;\\n}();\\n\\nvar primaryButton = 0;\\nvar sloppyClickThreshold = 5;\\n\\nfunction isSloppyClickThresholdExceeded(original, current) {\\n  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\\n}\\n\\nvar idle$1 = {\\n  type: 'IDLE'\\n};\\n\\nfunction getCaptureBindings(_ref) {\\n  var cancel = _ref.cancel,\\n      completed = _ref.completed,\\n      getPhase = _ref.getPhase,\\n      setPhase = _ref.setPhase;\\n  return [{\\n    eventName: 'mousemove',\\n    fn: function fn(event) {\\n      var button = event.button,\\n          clientX = event.clientX,\\n          clientY = event.clientY;\\n\\n      if (button !== primaryButton) {\\n        return;\\n      }\\n\\n      var point = {\\n        x: clientX,\\n        y: clientY\\n      };\\n      var phase = getPhase();\\n\\n      if (phase.type === 'DRAGGING') {\\n        event.preventDefault();\\n        phase.actions.move(point);\\n        return;\\n      }\\n\\n      !(phase.type === 'PENDING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot be IDLE') : invariant(false) : void 0;\\n      var pending = phase.point;\\n\\n      if (!isSloppyClickThresholdExceeded(pending, point)) {\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      var actions = phase.actions.fluidLift(point);\\n      setPhase({\\n        type: 'DRAGGING',\\n        actions: actions\\n      });\\n    }\\n  }, {\\n    eventName: 'mouseup',\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n\\n      if (phase.type !== 'DRAGGING') {\\n        cancel();\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      phase.actions.drop({\\n        shouldBlockNextClick: true\\n      });\\n      completed();\\n    }\\n  }, {\\n    eventName: 'mousedown',\\n    fn: function fn(event) {\\n      if (getPhase().type === 'DRAGGING') {\\n        event.preventDefault();\\n      }\\n\\n      cancel();\\n    }\\n  }, {\\n    eventName: 'keydown',\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n\\n      if (phase.type === 'PENDING') {\\n        cancel();\\n        return;\\n      }\\n\\n      if (event.keyCode === escape) {\\n        event.preventDefault();\\n        cancel();\\n        return;\\n      }\\n\\n      preventStandardKeyEvents(event);\\n    }\\n  }, {\\n    eventName: 'resize',\\n    fn: cancel\\n  }, {\\n    eventName: 'scroll',\\n    options: {\\n      passive: true,\\n      capture: false\\n    },\\n    fn: function fn() {\\n      if (getPhase().type === 'PENDING') {\\n        cancel();\\n      }\\n    }\\n  }, {\\n    eventName: 'webkitmouseforcedown',\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n      !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Unexpected phase') : invariant(false) : void 0;\\n\\n      if (phase.actions.shouldRespectForcePress()) {\\n        cancel();\\n        return;\\n      }\\n\\n      event.preventDefault();\\n    }\\n  }, {\\n    eventName: supportedEventName,\\n    fn: cancel\\n  }];\\n}\\n\\nfunction useMouseSensor(api) {\\n  var phaseRef = React.useRef(idle$1);\\n  var unbindEventsRef = React.useRef(noop);\\n  var startCaptureBinding = useMemoOne.useMemo(function () {\\n    return {\\n      eventName: 'mousedown',\\n      fn: function onMouseDown(event) {\\n        if (event.defaultPrevented) {\\n          return;\\n        }\\n\\n        if (event.button !== primaryButton) {\\n          return;\\n        }\\n\\n        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\\n          return;\\n        }\\n\\n        var draggableId = api.findClosestDraggableId(event);\\n\\n        if (!draggableId) {\\n          return;\\n        }\\n\\n        var actions = api.tryGetLock(draggableId, stop, {\\n          sourceEvent: event\\n        });\\n\\n        if (!actions) {\\n          return;\\n        }\\n\\n        event.preventDefault();\\n        var point = {\\n          x: event.clientX,\\n          y: event.clientY\\n        };\\n        unbindEventsRef.current();\\n        startPendingDrag(actions, point);\\n      }\\n    };\\n  }, [api]);\\n  var preventForcePressBinding = useMemoOne.useMemo(function () {\\n    return {\\n      eventName: 'webkitmouseforcewillbegin',\\n      fn: function fn(event) {\\n        if (event.defaultPrevented) {\\n          return;\\n        }\\n\\n        var id = api.findClosestDraggableId(event);\\n\\n        if (!id) {\\n          return;\\n        }\\n\\n        var options = api.findOptionsForDraggable(id);\\n\\n        if (!options) {\\n          return;\\n        }\\n\\n        if (options.shouldRespectForcePress) {\\n          return;\\n        }\\n\\n        if (!api.canGetLock(id)) {\\n          return;\\n        }\\n\\n        event.preventDefault();\\n      }\\n    };\\n  }, [api]);\\n  var listenForCapture = useMemoOne.useCallback(function listenForCapture() {\\n    var options = {\\n      passive: false,\\n      capture: true\\n    };\\n    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);\\n  }, [preventForcePressBinding, startCaptureBinding]);\\n  var stop = useMemoOne.useCallback(function () {\\n    var current = phaseRef.current;\\n\\n    if (current.type === 'IDLE') {\\n      return;\\n    }\\n\\n    phaseRef.current = idle$1;\\n    unbindEventsRef.current();\\n    listenForCapture();\\n  }, [listenForCapture]);\\n  var cancel = useMemoOne.useCallback(function () {\\n    var phase = phaseRef.current;\\n    stop();\\n\\n    if (phase.type === 'DRAGGING') {\\n      phase.actions.cancel({\\n        shouldBlockNextClick: true\\n      });\\n    }\\n\\n    if (phase.type === 'PENDING') {\\n      phase.actions.abort();\\n    }\\n  }, [stop]);\\n  var bindCapturingEvents = useMemoOne.useCallback(function bindCapturingEvents() {\\n    var options = {\\n      capture: true,\\n      passive: false\\n    };\\n    var bindings = getCaptureBindings({\\n      cancel: cancel,\\n      completed: stop,\\n      getPhase: function getPhase() {\\n        return phaseRef.current;\\n      },\\n      setPhase: function setPhase(phase) {\\n        phaseRef.current = phase;\\n      }\\n    });\\n    unbindEventsRef.current = bindEvents(window, bindings, options);\\n  }, [cancel, stop]);\\n  var startPendingDrag = useMemoOne.useCallback(function startPendingDrag(actions, point) {\\n    !(phaseRef.current.type === 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected to move from IDLE to PENDING drag') : invariant(false) : void 0;\\n    phaseRef.current = {\\n      type: 'PENDING',\\n      point: point,\\n      actions: actions\\n    };\\n    bindCapturingEvents();\\n  }, [bindCapturingEvents]);\\n  useIsomorphicLayoutEffect(function mount() {\\n    listenForCapture();\\n    return function unmount() {\\n      unbindEventsRef.current();\\n    };\\n  }, [listenForCapture]);\\n}\\n\\nvar _scrollJumpKeys;\\n\\nfunction noop$1() {}\\n\\nvar scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);\\n\\nfunction getDraggingBindings(actions, stop) {\\n  function cancel() {\\n    stop();\\n    actions.cancel();\\n  }\\n\\n  function drop() {\\n    stop();\\n    actions.drop();\\n  }\\n\\n  return [{\\n    eventName: 'keydown',\\n    fn: function fn(event) {\\n      if (event.keyCode === escape) {\\n        event.preventDefault();\\n        cancel();\\n        return;\\n      }\\n\\n      if (event.keyCode === space) {\\n        event.preventDefault();\\n        drop();\\n        return;\\n      }\\n\\n      if (event.keyCode === arrowDown) {\\n        event.preventDefault();\\n        actions.moveDown();\\n        return;\\n      }\\n\\n      if (event.keyCode === arrowUp) {\\n        event.preventDefault();\\n        actions.moveUp();\\n        return;\\n      }\\n\\n      if (event.keyCode === arrowRight) {\\n        event.preventDefault();\\n        actions.moveRight();\\n        return;\\n      }\\n\\n      if (event.keyCode === arrowLeft) {\\n        event.preventDefault();\\n        actions.moveLeft();\\n        return;\\n      }\\n\\n      if (scrollJumpKeys[event.keyCode]) {\\n        event.preventDefault();\\n        return;\\n      }\\n\\n      preventStandardKeyEvents(event);\\n    }\\n  }, {\\n    eventName: 'mousedown',\\n    fn: cancel\\n  }, {\\n    eventName: 'mouseup',\\n    fn: cancel\\n  }, {\\n    eventName: 'click',\\n    fn: cancel\\n  }, {\\n    eventName: 'touchstart',\\n    fn: cancel\\n  }, {\\n    eventName: 'resize',\\n    fn: cancel\\n  }, {\\n    eventName: 'wheel',\\n    fn: cancel,\\n    options: {\\n      passive: true\\n    }\\n  }, {\\n    eventName: supportedEventName,\\n    fn: cancel\\n  }];\\n}\\n\\nfunction useKeyboardSensor(api) {\\n  var unbindEventsRef = React.useRef(noop$1);\\n  var startCaptureBinding = useMemoOne.useMemo(function () {\\n    return {\\n      eventName: 'keydown',\\n      fn: function onKeyDown(event) {\\n        if (event.defaultPrevented) {\\n          return;\\n        }\\n\\n        if (event.keyCode !== space) {\\n          return;\\n        }\\n\\n        var draggableId = api.findClosestDraggableId(event);\\n\\n        if (!draggableId) {\\n          return;\\n        }\\n\\n        var preDrag = api.tryGetLock(draggableId, stop, {\\n          sourceEvent: event\\n        });\\n\\n        if (!preDrag) {\\n          return;\\n        }\\n\\n        event.preventDefault();\\n        var isCapturing = true;\\n        var actions = preDrag.snapLift();\\n        unbindEventsRef.current();\\n\\n        function stop() {\\n          !isCapturing ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot stop capturing a keyboard drag when not capturing') : invariant(false) : void 0;\\n          isCapturing = false;\\n          unbindEventsRef.current();\\n          listenForCapture();\\n        }\\n\\n        unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\\n          capture: true,\\n          passive: false\\n        });\\n      }\\n    };\\n  }, [api]);\\n  var listenForCapture = useMemoOne.useCallback(function tryStartCapture() {\\n    var options = {\\n      passive: false,\\n      capture: true\\n    };\\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\\n  }, [startCaptureBinding]);\\n  useIsomorphicLayoutEffect(function mount() {\\n    listenForCapture();\\n    return function unmount() {\\n      unbindEventsRef.current();\\n    };\\n  }, [listenForCapture]);\\n}\\n\\nvar idle$2 = {\\n  type: 'IDLE'\\n};\\nvar timeForLongPress = 120;\\nvar forcePressThreshold = 0.15;\\n\\nfunction getWindowBindings(_ref) {\\n  var cancel = _ref.cancel,\\n      getPhase = _ref.getPhase;\\n  return [{\\n    eventName: 'orientationchange',\\n    fn: cancel\\n  }, {\\n    eventName: 'resize',\\n    fn: cancel\\n  }, {\\n    eventName: 'contextmenu',\\n    fn: function fn(event) {\\n      event.preventDefault();\\n    }\\n  }, {\\n    eventName: 'keydown',\\n    fn: function fn(event) {\\n      if (getPhase().type !== 'DRAGGING') {\\n        cancel();\\n        return;\\n      }\\n\\n      if (event.keyCode === escape) {\\n        event.preventDefault();\\n      }\\n\\n      cancel();\\n    }\\n  }, {\\n    eventName: supportedEventName,\\n    fn: cancel\\n  }];\\n}\\n\\nfunction getHandleBindings(_ref2) {\\n  var cancel = _ref2.cancel,\\n      completed = _ref2.completed,\\n      getPhase = _ref2.getPhase;\\n  return [{\\n    eventName: 'touchmove',\\n    options: {\\n      capture: false\\n    },\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n\\n      if (phase.type !== 'DRAGGING') {\\n        cancel();\\n        return;\\n      }\\n\\n      phase.hasMoved = true;\\n      var _event$touches$ = event.touches[0],\\n          clientX = _event$touches$.clientX,\\n          clientY = _event$touches$.clientY;\\n      var point = {\\n        x: clientX,\\n        y: clientY\\n      };\\n      event.preventDefault();\\n      phase.actions.move(point);\\n    }\\n  }, {\\n    eventName: 'touchend',\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n\\n      if (phase.type !== 'DRAGGING') {\\n        cancel();\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      phase.actions.drop({\\n        shouldBlockNextClick: true\\n      });\\n      completed();\\n    }\\n  }, {\\n    eventName: 'touchcancel',\\n    fn: function fn(event) {\\n      if (getPhase().type !== 'DRAGGING') {\\n        cancel();\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      cancel();\\n    }\\n  }, {\\n    eventName: 'touchforcechange',\\n    fn: function fn(event) {\\n      var phase = getPhase();\\n      !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false) : invariant(false) : void 0;\\n      var touch = event.touches[0];\\n\\n      if (!touch) {\\n        return;\\n      }\\n\\n      var isForcePress = touch.force >= forcePressThreshold;\\n\\n      if (!isForcePress) {\\n        return;\\n      }\\n\\n      var shouldRespect = phase.actions.shouldRespectForcePress();\\n\\n      if (phase.type === 'PENDING') {\\n        if (shouldRespect) {\\n          cancel();\\n        }\\n\\n        return;\\n      }\\n\\n      if (shouldRespect) {\\n        if (phase.hasMoved) {\\n          event.preventDefault();\\n          return;\\n        }\\n\\n        cancel();\\n        return;\\n      }\\n\\n      event.preventDefault();\\n    }\\n  }, {\\n    eventName: supportedEventName,\\n    fn: cancel\\n  }];\\n}\\n\\nfunction useMouseSensor$1(api) {\\n  var phaseRef = React.useRef(idle$2);\\n  var unbindEventsRef = React.useRef(noop);\\n  var getPhase = useMemoOne.useCallback(function getPhase() {\\n    return phaseRef.current;\\n  }, []);\\n  var setPhase = useMemoOne.useCallback(function setPhase(phase) {\\n    phaseRef.current = phase;\\n  }, []);\\n  var startCaptureBinding = useMemoOne.useMemo(function () {\\n    return {\\n      eventName: 'touchstart',\\n      fn: function onTouchStart(event) {\\n        if (event.defaultPrevented) {\\n          return;\\n        }\\n\\n        var draggableId = api.findClosestDraggableId(event);\\n\\n        if (!draggableId) {\\n          return;\\n        }\\n\\n        var actions = api.tryGetLock(draggableId, stop, {\\n          sourceEvent: event\\n        });\\n\\n        if (!actions) {\\n          return;\\n        }\\n\\n        var touch = event.touches[0];\\n        var clientX = touch.clientX,\\n            clientY = touch.clientY;\\n        var point = {\\n          x: clientX,\\n          y: clientY\\n        };\\n        unbindEventsRef.current();\\n        startPendingDrag(actions, point);\\n      }\\n    };\\n  }, [api]);\\n  var listenForCapture = useMemoOne.useCallback(function listenForCapture() {\\n    var options = {\\n      capture: true,\\n      passive: false\\n    };\\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\\n  }, [startCaptureBinding]);\\n  var stop = useMemoOne.useCallback(function () {\\n    var current = phaseRef.current;\\n\\n    if (current.type === 'IDLE') {\\n      return;\\n    }\\n\\n    if (current.type === 'PENDING') {\\n      clearTimeout(current.longPressTimerId);\\n    }\\n\\n    setPhase(idle$2);\\n    unbindEventsRef.current();\\n    listenForCapture();\\n  }, [listenForCapture, setPhase]);\\n  var cancel = useMemoOne.useCallback(function () {\\n    var phase = phaseRef.current;\\n    stop();\\n\\n    if (phase.type === 'DRAGGING') {\\n      phase.actions.cancel({\\n        shouldBlockNextClick: true\\n      });\\n    }\\n\\n    if (phase.type === 'PENDING') {\\n      phase.actions.abort();\\n    }\\n  }, [stop]);\\n  var bindCapturingEvents = useMemoOne.useCallback(function bindCapturingEvents() {\\n    var options = {\\n      capture: true,\\n      passive: false\\n    };\\n    var args = {\\n      cancel: cancel,\\n      completed: stop,\\n      getPhase: getPhase\\n    };\\n    var unbindTarget = bindEvents(window, getHandleBindings(args), options);\\n    var unbindWindow = bindEvents(window, getWindowBindings(args), options);\\n\\n    unbindEventsRef.current = function unbindAll() {\\n      unbindTarget();\\n      unbindWindow();\\n    };\\n  }, [cancel, getPhase, stop]);\\n  var startDragging = useMemoOne.useCallback(function startDragging() {\\n    var phase = getPhase();\\n    !(phase.type === 'PENDING') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot start dragging from phase \\\" + phase.type) : invariant(false) : void 0;\\n    var actions = phase.actions.fluidLift(phase.point);\\n    setPhase({\\n      type: 'DRAGGING',\\n      actions: actions,\\n      hasMoved: false\\n    });\\n  }, [getPhase, setPhase]);\\n  var startPendingDrag = useMemoOne.useCallback(function startPendingDrag(actions, point) {\\n    !(getPhase().type === 'IDLE') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected to move from IDLE to PENDING drag') : invariant(false) : void 0;\\n    var longPressTimerId = setTimeout(startDragging, timeForLongPress);\\n    setPhase({\\n      type: 'PENDING',\\n      point: point,\\n      actions: actions,\\n      longPressTimerId: longPressTimerId\\n    });\\n    bindCapturingEvents();\\n  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);\\n  useIsomorphicLayoutEffect(function mount() {\\n    listenForCapture();\\n    return function unmount() {\\n      unbindEventsRef.current();\\n      var phase = getPhase();\\n\\n      if (phase.type === 'PENDING') {\\n        clearTimeout(phase.longPressTimerId);\\n        setPhase(idle$2);\\n      }\\n    };\\n  }, [getPhase, listenForCapture, setPhase]);\\n  useIsomorphicLayoutEffect(function webkitHack() {\\n    var unbind = bindEvents(window, [{\\n      eventName: 'touchmove',\\n      fn: function fn() {},\\n      options: {\\n        capture: false,\\n        passive: false\\n      }\\n    }]);\\n    return unbind;\\n  }, []);\\n}\\n\\nfunction useValidateSensorHooks(sensorHooks) {\\n  useDev(function () {\\n    var previousRef = usePrevious(sensorHooks);\\n    useDevSetupWarning(function () {\\n      !(previousRef.current.length === sensorHooks.length) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot change the amount of sensor hooks after mounting') : invariant(false) : void 0;\\n    });\\n  });\\n}\\n\\nvar interactiveTagNames = {\\n  input: true,\\n  button: true,\\n  textarea: true,\\n  select: true,\\n  option: true,\\n  optgroup: true,\\n  video: true,\\n  audio: true\\n};\\n\\nfunction isAnInteractiveElement(parent, current) {\\n  if (current == null) {\\n    return false;\\n  }\\n\\n  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);\\n\\n  if (hasAnInteractiveTag) {\\n    return true;\\n  }\\n\\n  var attribute = current.getAttribute('contenteditable');\\n\\n  if (attribute === 'true' || attribute === '') {\\n    return true;\\n  }\\n\\n  if (current === parent) {\\n    return false;\\n  }\\n\\n  return isAnInteractiveElement(parent, current.parentElement);\\n}\\n\\nfunction isEventInInteractiveElement(draggable, event) {\\n  var target = event.target;\\n\\n  if (!isHtmlElement(target)) {\\n    return false;\\n  }\\n\\n  return isAnInteractiveElement(draggable, target);\\n}\\n\\nvar getBorderBoxCenterPosition = (function (el) {\\n  return cssBoxModel.getRect(el.getBoundingClientRect()).center;\\n});\\n\\nfunction isElement(el) {\\n  return el instanceof getWindowFromEl(el).Element;\\n}\\n\\nvar supportedMatchesName = function () {\\n  var base = 'matches';\\n\\n  if (typeof document === 'undefined') {\\n    return base;\\n  }\\n\\n  var candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];\\n  var value = find(candidates, function (name) {\\n    return name in Element.prototype;\\n  });\\n  return value || base;\\n}();\\n\\nfunction closestPonyfill(el, selector) {\\n  if (el == null) {\\n    return null;\\n  }\\n\\n  if (el[supportedMatchesName](selector)) {\\n    return el;\\n  }\\n\\n  return closestPonyfill(el.parentElement, selector);\\n}\\n\\nfunction closest$1(el, selector) {\\n  if (el.closest) {\\n    return el.closest(selector);\\n  }\\n\\n  return closestPonyfill(el, selector);\\n}\\n\\nfunction getSelector(contextId) {\\n  return \\\"[\\\" + dragHandle.contextId + \\\"=\\\\\\\"\\\" + contextId + \\\"\\\\\\\"]\\\";\\n}\\n\\nfunction findClosestDragHandleFromEvent(contextId, event) {\\n  var target = event.target;\\n\\n  if (!isElement(target)) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning('event.target must be a Element') : void 0;\\n    return null;\\n  }\\n\\n  var selector = getSelector(contextId);\\n  var handle = closest$1(target, selector);\\n\\n  if (!handle) {\\n    return null;\\n  }\\n\\n  if (!isHtmlElement(handle)) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning('drag handle must be a HTMLElement') : void 0;\\n    return null;\\n  }\\n\\n  return handle;\\n}\\n\\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\\n  var handle = findClosestDragHandleFromEvent(contextId, event);\\n\\n  if (!handle) {\\n    return null;\\n  }\\n\\n  return handle.getAttribute(dragHandle.draggableId);\\n}\\n\\nfunction findDraggable(contextId, draggableId) {\\n  var selector = \\\"[\\\" + draggable.contextId + \\\"=\\\\\\\"\\\" + contextId + \\\"\\\\\\\"]\\\";\\n  var possible = toArray(document.querySelectorAll(selector));\\n  var draggable$1 = find(possible, function (el) {\\n    return el.getAttribute(draggable.id) === draggableId;\\n  });\\n\\n  if (!draggable$1) {\\n    return null;\\n  }\\n\\n  if (!isHtmlElement(draggable$1)) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning('Draggable element is not a HTMLElement') : void 0;\\n    return null;\\n  }\\n\\n  return draggable$1;\\n}\\n\\nfunction preventDefault(event) {\\n  event.preventDefault();\\n}\\n\\nfunction _isActive(_ref) {\\n  var expected = _ref.expected,\\n      phase = _ref.phase,\\n      isLockActive = _ref.isLockActive,\\n      shouldWarn = _ref.shouldWarn;\\n\\n  if (!isLockActive()) {\\n    if (shouldWarn) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n        Cannot perform action.\\\\n        The sensor no longer has an action lock.\\\\n\\\\n        Tips:\\\\n\\\\n        - Throw away your action handlers when forceStop() is called\\\\n        - Check actions.isActive() if you really need to\\\\n      \\\") : void 0;\\n    }\\n\\n    return false;\\n  }\\n\\n  if (expected !== phase) {\\n    if (shouldWarn) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n        Cannot perform action.\\\\n        The actions you used belong to an outdated phase\\\\n\\\\n        Current phase: \\\" + expected + \\\"\\\\n        You called an action from outdated phase: \\\" + phase + \\\"\\\\n\\\\n        Tips:\\\\n\\\\n        - Do not use preDragActions actions after calling preDragActions.lift()\\\\n      \\\") : void 0;\\n    }\\n\\n    return false;\\n  }\\n\\n  return true;\\n}\\n\\nfunction canStart(_ref2) {\\n  var lockAPI = _ref2.lockAPI,\\n      store = _ref2.store,\\n      registry = _ref2.registry,\\n      draggableId = _ref2.draggableId;\\n\\n  if (lockAPI.isClaimed()) {\\n    return false;\\n  }\\n\\n  var entry = registry.draggable.findById(draggableId);\\n\\n  if (!entry) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"Unable to find draggable with id: \\\" + draggableId) : void 0;\\n    return false;\\n  }\\n\\n  if (!entry.options.isEnabled) {\\n    return false;\\n  }\\n\\n  if (!canStartDrag(store.getState(), draggableId)) {\\n    return false;\\n  }\\n\\n  return true;\\n}\\n\\nfunction tryStart(_ref3) {\\n  var lockAPI = _ref3.lockAPI,\\n      contextId = _ref3.contextId,\\n      store = _ref3.store,\\n      registry = _ref3.registry,\\n      draggableId = _ref3.draggableId,\\n      forceSensorStop = _ref3.forceSensorStop,\\n      sourceEvent = _ref3.sourceEvent;\\n  var shouldStart = canStart({\\n    lockAPI: lockAPI,\\n    store: store,\\n    registry: registry,\\n    draggableId: draggableId\\n  });\\n\\n  if (!shouldStart) {\\n    return null;\\n  }\\n\\n  var entry = registry.draggable.getById(draggableId);\\n  var el = findDraggable(contextId, entry.descriptor.id);\\n\\n  if (!el) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"Unable to find draggable element with id: \\\" + draggableId) : void 0;\\n    return null;\\n  }\\n\\n  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\\n    return null;\\n  }\\n\\n  var lock = lockAPI.claim(forceSensorStop || noop);\\n  var phase = 'PRE_DRAG';\\n\\n  function getShouldRespectForcePress() {\\n    return entry.options.shouldRespectForcePress;\\n  }\\n\\n  function isLockActive() {\\n    return lockAPI.isActive(lock);\\n  }\\n\\n  function tryDispatch(expected, getAction) {\\n    if (_isActive({\\n      expected: expected,\\n      phase: phase,\\n      isLockActive: isLockActive,\\n      shouldWarn: true\\n    })) {\\n      store.dispatch(getAction());\\n    }\\n  }\\n\\n  var tryDispatchWhenDragging = tryDispatch.bind(this, 'DRAGGING');\\n\\n  function lift$1(args) {\\n    function completed() {\\n      lockAPI.release();\\n      phase = 'COMPLETED';\\n    }\\n\\n    if (phase !== 'PRE_DRAG') {\\n      completed();\\n      !(phase === 'PRE_DRAG') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Cannot lift in phase \\\" + phase) : invariant(false) : void 0;\\n    }\\n\\n    store.dispatch(lift(args.liftActionArgs));\\n    phase = 'DRAGGING';\\n\\n    function finish(reason, options) {\\n      if (options === void 0) {\\n        options = {\\n          shouldBlockNextClick: false\\n        };\\n      }\\n\\n      args.cleanup();\\n\\n      if (options.shouldBlockNextClick) {\\n        var unbind = bindEvents(window, [{\\n          eventName: 'click',\\n          fn: preventDefault,\\n          options: {\\n            once: true,\\n            passive: false,\\n            capture: true\\n          }\\n        }]);\\n        setTimeout(unbind);\\n      }\\n\\n      completed();\\n      store.dispatch(drop({\\n        reason: reason\\n      }));\\n    }\\n\\n    return _extends({\\n      isActive: function isActive() {\\n        return _isActive({\\n          expected: 'DRAGGING',\\n          phase: phase,\\n          isLockActive: isLockActive,\\n          shouldWarn: false\\n        });\\n      },\\n      shouldRespectForcePress: getShouldRespectForcePress,\\n      drop: function drop(options) {\\n        return finish('DROP', options);\\n      },\\n      cancel: function cancel(options) {\\n        return finish('CANCEL', options);\\n      }\\n    }, args.actions);\\n  }\\n\\n  function fluidLift(clientSelection) {\\n    var move$1 = rafSchd(function (client) {\\n      tryDispatchWhenDragging(function () {\\n        return move({\\n          client: client\\n        });\\n      });\\n    });\\n    var api = lift$1({\\n      liftActionArgs: {\\n        id: draggableId,\\n        clientSelection: clientSelection,\\n        movementMode: 'FLUID'\\n      },\\n      cleanup: function cleanup() {\\n        return move$1.cancel();\\n      },\\n      actions: {\\n        move: move$1\\n      }\\n    });\\n    return _extends({}, api, {\\n      move: move$1\\n    });\\n  }\\n\\n  function snapLift() {\\n    var actions = {\\n      moveUp: function moveUp$1() {\\n        return tryDispatchWhenDragging(moveUp);\\n      },\\n      moveRight: function moveRight$1() {\\n        return tryDispatchWhenDragging(moveRight);\\n      },\\n      moveDown: function moveDown$1() {\\n        return tryDispatchWhenDragging(moveDown);\\n      },\\n      moveLeft: function moveLeft$1() {\\n        return tryDispatchWhenDragging(moveLeft);\\n      }\\n    };\\n    return lift$1({\\n      liftActionArgs: {\\n        id: draggableId,\\n        clientSelection: getBorderBoxCenterPosition(el),\\n        movementMode: 'SNAP'\\n      },\\n      cleanup: noop,\\n      actions: actions\\n    });\\n  }\\n\\n  function abortPreDrag() {\\n    var shouldRelease = _isActive({\\n      expected: 'PRE_DRAG',\\n      phase: phase,\\n      isLockActive: isLockActive,\\n      shouldWarn: true\\n    });\\n\\n    if (shouldRelease) {\\n      lockAPI.release();\\n    }\\n  }\\n\\n  var preDrag = {\\n    isActive: function isActive() {\\n      return _isActive({\\n        expected: 'PRE_DRAG',\\n        phase: phase,\\n        isLockActive: isLockActive,\\n        shouldWarn: false\\n      });\\n    },\\n    shouldRespectForcePress: getShouldRespectForcePress,\\n    fluidLift: fluidLift,\\n    snapLift: snapLift,\\n    abort: abortPreDrag\\n  };\\n  return preDrag;\\n}\\n\\nvar defaultSensors = [useMouseSensor, useKeyboardSensor, useMouseSensor$1];\\nfunction useSensorMarshal(_ref4) {\\n  var contextId = _ref4.contextId,\\n      store = _ref4.store,\\n      registry = _ref4.registry,\\n      customSensors = _ref4.customSensors,\\n      enableDefaultSensors = _ref4.enableDefaultSensors;\\n  var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);\\n  var lockAPI = React.useState(function () {\\n    return create();\\n  })[0];\\n  var tryAbandonLock = useMemoOne.useCallback(function tryAbandonLock(previous, current) {\\n    if (previous.isDragging && !current.isDragging) {\\n      lockAPI.tryAbandon();\\n    }\\n  }, [lockAPI]);\\n  useIsomorphicLayoutEffect(function listenToStore() {\\n    var previous = store.getState();\\n    var unsubscribe = store.subscribe(function () {\\n      var current = store.getState();\\n      tryAbandonLock(previous, current);\\n      previous = current;\\n    });\\n    return unsubscribe;\\n  }, [lockAPI, store, tryAbandonLock]);\\n  useIsomorphicLayoutEffect(function () {\\n    return lockAPI.tryAbandon;\\n  }, [lockAPI.tryAbandon]);\\n  var canGetLock = useMemoOne.useCallback(function (draggableId) {\\n    return canStart({\\n      lockAPI: lockAPI,\\n      registry: registry,\\n      store: store,\\n      draggableId: draggableId\\n    });\\n  }, [lockAPI, registry, store]);\\n  var tryGetLock = useMemoOne.useCallback(function (draggableId, forceStop, options) {\\n    return tryStart({\\n      lockAPI: lockAPI,\\n      registry: registry,\\n      contextId: contextId,\\n      store: store,\\n      draggableId: draggableId,\\n      forceSensorStop: forceStop,\\n      sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\\n    });\\n  }, [contextId, lockAPI, registry, store]);\\n  var findClosestDraggableId = useMemoOne.useCallback(function (event) {\\n    return tryGetClosestDraggableIdFromEvent(contextId, event);\\n  }, [contextId]);\\n  var findOptionsForDraggable = useMemoOne.useCallback(function (id) {\\n    var entry = registry.draggable.findById(id);\\n    return entry ? entry.options : null;\\n  }, [registry.draggable]);\\n  var tryReleaseLock = useMemoOne.useCallback(lockAPI.tryAbandon, [lockAPI]);\\n  var isLockClaimed = useMemoOne.useCallback(lockAPI.isClaimed, [lockAPI]);\\n  var api = useMemoOne.useMemo(function () {\\n    return {\\n      canGetLock: canGetLock,\\n      tryGetLock: tryGetLock,\\n      findClosestDraggableId: findClosestDraggableId,\\n      findOptionsForDraggable: findOptionsForDraggable,\\n      tryReleaseLock: tryReleaseLock,\\n      isLockClaimed: isLockClaimed\\n    };\\n  }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);\\n  useValidateSensorHooks(useSensors);\\n\\n  for (var i = 0; i < useSensors.length; i++) {\\n    useSensors[i](api);\\n  }\\n}\\n\\nvar createResponders = function createResponders(props) {\\n  return {\\n    onBeforeDragStart: props.onBeforeDragStart,\\n    onDragStart: props.onDragStart,\\n    onDragEnd: props.onDragEnd,\\n    onDragUpdate: props.onDragUpdate\\n  };\\n};\\n\\nfunction getStore(lazyRef) {\\n  !lazyRef.current ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find store from lazy ref') : invariant(false) : void 0;\\n  return lazyRef.current;\\n}\\n\\nfunction App(props) {\\n  var contextId = props.contextId,\\n      setCallbacks = props.setCallbacks,\\n      sensors = props.sensors,\\n      nonce = props.nonce,\\n      liftInstruction = props.liftInstruction;\\n  var lazyStoreRef = React.useRef(null);\\n  useStartupValidation();\\n  var lastPropsRef = usePrevious(props);\\n  var getResponders = useMemoOne.useCallback(function () {\\n    return createResponders(lastPropsRef.current);\\n  }, [lastPropsRef]);\\n  var announce = useAnnouncer(contextId);\\n  var liftInstructionId = useLiftInstruction(contextId, liftInstruction);\\n  var styleMarshal = useStyleMarshal(contextId, nonce);\\n  var lazyDispatch = useMemoOne.useCallback(function (action) {\\n    getStore(lazyStoreRef).dispatch(action);\\n  }, []);\\n  var marshalCallbacks = useMemoOne.useMemo(function () {\\n    return redux.bindActionCreators({\\n      publishWhileDragging: publishWhileDragging,\\n      updateDroppableScroll: updateDroppableScroll,\\n      updateDroppableIsEnabled: updateDroppableIsEnabled,\\n      updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\\n      collectionStarting: collectionStarting\\n    }, lazyDispatch);\\n  }, [lazyDispatch]);\\n  var registry = useRegistry();\\n  var dimensionMarshal = useMemoOne.useMemo(function () {\\n    return createDimensionMarshal(registry, marshalCallbacks);\\n  }, [registry, marshalCallbacks]);\\n  var autoScroller = useMemoOne.useMemo(function () {\\n    return createAutoScroller(_extends({\\n      scrollWindow: scrollWindow,\\n      scrollDroppable: dimensionMarshal.scrollDroppable\\n    }, redux.bindActionCreators({\\n      move: move\\n    }, lazyDispatch)));\\n  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);\\n  var focusMarshal = useFocusMarshal(contextId);\\n  var store = useMemoOne.useMemo(function () {\\n    return createStore({\\n      announce: announce,\\n      autoScroller: autoScroller,\\n      dimensionMarshal: dimensionMarshal,\\n      focusMarshal: focusMarshal,\\n      getResponders: getResponders,\\n      styleMarshal: styleMarshal\\n    });\\n  }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (lazyStoreRef.current && lazyStoreRef.current !== store) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning('unexpected store change') : void 0;\\n    }\\n  }\\n\\n  lazyStoreRef.current = store;\\n  var tryResetStore = useMemoOne.useCallback(function () {\\n    var current = getStore(lazyStoreRef);\\n    var state = current.getState();\\n\\n    if (state.phase !== 'IDLE') {\\n      current.dispatch(flush());\\n    }\\n  }, []);\\n  var isDragging = useMemoOne.useCallback(function () {\\n    var state = getStore(lazyStoreRef).getState();\\n    return state.isDragging || state.phase === 'DROP_ANIMATING';\\n  }, []);\\n  var appCallbacks = useMemoOne.useMemo(function () {\\n    return {\\n      isDragging: isDragging,\\n      tryAbort: tryResetStore\\n    };\\n  }, [isDragging, tryResetStore]);\\n  setCallbacks(appCallbacks);\\n  var getCanLift = useMemoOne.useCallback(function (id) {\\n    return canStartDrag(getStore(lazyStoreRef).getState(), id);\\n  }, []);\\n  var getIsMovementAllowed = useMemoOne.useCallback(function () {\\n    return isMovementAllowed(getStore(lazyStoreRef).getState());\\n  }, []);\\n  var appContext = useMemoOne.useMemo(function () {\\n    return {\\n      marshal: dimensionMarshal,\\n      focus: focusMarshal,\\n      contextId: contextId,\\n      canLift: getCanLift,\\n      isMovementAllowed: getIsMovementAllowed,\\n      liftInstructionId: liftInstructionId,\\n      registry: registry\\n    };\\n  }, [contextId, dimensionMarshal, focusMarshal, getCanLift, getIsMovementAllowed, liftInstructionId, registry]);\\n  useSensorMarshal({\\n    contextId: contextId,\\n    store: store,\\n    registry: registry,\\n    customSensors: sensors,\\n    enableDefaultSensors: props.enableDefaultSensors !== false\\n  });\\n  React.useEffect(function () {\\n    return tryResetStore;\\n  }, [tryResetStore]);\\n  return React__default.createElement(AppContext.Provider, {\\n    value: appContext\\n  }, React__default.createElement(reactRedux.Provider, {\\n    context: StoreContext,\\n    store: store\\n  }, props.children));\\n}\\n\\nvar instanceCount = 0;\\nfunction resetServerContext() {\\n  instanceCount = 0;\\n}\\nfunction DragDropContext(props) {\\n  var contextId = useMemoOne.useMemo(function () {\\n    return \\\"\\\" + instanceCount++;\\n  }, []);\\n  var liftInstruction = props.liftInstruction || preset.liftInstruction;\\n  return React__default.createElement(ErrorBoundary, null, function (setCallbacks) {\\n    return React__default.createElement(App, {\\n      nonce: props.nonce,\\n      contextId: contextId,\\n      setCallbacks: setCallbacks,\\n      liftInstruction: liftInstruction,\\n      enableDefaultSensors: props.enableDefaultSensors,\\n      sensors: props.sensors,\\n      onBeforeDragStart: props.onBeforeDragStart,\\n      onDragStart: props.onDragStart,\\n      onDragUpdate: props.onDragUpdate,\\n      onDragEnd: props.onDragEnd\\n    }, props.children);\\n  });\\n}\\n\\nvar isEqual$1 = function isEqual(base) {\\n  return function (value) {\\n    return base === value;\\n  };\\n};\\n\\nvar isScroll = isEqual$1('scroll');\\nvar isAuto = isEqual$1('auto');\\nvar isVisible$1 = isEqual$1('visible');\\n\\nvar isEither = function isEither(overflow, fn) {\\n  return fn(overflow.overflowX) || fn(overflow.overflowY);\\n};\\n\\nvar isBoth = function isBoth(overflow, fn) {\\n  return fn(overflow.overflowX) && fn(overflow.overflowY);\\n};\\n\\nvar isElementScrollable = function isElementScrollable(el) {\\n  var style = window.getComputedStyle(el);\\n  var overflow = {\\n    overflowX: style.overflowX,\\n    overflowY: style.overflowY\\n  };\\n  return isEither(overflow, isScroll) || isEither(overflow, isAuto);\\n};\\n\\nvar isBodyScrollable = function isBodyScrollable() {\\n  if (process.env.NODE_ENV === 'production') {\\n    return false;\\n  }\\n\\n  var body = getBodyElement();\\n  var html = document.documentElement;\\n  !html ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false) : invariant(false) : void 0;\\n\\n  if (!isElementScrollable(body)) {\\n    return false;\\n  }\\n\\n  var htmlStyle = window.getComputedStyle(html);\\n  var htmlOverflow = {\\n    overflowX: htmlStyle.overflowX,\\n    overflowY: htmlStyle.overflowY\\n  };\\n\\n  if (isBoth(htmlOverflow, isVisible$1)) {\\n    return false;\\n  }\\n\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n    We have detected that your <body> element might be a scroll container.\\\\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\\\\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\\\\n\\\\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\\\\n    we will be treating the <body> as *not* a scroll container\\\\n\\\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\\\\n  \\\") : void 0;\\n  return false;\\n};\\n\\nvar getClosestScrollable = function getClosestScrollable(el) {\\n  if (el == null) {\\n    return null;\\n  }\\n\\n  if (el === document.body) {\\n    return isBodyScrollable() ? el : null;\\n  }\\n\\n  if (el === document.documentElement) {\\n    return null;\\n  }\\n\\n  if (!isElementScrollable(el)) {\\n    return getClosestScrollable(el.parentElement);\\n  }\\n\\n  return el;\\n};\\n\\nvar checkForNestedScrollContainers = (function (scrollable) {\\n  if (!scrollable) {\\n    return;\\n  }\\n\\n  var anotherScrollParent = getClosestScrollable(scrollable.parentElement);\\n\\n  if (!anotherScrollParent) {\\n    return;\\n  }\\n\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n    Droppable: unsupported nested scroll container detected.\\\\n    A Droppable can only have one scroll parent (which can be itself)\\\\n    Nested scroll containers are currently not supported.\\\\n\\\\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\\\\n  \\\") : void 0;\\n});\\n\\nvar getScroll$1 = (function (el) {\\n  return {\\n    x: el.scrollLeft,\\n    y: el.scrollTop\\n  };\\n});\\n\\nvar getIsFixed = function getIsFixed(el) {\\n  if (!el) {\\n    return false;\\n  }\\n\\n  var style = window.getComputedStyle(el);\\n\\n  if (style.position === 'fixed') {\\n    return true;\\n  }\\n\\n  return getIsFixed(el.parentElement);\\n};\\n\\nvar getEnv = (function (start) {\\n  var closestScrollable = getClosestScrollable(start);\\n  var isFixedOnPage = getIsFixed(start);\\n  return {\\n    closestScrollable: closestScrollable,\\n    isFixedOnPage: isFixedOnPage\\n  };\\n});\\n\\nvar getDroppableDimension = (function (_ref) {\\n  var descriptor = _ref.descriptor,\\n      isEnabled = _ref.isEnabled,\\n      isCombineEnabled = _ref.isCombineEnabled,\\n      isFixedOnPage = _ref.isFixedOnPage,\\n      direction = _ref.direction,\\n      client = _ref.client,\\n      page = _ref.page,\\n      closest = _ref.closest;\\n\\n  var frame = function () {\\n    if (!closest) {\\n      return null;\\n    }\\n\\n    var scrollSize = closest.scrollSize,\\n        frameClient = closest.client;\\n    var maxScroll = getMaxScroll({\\n      scrollHeight: scrollSize.scrollHeight,\\n      scrollWidth: scrollSize.scrollWidth,\\n      height: frameClient.paddingBox.height,\\n      width: frameClient.paddingBox.width\\n    });\\n    return {\\n      pageMarginBox: closest.page.marginBox,\\n      frameClient: frameClient,\\n      scrollSize: scrollSize,\\n      shouldClipSubject: closest.shouldClipSubject,\\n      scroll: {\\n        initial: closest.scroll,\\n        current: closest.scroll,\\n        max: maxScroll,\\n        diff: {\\n          value: origin,\\n          displacement: origin\\n        }\\n      }\\n    };\\n  }();\\n\\n  var axis = direction === 'vertical' ? vertical : horizontal;\\n  var subject = getSubject({\\n    page: page,\\n    withPlaceholder: null,\\n    axis: axis,\\n    frame: frame\\n  });\\n  var dimension = {\\n    descriptor: descriptor,\\n    isCombineEnabled: isCombineEnabled,\\n    isFixedOnPage: isFixedOnPage,\\n    axis: axis,\\n    isEnabled: isEnabled,\\n    client: client,\\n    page: page,\\n    frame: frame,\\n    subject: subject\\n  };\\n  return dimension;\\n});\\n\\nvar getClient = function getClient(targetRef, closestScrollable) {\\n  var base = cssBoxModel.getBox(targetRef);\\n\\n  if (!closestScrollable) {\\n    return base;\\n  }\\n\\n  if (targetRef !== closestScrollable) {\\n    return base;\\n  }\\n\\n  var top = base.paddingBox.top - closestScrollable.scrollTop;\\n  var left = base.paddingBox.left - closestScrollable.scrollLeft;\\n  var bottom = top + closestScrollable.scrollHeight;\\n  var right = left + closestScrollable.scrollWidth;\\n  var paddingBox = {\\n    top: top,\\n    right: right,\\n    bottom: bottom,\\n    left: left\\n  };\\n  var borderBox = cssBoxModel.expand(paddingBox, base.border);\\n  var client = cssBoxModel.createBox({\\n    borderBox: borderBox,\\n    margin: base.margin,\\n    border: base.border,\\n    padding: base.padding\\n  });\\n  return client;\\n};\\n\\nvar getDimension = (function (_ref) {\\n  var ref = _ref.ref,\\n      descriptor = _ref.descriptor,\\n      env = _ref.env,\\n      windowScroll = _ref.windowScroll,\\n      direction = _ref.direction,\\n      isDropDisabled = _ref.isDropDisabled,\\n      isCombineEnabled = _ref.isCombineEnabled,\\n      shouldClipSubject = _ref.shouldClipSubject;\\n  var closestScrollable = env.closestScrollable;\\n  var client = getClient(ref, closestScrollable);\\n  var page = cssBoxModel.withScroll(client, windowScroll);\\n\\n  var closest = function () {\\n    if (!closestScrollable) {\\n      return null;\\n    }\\n\\n    var frameClient = cssBoxModel.getBox(closestScrollable);\\n    var scrollSize = {\\n      scrollHeight: closestScrollable.scrollHeight,\\n      scrollWidth: closestScrollable.scrollWidth\\n    };\\n    return {\\n      client: frameClient,\\n      page: cssBoxModel.withScroll(frameClient, windowScroll),\\n      scroll: getScroll$1(closestScrollable),\\n      scrollSize: scrollSize,\\n      shouldClipSubject: shouldClipSubject\\n    };\\n  }();\\n\\n  var dimension = getDroppableDimension({\\n    descriptor: descriptor,\\n    isEnabled: !isDropDisabled,\\n    isCombineEnabled: isCombineEnabled,\\n    isFixedOnPage: env.isFixedOnPage,\\n    direction: direction,\\n    client: client,\\n    page: page,\\n    closest: closest\\n  });\\n  return dimension;\\n});\\n\\nvar immediate = {\\n  passive: false\\n};\\nvar delayed = {\\n  passive: true\\n};\\nvar getListenerOptions = (function (options) {\\n  return options.shouldPublishImmediately ? immediate : delayed;\\n});\\n\\nfunction useRequiredContext(Context) {\\n  var result = React.useContext(Context);\\n  !result ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find required context') : invariant(false) : void 0;\\n  return result;\\n}\\n\\nvar count = 0;\\nfunction useUniqueId(prefix) {\\n  var countRef = React.useRef(count++);\\n  return prefix + \\\"::\\\" + countRef.current;\\n}\\n\\nvar getClosestScrollableFromDrag = function getClosestScrollableFromDrag(dragging) {\\n  return dragging && dragging.env.closestScrollable || null;\\n};\\n\\nfunction useDroppablePublisher(args) {\\n  var whileDraggingRef = React.useRef(null);\\n  var appContext = useRequiredContext(AppContext);\\n  var uniqueId = useUniqueId('droppable');\\n  var registry = appContext.registry,\\n      marshal = appContext.marshal;\\n  var previousRef = usePrevious(args);\\n  var descriptor = useMemoOne.useMemo(function () {\\n    return {\\n      id: args.droppableId,\\n      type: args.type,\\n      mode: args.mode\\n    };\\n  }, [args.droppableId, args.mode, args.type]);\\n  var publishedDescriptorRef = React.useRef(descriptor);\\n  var memoizedUpdateScroll = useMemoOne.useMemo(function () {\\n    return memoizeOne(function (x, y) {\\n      !whileDraggingRef.current ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Can only update scroll when dragging') : invariant(false) : void 0;\\n      var scroll = {\\n        x: x,\\n        y: y\\n      };\\n      marshal.updateDroppableScroll(descriptor.id, scroll);\\n    });\\n  }, [descriptor.id, marshal]);\\n  var getClosestScroll = useMemoOne.useCallback(function () {\\n    var dragging = whileDraggingRef.current;\\n\\n    if (!dragging || !dragging.env.closestScrollable) {\\n      return origin;\\n    }\\n\\n    return getScroll$1(dragging.env.closestScrollable);\\n  }, []);\\n  var updateScroll = useMemoOne.useCallback(function () {\\n    var scroll = getClosestScroll();\\n    memoizedUpdateScroll(scroll.x, scroll.y);\\n  }, [getClosestScroll, memoizedUpdateScroll]);\\n  var scheduleScrollUpdate = useMemoOne.useMemo(function () {\\n    return rafSchd(updateScroll);\\n  }, [updateScroll]);\\n  var onClosestScroll = useMemoOne.useCallback(function () {\\n    var dragging = whileDraggingRef.current;\\n    var closest = getClosestScrollableFromDrag(dragging);\\n    !(dragging && closest) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find scroll options while scrolling') : invariant(false) : void 0;\\n    var options = dragging.scrollOptions;\\n\\n    if (options.shouldPublishImmediately) {\\n      updateScroll();\\n      return;\\n    }\\n\\n    scheduleScrollUpdate();\\n  }, [scheduleScrollUpdate, updateScroll]);\\n  var getDimensionAndWatchScroll = useMemoOne.useCallback(function (windowScroll, options) {\\n    !!whileDraggingRef.current ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot collect a droppable while a drag is occurring') : invariant(false) : void 0;\\n    var previous = previousRef.current;\\n    var ref = previous.getDroppableRef();\\n    !ref ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot collect without a droppable ref') : invariant(false) : void 0;\\n    var env = getEnv(ref);\\n    var dragging = {\\n      ref: ref,\\n      descriptor: descriptor,\\n      env: env,\\n      scrollOptions: options\\n    };\\n    whileDraggingRef.current = dragging;\\n    var dimension = getDimension({\\n      ref: ref,\\n      descriptor: descriptor,\\n      env: env,\\n      windowScroll: windowScroll,\\n      direction: previous.direction,\\n      isDropDisabled: previous.isDropDisabled,\\n      isCombineEnabled: previous.isCombineEnabled,\\n      shouldClipSubject: !previous.ignoreContainerClipping\\n    });\\n    var scrollable = env.closestScrollable;\\n\\n    if (scrollable) {\\n      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\\n      scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        checkForNestedScrollContainers(scrollable);\\n      }\\n    }\\n\\n    return dimension;\\n  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);\\n  var getScrollWhileDragging = useMemoOne.useCallback(function () {\\n    var dragging = whileDraggingRef.current;\\n    var closest = getClosestScrollableFromDrag(dragging);\\n    !(dragging && closest) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Can only recollect Droppable client for Droppables that have a scroll container') : invariant(false) : void 0;\\n    return getScroll$1(closest);\\n  }, []);\\n  var dragStopped = useMemoOne.useCallback(function () {\\n    var dragging = whileDraggingRef.current;\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot stop drag when no active drag') : invariant(false) : void 0;\\n    var closest = getClosestScrollableFromDrag(dragging);\\n    whileDraggingRef.current = null;\\n\\n    if (!closest) {\\n      return;\\n    }\\n\\n    scheduleScrollUpdate.cancel();\\n    closest.removeAttribute(scrollContainer.contextId);\\n    closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\\n  }, [onClosestScroll, scheduleScrollUpdate]);\\n  var scroll = useMemoOne.useCallback(function (change) {\\n    var dragging = whileDraggingRef.current;\\n    !dragging ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot scroll when there is no drag') : invariant(false) : void 0;\\n    var closest = getClosestScrollableFromDrag(dragging);\\n    !closest ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : invariant(false) : void 0;\\n    closest.scrollTop += change.y;\\n    closest.scrollLeft += change.x;\\n  }, []);\\n  var callbacks = useMemoOne.useMemo(function () {\\n    return {\\n      getDimensionAndWatchScroll: getDimensionAndWatchScroll,\\n      getScrollWhileDragging: getScrollWhileDragging,\\n      dragStopped: dragStopped,\\n      scroll: scroll\\n    };\\n  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll]);\\n  var entry = useMemoOne.useMemo(function () {\\n    return {\\n      uniqueId: uniqueId,\\n      descriptor: descriptor,\\n      callbacks: callbacks\\n    };\\n  }, [callbacks, descriptor, uniqueId]);\\n  useIsomorphicLayoutEffect(function () {\\n    publishedDescriptorRef.current = entry.descriptor;\\n    registry.droppable.register(entry);\\n    return function () {\\n      if (whileDraggingRef.current) {\\n        process.env.NODE_ENV !== \\\"production\\\" ? warning('Unsupported: changing the droppableId or type of a Droppable during a drag') : void 0;\\n        dragStopped();\\n      }\\n\\n      registry.droppable.unregister(entry);\\n    };\\n  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);\\n  useIsomorphicLayoutEffect(function () {\\n    if (!whileDraggingRef.current) {\\n      return;\\n    }\\n\\n    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\\n  }, [args.isDropDisabled, marshal]);\\n  useIsomorphicLayoutEffect(function () {\\n    if (!whileDraggingRef.current) {\\n      return;\\n    }\\n\\n    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\\n  }, [args.isCombineEnabled, marshal]);\\n}\\n\\nfunction noop$2() {}\\n\\nvar empty = {\\n  width: 0,\\n  height: 0,\\n  margin: noSpacing\\n};\\n\\nvar getSize = function getSize(_ref) {\\n  var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount,\\n      placeholder = _ref.placeholder,\\n      animate = _ref.animate;\\n\\n  if (isAnimatingOpenOnMount) {\\n    return empty;\\n  }\\n\\n  if (animate === 'close') {\\n    return empty;\\n  }\\n\\n  return {\\n    height: placeholder.client.borderBox.height,\\n    width: placeholder.client.borderBox.width,\\n    margin: placeholder.client.margin\\n  };\\n};\\n\\nvar getStyle = function getStyle(_ref2) {\\n  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount,\\n      placeholder = _ref2.placeholder,\\n      animate = _ref2.animate;\\n  var size = getSize({\\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\\n    placeholder: placeholder,\\n    animate: animate\\n  });\\n  return {\\n    display: placeholder.display,\\n    boxSizing: 'border-box',\\n    width: size.width,\\n    height: size.height,\\n    marginTop: size.margin.top,\\n    marginRight: size.margin.right,\\n    marginBottom: size.margin.bottom,\\n    marginLeft: size.margin.left,\\n    flexShrink: '0',\\n    flexGrow: '0',\\n    pointerEvents: 'none',\\n    transition: animate !== 'none' ? transitions.placeholder : null\\n  };\\n};\\n\\nfunction Placeholder(props) {\\n  var animateOpenTimerRef = React.useRef(null);\\n  var tryClearAnimateOpenTimer = useMemoOne.useCallback(function () {\\n    if (!animateOpenTimerRef.current) {\\n      return;\\n    }\\n\\n    clearTimeout(animateOpenTimerRef.current);\\n    animateOpenTimerRef.current = null;\\n  }, []);\\n  var animate = props.animate,\\n      onTransitionEnd = props.onTransitionEnd,\\n      onClose = props.onClose,\\n      contextId = props.contextId;\\n\\n  var _useState = React.useState(props.animate === 'open'),\\n      isAnimatingOpenOnMount = _useState[0],\\n      setIsAnimatingOpenOnMount = _useState[1];\\n\\n  React.useEffect(function () {\\n    if (!isAnimatingOpenOnMount) {\\n      return noop$2;\\n    }\\n\\n    if (animate !== 'open') {\\n      tryClearAnimateOpenTimer();\\n      setIsAnimatingOpenOnMount(false);\\n      return noop$2;\\n    }\\n\\n    if (animateOpenTimerRef.current) {\\n      return noop$2;\\n    }\\n\\n    animateOpenTimerRef.current = setTimeout(function () {\\n      animateOpenTimerRef.current = null;\\n      setIsAnimatingOpenOnMount(false);\\n    });\\n    return tryClearAnimateOpenTimer;\\n  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);\\n  var onSizeChangeEnd = useMemoOne.useCallback(function (event) {\\n    if (event.propertyName !== 'height') {\\n      return;\\n    }\\n\\n    onTransitionEnd();\\n\\n    if (animate === 'close') {\\n      onClose();\\n    }\\n  }, [animate, onClose, onTransitionEnd]);\\n  var style = getStyle({\\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\\n    animate: props.animate,\\n    placeholder: props.placeholder\\n  });\\n  return React__default.createElement(props.placeholder.tagName, {\\n    style: style,\\n    'data-rbd-placeholder-context-id': contextId,\\n    onTransitionEnd: onSizeChangeEnd,\\n    ref: props.innerRef\\n  });\\n}\\n\\nvar Placeholder$1 = React__default.memo(Placeholder);\\n\\nvar DroppableContext = React__default.createContext(null);\\n\\nfunction checkIsValidInnerRef(el) {\\n  !(el && isHtmlElement(el)) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"\\\\n    provided.innerRef has not been provided with a HTMLElement.\\\\n\\\\n    You can find a guide on using the innerRef callback functions at:\\\\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\\\\n  \\\") : invariant(false) : void 0;\\n}\\n\\nfunction isBoolean(value) {\\n  return typeof value === 'boolean';\\n}\\n\\nfunction runChecks(args, checks) {\\n  checks.forEach(function (check) {\\n    return check(args);\\n  });\\n}\\n\\nvar shared = [function required(_ref) {\\n  var props = _ref.props;\\n  !props.droppableId ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'A Droppable requires a droppableId prop') : invariant(false) : void 0;\\n  !(typeof props.droppableId === 'string') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"A Droppable requires a [string] droppableId. Provided: [\\\" + typeof props.droppableId + \\\"]\\\") : invariant(false) : void 0;\\n}, function _boolean(_ref2) {\\n  var props = _ref2.props;\\n  !isBoolean(props.isDropDisabled) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'isDropDisabled must be a boolean') : invariant(false) : void 0;\\n  !isBoolean(props.isCombineEnabled) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'isCombineEnabled must be a boolean') : invariant(false) : void 0;\\n  !isBoolean(props.ignoreContainerClipping) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'ignoreContainerClipping must be a boolean') : invariant(false) : void 0;\\n}, function ref(_ref3) {\\n  var getDroppableRef = _ref3.getDroppableRef;\\n  checkIsValidInnerRef(getDroppableRef());\\n}];\\nvar standard = [function placeholder(_ref4) {\\n  var props = _ref4.props,\\n      getPlaceholderRef = _ref4.getPlaceholderRef;\\n\\n  if (!props.placeholder) {\\n    return;\\n  }\\n\\n  var ref = getPlaceholderRef();\\n\\n  if (ref) {\\n    return;\\n  }\\n\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(\\\"\\\\n      Droppable setup issue [droppableId: \\\\\\\"\\\" + props.droppableId + \\\"\\\\\\\"]:\\\\n      DroppableProvided > placeholder could not be found.\\\\n\\\\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\\\\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\\\\n    \\\") : void 0;\\n}];\\nvar virtual = [function hasClone(_ref5) {\\n  var props = _ref5.props;\\n  !props.renderClone ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Must provide a clone render function (renderClone) for virtual lists') : invariant(false) : void 0;\\n}, function hasNoPlaceholder(_ref6) {\\n  var getPlaceholderRef = _ref6.getPlaceholderRef;\\n  !!getPlaceholderRef() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Expected virtual list to not have a placeholder') : invariant(false) : void 0;\\n}];\\nfunction useValidation(args) {\\n  useDevSetupWarning(function () {\\n    runChecks(args, shared);\\n\\n    if (args.props.mode === 'standard') {\\n      runChecks(args, standard);\\n    }\\n\\n    if (args.props.mode === 'virtual') {\\n      runChecks(args, virtual);\\n    }\\n  });\\n}\\n\\nvar AnimateInOut = function (_React$PureComponent) {\\n  _inheritsLoose(AnimateInOut, _React$PureComponent);\\n\\n  function AnimateInOut() {\\n    var _this;\\n\\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\\n    _this.state = {\\n      isVisible: Boolean(_this.props.on),\\n      data: _this.props.on,\\n      animate: _this.props.shouldAnimate && _this.props.on ? 'open' : 'none'\\n    };\\n\\n    _this.onClose = function () {\\n      if (_this.state.animate !== 'close') {\\n        return;\\n      }\\n\\n      _this.setState({\\n        isVisible: false\\n      });\\n    };\\n\\n    return _this;\\n  }\\n\\n  AnimateInOut.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\\n    if (!props.shouldAnimate) {\\n      return {\\n        isVisible: Boolean(props.on),\\n        data: props.on,\\n        animate: 'none'\\n      };\\n    }\\n\\n    if (props.on) {\\n      return {\\n        isVisible: true,\\n        data: props.on,\\n        animate: 'open'\\n      };\\n    }\\n\\n    if (state.isVisible) {\\n      return {\\n        isVisible: true,\\n        data: state.data,\\n        animate: 'close'\\n      };\\n    }\\n\\n    return {\\n      isVisible: false,\\n      animate: 'close',\\n      data: null\\n    };\\n  };\\n\\n  var _proto = AnimateInOut.prototype;\\n\\n  _proto.render = function render() {\\n    if (!this.state.isVisible) {\\n      return null;\\n    }\\n\\n    var provided = {\\n      onClose: this.onClose,\\n      data: this.state.data,\\n      animate: this.state.animate\\n    };\\n    return this.props.children(provided);\\n  };\\n\\n  return AnimateInOut;\\n}(React__default.PureComponent);\\n\\nvar zIndexOptions = {\\n  dragging: 5000,\\n  dropAnimating: 4500\\n};\\n\\nvar getDraggingTransition = function getDraggingTransition(shouldAnimateDragMovement, dropping) {\\n  if (dropping) {\\n    return transitions.drop(dropping.duration);\\n  }\\n\\n  if (shouldAnimateDragMovement) {\\n    return transitions.snap;\\n  }\\n\\n  return transitions.fluid;\\n};\\n\\nvar getDraggingOpacity = function getDraggingOpacity(isCombining, isDropAnimating) {\\n  if (!isCombining) {\\n    return null;\\n  }\\n\\n  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\\n};\\n\\nvar getShouldDraggingAnimate = function getShouldDraggingAnimate(dragging) {\\n  if (dragging.forceShouldAnimate != null) {\\n    return dragging.forceShouldAnimate;\\n  }\\n\\n  return dragging.mode === 'SNAP';\\n};\\n\\nfunction getDraggingStyle(dragging) {\\n  var dimension = dragging.dimension;\\n  var box = dimension.client;\\n  var offset = dragging.offset,\\n      combineWith = dragging.combineWith,\\n      dropping = dragging.dropping;\\n  var isCombining = Boolean(combineWith);\\n  var shouldAnimate = getShouldDraggingAnimate(dragging);\\n  var isDropAnimating = Boolean(dropping);\\n  var transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\\n  var style = {\\n    position: 'fixed',\\n    top: box.marginBox.top,\\n    left: box.marginBox.left,\\n    boxSizing: 'border-box',\\n    width: box.borderBox.width,\\n    height: box.borderBox.height,\\n    transition: getDraggingTransition(shouldAnimate, dropping),\\n    transform: transform,\\n    opacity: getDraggingOpacity(isCombining, isDropAnimating),\\n    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\\n    pointerEvents: 'none'\\n  };\\n  return style;\\n}\\n\\nfunction getSecondaryStyle(secondary) {\\n  return {\\n    transform: transforms.moveTo(secondary.offset),\\n    transition: secondary.shouldAnimateDisplacement ? null : 'none'\\n  };\\n}\\n\\nfunction getStyle$1(mapped) {\\n  return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\\n}\\n\\nfunction getDimension$1(descriptor, el, windowScroll) {\\n  if (windowScroll === void 0) {\\n    windowScroll = origin;\\n  }\\n\\n  var computedStyles = window.getComputedStyle(el);\\n  var borderBox = el.getBoundingClientRect();\\n  var client = cssBoxModel.calculateBox(borderBox, computedStyles);\\n  var page = cssBoxModel.withScroll(client, windowScroll);\\n  var placeholder = {\\n    client: client,\\n    tagName: el.tagName.toLowerCase(),\\n    display: computedStyles.display\\n  };\\n  var displaceBy = {\\n    x: client.marginBox.width,\\n    y: client.marginBox.height\\n  };\\n  var dimension = {\\n    descriptor: descriptor,\\n    placeholder: placeholder,\\n    displaceBy: displaceBy,\\n    client: client,\\n    page: page\\n  };\\n  return dimension;\\n}\\n\\nfunction useDraggablePublisher(args) {\\n  var uniqueId = useUniqueId('draggable');\\n  var descriptor = args.descriptor,\\n      registry = args.registry,\\n      getDraggableRef = args.getDraggableRef,\\n      canDragInteractiveElements = args.canDragInteractiveElements,\\n      shouldRespectForcePress = args.shouldRespectForcePress,\\n      isEnabled = args.isEnabled;\\n  var options = useMemoOne.useMemo(function () {\\n    return {\\n      canDragInteractiveElements: canDragInteractiveElements,\\n      shouldRespectForcePress: shouldRespectForcePress,\\n      isEnabled: isEnabled\\n    };\\n  }, [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);\\n  var getDimension = useMemoOne.useCallback(function (windowScroll) {\\n    var el = getDraggableRef();\\n    !el ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Cannot get dimension when no ref is set') : invariant(false) : void 0;\\n    return getDimension$1(descriptor, el, windowScroll);\\n  }, [descriptor, getDraggableRef]);\\n  var entry = useMemoOne.useMemo(function () {\\n    return {\\n      uniqueId: uniqueId,\\n      descriptor: descriptor,\\n      options: options,\\n      getDimension: getDimension\\n    };\\n  }, [descriptor, getDimension, options, uniqueId]);\\n  var publishedRef = React.useRef(entry);\\n  var isFirstPublishRef = React.useRef(true);\\n  useIsomorphicLayoutEffect(function () {\\n    registry.draggable.register(publishedRef.current);\\n    return function () {\\n      return registry.draggable.unregister(publishedRef.current);\\n    };\\n  }, [registry.draggable]);\\n  useIsomorphicLayoutEffect(function () {\\n    if (isFirstPublishRef.current) {\\n      isFirstPublishRef.current = false;\\n      return;\\n    }\\n\\n    var last = publishedRef.current;\\n    publishedRef.current = entry;\\n    registry.draggable.update(entry, last);\\n  }, [entry, registry.draggable]);\\n}\\n\\nfunction useValidation$1(props, contextId, getRef) {\\n  useDevSetupWarning(function () {\\n    function prefix(id) {\\n      return \\\"Draggable[id: \\\" + id + \\\"]: \\\";\\n    }\\n\\n    var id = props.draggableId;\\n    !id ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Draggable requires a draggableId') : invariant(false) : void 0;\\n    !(typeof id === 'string') ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Draggable requires a [string] draggableId.\\\\n      Provided: [type: \\\" + typeof id + \\\"] (value: \\\" + id + \\\")\\\") : invariant(false) : void 0;\\n    !_Number$isInteger(props.index) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, prefix(id) + \\\" requires an integer index prop\\\") : invariant(false) : void 0;\\n\\n    if (props.mapped.type === 'DRAGGING') {\\n      return;\\n    }\\n\\n    checkIsValidInnerRef(getRef());\\n\\n    if (props.isEnabled) {\\n      !findDragHandle(contextId, id) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, prefix(id) + \\\" Unable to find drag handle\\\") : invariant(false) : void 0;\\n    }\\n  });\\n}\\nfunction useClonePropValidation(isClone) {\\n  useDev(function () {\\n    var initialRef = React.useRef(isClone);\\n    useDevSetupWarning(function () {\\n      !(isClone === initialRef.current) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Draggable isClone prop value changed during component life') : invariant(false) : void 0;\\n    }, [isClone]);\\n  });\\n}\\n\\nfunction preventHtml5Dnd(event) {\\n  event.preventDefault();\\n}\\n\\nfunction Draggable(props) {\\n  var ref = React.useRef(null);\\n  var setRef = useMemoOne.useCallback(function (el) {\\n    ref.current = el;\\n  }, []);\\n  var getRef = useMemoOne.useCallback(function () {\\n    return ref.current;\\n  }, []);\\n\\n  var _useRequiredContext = useRequiredContext(AppContext),\\n      contextId = _useRequiredContext.contextId,\\n      liftInstructionId = _useRequiredContext.liftInstructionId,\\n      registry = _useRequiredContext.registry;\\n\\n  var _useRequiredContext2 = useRequiredContext(DroppableContext),\\n      type = _useRequiredContext2.type,\\n      droppableId = _useRequiredContext2.droppableId;\\n\\n  var descriptor = useMemoOne.useMemo(function () {\\n    return {\\n      id: props.draggableId,\\n      index: props.index,\\n      type: type,\\n      droppableId: droppableId\\n    };\\n  }, [props.draggableId, props.index, type, droppableId]);\\n  var children = props.children,\\n      draggableId = props.draggableId,\\n      isEnabled = props.isEnabled,\\n      shouldRespectForcePress = props.shouldRespectForcePress,\\n      canDragInteractiveElements = props.canDragInteractiveElements,\\n      isClone = props.isClone,\\n      mapped = props.mapped,\\n      dropAnimationFinishedAction = props.dropAnimationFinished;\\n  useValidation$1(props, contextId, getRef);\\n  useClonePropValidation(isClone);\\n\\n  if (!isClone) {\\n    var forPublisher = useMemoOne.useMemo(function () {\\n      return {\\n        descriptor: descriptor,\\n        registry: registry,\\n        getDraggableRef: getRef,\\n        canDragInteractiveElements: canDragInteractiveElements,\\n        shouldRespectForcePress: shouldRespectForcePress,\\n        isEnabled: isEnabled\\n      };\\n    }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);\\n    useDraggablePublisher(forPublisher);\\n  }\\n\\n  var dragHandleProps = useMemoOne.useMemo(function () {\\n    return isEnabled ? {\\n      tabIndex: 0,\\n      'data-rbd-drag-handle-draggable-id': draggableId,\\n      'data-rbd-drag-handle-context-id': contextId,\\n      'aria-labelledby': liftInstructionId,\\n      draggable: false,\\n      onDragStart: preventHtml5Dnd\\n    } : null;\\n  }, [contextId, draggableId, isEnabled, liftInstructionId]);\\n  var onMoveEnd = useMemoOne.useCallback(function (event) {\\n    if (mapped.type !== 'DRAGGING') {\\n      return;\\n    }\\n\\n    if (!mapped.dropping) {\\n      return;\\n    }\\n\\n    if (event.propertyName !== 'transform') {\\n      return;\\n    }\\n\\n    dropAnimationFinishedAction();\\n  }, [dropAnimationFinishedAction, mapped]);\\n  var provided = useMemoOne.useMemo(function () {\\n    var style = getStyle$1(mapped);\\n    var onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : null;\\n    var result = {\\n      innerRef: setRef,\\n      draggableProps: {\\n        'data-rbd-draggable-context-id': contextId,\\n        'data-rbd-draggable-id': draggableId,\\n        style: style,\\n        onTransitionEnd: onTransitionEnd\\n      },\\n      dragHandleProps: dragHandleProps\\n    };\\n    return result;\\n  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);\\n  var rubric = useMemoOne.useMemo(function () {\\n    return {\\n      draggableId: descriptor.id,\\n      type: descriptor.type,\\n      source: {\\n        index: descriptor.index,\\n        droppableId: descriptor.droppableId\\n      }\\n    };\\n  }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);\\n  return children(provided, mapped.snapshot, rubric);\\n}\\n\\nvar isStrictEqual = (function (a, b) {\\n  return a === b;\\n});\\n\\nvar whatIsDraggedOverFromResult = (function (result) {\\n  var combine = result.combine,\\n      destination = result.destination;\\n\\n  if (destination) {\\n    return destination.droppableId;\\n  }\\n\\n  if (combine) {\\n    return combine.droppableId;\\n  }\\n\\n  return null;\\n});\\n\\nvar getCombineWithFromResult = function getCombineWithFromResult(result) {\\n  return result.combine ? result.combine.draggableId : null;\\n};\\n\\nvar getCombineWithFromImpact = function getCombineWithFromImpact(impact) {\\n  return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;\\n};\\n\\nfunction getDraggableSelector() {\\n  var memoizedOffset = memoizeOne(function (x, y) {\\n    return {\\n      x: x,\\n      y: y\\n    };\\n  });\\n  var getMemoizedSnapshot = memoizeOne(function (mode, isClone, draggingOver, combineWith, dropping) {\\n    return {\\n      isDragging: true,\\n      isClone: isClone,\\n      isDropAnimating: Boolean(dropping),\\n      dropAnimation: dropping,\\n      mode: mode,\\n      draggingOver: draggingOver,\\n      combineWith: combineWith,\\n      combineTargetFor: null\\n    };\\n  });\\n  var getMemoizedProps = memoizeOne(function (offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {\\n    return {\\n      mapped: {\\n        type: 'DRAGGING',\\n        dropping: null,\\n        draggingOver: draggingOver,\\n        combineWith: combineWith,\\n        mode: mode,\\n        offset: offset,\\n        dimension: dimension,\\n        forceShouldAnimate: forceShouldAnimate,\\n        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\\n      }\\n    };\\n  });\\n\\n  var selector = function selector(state, ownProps) {\\n    if (state.isDragging) {\\n      if (state.critical.draggable.id !== ownProps.draggableId) {\\n        return null;\\n      }\\n\\n      var offset = state.current.client.offset;\\n      var dimension = state.dimensions.draggables[ownProps.draggableId];\\n      var draggingOver = whatIsDraggedOver(state.impact);\\n      var combineWith = getCombineWithFromImpact(state.impact);\\n      var forceShouldAnimate = state.forceShouldAnimate;\\n      return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\\n    }\\n\\n    if (state.phase === 'DROP_ANIMATING') {\\n      var completed = state.completed;\\n\\n      if (completed.result.draggableId !== ownProps.draggableId) {\\n        return null;\\n      }\\n\\n      var isClone = ownProps.isClone;\\n      var _dimension = state.dimensions.draggables[ownProps.draggableId];\\n      var result = completed.result;\\n      var mode = result.mode;\\n\\n      var _draggingOver = whatIsDraggedOverFromResult(result);\\n\\n      var _combineWith = getCombineWithFromResult(result);\\n\\n      var duration = state.dropDuration;\\n      var dropping = {\\n        duration: duration,\\n        curve: curves.drop,\\n        moveTo: state.newHomeClientOffset,\\n        opacity: _combineWith ? combine.opacity.drop : null,\\n        scale: _combineWith ? combine.scale.drop : null\\n      };\\n      return {\\n        mapped: {\\n          type: 'DRAGGING',\\n          offset: state.newHomeClientOffset,\\n          dimension: _dimension,\\n          dropping: dropping,\\n          draggingOver: _draggingOver,\\n          combineWith: _combineWith,\\n          mode: mode,\\n          forceShouldAnimate: null,\\n          snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)\\n        }\\n      };\\n    }\\n\\n    return null;\\n  };\\n\\n  return selector;\\n}\\n\\nfunction getSecondarySnapshot(combineTargetFor) {\\n  return {\\n    isDragging: false,\\n    isDropAnimating: false,\\n    isClone: false,\\n    dropAnimation: null,\\n    mode: null,\\n    draggingOver: null,\\n    combineTargetFor: combineTargetFor,\\n    combineWith: null\\n  };\\n}\\n\\nvar atRest = {\\n  mapped: {\\n    type: 'SECONDARY',\\n    offset: origin,\\n    combineTargetFor: null,\\n    shouldAnimateDisplacement: true,\\n    snapshot: getSecondarySnapshot(null)\\n  }\\n};\\n\\nfunction getSecondarySelector() {\\n  var memoizedOffset = memoizeOne(function (x, y) {\\n    return {\\n      x: x,\\n      y: y\\n    };\\n  });\\n  var getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);\\n  var getMemoizedProps = memoizeOne(function (offset, combineTargetFor, shouldAnimateDisplacement) {\\n    if (combineTargetFor === void 0) {\\n      combineTargetFor = null;\\n    }\\n\\n    return {\\n      mapped: {\\n        type: 'SECONDARY',\\n        offset: offset,\\n        combineTargetFor: combineTargetFor,\\n        shouldAnimateDisplacement: shouldAnimateDisplacement,\\n        snapshot: getMemoizedSnapshot(combineTargetFor)\\n      }\\n    };\\n  });\\n\\n  var getFallback = function getFallback(combineTargetFor) {\\n    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\\n  };\\n\\n  var getProps = function getProps(ownId, draggingId, impact, afterCritical) {\\n    var visualDisplacement = impact.displaced.visible[ownId];\\n    var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\\n    var combine = tryGetCombine(impact);\\n    var combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\\n\\n    if (!visualDisplacement) {\\n      if (!isAfterCriticalInVirtualList) {\\n        return getFallback(combineTargetFor);\\n      }\\n\\n      if (impact.displaced.invisible[ownId]) {\\n        return null;\\n      }\\n\\n      var change = negate(afterCritical.displacedBy.point);\\n\\n      var _offset = memoizedOffset(change.x, change.y);\\n\\n      return getMemoizedProps(_offset, combineTargetFor, true);\\n    }\\n\\n    if (isAfterCriticalInVirtualList) {\\n      return getFallback(combineTargetFor);\\n    }\\n\\n    var displaceBy = impact.displacedBy.point;\\n    var offset = memoizedOffset(displaceBy.x, displaceBy.y);\\n    return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\\n  };\\n\\n  var selector = function selector(state, ownProps) {\\n    if (state.isDragging) {\\n      if (state.critical.draggable.id === ownProps.draggableId) {\\n        return null;\\n      }\\n\\n      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\\n    }\\n\\n    if (state.phase === 'DROP_ANIMATING') {\\n      var completed = state.completed;\\n\\n      if (completed.result.draggableId === ownProps.draggableId) {\\n        return null;\\n      }\\n\\n      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\\n    }\\n\\n    return null;\\n  };\\n\\n  return selector;\\n}\\n\\nvar makeMapStateToProps = function makeMapStateToProps() {\\n  var draggingSelector = getDraggableSelector();\\n  var secondarySelector = getSecondarySelector();\\n\\n  var selector = function selector(state, ownProps) {\\n    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\\n  };\\n\\n  return selector;\\n};\\nvar mapDispatchToProps = {\\n  dropAnimationFinished: dropAnimationFinished\\n};\\nvar ConnectedDraggable = reactRedux.connect(makeMapStateToProps, mapDispatchToProps, null, {\\n  context: StoreContext,\\n  pure: true,\\n  areStatePropsEqual: isStrictEqual\\n})(Draggable);\\n\\nfunction PrivateDraggable(props) {\\n  var droppableContext = useRequiredContext(DroppableContext);\\n  var isUsingCloneFor = droppableContext.isUsingCloneFor;\\n\\n  if (isUsingCloneFor === props.draggableId && !props.isClone) {\\n    return null;\\n  }\\n\\n  return React__default.createElement(ConnectedDraggable, props);\\n}\\nfunction PublicDraggable(props) {\\n  var isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;\\n  var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\\n  var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\\n  return React__default.createElement(PrivateDraggable, _extends({}, props, {\\n    isClone: false,\\n    isEnabled: isEnabled,\\n    canDragInteractiveElements: canDragInteractiveElements,\\n    shouldRespectForcePress: shouldRespectForcePress\\n  }));\\n}\\n\\nfunction Droppable(props) {\\n  var appContext = React.useContext(AppContext);\\n  !appContext ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'Could not find app context') : invariant(false) : void 0;\\n  var contextId = appContext.contextId,\\n      isMovementAllowed = appContext.isMovementAllowed;\\n  var droppableRef = React.useRef(null);\\n  var placeholderRef = React.useRef(null);\\n  var children = props.children,\\n      droppableId = props.droppableId,\\n      type = props.type,\\n      mode = props.mode,\\n      direction = props.direction,\\n      ignoreContainerClipping = props.ignoreContainerClipping,\\n      isDropDisabled = props.isDropDisabled,\\n      isCombineEnabled = props.isCombineEnabled,\\n      snapshot = props.snapshot,\\n      useClone = props.useClone,\\n      updateViewportMaxScroll = props.updateViewportMaxScroll,\\n      getContainerForClone = props.getContainerForClone;\\n  var getDroppableRef = useMemoOne.useCallback(function () {\\n    return droppableRef.current;\\n  }, []);\\n  var setDroppableRef = useMemoOne.useCallback(function (value) {\\n    droppableRef.current = value;\\n  }, []);\\n  var getPlaceholderRef = useMemoOne.useCallback(function () {\\n    return placeholderRef.current;\\n  }, []);\\n  var setPlaceholderRef = useMemoOne.useCallback(function (value) {\\n    placeholderRef.current = value;\\n  }, []);\\n  useValidation({\\n    props: props,\\n    getDroppableRef: getDroppableRef,\\n    getPlaceholderRef: getPlaceholderRef\\n  });\\n  var onPlaceholderTransitionEnd = useMemoOne.useCallback(function () {\\n    if (isMovementAllowed()) {\\n      updateViewportMaxScroll({\\n        maxScroll: getMaxWindowScroll()\\n      });\\n    }\\n  }, [isMovementAllowed, updateViewportMaxScroll]);\\n  useDroppablePublisher({\\n    droppableId: droppableId,\\n    type: type,\\n    mode: mode,\\n    direction: direction,\\n    isDropDisabled: isDropDisabled,\\n    isCombineEnabled: isCombineEnabled,\\n    ignoreContainerClipping: ignoreContainerClipping,\\n    getDroppableRef: getDroppableRef\\n  });\\n  var placeholder = React__default.createElement(AnimateInOut, {\\n    on: props.placeholder,\\n    shouldAnimate: props.shouldAnimatePlaceholder\\n  }, function (_ref) {\\n    var onClose = _ref.onClose,\\n        data = _ref.data,\\n        animate = _ref.animate;\\n    return React__default.createElement(Placeholder$1, {\\n      placeholder: data,\\n      onClose: onClose,\\n      innerRef: setPlaceholderRef,\\n      animate: animate,\\n      contextId: contextId,\\n      onTransitionEnd: onPlaceholderTransitionEnd\\n    });\\n  });\\n  var provided = useMemoOne.useMemo(function () {\\n    return {\\n      innerRef: setDroppableRef,\\n      placeholder: placeholder,\\n      droppableProps: {\\n        'data-rbd-droppable-id': droppableId,\\n        'data-rbd-droppable-context-id': contextId\\n      }\\n    };\\n  }, [contextId, droppableId, placeholder, setDroppableRef]);\\n  var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\\n  var droppableContext = useMemoOne.useMemo(function () {\\n    return {\\n      droppableId: droppableId,\\n      type: type,\\n      isUsingCloneFor: isUsingCloneFor\\n    };\\n  }, [droppableId, isUsingCloneFor, type]);\\n\\n  function getClone() {\\n    if (!useClone) {\\n      return null;\\n    }\\n\\n    var dragging = useClone.dragging,\\n        render = useClone.render;\\n    var node = React__default.createElement(PrivateDraggable, {\\n      draggableId: dragging.draggableId,\\n      index: dragging.source.index,\\n      isClone: true,\\n      isEnabled: true,\\n      shouldRespectForcePress: false,\\n      canDragInteractiveElements: true\\n    }, function (draggableProvided, draggableSnapshot) {\\n      return render(draggableProvided, draggableSnapshot, dragging);\\n    });\\n    return ReactDOM.createPortal(node, getContainerForClone());\\n  }\\n\\n  return React__default.createElement(DroppableContext.Provider, {\\n    value: droppableContext\\n  }, children(provided, snapshot), getClone());\\n}\\n\\nvar isMatchingType = function isMatchingType(type, critical) {\\n  return type === critical.droppable.type;\\n};\\n\\nvar getDraggable = function getDraggable(critical, dimensions) {\\n  return dimensions.draggables[critical.draggable.id];\\n};\\n\\nvar makeMapStateToProps$1 = function makeMapStateToProps() {\\n  var idleWithAnimation = {\\n    placeholder: null,\\n    shouldAnimatePlaceholder: true,\\n    snapshot: {\\n      isDraggingOver: false,\\n      draggingOverWith: null,\\n      draggingFromThisWith: null,\\n      isUsingPlaceholder: false\\n    },\\n    useClone: null\\n  };\\n\\n  var idleWithoutAnimation = _extends({}, idleWithAnimation, {\\n    shouldAnimatePlaceholder: false\\n  });\\n\\n  var getDraggableRubric = memoizeOne(function (descriptor) {\\n    return {\\n      draggableId: descriptor.id,\\n      type: descriptor.type,\\n      source: {\\n        index: descriptor.index,\\n        droppableId: descriptor.droppableId\\n      }\\n    };\\n  });\\n  var getMapProps = memoizeOne(function (id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {\\n    var draggableId = dragging.descriptor.id;\\n    var isHome = dragging.descriptor.droppableId === id;\\n\\n    if (isHome) {\\n      var useClone = renderClone ? {\\n        render: renderClone,\\n        dragging: getDraggableRubric(dragging.descriptor)\\n      } : null;\\n      var _snapshot = {\\n        isDraggingOver: isDraggingOverForConsumer,\\n        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\\n        draggingFromThisWith: draggableId,\\n        isUsingPlaceholder: true\\n      };\\n      return {\\n        placeholder: dragging.placeholder,\\n        shouldAnimatePlaceholder: false,\\n        snapshot: _snapshot,\\n        useClone: useClone\\n      };\\n    }\\n\\n    if (!isEnabled) {\\n      return idleWithoutAnimation;\\n    }\\n\\n    if (!isDraggingOverForImpact) {\\n      return idleWithAnimation;\\n    }\\n\\n    var snapshot = {\\n      isDraggingOver: isDraggingOverForConsumer,\\n      draggingOverWith: draggableId,\\n      draggingFromThisWith: null,\\n      isUsingPlaceholder: true\\n    };\\n    return {\\n      placeholder: dragging.placeholder,\\n      shouldAnimatePlaceholder: true,\\n      snapshot: snapshot,\\n      useClone: null\\n    };\\n  });\\n\\n  var selector = function selector(state, ownProps) {\\n    var id = ownProps.droppableId;\\n    var type = ownProps.type;\\n    var isEnabled = !ownProps.isDropDisabled;\\n    var renderClone = ownProps.renderClone;\\n\\n    if (state.isDragging) {\\n      var critical = state.critical;\\n\\n      if (!isMatchingType(type, critical)) {\\n        return idleWithoutAnimation;\\n      }\\n\\n      var dragging = getDraggable(critical, state.dimensions);\\n      var isDraggingOver = whatIsDraggedOver(state.impact) === id;\\n      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\\n    }\\n\\n    if (state.phase === 'DROP_ANIMATING') {\\n      var completed = state.completed;\\n\\n      if (!isMatchingType(type, completed.critical)) {\\n        return idleWithoutAnimation;\\n      }\\n\\n      var _dragging = getDraggable(completed.critical, state.dimensions);\\n\\n      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);\\n    }\\n\\n    if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {\\n      var _completed = state.completed;\\n\\n      if (!isMatchingType(type, _completed.critical)) {\\n        return idleWithoutAnimation;\\n      }\\n\\n      var wasOver = whatIsDraggedOver(_completed.impact) === id;\\n      var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === 'COMBINE');\\n      var isHome = _completed.critical.droppable.id === id;\\n\\n      if (wasOver) {\\n        return wasCombining ? idleWithAnimation : idleWithoutAnimation;\\n      }\\n\\n      if (isHome) {\\n        return idleWithAnimation;\\n      }\\n\\n      return idleWithoutAnimation;\\n    }\\n\\n    return idleWithoutAnimation;\\n  };\\n\\n  return selector;\\n};\\nvar mapDispatchToProps$1 = {\\n  updateViewportMaxScroll: updateViewportMaxScroll\\n};\\n\\nfunction getBody() {\\n  !document.body ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'document.body is not ready') : invariant(false) : void 0;\\n  return document.body;\\n}\\n\\nvar defaultProps = {\\n  mode: 'standard',\\n  type: 'DEFAULT',\\n  direction: 'vertical',\\n  isDropDisabled: false,\\n  isCombineEnabled: false,\\n  ignoreContainerClipping: false,\\n  renderClone: null,\\n  getContainerForClone: getBody\\n};\\nvar ConnectedDroppable = reactRedux.connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {\\n  context: StoreContext,\\n  pure: true,\\n  areStatePropsEqual: isStrictEqual\\n})(Droppable);\\nConnectedDroppable.defaultProps = defaultProps;\\n\\nexports.DragDropContext = DragDropContext;\\nexports.Draggable = PublicDraggable;\\nexports.Droppable = ConnectedDroppable;\\nexports.resetServerContext = resetServerContext;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopDefault\",\"ex\",\"log\",\"type\",\"message\",\"_console\",\"window\",\"isDisabledFlag\",\"console\",\"apply\",\"replace\",\"spacesAndTabs\",\"lineStartWithSpaces\",\"trim\",\"noop\",\"bindEvents\",\"el\",\"bindings\",\"sharedOptions\",\"unbindings\",\"map\",\"binding\",\"options\",\"_extends\",\"addEventListener\",\"eventName\",\"fn\",\"unbind\",\"removeEventListener\",\"unbindAll\",\"forEach\",\"RbdInvariant\",\"invariant\",\"condition\",\"findIndex\",\"list\",\"predicate\",\"i\",\"length\",\"find\",\"index\",\"tryGetDestination\",\"impact\",\"at\",\"destination\",\"tryGetCombine\",\"combine\",\"getDisplacementGroups\",\"_ref\",\"displacedBy\",\"viewport\",\"forceShouldAnimate\",\"last\",\"afterDragging\",\"reduce\",\"process\",\"groups\",\"draggable\",\"cssBoxModel\",\"getRect\",\"expand\",\"page\",\"marginBox\",\"expandBy\",\"top\",\"point\",\"y\",\"right\",\"bottom\",\"left\",\"x\",\"id\",\"descriptor\",\"all\",\"push\",\"isVisible\",\"args\",\"target\",\"withDroppableDisplacement\",\"isVisibleThroughFrameFn\",\"isPartiallyVisibleThroughFrame\",\"invisible\",\"visible\",\"previous\",\"shouldAnimate\",\"displacement\",\"draggableId\",\"goAtEnd\",\"insideDestination\",\"inHomeList\",\"indexOfLastItem\",\"displaced\",\"emptyGroups\",\"droppableId\",\"newIndex\",\"calculateReorderImpact\",\"_ref2\",\"isHomeOf\",\"match\",\"item\",\"withoutDragging\",\"removeDraggableFromList\",\"sliceFrom\",\"indexOf\",\"impacted\",\"slice\",\"frame\",\"getDraggables\",\"ids\",\"draggables\",\"isMovementAllowed\",\"state\",\"phase\",\"atIndex\",\"closest\",\"calculateCombineImpact\",\"combineWithId\",\"destinationId\",\"userDirection\",\"previousImpact\",\"lastCombineImpact\",\"whenEntered\",\"getDraggables$1\",\"removeScrollJumpRequest\",\"isDragging\",\"movementMode\",\"scrollJumpRequest\",\"checkIndexes\",\"indexes\",\"d\",\"errors\",\"current\",\"_Object$keys\",\"formatted\",\"hasError\",\"join\",\"warning\",\"getWindowScrollBinding\",\"update\",\"passive\",\"capture\",\"event\",\"document\",\"getScrollListener\",\"isActive\",\"onWindowScroll\",\"scheduled\",\"rafSchd\",\"updateScroll\",\"pageXOffset\",\"pageYOffset\",\"start\",\"stop\",\"cancel\",\"createPublisher\",\"registry\",\"callbacks\",\"staging\",\"clean$1\",\"frameId\",\"collect\",\"collectionStarting\",\"requestAnimationFrame\",\"_staging\",\"removals\",\"modified\",\"added\",\"additions\",\"getById\",\"getDimension\",\"origin\",\"sort\",\"a\",\"b\",\"updated\",\"scroll\",\"droppable\",\"entry\",\"getScrollWhileDragging\",\"result\",\"publish\",\"add\",\"remove\",\"cancelAnimationFrame\",\"shouldPublishUpdate\",\"dragging\",\"home\",\"mode\",\"useStyleMarshal\",\"contextId\",\"nonce\",\"styles\",\"useMemoOne\",\"useMemo\",\"getSelector\",\"makeGetSelector\",\"dragHandle$1\",\"selector\",\"dragHandle\",\"always\",\"resting\",\"grabCursor\",\"noPointerEvents\",\"dropAnimating\",\"transition\",\"transitions\",\"outOfTheWay\",\"userCancel\",\"droppable$1\",\"rules\",\"draggable$1\",\"body\",\"getStyles\",\"alwaysRef\",\"React\",\"useRef\",\"dynamicRef\",\"setDynamicStyle\",\"useCallback\",\"memoizeOne\",\"proposed\",\"textContent\",\"setAlwaysStyle\",\"useIsomorphicLayoutEffect\",\"createStyleEl\",\"dynamic\",\"setAttribute\",\"getHead\",\"appendChild\",\"ref\",\"removeChild\",\"dropping\",\"reason\",\"marshal\",\"isHtmlElement\",\"HTMLElement\",\"ownerDocument\",\"defaultView\",\"findDragHandle\",\"possible\",\"Array\",\"prototype\",\"call\",\"querySelectorAll\",\"handle\",\"getAttribute\",\"useFocusMarshal\",\"entriesRef\",\"recordRef\",\"restoreFocusFrameRef\",\"isMountedRef\",\"register\",\"focus\",\"unregister\",\"entries\",\"tryGiveFocus\",\"tryGiveFocusTo\",\"activeElement\",\"tryShiftRecord\",\"redirectTo\",\"tryRestoreFocusRecorded\",\"record\",\"tryRecordFocus\",\"focused\",\"clearFrameOnUnmount\",\"createRegistry\",\"notify\",\"subscribers\",\"cb\",\"findDraggableById\",\"findDroppableById\",\"droppables\",\"draggableAPI\",\"value\",\"uniqueId\",\"getDraggableById\",\"findById\",\"exists\",\"getAllByType\",\"_Object$values\",\"filter\",\"droppableAPI\",\"getDroppableById\",\"subscribe\",\"unsubscribe\",\"splice\",\"clean\",\"useRegistry\",\"useEffect\",\"unmount\",\"useAnnouncer\",\"createElement\",\"_Object$assign\",\"style\",\"visuallyHidden\",\"getBodyElement\",\"setTimeout\",\"toBeRemoved\",\"announce\",\"useLiftInstruction\",\"liftInstruction\",\"mount\",\"useDevSetupWarning\",\"inputs\",\"useHook\",\"e\",\"error\",\"useStartupValidation\",\"version\",\"React__default\",\"peerDep\",\"getVersion\",\"peerDependencies\",\"react\",\"actual\",\"actualValue\",\"major\",\"minor\",\"patch\",\"raw\",\"doctype\",\"name\",\"toLowerCase\",\"publicId\",\"usePrevious\",\"create\",\"release\",\"lock\",\"isClaimed\",\"claim\",\"abandon\",\"newLock\",\"tryAbandon\",\"getCaptureBindings\",\"completed\",\"getPhase\",\"setPhase\",\"primaryButton\",\"button\",\"clientX\",\"clientY\",\"preventDefault\",\"actions\",\"move\",\"pending\",\"sloppyClickThreshold\",\"Math\",\"abs\",\"fluidLift\",\"drop\",\"shouldBlockNextClick\",\"escape\",\"keyCode\",\"preventedKeys\",\"shouldRespectForcePress\",\"supportedEventName\",\"noop$1\",\"getDraggingBindings\",\"space\",\"arrowDown\",\"moveDown\",\"arrowUp\",\"moveUp\",\"arrowRight\",\"moveRight\",\"arrowLeft\",\"moveLeft\",\"scrollJumpKeys\",\"getWindowBindings\",\"getHandleBindings\",\"hasMoved\",\"_event$touches$\",\"touches\",\"touch\",\"forcePressThreshold\",\"force\",\"shouldRespect\",\"useValidateSensorHooks\",\"sensorHooks\",\"previousRef\",\"isAnInteractiveElement\",\"parent\",\"interactiveTagNames\",\"hasAnInteractiveTag\",\"tagName\",\"attribute\",\"parentElement\",\"isEventInInteractiveElement\",\"closestPonyfill\",\"supportedMatchesName\",\"findClosestDragHandleFromEvent\",\"Element\",\"findDraggable\",\"_isActive\",\"expected\",\"isLockActive\",\"shouldWarn\",\"canStart\",\"store\",\"lockAPI\",\"isEnabled\",\"canStartDrag\",\"getState\",\"tryStart\",\"_ref3\",\"getShouldRespectForcePress\",\"lift$1\",\"finish\",\"cleanup\",\"once\",\"dispatch\",\"payload\",\"liftActionArgs\",\"forceSensorStop\",\"sourceEvent\",\"shouldStart\",\"canDragInteractiveElements\",\"tryDispatchWhenDragging\",\"tryDispatch\",\"getAction\",\"bind\",\"preDrag\",\"clientSelection\",\"move$1\",\"client\",\"api\",\"snapLift\",\"getBoundingClientRect\",\"center\",\"moveUp$1\",\"moveRight$1\",\"moveDown$1\",\"moveLeft$1\",\"abort\",\"abortPreDrag\",\"shouldRelease\",\"useSensorMarshal\",\"_ref4\",\"useSensors\",\"concat\",\"enableDefaultSensors\",\"defaultSensors\",\"customSensors\",\"useState\",\"tryAbandonLock\",\"listenToStore\",\"canGetLock\",\"tryGetLock\",\"forceStop\",\"findClosestDraggableId\",\"findOptionsForDraggable\",\"tryReleaseLock\",\"isLockClaimed\",\"getStore\",\"lazyRef\",\"App\",\"props\",\"setCallbacks\",\"sensors\",\"lazyStoreRef\",\"lastPropsRef\",\"getResponders\",\"onBeforeDragStart\",\"onDragStart\",\"onDragEnd\",\"onDragUpdate\",\"liftInstructionId\",\"styleMarshal\",\"lazyDispatch\",\"action\",\"marshalCallbacks\",\"redux\",\"bindActionCreators\",\"publishWhileDragging\",\"updateDroppableScroll\",\"updateDroppableIsEnabled\",\"updateDroppableIsCombineEnabled\",\"dimensionMarshal\",\"createDimensionMarshal\",\"autoScroller\",\"createAutoScroller\",\"scrollWindow\",\"scrollDroppable\",\"focusMarshal\",\"createStore\",\"reducer\",\"composeEnhancers\",\"applyMiddleware\",\"dimensionMarshalStopper\",\"drop$1\",\"dropAnimationFinish\",\"dropAnimationFlushOnScroll\",\"pendingDrop\",\"autoScroll\",\"scrollListener\",\"responders\",\"tryResetStore\",\"appCallbacks\",\"tryAbort\",\"getCanLift\",\"getIsMovementAllowed\",\"appContext\",\"canLift\",\"AppContext\",\"Provider\",\"reactRedux\",\"context\",\"StoreContext\",\"children\",\"useRequiredContext\",\"Context\",\"useContext\",\"useUniqueId\",\"prefix\",\"countRef\",\"count\",\"useDroppablePublisher\",\"whileDraggingRef\",\"publishedDescriptorRef\",\"memoizedUpdateScroll\",\"getClosestScroll\",\"env\",\"closestScrollable\",\"getScroll$1\",\"scheduleScrollUpdate\",\"onClosestScroll\",\"scrollOptions\",\"shouldPublishImmediately\",\"getDimensionAndWatchScroll\",\"windowScroll\",\"getDroppableRef\",\"getClosestScrollable\",\"isFixedOnPage\",\"getIsFixed\",\"direction\",\"isDropDisabled\",\"isCombineEnabled\",\"shouldClipSubject\",\"ignoreContainerClipping\",\"base\",\"getBox\",\"paddingBox\",\"scrollTop\",\"scrollLeft\",\"borderBox\",\"scrollWidth\",\"scrollHeight\",\"border\",\"createBox\",\"margin\",\"padding\",\"withScroll\",\"frameClient\",\"scrollSize\",\"maxScroll\",\"getMaxScroll\",\"height\",\"width\",\"pageMarginBox\",\"initial\",\"max\",\"diff\",\"axis\",\"vertical\",\"horizontal\",\"subject\",\"getSubject\",\"withPlaceholder\",\"dimension\",\"scrollable\",\"scrollContainer\",\"immediate\",\"delayed\",\"anotherScrollParent\",\"dragStopped\",\"removeAttribute\",\"change\",\"noop$2\",\"checkIsValidInnerRef\",\"runChecks\",\"checks\",\"check\",\"useValidation\",\"shared\",\"standard\",\"virtual\",\"useDraggablePublisher\",\"getDraggableRef\",\"computedStyles\",\"getComputedStyle\",\"calculateBox\",\"placeholder\",\"display\",\"displaceBy\",\"publishedRef\",\"isFirstPublishRef\",\"useValidation$1\",\"getRef\",\"_Number$isInteger\",\"mapped\",\"useClonePropValidation\",\"isClone\",\"initialRef\",\"preventHtml5Dnd\",\"getDraggableSelector\",\"memoizedOffset\",\"getMemoizedSnapshot\",\"draggingOver\",\"combineWith\",\"isDropAnimating\",\"dropAnimation\",\"combineTargetFor\",\"getMemoizedProps\",\"offset\",\"snapshot\",\"ownProps\",\"critical\",\"dimensions\",\"whatIsDraggedOver\",\"_dimension\",\"_draggingOver\",\"whatIsDraggedOverFromResult\",\"_combineWith\",\"duration\",\"dropDuration\",\"curve\",\"curves\",\"moveTo\",\"newHomeClientOffset\",\"opacity\",\"scale\",\"getSecondarySnapshot\",\"getSecondarySelector\",\"shouldAnimateDisplacement\",\"getProps\",\"ownId\",\"draggingId\",\"afterCritical\",\"visualDisplacement\",\"isAfterCriticalInVirtualList\",\"inVirtualList\",\"effected\",\"negate\",\"_offset\",\"PrivateDraggable\",\"droppableContext\",\"DroppableContext\",\"isUsingCloneFor\",\"ConnectedDraggable\",\"Object\",\"defineProperty\",\"_inheritsLoose\",\"_Date$now\",\"ReactDOM\",\"toString\",\"RbdInvariant.prototype.toString\",\"ErrorBoundary\",\"_React$Component\",\"_this\",\"_len\",\"arguments\",\"_key\",\"onWindowError\",\"_this.onWindowError\",\"getCallbacks\",\"err\",\"_this.getCallbacks\",\"Error\",\"_this.setCallbacks\",\"_proto\",\"componentDidMount\",\"_proto.componentDidMount\",\"componentWillUnmount\",\"_proto.componentWillUnmount\",\"componentDidCatch\",\"_proto.componentDidCatch\",\"setState\",\"render\",\"_proto.render\",\"Component\",\"withLocation\",\"source\",\"startPosition\",\"endPosition\",\"withCombine\",\"returnedToStart\",\"location\",\"point1\",\"point2\",\"subtract\",\"isEqual\",\"line\",\"otherValue\",\"distance\",\"sqrt\",\"pow\",\"points\",\"min\",\"offsetByPosition\",\"spacing\",\"getCorners\",\"increasedBy\",\"_extends2\",\"scrolled\",\"end\",\"increased\",\"active\",\"clipped\",\"newScroll\",\"scrollDiff\",\"scrollDisplacement\",\"toDroppableMap\",\"toDraggableMap\",\"toDroppableList\",\"toDraggableList\",\"getDraggablesInsideDroppable\",\"forward\",\"backward\",\"moveToNextCombine\",\"getImpact\",\"isMovingForward\",\"closestId\",\"withoutDraggable\",\"indexOfClosest\",\"proposedIndex\",\"before\",\"noDisplacedBy\",\"noImpact\",\"isWithin\",\"lowerBound\",\"upperBound\",\"isWithinVertical\",\"isWithinHorizontal\",\"isPartiallyVisibleVertically\",\"isPartiallyVisibleHorizontally\",\"isBiggerVertically\",\"isBiggerHorizontally\",\"isTotallyVisibleThroughFrame\",\"crossAxisLine\",\"size\",\"crossAxisStart\",\"crossAxisEnd\",\"crossAxisSize\",\"isTotallyVisibleThroughFrameOnAxis\",\"toBeDisplaced\",\"displacedTarget\",\"isTotallyVisible\",\"getCombinedItemDisplacement\",\"isDisplaced\",\"getCrossAxisBorderBoxCenter\",\"isMoving\",\"goAfter\",\"moveRelativeTo\",\"goBefore\",\"whenReordering\",\"draggablePage\",\"moveInto\",\"contentBox\",\"closestAfter\",\"withDisplacement\",\"getPageBorderBoxCenterFromImpact\",\"original\",\"withoutDisplacement\",\"scrollViewport\",\"speculativelyIncrease\",\"maxScrollChange\",\"scrolledViewport\",\"scrolledDroppable\",\"withViewportScroll\",\"withDroppableScroll\",\"newImpact\",\"getClientFromPageBorderBoxCenter\",\"withoutPageScrollChange\",\"pageBorderBoxCenter\",\"isTotallyVisibleInNewLocation\",\"_ref$onlyOnMainAxis\",\"onlyOnMainAxis\",\"changeNeeded\",\"newPageBorderBoxCenter\",\"shifted\",\"moveToNextPlace\",\"previousPageBorderBoxCenter\",\"previousClientSelection\",\"isInHomeList\",\"wasAt\",\"currentIndex\",\"lastIndex\",\"_newIndex\",\"combineId\",\"combineWithIndex\",\"didCombineWithStartAfterCritical\",\"isVisibleInNewLocation\",\"cautious\",\"getKnownActive\",\"rect\",\"getBestCrossAxisDroppable\",\"isBetweenSourceClipped\",\"candidates\",\"activeOfTarget\",\"isBetweenDestinationClipped\",\"first\",\"second\",\"array\",\"contains\",\"isWithinDroppable\",\"getCurrentPageBorderBoxCenter\",\"getClosestDraggable\",\"sorted\",\"distanceToA\",\"distanceToB\",\"getDisplacedBy\",\"getRequiredGrowthForPlaceholder\",\"placeholderSize\",\"availableSpace\",\"needsToGrowBy\",\"insideDroppable\",\"spaceUsed\",\"sum\",\"addPlaceholder\",\"requiredGrowth\",\"oldFrameMaxScroll\",\"_subject\",\"newFrame\",\"moveInDirection\",\"isOver\",\"isActuallyOver\",\"isMovingOnMainAxis\",\"borderBoxCenter\",\"_state$dimensions\",\"isGoingBeforeTarget\",\"relativeTo\",\"proposedPageBorderBoxCenter\",\"isPositionInFrame\",\"getDroppableOver$1\",\"maybe\",\"isUserMovingForward\",\"getReorderImpact\",\"currentCenter\",\"pageBorderBoxCenterWithDroppableScrollChange\",\"targetCenter\",\"child\",\"didStartAfterCritical$1\",\"getCombineImpact\",\"canBeDisplacedBy\",\"twoThirdsOfSize\",\"getDragImpact\",\"patchDroppableMap\",\"forcedImpact\",\"currentWindowScroll\",\"selection\",\"now\",\"lastDroppable\",\"oldMaxScroll\",\"_subject2\",\"cleaned\",\"patched\",\"withUpdatedPlaceholders\",\"recompute\",\"getClientBorderBoxCenter\",\"refreshSnap\",\"forcedDimensions\",\"forcedViewport\",\"needsVisibilityCheck\",\"getHomeLocation\",\"getLiftEffect\",\"insideHome\",\"rawIndex\",\"adjustAdditionsForScrollChanges\",\"updatedDroppables\",\"windowScrollChange\",\"totalChange\",\"initialWindowScroll\",\"moved\",\"publishWhileDraggingInVirtual\",\"_extends3\",\"published\",\"withScrollChange\",\"existing\",\"updatedAdditions\",\"wasOver\",\"wasOverId\",\"_getLiftEffect\",\"onLiftImpact\",\"draggingState\",\"dropPending\",\"isWaiting\",\"postDroppableChange\",\"isEnabledChanging\",\"idle\",\"shouldFlush\",\"_action$payload\",\"isWindowScrollAllowed\",\"every\",\"_result\",\"_clientSelection\",\"_action$payload2\",\"_action$payload3\",\"_id\",\"_target\",\"String\",\"_action$payload4\",\"_id2\",\"_target2\",\"_updated\",\"_newScroll\",\"_viewport\",\"withMaxScroll\",\"_result2\",\"newState\",\"_action$payload5\",\"_result3\",\"completeDrop\",\"dropAnimationFinished\",\"next\",\"_marshal$startPublish\",\"startPublishing\",\"request\",\"combining\",\"outOfTheWayTiming\",\"fluid\",\"snap\",\"timing\",\"transforms\",\"isCombining\",\"translate\",\"dropTimeRange\",\"maxDropTime\",\"minDropTime\",\"lastImpact\",\"withoutMovement\",\"recomputedHomeImpact\",\"didDropInsideDroppable\",\"newClientCenter\",\"distance$1\",\"maxDropTimeAtDistance\",\"Number\",\"toFixed\",\"withDuration\",\"cancelDropModifier\",\"listener\",\"getExpiringAnnounce\",\"wasCalled\",\"isExpired\",\"timeoutId\",\"clearTimeout\",\"result.wasCalled\",\"getAsyncMarshal\",\"execute\",\"timerId\",\"_entries$splice\",\"callback\",\"flush\",\"shallow\",\"areLocationsEqual\",\"isCombineEqual\",\"isCriticalEqual\",\"isDroppableEqual\",\"withTimings\",\"key\",\"getDragStart\",\"responder\",\"data\",\"getDefaultMessage\",\"willExpire\",\"provided\",\"getPublisher\",\"asyncMarshal\",\"beforeStart\",\"lastCritical\",\"lastLocation\",\"lastCombine\",\"hasCriticalChanged\",\"hasLocationChanged\",\"hasGroupingChanged\",\"publisher\",\"flushDropAnimation\",\"stopPublishing\",\"isWatching\",\"postActionState\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"compose\",\"adjustedMaxScroll\",\"getDocumentElement\",\"doc\",\"documentElement\",\"getMaxWindowScroll\",\"clientWidth\",\"clientHeight\",\"getViewport\",\"getInitialPublish\",\"collection\",\"subscriber\",\"scrollBy\",\"getScrollableDroppables\",\"getScrollableDroppableOver\",\"config\",\"startFromPercentage\",\"maxScrollAtPercentage\",\"maxPixelScroll\",\"ease\",\"percentage\",\"durationDampening\",\"stopDampeningAt\",\"accelerateAt\",\"getPercentage\",\"startOfRange\",\"range\",\"endOfRange\",\"getValueFromDistance\",\"distanceToEdge\",\"thresholds\",\"startScrollingFrom\",\"maxScrollValueAt\",\"minScroll\",\"percentageFromMaxScrollValueAt\",\"ceil\",\"stopAt\",\"dampenValueByTime\",\"proposedScroll\",\"dragStartTime\",\"runTime\",\"betweenAccelerateAtAndStopAtPercentage\",\"getValue\",\"shouldUseTimeDampening\",\"getScrollOnAxis\",\"container\",\"distanceToEdges\",\"clean$2\",\"getScroll\",\"required\",\"isTooBigVertically\",\"isTooBigHorizontally\",\"limited\",\"smallestSigned\",\"getOverlap\",\"getRemainder\",\"targetScroll\",\"overlap\",\"canPartiallyScroll\",\"rawMax\",\"smallestChange\",\"canScrollWindow\",\"canScrollDroppable\",\"scroll$1\",\"_change\",\"createFluidScroller\",\"scheduleWindowScroll\",\"scheduleDroppableScroll\",\"tryScroll\",\"_dragging\",\"start$1\",\"wasScrollNeeded\",\"fakeScrollCallback\",\"createJumpScroller\",\"jumpScroller\",\"whatTheDroppableCanScroll\",\"remainder\",\"droppableRemainder\",\"whatTheWindowCanScroll\",\"windowRemainder\",\"fluidScroller\",\"jumpScroll\",\"scroller\",\"property\",\"rule\",\"useLayoutEffect\",\"head\",\"querySelector\",\"createContext\",\"position\",\"overflow\",\"clip\",\"semver\",\"exec\",\"_preventedKeys\",\"enter\",\"tab\",\"supported\",\"idle$1\",\"_scrollJumpKeys\",\"pageDown\",\"pageUp\",\"idle$2\",\"input\",\"textarea\",\"select\",\"option\",\"optgroup\",\"video\",\"audio\",\"useMouseSensor\",\"phaseRef\",\"unbindEventsRef\",\"startCaptureBinding\",\"onMouseDown\",\"defaultPrevented\",\"ctrlKey\",\"metaKey\",\"shiftKey\",\"altKey\",\"startPendingDrag\",\"preventForcePressBinding\",\"listenForCapture\",\"bindCapturingEvents\",\"useKeyboardSensor\",\"onKeyDown\",\"isCapturing\",\"tryStartCapture\",\"useMouseSensor$1\",\"onTouchStart\",\"longPressTimerId\",\"unbindTarget\",\"unbindWindow\",\"unbindEventsRef.current\",\"startDragging\",\"timeForLongPress\",\"webkitHack\",\"instanceCount\",\"isEqual$1\",\"isScroll\",\"isAuto\",\"isVisible$1\",\"isEither\",\"overflowX\",\"overflowY\",\"isElementScrollable\",\"isBodyScrollable\",\"html\",\"htmlStyle\",\"empty\",\"noSpacing\",\"getStyle\",\"animate\",\"isAnimatingOpenOnMount\",\"boxSizing\",\"marginTop\",\"marginRight\",\"marginBottom\",\"marginLeft\",\"flexShrink\",\"flexGrow\",\"pointerEvents\",\"Placeholder$1\",\"memo\",\"Placeholder\",\"animateOpenTimerRef\",\"tryClearAnimateOpenTimer\",\"onTransitionEnd\",\"onClose\",\"_useState\",\"setIsAnimatingOpenOnMount\",\"onSizeChangeEnd\",\"propertyName\",\"innerRef\",\"_boolean\",\"getPlaceholderRef\",\"hasClone\",\"_ref5\",\"renderClone\",\"hasNoPlaceholder\",\"_ref6\",\"AnimateInOut\",\"_React$PureComponent\",\"on\",\"_this.onClose\",\"getDerivedStateFromProps\",\"AnimateInOut.getDerivedStateFromProps\",\"PureComponent\",\"isStrictEqual\",\"atRest\",\"connect\",\"makeMapStateToProps\",\"draggingSelector\",\"secondarySelector\",\"mapDispatchToProps\",\"pure\",\"areStatePropsEqual\",\"Draggable\",\"setRef\",\"_useRequiredContext\",\"_useRequiredContext2\",\"dropAnimationFinishedAction\",\"forPublisher\",\"dragHandleProps\",\"tabIndex\",\"onMoveEnd\",\"box\",\"transform\",\"zIndex\",\"draggableProps\",\"rubric\",\"ConnectedDroppable\",\"makeMapStateToProps$1\",\"idleWithAnimation\",\"shouldAnimatePlaceholder\",\"isDraggingOver\",\"draggingOverWith\",\"draggingFromThisWith\",\"isUsingPlaceholder\",\"useClone\",\"idleWithoutAnimation\",\"getDraggableRubric\",\"getMapProps\",\"isDraggingOverForConsumer\",\"isDraggingOverForImpact\",\"_snapshot\",\"_completed\",\"wasCombining\",\"mapDispatchToProps$1\",\"updateViewportMaxScroll\",\"Droppable\",\"droppableRef\",\"placeholderRef\",\"getContainerForClone\",\"setDroppableRef\",\"setPlaceholderRef\",\"onPlaceholderTransitionEnd\",\"droppableProps\",\"getClone\",\"node\",\"draggableProvided\",\"draggableSnapshot\",\"createPortal\",\"defaultProps\",\"getBody\",\"DragDropContext\",\"PublicDraggable\",\"isDragDisabled\",\"disableInteractiveElementBlocking\",\"resetServerContext\"]\n}\n"]