["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/eventemitter3/index.js"],"~:js","shadow$provide.module$node_modules$eventemitter3$index=function(global,require,module,exports){function EE(fn,context,once){this.fn=fn;this.context=context;this.once=once||!1}function EventEmitter(){}var has=Object.prototype.hasOwnProperty,prefix=\"function\"!==typeof Object.create?\"~\":!1;EventEmitter.prototype._events=void 0;EventEmitter.prototype.eventNames=function(){var events=this._events,names=[],name;if(!events)return names;for(name in events)has.call(events,name)&&names.push(prefix?name.slice(1):\nname);return Object.getOwnPropertySymbols?names.concat(Object.getOwnPropertySymbols(events)):names};EventEmitter.prototype.listeners=function(event,exists){event=prefix?prefix+event:event;event=this._events&&this._events[event];if(exists)return!!event;if(!event)return[];if(event.fn)return[event.fn];exists=0;for(var l=event.length,ee=Array(l);exists<l;exists++)ee[exists]=event[exists].fn;return ee};EventEmitter.prototype.emit=function(event,a1,a2,a3,a4,a5){var evt=prefix?prefix+event:event;if(!this._events||\n!this._events[evt])return!1;evt=this._events[evt];var len=arguments.length,args;if(\"function\"===typeof evt.fn){evt.once&&this.removeListener(event,evt.fn,void 0,!0);switch(len){case 1:return evt.fn.call(evt.context),!0;case 2:return evt.fn.call(evt.context,a1),!0;case 3:return evt.fn.call(evt.context,a1,a2),!0;case 4:return evt.fn.call(evt.context,a1,a2,a3),!0;case 5:return evt.fn.call(evt.context,a1,a2,a3,a4),!0;case 6:return evt.fn.call(evt.context,a1,a2,a3,a4,a5),!0}var i=1;for(args=Array(len-\n1);i<len;i++)args[i-1]=arguments[i];evt.fn.apply(evt.context,args)}else{var length=evt.length;for(i=0;i<length;i++)switch(evt[i].once&&this.removeListener(event,evt[i].fn,void 0,!0),len){case 1:evt[i].fn.call(evt[i].context);break;case 2:evt[i].fn.call(evt[i].context,a1);break;case 3:evt[i].fn.call(evt[i].context,a1,a2);break;default:if(!args){var j=1;for(args=Array(len-1);j<len;j++)args[j-1]=arguments[j]}evt[i].fn.apply(evt[i].context,args)}}return!0};EventEmitter.prototype.on=function(event,fn,\ncontext){fn=new EE(fn,context||this);event=prefix?prefix+event:event;this._events||(this._events=prefix?{}:Object.create(null));this._events[event]?this._events[event].fn?this._events[event]=[this._events[event],fn]:this._events[event].push(fn):this._events[event]=fn;return this};EventEmitter.prototype.once=function(event,fn,context){fn=new EE(fn,context||this,!0);event=prefix?prefix+event:event;this._events||(this._events=prefix?{}:Object.create(null));this._events[event]?this._events[event].fn?\nthis._events[event]=[this._events[event],fn]:this._events[event].push(fn):this._events[event]=fn;return this};EventEmitter.prototype.removeListener=function(event,fn,context,once){event=prefix?prefix+event:event;if(!this._events||!this._events[event])return this;var listeners=this._events[event],events=[];if(fn)if(listeners.fn)(listeners.fn!==fn||once&&!listeners.once||context&&listeners.context!==context)&&events.push(listeners);else for(var i=0,length=listeners.length;i<length;i++)(listeners[i].fn!==\nfn||once&&!listeners[i].once||context&&listeners[i].context!==context)&&events.push(listeners[i]);events.length?this._events[event]=1===events.length?events[0]:events:delete this._events[event];return this};EventEmitter.prototype.removeAllListeners=function(event){if(!this._events)return this;event?delete this._events[prefix?prefix+event:event]:this._events=prefix?{}:Object.create(null);return this};EventEmitter.prototype.off=EventEmitter.prototype.removeListener;EventEmitter.prototype.addListener=\nEventEmitter.prototype.on;EventEmitter.prototype.setMaxListeners=function(){return this};EventEmitter.prefixed=prefix;\"undefined\"!==typeof module&&(module.exports=EventEmitter)}","~:source","shadow$provide[\"module$node_modules$eventemitter3$index\"] = function(global,require,module,exports) {\n'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} [once=false] Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Hold the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var events = this._events\n    , names = []\n    , name;\n\n  if (!events) return names;\n\n  for (name in events) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["_events","once","off","prefixed","fn","removeAllListeners","setMaxListeners","removeListener","addListener","context","emit","on","eventNames","listeners"]],"~:compiled-at",1577908996457,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$eventemitter3$index.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/eventemitter3/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$eventemitter3$index\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nvar has = Object.prototype.hasOwnProperty;\\n\\n//\\n// We store our EE objects in a plain object whose properties are event names.\\n// If `Object.create(null)` is not supported we prefix the event names with a\\n// `~` to make sure that the built-in object properties are not overridden or\\n// used as an attack vector.\\n// We also assume that `Object.create(null)` is available when the event name\\n// is an ES6 Symbol.\\n//\\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\\n\\n/**\\n * Representation of a single EventEmitter function.\\n *\\n * @param {Function} fn Event handler to be called.\\n * @param {Mixed} context Context for function execution.\\n * @param {Boolean} [once=false] Only emit once\\n * @api private\\n */\\nfunction EE(fn, context, once) {\\n  this.fn = fn;\\n  this.context = context;\\n  this.once = once || false;\\n}\\n\\n/**\\n * Minimal EventEmitter interface that is molded against the Node.js\\n * EventEmitter interface.\\n *\\n * @constructor\\n * @api public\\n */\\nfunction EventEmitter() { /* Nothing to set */ }\\n\\n/**\\n * Hold the assigned EventEmitters by name.\\n *\\n * @type {Object}\\n * @private\\n */\\nEventEmitter.prototype._events = undefined;\\n\\n/**\\n * Return an array listing the events for which the emitter has registered\\n * listeners.\\n *\\n * @returns {Array}\\n * @api public\\n */\\nEventEmitter.prototype.eventNames = function eventNames() {\\n  var events = this._events\\n    , names = []\\n    , name;\\n\\n  if (!events) return names;\\n\\n  for (name in events) {\\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\\n  }\\n\\n  if (Object.getOwnPropertySymbols) {\\n    return names.concat(Object.getOwnPropertySymbols(events));\\n  }\\n\\n  return names;\\n};\\n\\n/**\\n * Return a list of assigned event listeners.\\n *\\n * @param {String} event The events that should be listed.\\n * @param {Boolean} exists We only need to know if there are listeners.\\n * @returns {Array|Boolean}\\n * @api public\\n */\\nEventEmitter.prototype.listeners = function listeners(event, exists) {\\n  var evt = prefix ? prefix + event : event\\n    , available = this._events && this._events[evt];\\n\\n  if (exists) return !!available;\\n  if (!available) return [];\\n  if (available.fn) return [available.fn];\\n\\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\\n    ee[i] = available[i].fn;\\n  }\\n\\n  return ee;\\n};\\n\\n/**\\n * Emit an event to all registered event listeners.\\n *\\n * @param {String} event The name of the event.\\n * @returns {Boolean} Indication if we've emitted an event.\\n * @api public\\n */\\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\\n  var evt = prefix ? prefix + event : event;\\n\\n  if (!this._events || !this._events[evt]) return false;\\n\\n  var listeners = this._events[evt]\\n    , len = arguments.length\\n    , args\\n    , i;\\n\\n  if ('function' === typeof listeners.fn) {\\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\\n\\n    switch (len) {\\n      case 1: return listeners.fn.call(listeners.context), true;\\n      case 2: return listeners.fn.call(listeners.context, a1), true;\\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\\n    }\\n\\n    for (i = 1, args = new Array(len -1); i < len; i++) {\\n      args[i - 1] = arguments[i];\\n    }\\n\\n    listeners.fn.apply(listeners.context, args);\\n  } else {\\n    var length = listeners.length\\n      , j;\\n\\n    for (i = 0; i < length; i++) {\\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\\n\\n      switch (len) {\\n        case 1: listeners[i].fn.call(listeners[i].context); break;\\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\\n        default:\\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\\n            args[j - 1] = arguments[j];\\n          }\\n\\n          listeners[i].fn.apply(listeners[i].context, args);\\n      }\\n    }\\n  }\\n\\n  return true;\\n};\\n\\n/**\\n * Register a new EventListener for the given event.\\n *\\n * @param {String} event Name of the event.\\n * @param {Function} fn Callback function.\\n * @param {Mixed} [context=this] The context of the function.\\n * @api public\\n */\\nEventEmitter.prototype.on = function on(event, fn, context) {\\n  var listener = new EE(fn, context || this)\\n    , evt = prefix ? prefix + event : event;\\n\\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\\n  if (!this._events[evt]) this._events[evt] = listener;\\n  else {\\n    if (!this._events[evt].fn) this._events[evt].push(listener);\\n    else this._events[evt] = [\\n      this._events[evt], listener\\n    ];\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Add an EventListener that's only called once.\\n *\\n * @param {String} event Name of the event.\\n * @param {Function} fn Callback function.\\n * @param {Mixed} [context=this] The context of the function.\\n * @api public\\n */\\nEventEmitter.prototype.once = function once(event, fn, context) {\\n  var listener = new EE(fn, context || this, true)\\n    , evt = prefix ? prefix + event : event;\\n\\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\\n  if (!this._events[evt]) this._events[evt] = listener;\\n  else {\\n    if (!this._events[evt].fn) this._events[evt].push(listener);\\n    else this._events[evt] = [\\n      this._events[evt], listener\\n    ];\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Remove event listeners.\\n *\\n * @param {String} event The event we want to remove.\\n * @param {Function} fn The listener that we need to find.\\n * @param {Mixed} context Only remove listeners matching this context.\\n * @param {Boolean} once Only remove once listeners.\\n * @api public\\n */\\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\\n  var evt = prefix ? prefix + event : event;\\n\\n  if (!this._events || !this._events[evt]) return this;\\n\\n  var listeners = this._events[evt]\\n    , events = [];\\n\\n  if (fn) {\\n    if (listeners.fn) {\\n      if (\\n           listeners.fn !== fn\\n        || (once && !listeners.once)\\n        || (context && listeners.context !== context)\\n      ) {\\n        events.push(listeners);\\n      }\\n    } else {\\n      for (var i = 0, length = listeners.length; i < length; i++) {\\n        if (\\n             listeners[i].fn !== fn\\n          || (once && !listeners[i].once)\\n          || (context && listeners[i].context !== context)\\n        ) {\\n          events.push(listeners[i]);\\n        }\\n      }\\n    }\\n  }\\n\\n  //\\n  // Reset the array, or remove it completely if we have no more listeners.\\n  //\\n  if (events.length) {\\n    this._events[evt] = events.length === 1 ? events[0] : events;\\n  } else {\\n    delete this._events[evt];\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Remove all listeners or only the listeners for the specified event.\\n *\\n * @param {String} event The event want to remove all listeners for.\\n * @api public\\n */\\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\\n  if (!this._events) return this;\\n\\n  if (event) delete this._events[prefix ? prefix + event : event];\\n  else this._events = prefix ? {} : Object.create(null);\\n\\n  return this;\\n};\\n\\n//\\n// Alias methods names because people roll like that.\\n//\\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\\n\\n//\\n// This function doesn't apply anymore.\\n//\\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\\n  return this;\\n};\\n\\n//\\n// Expose the prefix.\\n//\\nEventEmitter.prefixed = prefix;\\n\\n//\\n// Expose the module.\\n//\\nif ('undefined' !== typeof module) {\\n  module.exports = EventEmitter;\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"EE\",\"fn\",\"context\",\"once\",\"EventEmitter\",\"has\",\"Object\",\"prototype\",\"hasOwnProperty\",\"prefix\",\"create\",\"_events\",\"undefined\",\"eventNames\",\"EventEmitter.prototype.eventNames\",\"events\",\"names\",\"name\",\"call\",\"push\",\"slice\",\"getOwnPropertySymbols\",\"concat\",\"listeners\",\"EventEmitter.prototype.listeners\",\"event\",\"exists\",\"evt\",\"available\",\"i\",\"l\",\"length\",\"ee\",\"Array\",\"emit\",\"EventEmitter.prototype.emit\",\"a1\",\"a2\",\"a3\",\"a4\",\"a5\",\"len\",\"arguments\",\"args\",\"removeListener\",\"apply\",\"j\",\"on\",\"EventEmitter.prototype.on\",\"listener\",\"EventEmitter.prototype.once\",\"EventEmitter.prototype.removeListener\",\"removeAllListeners\",\"EventEmitter.prototype.removeAllListeners\",\"off\",\"addListener\",\"setMaxListeners\",\"EventEmitter.prototype.setMaxListeners\",\"prefixed\"]\n}\n"]