{"version":3,"sources":["barber/subs.cljs"],"mappings":"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","names":["G__71703","G__71704","re-frame.core/reg-sub","p__71706","vec__71718","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","db","_","the-key","cljs.core.get.cljs$core$IFn$_invoke$arity$2","G__71721","G__71722","p__71723","vec__71724","cljs.core/PersistentVector","G__71727","G__71728","p__71729","vec__71730","and__4120__auto__","G__71738","G__71739","barber.subs/sorted-todos","G__71755","G__71756","G__71764","G__71765","G__71766","query-v","G__71767","re-frame.core/subscribe","sorted-todos","cljs.core/vals","G__71773","G__71774","G__71775","G__71786","G__71787","p__71789","vec__71790","todos","showing","filter-fn","G__71794","cljs.core/Keyword","js/Error","cljs.core/complement","cljs.core/identity","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","G__71799","G__71800","G__71801","G__71802","cljs.core/every?","G__71803","G__71804","G__71805","G__71806","cljs.core/count","G__71808","G__71809","G__71810","G__71811","G__71812","G__71813","p__71816","vec__71817","completed"],"sourcesContent":["(ns barber.subs\n  (:require [re-frame.core :refer [reg-sub subscribe]]))\n\n;; -------------------------------------------------------------------------------------\n;; Layer 2\n;;\n;; See https://github.com/Day8/re-frame/blob/master/docs/SubscriptionInfographic.md\n;;\n;; Layer 2 query functions are \"extractors\". They take from `app-db`\n;; and don't do any further computation on the extracted values. Any further\n;; computation should happen in Layer 3.\n;; Why?  It is an efficiency thing. Every Layer 2 subscription will rerun any time\n;; that `app-db` changes (in any way). As a result, we want Layer 2 to be trivial.\n;;\n\n(reg-sub\n  :data\n  (fn [db [_ the-key]]\n    (get db the-key)))\n\n(reg-sub :selected-date-and-day\n         (fn [db []]\n           (vector (get db :selected-date)\n                   (get db :selected-day))))\n\n\n\n\n\n\n(reg-sub\n  :calendar-data-loaded?\n  (fn [db [_ the-key]]\n      (if (and (:reservations db)\n               (:employees db)\n               (:services db)\n               (:opening-hours db))\n        true\n        false)))\n\n(reg-sub\n  :showing          ;; usage:   (subscribe [:showing])\n  (fn [db _]        ;; db is the (map) value stored in the app-db atom\n    (:showing db))) ;; extract a value from the application state\n\n\n;; Next, the registration of a similar handler is done in two steps.\n;; First, we `defn` a pure handler function.  Then, we use `reg-sub` to register it.\n;; Two steps. This is different to that first registration, above, which was done\n;; in one step using an anonymous function.\n(defn sorted-todos\n  [db _]\n  (:todos db))\n(reg-sub :sorted-todos sorted-todos)    ;; usage: (subscribe [:sorted-todos])\n\n;; -------------------------------------------------------------------------------------\n;; Layer 3\n;;\n;; See https://github.com/Day8/re-frame/blob/master/docs/SubscriptionInfographic.md\n;;\n;; A subscription handler is a function which is re-run when its input signals\n;; change. Each time it is rerun, it produces a new output (return value).\n;;\n;; In the simple case, app-db is the only input signal, as was the case in the two\n;; simple subscriptions above. But many subscriptions are not directly dependent on\n;; app-db, and instead, depend on a value derived from app-db.\n;;\n;; Such handlers represent \"intermediate nodes\" in a signal graph.  New values emanate\n;; from app-db, and flow out through a signal graph, into and out of these intermediate\n;; nodes, before a leaf subscription delivers data into views which render data as hiccup.\n;;\n;; When writing and registering the handler for an intermediate node, you must nominate\n;; one or more input signals (typically one or two).\n;;\n;; reg-sub allows you to supply:\n;;\n;;   1. a function which returns the input signals. It can return either a single signal or\n;;      a vector of signals, or a map where the values are the signals.\n;;\n;;   2. a function which does the computation. It takes input values and produces a new\n;;      derived value.\n;;\n;; In the two simple examples at the top, we only supplied the 2nd of these functions.\n;; But now we are dealing with intermediate (layer 3) nodes, we'll need to provide both fns.\n;;\n(reg-sub\n  :todos        ;; usage:   (subscribe [:todos])\n\n  ;; This function returns the input signals.\n  ;; In this case, it returns a single signal.\n  ;; Although not required in this example, it is called with two parameters\n  ;; being the two values supplied in the originating `(subscribe X Y)`.\n  ;; X will be the query vector and Y is an advanced feature and out of scope\n  ;; for this explanation.\n  (fn [query-v _]\n    (subscribe [:sorted-todos]))    ;; returns a single input signal\n\n  ;; This 2nd fn does the computation. Data values in, derived data out.\n  ;; It is the same as the two simple subscription handlers up at the top.\n  ;; Except they took the value in app-db as their first argument and, instead,\n  ;; this function takes the value delivered by another input signal, supplied by the\n  ;; function above: (subscribe [:sorted-todos])\n  ;;\n  ;; Subscription handlers can take 3 parameters:\n  ;;  - the input signals (a single item, a vector or a map)\n  ;;  - the query vector supplied to query-v  (the query vector argument\n  ;; to the \"subscribe\") and the 3rd one is for advanced cases, out of scope for this discussion.\n  (fn [sorted-todos query-v _]\n    (vals sorted-todos)))\n\n;; So here we define the handler for another intermediate node.\n;; This time the computation involves two input signals.\n;; As a result note:\n;;   - the first function (which returns the signals) returns a 2-vector\n;;   - the second function (which is the computation) destructures this 2-vector as its first parameter\n(reg-sub\n  :visible-todos\n\n  ;; Signal Function\n  ;; Tells us what inputs flow into this node.\n  ;; Returns a vector of two input signals (in this case)\n  (fn [query-v _]\n    [(subscribe [:todos])\n     (subscribe [:showing])])\n\n  ;; Computation Function\n  (fn [[todos showing] _]   ;; that 1st parameter is a 2-vector of values\n    (let [filter-fn (case showing\n                      :active (complement :done)\n                      :done   :done\n                      :all    identity)]\n      (filter filter-fn todos))))\n\n;; -------------------------------------------------------------------------------------\n;; Hey, wait on!!\n;;\n;; How did those two simple Layer 2 registrations at the top work?\n;; We only supplied one function in those registrations, not two?\n;; Very observant of you, I'm glad you asked.\n;; When the signal-returning-fn is omitted, reg-sub provides a default,\n;; and it looks like this:\n;;    (fn [_ _]\n;;       re-frame.db/app-db)\n;; It returns one signal, and that signal is app-db itself.\n;;\n;; So the two simple registrations at the top didn't need to provide a signal-fn,\n;; because they operated only on the value in app-db, supplied as 'db' in the 1st argument.\n;;\n;; So that, by the way, is why Layer 2 subscriptions always re-calculate when `app-db`\n;; changes - `app-db` is literally their input signal.\n\n;; -------------------------------------------------------------------------------------\n;; SUGAR ?\n;; Now for some syntactic sugar...\n;; The purpose of the sugar is to remove boilerplate noise. To distill to the essential\n;; in 90% of cases.\n;; Because it is so common to nominate 1 or more input signals,\n;; reg-sub provides some macro sugar so you can nominate a very minimal\n;; vector of input signals. The 1st function is not needed.\n;; Here is the example above rewritten using the sugar.\n#_(reg-sub\n   :visible-todos\n   :<- [:todos]\n   :<- [:showing]\n   (fn [[todos showing] _]\n     (let [filter-fn (case showing\n                       :active (complement :done)\n                       :done   :done\n                       :all    identity)]\n       (filter filter-fn todos))))\n\n\n(reg-sub\n  :all-complete?\n  :<- [:todos]\n  (fn [todos _]\n    (every? :done todos)))\n\n(reg-sub\n  :completed-count\n  :<- [:todos]\n  (fn [todos _]\n    (count (filter :done todos))))\n\n(reg-sub\n  :footer-counts\n  :<- [:todos]\n  :<- [:completed-count]\n  (fn [[todos completed] _]\n    [(- (count todos) completed) completed]))\n"]}