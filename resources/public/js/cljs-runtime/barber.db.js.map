{"version":3,"sources":["barber/db.cljs"],"mappings":";;;;;AAoBA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAYC;AACZ,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAeE;AACf,AAAAF,AAAA,AAAA,AAAA,AAAA,AAAcG;AACd,AAAAH,AAAA,AAAA,AAAA,AAAA,AAAc,AAAAI,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAAA;AAAA,AAAA,AAAAE,AAAAF,AAAA;AAAA,AAAAA;AAAA,AAAA,AAAAE,AAAAF,AAAA;AAAA,AAAAA;AAAA,AAAA,AAAAE,AAAAF,AAAA;AAAA,AAAAA;AAAA,AAAA,AAAA,AAAAC,AAAAD,AAAA,AAAAE,AAAAF,AAAA,AAAA,AAAAE,AAAAF,AAAA,AAAA,AAAAE,AAAAF,AAAA;AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AACd,AAAAL,AAAA,AAAA,AAAA,AAAA,AAAe,AAAAQ,AAAA,AAAA,AAAA,AACE,AAAAE,AAAA,AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC;AAAA,AAAA,AAAAN,AAAAM;AAAA,AAAAN,AAAA,AAAA,AAAAO,AAAAC;AAAA,AAAA,AAAAC,AAAAD,AAAA;AADF,AAAAL,AACE,AAAA,AAAA,AAAA,AAAA,AAAA;AADF,AAEG,AAAAA,AAAWO;AAFd;AAIf,AAAAhB,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAKA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAY,AAAAI,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAa;AAAA,AAAA,AAAAX,AAAAW;AAAA,AAAAA;AAAA,AAAA,AAAAV,AAAAU,AAAA;AAAA,AAAAA;AAAA,AAAA,AAAAV,AAAAU,AAAA;AAAA,AAAAA;AAAA,AAAA,AAAA,AAAAX,AAAAW,AAAA,AAAAV,AAAAU,AAAA,AAAA,AAAAV,AAAAU,AAAA;AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAWZ,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAKC,AACO,AAACC;AAab,AAAA,AAAKC;AAEL;;;AAAA,AAAMC,AAEHC;AAFH,AAGE,AAAUC,AAAgBH,AAAO,AAAKE;;AAcxC,AAAAE,AAAA;AAAAC,AAEE;AAAKE,AAAKC;AAAV,AAEI,AAAA,AAACC,AAAMF,AAEA,AAACG,AAAK,AAACX,AACD,AAAAY,AAAS,AAAUR,AAAgBH;AAAnC,AAAA,AAAA,AAAAW,AAAA;AAAA;;AACS,AAAAA,AAACC;;;;;AAR7B,AAAA,AAAAR,AAAAC,AAAAD,AAAAC,AAACC,AAAAA,AAAAA","names":["cljs.spec.alpha/def-impl","cljs.core/int?","cljs.core/string?","cljs.core/boolean?","cljs.spec.alpha/map-spec-impl","G__13448","cljs.core/map?","cljs.core/contains?","cljs.spec.alpha/and-spec-impl","p1__13469#","cljs.spec.alpha.every_impl.cljs$core$IFn$_invoke$arity$4","cljs.spec.alpha.tuple_impl.cljs$core$IFn$_invoke$arity$2","G__13484","i__32576__auto__","v__32577__auto__","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","cljs.core/PersistentTreeMap","G__13494","barber.db/default-db","cljs.core/sorted-map","barber.db/ls-key","barber.db/todos->local-store","todos","js/localStorage","G__13552","G__13553","re-frame.core/reg-cofx","cofx","_","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core.into.cljs$core$IFn$_invoke$arity$2","G__13557","cljs.reader.read_string.cljs$core$IFn$_invoke$arity$1"],"sourcesContent":["(ns barber.db\n  (:require [cljs.reader]\n            [cljs.spec.alpha :as s]\n            [re-frame.core :as re-frame]))\n\n;; -- Spec --------------------------------------------------------------------\n;;\n;; This is a clojure.spec specification for the value in app-db. It is like a\n;; Schema. See: http://clojure.org/guides/spec\n;;\n;; The value in app-db should always match this spec. Only event handlers\n;; can change the value in app-db so, after each event handler\n;; has run, we re-check app-db for correctness (compliance with the Schema).\n;;\n;; How is this done? Look in events.cljs and you'll notice that all handlers\n;; have an \"after\" interceptor which does the spec re-check.\n;;\n;; None of this is strictly necessary. It could be omitted. But we find it\n;; good practice.\n\n(s/def ::id int?)\n(s/def ::title string?)\n(s/def ::done boolean?)\n(s/def ::todo (s/keys :req-un [::id ::title ::done]))\n(s/def ::todos (s/and                                       ;; should use the :kind kw to s/map-of (not supported yet)\n                 (s/map-of ::id ::todo)                     ;; in this map, each todo is keyed by its :id\n                 #(instance? PersistentTreeMap %)))           ;; is a sorted-map (not just a map)\n\n(s/def ::showing                                            ;; what todos are shown to the user?\n  #{:all                                                    ;; all todos are shown\n    :active                                                 ;; only todos whose :done is false\n    :done})                                                   ;; only todos whose :done is true\n\n(s/def ::db (s/keys :req-un [::todos ::showing]))\n\n;; -- Default app-db Value  ---------------------------------------------------\n;;\n;; When the application first starts, this will be the value put in app-db\n;; Unless, of course, there are todos in the LocalStore (see further below)\n;; Look in:\n;;   1.  `core.cljs` for  \"(dispatch-sync [:initialise-db])\"\n;;   2.  `events.cljs` for the registration of :initialise-db handler\n;;\n\n(def default-db           ;; what gets put into app-db by default.\n  {:todos   (sorted-map)  ;; an empty list of todos. Use the (int) :id as the key\n   :showing :all\n   :events {\"box\" {}}})        ;; show all todos\n\n\n;; -- Local Storage  ----------------------------------------------------------\n;;\n;; Part of the todomvc challenge is to store todos in LocalStorage, and\n;; on app startup, reload the todos from when the program was last run.\n;; But the challenge stipulates to NOT load the setting for the \"showing\"\n;; filter. Just the todos.\n;;\n\n(def ls-key \"todos-reframe\")                         ;; localstore key\n\n(defn todos->local-store\n  \"Puts todos into localStorage\"\n  [todos]\n  (.setItem js/localStorage ls-key (str todos)))     ;; sorted-map written as an EDN map\n\n\n;; -- cofx Registrations  -----------------------------------------------------\n\n;; Use `reg-cofx` to register a \"coeffect handler\" which will inject the todos\n;; stored in localstore.\n;;\n;; To see it used, look in `events.cljs` at the event handler for `:initialise-db`.\n;; That event handler has the interceptor `(inject-cofx :local-store-todos)`\n;; The function registered below will be used to fulfill that request.\n;;\n;; We must supply a `sorted-map` but in LocalStore it is stored as a `map`.\n;;\n(re-frame/reg-cofx\n  :local-store-todos\n  (fn [cofx _]\n      ;; put the localstore todos into the coeffect under :local-store-todos\n      (assoc cofx :local-store-todos\n             ;; read in todos from localstore, and process into a sorted map\n             (into (sorted-map)\n                   (some->> (.getItem js/localStorage ls-key)\n                            (cljs.reader/read-string))))))    ;; EDN map -> map\n"]}